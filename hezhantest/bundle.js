/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2);
	module.exports = __webpack_require__(2);


/***/ },
/* 1 */,
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var pGrid = __webpack_require__(3);
	var memoryData = __webpack_require__(107).value;
	var tmpl = __webpack_require__(108);
	
	var gridConfig = {
	  el: '#container',
	  dataSource: {
	    type: 'memory',
	    data: memoryData,
	    primaryKey: 'UserName'
	  },
	  columns: [{
	    name: 'UserName',
	    title: 'User Name',
	    sortable: true,
	    locked: true
	  }, {
	    name: 'FirstName',
	    title: 'First Name',
	    editable: true,
	    colClasses: ['nameClass1', 'nameClass2'],
	    headerClasses: ['nameHeaderClass1', 'nameHeaderClass2']
	  }, {
	    name: 'LastName',
	    title: 'Last Name',
	    editable: true,
	    colClasses: ['nameClass1', 'nameClass2'],
	    headerClasses: ['nameHeaderClass1', 'nameHeaderClass2']
	  }, {
	    name: 'Address',
	    property: 'AddressInfo/0/Address',
	    template: tmpl
	  }, {
	    name: 'Gender',
	    html: '<i>Gender</i>'
	  }, {
	    name: 'Concurrency',
	    hidden: true
	  }]
	};
	
	var pgrid = pGrid.factory({ vnext: true }).create(gridConfig);
	var gridView = pgrid.gridView.render();

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _gridFactory = __webpack_require__(4);
	
	var _gridFactory2 = _interopRequireDefault(_gridFactory);
	
	var _dataSource = __webpack_require__(69);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = {
	  version: '0.1.0-41',
	  GridView: __webpack_require__(63),
	  projections: __webpack_require__(20),
	  layout: __webpack_require__(7),
	  factory: _gridFactory2.default,
	  popupEditorPrompt: __webpack_require__(34),
	  dataSource: {
	    Base: _dataSource.DataSource,
	    Memory: _dataSource.MemoryDataSource,
	    OData: _dataSource.ODataDataSource,
	    JSData: _dataSource.JSDataDataSource
	  }
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.default = function (options) {
	  return new GridFactory(options);
	};
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _renderersPlugin = __webpack_require__(6);
	
	var _renderersPlugin2 = _interopRequireDefault(_renderersPlugin);
	
	var _projectionPlugin = __webpack_require__(19);
	
	var _projectionPlugin2 = _interopRequireDefault(_projectionPlugin);
	
	var _gridViewPlugin = __webpack_require__(62);
	
	var _gridViewPlugin2 = _interopRequireDefault(_gridViewPlugin);
	
	var _dataSourcePlugin = __webpack_require__(68);
	
	var _dataSourcePlugin2 = _interopRequireDefault(_dataSourcePlugin);
	
	var _gridViewPlugin3 = __webpack_require__(74);
	
	var _gridViewPlugin4 = _interopRequireDefault(_gridViewPlugin3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var configPlugin = function configPlugin(definePlugin) {
	  return definePlugin('config', [], function () {
	    return this.config;
	  });
	};
	
	var GridFactory = function () {
	  function GridFactory() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	    var _ref$vnext = _ref.vnext;
	    var vnext = _ref$vnext === undefined ? false : _ref$vnext;
	
	    _classCallCheck(this, GridFactory);
	
	    this.pluginIndex = {};
	    this.plugins = [];
	    if (vnext) {
	      this.use(configPlugin).use(_dataSourcePlugin2.default).use(_gridViewPlugin4.default);
	    } else {
	      this.use(configPlugin).use(_projectionPlugin2.default).use(_renderersPlugin2.default).use(_gridViewPlugin2.default);
	    }
	  }
	
	  _createClass(GridFactory, [{
	    key: 'definePlugin',
	    value: function definePlugin(name, deps, callback) {
	      var _this = this;
	
	      var plugin = { name: name, deps: deps, callback: callback };
	
	      this.pluginIndex[name] = plugin;
	      this.plugins.push(plugin);
	      _underscore2.default.each(deps, function (dep) {
	        if (!_underscore2.default.has(_this.pluginIndex, dep)) {
	          throw new Error('unresolved plugin dependency ' + name + ' -> ' + dep);
	        }
	      });
	    }
	  }, {
	    key: 'use',
	    value: function use(callback) {
	      callback(this.definePlugin.bind(this));
	      return this;
	    }
	  }, {
	    key: 'create',
	    value: function create(config) {
	      return _underscore2.default.reduce(this.plugins, function (result, _ref2) {
	        var name = _ref2.name;
	        var deps = _ref2.deps;
	        var callback = _ref2.callback;
	        return _underscore2.default.extend(result, _defineProperty({}, name, callback.apply(result, _underscore2.default.map(deps, function (dep) {
	          return result[dep];
	        }))));
	      }, { config: config });
	    }
	  }]);

	  return GridFactory;
	}();

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.
	
	(function() {
	
	  // Baseline setup
	  // --------------
	
	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;
	
	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;
	
	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
	
	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;
	
	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;
	
	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};
	
	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };
	
	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }
	
	  // Current version.
	  _.VERSION = '1.8.3';
	
	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };
	
	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result — either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };
	
	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };
	
	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };
	
	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };
	
	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };
	
	  // Collection Functions
	  // --------------------
	
	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };
	
	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };
	
	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }
	
	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }
	
	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);
	
	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);
	
	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };
	
	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };
	
	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };
	
	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };
	
	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };
	
	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };
	
	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };
	
	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };
	
	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };
	
	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };
	
	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };
	
	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };
	
	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };
	
	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };
	
	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };
	
	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };
	
	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });
	
	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });
	
	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });
	
	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };
	
	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };
	
	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };
	
	  // Array Functions
	  // ---------------
	
	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };
	
	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };
	
	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };
	
	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };
	
	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };
	
	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };
	
	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };
	
	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };
	
	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };
	
	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };
	
	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };
	
	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };
	
	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };
	
	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);
	
	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };
	
	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };
	
	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }
	
	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);
	
	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };
	
	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }
	
	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
	
	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;
	
	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);
	
	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }
	
	    return range;
	  };
	
	  // Function (ahem) Functions
	  // ------------------
	
	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };
	
	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };
	
	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };
	
	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };
	
	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };
	
	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };
	
	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);
	
	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };
	
	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;
	
	    var later = function() {
	      var last = _.now() - timestamp;
	
	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };
	
	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }
	
	      return result;
	    };
	  };
	
	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };
	
	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };
	
	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };
	
	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };
	
	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };
	
	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);
	
	  // Object Functions
	  // ----------------
	
	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
	
	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;
	
	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
	
	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }
	
	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };
	
	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };
	
	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };
	
	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };
	
	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };
	
	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };
	
	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };
	
	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);
	
	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);
	
	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };
	
	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };
	
	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };
	
	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);
	
	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };
	
	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };
	
	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };
	
	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };
	
	
	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }
	
	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;
	
	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
	
	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }
	
	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);
	
	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };
	
	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };
	
	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };
	
	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };
	
	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };
	
	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };
	
	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });
	
	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }
	
	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }
	
	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };
	
	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };
	
	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };
	
	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };
	
	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };
	
	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };
	
	  // Utility Functions
	  // -----------------
	
	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };
	
	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };
	
	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };
	
	  _.noop = function(){};
	
	  _.property = property;
	
	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };
	
	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };
	
	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };
	
	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };
	
	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };
	
	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);
	
	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);
	
	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };
	
	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };
	
	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };
	
	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;
	
	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };
	
	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);
	
	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');
	
	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;
	
	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }
	
	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";
	
	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';
	
	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }
	
	    var template = function(data) {
	      return render.call(this, data, _);
	    };
	
	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';
	
	    return template;
	  };
	
	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };
	
	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.
	
	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };
	
	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };
	
	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);
	
	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });
	
	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });
	
	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };
	
	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
	
	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };
	
	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _index = __webpack_require__(7);
	
	var _index2 = _interopRequireDefault(_index);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (definePlugin) {
	  return definePlugin('renderers', ['config'], function (config) {
	    var renderers = [];
	
	    if (config.scrollable) {
	      if (config.scrollable.virtual) {
	        renderers.push(_index2.default.renderers.Virtualization);
	      }
	      if (config.scrollable.fixedHeader) {
	        renderers.push(_index2.default.renderers.FixedHeader);
	      }
	    }
	
	    return renderers;
	  });
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = {
	  TableLayout: __webpack_require__(8),
	  templates: {
	    table: __webpack_require__(11)
	  },
	  renderers: __webpack_require__(14)
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(9), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, Backbone) {
	  var View = Backbone.View.extend({
	    events: {
	      'click th': 'thClick',
	      'click td': 'tdClick',
	      'change td>input.grid-text-input': 'editableStringChange'
	    },
	
	    initialize: function initialize(options) {
	      _.bindAll(this, 'update', 'thClick', 'tdClick', 'dataFor');
	
	      this.options = _.extend(this.options, options);
	
	      // TODO [akamel] rename? this isn't a backbone data obj?
	      this.data = undefined;
	
	      this.container = options.container;
	      this.grid = options.grid;
	
	      this.renderers = _.map(this.options.renderers, function (Renderer) {
	        return new Renderer({ layout: this });
	      }.bind(this));
	
	      this.subviews = [];
	
	      this.onViewPortChange = this.onViewPortChange.bind(this);
	
	      if (!_.isEmpty(this.renderers)) {
	        this.listenTo(this.container, 'scroll:container', this.onViewPortChange);
	        this.listenTo(this.container, 'resize:container', this.onViewPortChange);
	      }
	    },
	
	    onViewPortChange: function onViewPortChange() {
	      this.scheduleDraw();
	    },
	
	    removeSubviews: function removeSubviews() {
	      _.each(this.subviews, function (subview) {
	        subview.remove();
	      });
	      this.subviews = [];
	    },
	
	    remove: function remove() {
	      this.removeSubviews();
	      this.container.stopListening(this.container);
	      _.each(this.renderers, function (renderer) {
	        return renderer.remove();
	      });
	      Backbone.View.prototype.remove.apply(this, arguments);
	    },
	
	    thClick: function thClick(e) {
	      var arg = this.dataFor(e.currentTarget);
	
	      if (arg.column) {
	        this.trigger('click:header', e, arg);
	      }
	    },
	
	    tdClick: function tdClick(e) {
	      var arg = this.dataFor(e.currentTarget);
	
	      if (arg.column) {
	        this.trigger('click:cell', e, arg);
	      }
	    },
	
	    editableStringChange: function editableStringChange(e) {
	      var arg = this.dataFor(e.currentTarget);
	      var colEditableStr = this.grid.projection.get('column.editable.string');
	
	      if (arg.column) {
	        if (_.isObject(colEditableStr) && !_.isUndefined(colEditableStr[arg.property])) {
	          this.grid.projection.get('projection:column-editable-string').trigger('change:string', e, arg);
	        } else {
	          this.trigger('change:editable.string', e, arg);
	        }
	      }
	    },
	
	    dataFor: function dataFor(el) {
	      if (!$.contains(this.el, el)) {
	        return undefined;
	      }
	
	      var $el = $(el);
	      // TODO [akamel] can we use target instead?
	      var $tr = $el.closest('tr', this.el);
	      var $closestTD = $el.closest('td', this.el);
	      var $closestTH = $el.closest('th', this.el);
	      var $td = _.size($closestTD) ? $closestTD : $closestTH;
	      var virtualizer = this.getRenderer('virtualization');
	      var i = $tr.index();
	      var j = $td.index();
	      // TODO [akamel] 1- check if $td is th; 2- throw if el is neither th or td as it is assumed in this function
	      var isHeader = $td.closest('thead', this.el).length;
	      var ret = { header: isHeader };
	
	      // we are not in header
	      if (isHeader) {
	        if (i === 0) {
	          ret.property = this.data.select[j];
	        } else if (i === 1) {
	          ret.property = this.data.subSelect[j];
	        } else {
	          ret.property = this.data.selectExpand[j];
	        }
	      } else {
	        i += virtualizer ? virtualizer.first : 0;
	        ret.model = this.data.value[i];
	        if (this.data.selectExpand) {
	          ret.property = this.data.selectExpand[j];
	        } else {
	          ret.property = this.data.select[j];
	        }
	      }
	
	      ret.column = this.data.columns[ret.property];
	      if (ret.property === this.grid.projection.get('column.checked')) {
	        // TODO [akamel] this shouldn't be here
	        var checkbox = $el.find('.column-selection');
	        if (checkbox.length) {
	          ret.checked = checkbox[0].checked;
	        }
	      }
	      ret.grid = this.grid;
	
	      return ret;
	    },
	
	    // TODO [akamel] [perf] 8.5%
	    toHTML: function toHTML(value) {
	      var data = _.defaults({ value: value }, this.data);
	
	      _.each(data.columns, function (col) {
	        if (_.isObject(col.$metadata)) {
	          if (_.has(col.$metadata['attr.head'], 'class') && _.isArray(col.$metadata['attr.head'].class)) {
	            col.$metadata['attr.head'].class = col.$metadata['attr.head'].class.join(' ');
	          }
	
	          if (_.has(col.$metadata['attr.body'], 'class') && _.isArray(col.$metadata['attr.body'].class)) {
	            col.$metadata['attr.body'].class = col.$metadata['attr.body'].class.join(' ');
	          }
	
	          // TODO [akamel] merge attr that are on $metadata['attr']
	        }
	      });
	
	      return this.options.template(data);
	    },
	
	    update: function update(model) {
	      _.each(this.renderers, function (renderer) {
	        renderer.update && renderer.update();
	      });
	
	      var value = model.get('value');
	      var columns = model.get('columns');
	      var columnsDelta = {};
	      var colOptions = this.options.columns || {};
	      var orderby = {};
	
	      _.each(this.grid.projection.get('orderby'), function (element, index) {
	        var key = _.first(_.keys(element));
	        orderby[key] = {
	          dir: element[key],
	          index: index
	        };
	      });
	
	      _.each(columns, function (col, property) {
	        // TODO [akamel] consider filtering which props to copy/override
	        var delta = {};
	        var colOption = colOptions[property];
	        var orderName = property;
	
	        if (colOption && _.isString(colOption.sortable)) {
	          orderName = colOption.sortable;
	        } else if (col && _.isString(col.sortable)) {
	          orderName = col.sortable;
	        }
	
	        if (orderby[orderName]) {
	          delta.$orderby = orderby[orderName];
	        }
	
	        columnsDelta[property] = _.defaults(delta, colOption, col);
	      });
	
	      if (_.has(this.options.$metadata, 'class') && _.isArray(this.options.$metadata.class)) {
	        this.options.$metadata.class = this.options.$metadata.class.join(' ');
	      }
	
	      var delta = {
	        'value': value,
	        'columns': columnsDelta,
	        'columns.lookup': _.indexBy(columns, function (col) {
	          return col.property;
	        }),
	        '$metadata': this.options.$metadata,
	        'hideHeaders': this.options.hideHeaders
	      };
	
	      this.data = _.defaults(delta, model.toJSON());
	
	      this.draw({ canSkipDraw: false });
	    },
	
	    scheduleDraw: function scheduleDraw() {
	      if (!this.scheduledDraw) {
	        this.scheduledDraw = true;
	
	        window.requestAnimationFrame(function () {
	          this.scheduledDraw = false;
	          this.draw();
	        }.bind(this));
	      }
	    },
	
	    drawable: function drawable() {
	      return this.data;
	    },
	
	    getRenderer: function getRenderer(name) {
	      return _.find(this.renderers, function (r) {
	        return r.name === name;
	      });
	    },
	
	    draw: function draw(options) {
	      if (!this.drawable()) {
	        return;
	      }
	
	      this.trigger('render:beginning');
	
	      var renderers = this.renderers;
	      var i = 0;
	
	      var middleware = function middleware(data, cb) {
	        var r = renderers[i++];
	        if (r) {
	          var clone = _.defaults({}, data, { css: {} });
	          delete clone.canSkipDraw;
	
	          r.draw(clone, _.once(function (err, res) {
	            res.canSkipDraw = data.canSkipDraw === true && res.canSkipDraw === true;
	            if (err) {
	              cb(err);
	            } else {
	              middleware(res || clone, cb);
	            }
	          }));
	        } else {
	          cb(undefined, data);
	        }
	      };
	
	      var canSkipDraw = _.has(options, 'canSkipDraw') ? options.canSkipDraw : true;
	
	      // this is _not_ and _cannot_ be async
	      middleware({ rows: this.data.value, canSkipDraw: canSkipDraw }, function (err, res) {
	        res.css && this.$el.css(res.css);
	
	        if (err) {
	          throw err;
	        }
	
	        this.removeSubviews();
	
	        if (res.canSkipDraw !== true) {
	          this.el.innerHTML = this.toHTML(res.rows);
	        }
	
	        _.each(this.data.columns, function (column) {
	          if (column.config) {
	            if (_.isFunction(column.config.View)) {
	              this.$('td.col-' + column.config.name).each(function (index, el) {
	                var cellView = new column.config.View({ model: this.dataFor(el).model });
	                this.$(el).html(cellView.render().el);
	                this.subviews.push(cellView);
	              }.bind(this));
	            }
	            if (_.isFunction(column.config.HeaderView)) {
	              this.$('th.col-' + column.config.name).each(function (index, el) {
	                var headerView = new column.config.HeaderView();
	                this.$(el).html(headerView.render().el);
	                this.subviews.push(headerView);
	              }.bind(this));
	            }
	          }
	        }, this);
	      }.bind(this));
	
	      this.trigger('render:finished');
	    },
	
	    render: function render() {
	      this.grid.on('change:data', this.update);
	
	      // this.grid.projection.data.on('change', this.update);
	    }
	  });
	
	  View.partial = function (options) {
	    return View.extend({ options: options });
	  };
	
	  return View;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.2.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-05-20T17:23Z
	 */
	
	(function( global, factory ) {
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];
	
	var document = window.document;
	
	var slice = arr.slice;
	
	var concat = arr.concat;
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var support = {};
	
	
	
	var
		version = "2.2.4",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
	
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
	
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// Start with an empty selector
		selector: "",
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?
	
				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :
	
				// Return all the elements in a clean array
				slice.call( this );
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor();
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
	
			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {
	
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {
	
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend( {
	
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},
	
		isArray: Array.isArray,
	
		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},
	
		isNumeric: function( obj ) {
	
			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
		},
	
		isPlainObject: function( obj ) {
			var key;
	
			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}
	
			// Not own constructor property must be Object
			if ( obj.constructor &&
					!hasOwn.call( obj, "constructor" ) &&
					!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
				return false;
			}
	
			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for ( key in obj ) {}
	
			return key === undefined || hasOwn.call( obj, key );
		},
	
		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
	
			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;
	
			code = jQuery.trim( code );
	
			if ( code ) {
	
				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf( "use strict" ) === 1 ) {
					script = document.createElement( "script" );
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {
	
					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval
	
					indirect( code );
				}
			}
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		each: function( obj, callback ) {
			var length, i = 0;
	
			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: Date.now,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );
	
	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	/* jshint ignore: end */
	
	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );
	
	function isArrayLike( obj ) {
	
		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.1
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-10-17
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
		rescape = /'|\\/g,
	
		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, nidselect, match, groups, newSelector,
			newContext = context && context.ownerDocument,
	
			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;
	
		results = results || [];
	
		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {
	
			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;
	
			if ( documentIsHTML ) {
	
				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
	
					// ID selector
					if ( (m = match[1]) ) {
	
						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {
	
								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}
	
						// Element context
						} else {
	
							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {
	
								results.push( elem );
								return results;
							}
						}
	
					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;
	
					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {
	
						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}
	
				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
	
					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;
	
					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {
	
						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rescape, "\\$&" );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}
	
						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
						while ( i-- ) {
							groups[i] = nidselect + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );
	
						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}
	
					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");
	
		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );
	
		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( (parent = document.defaultView) && parent.top !== parent ) {
			// Support: IE 11
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );
	
			// Support: IE 9 - 10 only
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( document.createComment("") );
			return !div.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});
	
		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];
	
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return document;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {
	
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
	
								// Seek `elem` from a previously-cached index
	
								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});
	
								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});
	
								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});
	
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});
	
									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}
	
								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {
	
										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {
	
											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});
	
												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});
	
												uniqueCache[ type ] = [ dirruns, diff ];
											}
	
											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},
	
			"disabled": function( elem ) {
				return elem.disabled === true;
			},
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
	
							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
	
							if ( (oldCache = uniqueCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ dir ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}
	
				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;
	
				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {
	
			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	
	
	
	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;
	
		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};
	
	
	var siblings = function( n, elem ) {
		var matched = [];
	
		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}
	
		return matched;
	};
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
	
		}
	
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
	
		}
	
		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}
	
			qualifier = jQuery.filter( qualifier, elements );
		}
	
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};
	
	jQuery.fn.extend( {
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	
		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {
	
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
	
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );
	
						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {
	
							// Inject the element directly into the jQuery object
							this.length = 1;
							this[ 0 ] = elem;
						}
	
						this.context = document;
						this.selector = selector;
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[ 0 ] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :
	
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;
	
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
	
					// Always skip document fragments
					if ( cur.nodeType < 11 && ( pos ?
						pos.index( cur ) > -1 :
	
						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {
	
						matched.push( cur );
						break;
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );
	
	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
	
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );
	
	
	
	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
	
			// Last fire value for non-forgettable lists
			memory,
	
			// Flag to know if list was already fired
			fired,
	
			// Flag to prevent firing
			locked,
	
			// Actual callback list
			list = [],
	
			// Queue of execution data for repeatable lists
			queue = [],
	
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
	
			// Fire callbacks
			fire = function() {
	
				// Enforce single-firing
				locked = options.once;
	
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {
	
						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {
	
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
	
				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}
	
				firing = false;
	
				// Clean up if we're done firing for good
				if ( locked ) {
	
					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];
	
					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
	
			// Actual Callbacks object
			self = {
	
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
	
						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}
	
						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
	
									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );
	
						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
	
							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},
	
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},
	
				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},
	
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},
	
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},
	
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
	
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	jQuery.extend( {
	
		Deferred: function( func ) {
			var tuples = [
	
					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
	
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this === promise ? newDefer.promise() : this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
	
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Keep pipe for back-compat
			promise.pipe = promise.then;
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];
	
				// promise[ done | fail | progress ] = list.add
				promise[ tuple[ 1 ] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add( function() {
	
						// state = [ resolved | rejected ]
						state = stateString;
	
					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}
	
				// deferred[ resolve | reject | notify ]
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,
	
				// the count of uncompleted subordinates
				remaining = length !== 1 ||
					( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
	
				// the master Deferred.
				// If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
	
				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},
	
				progressValues, progressContexts, resolveContexts;
	
			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.progress( updateFunc( i, progressContexts, progressValues ) )
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject );
					} else {
						--remaining;
					}
				}
			}
	
			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}
	
			return deferred.promise();
		}
	} );
	
	
	// The deferred used on DOM ready
	var readyList;
	
	jQuery.fn.ready = function( fn ) {
	
		// Add the callback
		jQuery.ready.promise().done( fn );
	
		return this;
	};
	
	jQuery.extend( {
	
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
	
			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	} );
	
	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}
	
	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {
	
			readyList = jQuery.Deferred();
	
			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if ( document.readyState === "complete" ||
				( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
	
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout( jQuery.ready );
	
			} else {
	
				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed );
	
				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed );
			}
		}
		return readyList.promise( obj );
	};
	
	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
	
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}
	
		return chainable ?
			elems :
	
			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {
	
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	
	
	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	
	Data.prototype = {
	
		register: function( owner, initial ) {
			var value = initial || {};
	
			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if ( owner.nodeType ) {
				owner[ this.expando ] = value;
	
			// Otherwise secure it in a non-enumerable, non-writable property
			// configurability must be true to allow the property to be
			// deleted with the delete operator
			} else {
				Object.defineProperty( owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				} );
			}
			return owner[ this.expando ];
		},
		cache: function( owner ) {
	
			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( !acceptData( owner ) ) {
				return {};
			}
	
			// Check if the owner object already has a cache
			var value = owner[ this.expando ];
	
			// If not, create one
			if ( !value ) {
				value = {};
	
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {
	
					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;
	
					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}
	
			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );
	
			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
	
				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
				owner[ this.expando ] && owner[ this.expando ][ key ];
		},
		access: function( owner, key, value ) {
			var stored;
	
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {
	
				stored = this.get( owner, key );
	
				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase( key ) );
			}
	
			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				cache = owner[ this.expando ];
	
			if ( cache === undefined ) {
				return;
			}
	
			if ( key === undefined ) {
				this.register( owner );
	
			} else {
	
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
	
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );
	
					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {
	
						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}
	
				i = name.length;
	
				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}
	
			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
	
				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();
	
	var dataUser = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
	
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch ( e ) {}
	
				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );
	
	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );
	
					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}
	
			return access( this, function( value ) {
				var data, camelKey;
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
	
					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get( elem, key ) ||
	
						// Try to find dashed key if it exists (gh-2779)
						// This is for 2.2.x only
						dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );
	
					if ( data !== undefined ) {
						return data;
					}
	
					camelKey = jQuery.camelCase( key );
	
					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				camelKey = jQuery.camelCase( key );
				this.each( function() {
	
					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get( this, camelKey );
	
					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set( this, camelKey, value );
	
					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
						dataUser.set( this, key, value );
					}
				} );
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );
	
	
	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );
	
	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}
	
			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
	
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
	
	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
	
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHidden = function( elem, el ) {
	
			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" ||
				!jQuery.contains( elem.ownerDocument, elem );
		};
	
	
	
	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() { return tween.cur(); } :
				function() { return jQuery.css( elem, prop, "" ); },
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );
	
		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
	
			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];
	
			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
	
			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;
	
			do {
	
				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";
	
				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );
	
			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}
	
		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;
	
			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = ( /^(?:checkbox|radio)$/i );
	
	var rtagName = ( /<([\w:-]+)/ );
	
	var rscriptType = ( /^$|\/(?:java|ecma)script/i );
	
	
	
	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {
	
		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
	
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
		_default: [ 0, "", "" ]
	};
	
	// Support: IE9
	wrapMap.optgroup = wrapMap.option;
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	
	function getAll( context, tag ) {
	
		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];
	
		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}
	
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	
	var rhtml = /<|&#?\w+;/;
	
	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			elem = elems[ i ];
	
			if ( elem || elem === 0 ) {
	
				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
	
					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );
	
				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
	
					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
	
					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}
	
					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );
	
					// Remember the top-level container
					tmp = fragment.firstChild;
	
					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}
	
		// Remove wrapper from fragment
		fragment.textContent = "";
	
		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {
	
			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}
	
			contains = jQuery.contains( elem.ownerDocument, elem );
	
			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );
	
			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}
	
			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}
	
		return fragment;
	}
	
	
	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;
	
		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
	
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
	
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}
	
		if ( data == null && fn == null ) {
	
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
	
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
	
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}
	
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
	
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
	
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {
	
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
	
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
	
			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
	
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},
	
		dispatch: function( event ) {
	
			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );
	
			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}
	
			return handlerQueue;
		},
	
		// Includes some event props shared by KeyEvent and MouseEvent
		props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
			"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),
	
		fixHooks: {},
	
		keyHooks: {
			props: "char charCode key keyCode".split( " " ),
			filter: function( event, original ) {
	
				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}
	
				return event;
			}
		},
	
		mouseHooks: {
			props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
				"screenX screenY toElement" ).split( " " ),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;
	
				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;
	
					event.pageX = original.clientX +
						( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
						( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY +
						( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
						( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}
	
				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}
	
				return event;
			}
		},
	
		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}
	
			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];
	
			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
	
			event = new jQuery.Event( originalEvent );
	
			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}
	
			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}
	
			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}
	
			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},
	
		special: {
			load: {
	
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
	
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
	
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};
	
	jQuery.removeEvent = function( elem, type, handle ) {
	
		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};
	
	jQuery.Event = function( src, props ) {
	
		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
	
					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );
	
	jQuery.fn.extend( {
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
	
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
	
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
	
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );
	
	
	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
	
		// Support: IE 10-11, Edge 10240+
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
	
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	
	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
	
			elem.getElementsByTagName( "tbody" )[ 0 ] ||
				elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
			elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
	
		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}
	
		return elem;
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;
	
			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			dataUser.set( dest, udataCur );
		}
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	function domManip( collection, args, callback, ignored ) {
	
		// Flatten any nested arrays
		args = concat.apply( [], args );
	
		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );
	
		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}
	
		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;
	
			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}
	
			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;
	
				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;
	
					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );
	
						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
	
							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}
	
					callback.call( collection[ i ], node, i );
				}
	
				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;
	
					// Reenable scripts
					jQuery.map( scripts, restoreScript );
	
					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {
	
							if ( node.src ) {
	
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}
	
		return collection;
	}
	
	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;
	
		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}
	
			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}
	
		return elem;
	}
	
	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},
	
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {
	
						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );
	
	jQuery.fn.extend( {
	
		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,
	
		detach: function( selector ) {
			return remove( this, selector, true );
		},
	
		remove: function( selector ) {
			return remove( this, selector );
		},
	
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},
	
		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},
	
		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},
	
		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},
	
		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = jQuery.htmlPrefilter( value );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var ignored = [];
	
			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;
	
				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}
	
			// Force callback invocation
			}, ignored );
		}
	} );
	
	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	} );
	
	
	var iframe,
		elemdisplay = {
	
			// Support: Firefox
			// We have to pre-define these values for FF (#10227)
			HTML: "block",
			BODY: "block"
		};
	
	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */
	
	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
	
			display = jQuery.css( elem[ 0 ], "display" );
	
		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();
	
		return display;
	}
	
	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];
	
		if ( !display ) {
			display = actualDisplay( nodeName, doc );
	
			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {
	
				// Use the already-created iframe if possible
				iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
					.appendTo( doc.documentElement );
	
				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;
	
				// Support: IE
				doc.write();
				doc.close();
	
				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}
	
			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}
	
		return display;
	}
	var rmargin = ( /^margin/ );
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
	
			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;
	
			if ( !view || !view.opener ) {
				view = window;
			}
	
			return view.getComputedStyle( elem );
		};
	
	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	var documentElement = document.documentElement;
	
	
	
	( function() {
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}
	
		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =
	
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );
	
			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";
	
			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";
	
			documentElement.removeChild( container );
		}
	
		jQuery.extend( support, {
			pixelPosition: function() {
	
				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
	
				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
	
				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function() {
	
				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );
	
				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
	
					// Support: Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;box-sizing:content-box;" +
					"display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild( container );
	
				ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );
	
				documentElement.removeChild( container );
				div.removeChild( marginDiv );
	
				return ret;
			}
		} );
	} )();
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;
	
		computed = computed || getStyles( elem );
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;
	
		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}
	
		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
	
			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
	
			// Support: IE9-11+
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
	
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
	
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}
	
	
	var
	
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;
	
	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {
	
		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}
	
		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}
	
	function setPositiveNumber( elem, value, subtract ) {
	
		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?
	
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
	
			// If we already have the right measurement, avoid augmentation
			4 :
	
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,
	
			val = 0;
	
		for ( ; i < 4; i += 2 ) {
	
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
	
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
	
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
	
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}
	
			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;
	
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			values[ index ] = dataPriv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {
	
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}
	
				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = dataPriv.access(
						elem,
						"olddisplay",
						defaultDisplay( elem.nodeName )
					);
				}
			} else {
				hidden = isHidden( elem );
	
				if ( display !== "none" || !hidden ) {
					dataPriv.set(
						elem,
						"olddisplay",
						hidden ? display : jQuery.css( elem, "display" )
					);
				}
			}
		}
	
		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}
	
		return elements;
	}
	
	jQuery.extend( {
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );
	
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}
	
				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {
	
					style[ name ] = value;
				}
	
			} else {
	
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
	
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );
	
	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
						elem.offsetWidth === 0 ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);
	
				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {
	
					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}
	
				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );
	
	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);
	
	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );
	
	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each( function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
	
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
	
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back Compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );
	
		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always( function() {
	
				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}
	
		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
	
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );
	
			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;
	
			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}
	
		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
	
			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}
	
		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", {} );
			}
	
			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done( function() {
					jQuery( elem ).hide();
				} );
			}
			anim.done( function() {
				var prop;
	
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
	
				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}
	
		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
			style.display = display;
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {
	
				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
	
					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ] );
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
	
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length ; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilters: [ defaultPrefilter ],
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
	
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {
	
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );
	
	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );
	
	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
	
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		window.clearInterval( timerId );
	
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
	
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};
	
	
	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;
	
		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();
	
	
	var boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );
	
	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}
	
			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}
	
			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}
	
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				elem.setAttribute( name, value + "" );
				return value;
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			ret = jQuery.find.attr( elem, name );
	
			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
	
		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					propName = jQuery.propFix[ name ] || name;
	
					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {
	
						// Set corresponding property to false
						elem[ propName ] = false;
					}
	
					elem.removeAttribute( name );
				}
			}
		}
	} );
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
	
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
	
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	} );
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;
	
	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );
	
	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
	
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				return ( elem[ name ] = value );
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			return elem[ name ];
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
	
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );
	
					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},
	
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );
	
	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;
	
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}
	
	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );
	
	
	
	
	var rclass = /[\t\r\n\f]/g;
	
	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}
	
	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
	
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
	
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}
	
			return this.each( function() {
				var className, i, self, classNames;
	
				if ( type === "string" ) {
	
					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];
	
					while ( ( className = classNames[ i++ ] ) ) {
	
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {
	
						// Store className if set
						dataPriv.set( this, "__className__", className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},
	
		hasClass: function( selector ) {
			var className, elem,
				i = 0;
	
			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}
	
			return false;
		}
	} );
	
	
	
	
	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;
	
	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}
	
					ret = elem.value;
	
					return typeof ret === "string" ?
	
						// Handle most common string cases
						ret.replace( rreturn, "" ) :
	
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each( function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );
	
	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {
	
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
	
						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
	
								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ?
									!option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );
	
	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	
	jQuery.extend( jQuery.event, {
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf( "." ) > -1 ) {
	
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);
	
			jQuery.event.trigger( e, null, elem );
		}
	
	} );
	
	jQuery.fn.extend( {
	
		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );
	
	
	jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
		function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );
	
	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );
	
	
	
	
	support.focusin = "onfocusin" in window;
	
	
	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );
	
					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;
	
	var nonce = jQuery.now();
	
	var rquery = ( /\?/ );
	
	
	
	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE9
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
	
				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {
	
					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
	
					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
	
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
	
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
	
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
	
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
	
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend( {
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
	
				// URL without anti-cache param
				cacheURL,
	
				// Response headers
				responseHeadersString,
				responseHeaders,
	
				// timeout handle
				timeoutTimer,
	
				// Url cleanup var
				urlAnchor,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				// Loop variable
				i,
	
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
	
				// Callbacks context
				callbackContext = s.context || s,
	
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,
	
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),
	
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
	
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
	
				// The jqXHR state
				state = 0,
	
				// Default abort message
				strAbort = "canceled",
	
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {
	
									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {
	
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;
	
			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
				.replace( rprotocol, location.protocol + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
	
			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );
	
				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;
	
					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {
	
					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
	
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?
	
						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :
	
						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
	
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
	
				// If request was aborted inside ajaxSend, stop there
				if ( state === 2 ) {
					return jqXHR;
				}
	
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}
	
				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {
	
					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );
	
					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Called once
				if ( state === 2 ) {
					return;
				}
	
				// State is "done" now
				state = 2;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
	
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
	
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
	
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,
	
			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		} );
	};
	
	
	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;
	
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapAll( html.call( this, i ) );
				} );
			}
	
			if ( this[ 0 ] ) {
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map( function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				} ).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}
	
			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			} );
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},
	
		unwrap: function() {
			return this.parent().each( function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			} ).end();
		}
	} );
	
	
	jQuery.expr.filters.hidden = function( elem ) {
		return !jQuery.expr.filters.visible( elem );
	};
	jQuery.expr.filters.visible = function( elem ) {
	
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};
	
	
	
	
	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
	
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
	
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
	
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
	
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
	
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {
	
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};
	
		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );
	
		} else {
	
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};
	
	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {
	
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();
	
				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};
	
	var xhrSuccessStatus = {
	
			// File protocol always yields status code 0, assume 200
			0: 200,
	
			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();
	
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
	
									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(
	
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
	
										// Support: IE9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );
	
					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {
	
							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {
	
								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}
	
					// Create the abort callback
					callback = callback( "abort" );
	
					try {
	
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
	
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
	
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
	
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// Force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always( function() {
	
				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );
	
				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}
	
				// Save back as free
				if ( s[ callbackName ] ) {
	
					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			} );
	
			// Delegate to script
			return "script";
		}
	} );
	
	
	
	
	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;
	
		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}
	
		parsed = buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	// Keep a copy of the old load method
	var _load = jQuery.fn.load;
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}
	
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );
	
		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,
	
				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );
	
	
	
	
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};
	
	
	
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
	
				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend( {
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}
	
			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;
	
			if ( !doc ) {
				return;
			}
	
			docElem = doc.documentElement;
	
			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}
	
			box = elem.getBoundingClientRect();
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
	
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
	
			} else {
	
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;
	
				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || documentElement;
			} );
		}
	} );
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );
	
	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
	
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {
	
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
	
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
	
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		} );
	} );
	
	
	jQuery.fn.extend( {
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
	
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		},
		size: function() {
			return this.length;
		}
	} );
	
	jQuery.fn.andSelf = jQuery.fn.addBack;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	var
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}
	
	return jQuery;
	}));


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {//     Backbone.js 1.3.3
	
	//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Backbone may be freely distributed under the MIT license.
	//     For all details and documentation:
	//     http://backbonejs.org
	
	(function(factory) {
	
	  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
	  // We use `self` instead of `window` for `WebWorker` support.
	  var root = (typeof self == 'object' && self.self === self && self) ||
	            (typeof global == 'object' && global.global === global && global);
	
	  // Set up Backbone appropriately for the environment. Start with AMD.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(9), exports], __WEBPACK_AMD_DEFINE_RESULT__ = function(_, $, exports) {
	      // Export global even in AMD case in case this script is loaded with
	      // others that may still expect a global Backbone.
	      root.Backbone = factory(root, exports, _, $);
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
	  } else if (typeof exports !== 'undefined') {
	    var _ = require('underscore'), $;
	    try { $ = require('jquery'); } catch (e) {}
	    factory(root, exports, _, $);
	
	  // Finally, as a browser global.
	  } else {
	    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
	  }
	
	})(function(root, Backbone, _, $) {
	
	  // Initial Setup
	  // -------------
	
	  // Save the previous value of the `Backbone` variable, so that it can be
	  // restored later on, if `noConflict` is used.
	  var previousBackbone = root.Backbone;
	
	  // Create a local reference to a common array method we'll want to use later.
	  var slice = Array.prototype.slice;
	
	  // Current version of the library. Keep in sync with `package.json`.
	  Backbone.VERSION = '1.3.3';
	
	  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
	  // the `$` variable.
	  Backbone.$ = $;
	
	  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
	  // to its previous owner. Returns a reference to this Backbone object.
	  Backbone.noConflict = function() {
	    root.Backbone = previousBackbone;
	    return this;
	  };
	
	  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
	  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
	  // set a `X-Http-Method-Override` header.
	  Backbone.emulateHTTP = false;
	
	  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
	  // `application/json` requests ... this will encode the body as
	  // `application/x-www-form-urlencoded` instead and will send the model in a
	  // form param named `model`.
	  Backbone.emulateJSON = false;
	
	  // Proxy Backbone class methods to Underscore functions, wrapping the model's
	  // `attributes` object or collection's `models` array behind the scenes.
	  //
	  // collection.filter(function(model) { return model.get('age') > 10 });
	  // collection.each(this.addView);
	  //
	  // `Function#apply` can be slow so we use the method's arg count, if we know it.
	  var addMethod = function(length, method, attribute) {
	    switch (length) {
	      case 1: return function() {
	        return _[method](this[attribute]);
	      };
	      case 2: return function(value) {
	        return _[method](this[attribute], value);
	      };
	      case 3: return function(iteratee, context) {
	        return _[method](this[attribute], cb(iteratee, this), context);
	      };
	      case 4: return function(iteratee, defaultVal, context) {
	        return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
	      };
	      default: return function() {
	        var args = slice.call(arguments);
	        args.unshift(this[attribute]);
	        return _[method].apply(_, args);
	      };
	    }
	  };
	  var addUnderscoreMethods = function(Class, methods, attribute) {
	    _.each(methods, function(length, method) {
	      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
	    });
	  };
	
	  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
	  var cb = function(iteratee, instance) {
	    if (_.isFunction(iteratee)) return iteratee;
	    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
	    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };
	    return iteratee;
	  };
	  var modelMatcher = function(attrs) {
	    var matcher = _.matches(attrs);
	    return function(model) {
	      return matcher(model.attributes);
	    };
	  };
	
	  // Backbone.Events
	  // ---------------
	
	  // A module that can be mixed in to *any object* in order to provide it with
	  // a custom event channel. You may bind a callback to an event with `on` or
	  // remove with `off`; `trigger`-ing an event fires all callbacks in
	  // succession.
	  //
	  //     var object = {};
	  //     _.extend(object, Backbone.Events);
	  //     object.on('expand', function(){ alert('expanded'); });
	  //     object.trigger('expand');
	  //
	  var Events = Backbone.Events = {};
	
	  // Regular expression used to split event strings.
	  var eventSplitter = /\s+/;
	
	  // Iterates over the standard `event, callback` (as well as the fancy multiple
	  // space-separated events `"change blur", callback` and jQuery-style event
	  // maps `{event: callback}`).
	  var eventsApi = function(iteratee, events, name, callback, opts) {
	    var i = 0, names;
	    if (name && typeof name === 'object') {
	      // Handle event maps.
	      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
	      for (names = _.keys(name); i < names.length ; i++) {
	        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
	      }
	    } else if (name && eventSplitter.test(name)) {
	      // Handle space-separated event names by delegating them individually.
	      for (names = name.split(eventSplitter); i < names.length; i++) {
	        events = iteratee(events, names[i], callback, opts);
	      }
	    } else {
	      // Finally, standard events.
	      events = iteratee(events, name, callback, opts);
	    }
	    return events;
	  };
	
	  // Bind an event to a `callback` function. Passing `"all"` will bind
	  // the callback to all events fired.
	  Events.on = function(name, callback, context) {
	    return internalOn(this, name, callback, context);
	  };
	
	  // Guard the `listening` argument from the public API.
	  var internalOn = function(obj, name, callback, context, listening) {
	    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
	      context: context,
	      ctx: obj,
	      listening: listening
	    });
	
	    if (listening) {
	      var listeners = obj._listeners || (obj._listeners = {});
	      listeners[listening.id] = listening;
	    }
	
	    return obj;
	  };
	
	  // Inversion-of-control versions of `on`. Tell *this* object to listen to
	  // an event in another object... keeping track of what it's listening to
	  // for easier unbinding later.
	  Events.listenTo = function(obj, name, callback) {
	    if (!obj) return this;
	    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
	    var listeningTo = this._listeningTo || (this._listeningTo = {});
	    var listening = listeningTo[id];
	
	    // This object is not listening to any other events on `obj` yet.
	    // Setup the necessary references to track the listening callbacks.
	    if (!listening) {
	      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
	      listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};
	    }
	
	    // Bind callbacks on obj, and keep track of them on listening.
	    internalOn(obj, name, callback, this, listening);
	    return this;
	  };
	
	  // The reducing API that adds a callback to the `events` object.
	  var onApi = function(events, name, callback, options) {
	    if (callback) {
	      var handlers = events[name] || (events[name] = []);
	      var context = options.context, ctx = options.ctx, listening = options.listening;
	      if (listening) listening.count++;
	
	      handlers.push({callback: callback, context: context, ctx: context || ctx, listening: listening});
	    }
	    return events;
	  };
	
	  // Remove one or many callbacks. If `context` is null, removes all
	  // callbacks with that function. If `callback` is null, removes all
	  // callbacks for the event. If `name` is null, removes all bound
	  // callbacks for all events.
	  Events.off = function(name, callback, context) {
	    if (!this._events) return this;
	    this._events = eventsApi(offApi, this._events, name, callback, {
	      context: context,
	      listeners: this._listeners
	    });
	    return this;
	  };
	
	  // Tell this object to stop listening to either specific events ... or
	  // to every object it's currently listening to.
	  Events.stopListening = function(obj, name, callback) {
	    var listeningTo = this._listeningTo;
	    if (!listeningTo) return this;
	
	    var ids = obj ? [obj._listenId] : _.keys(listeningTo);
	
	    for (var i = 0; i < ids.length; i++) {
	      var listening = listeningTo[ids[i]];
	
	      // If listening doesn't exist, this object is not currently
	      // listening to obj. Break out early.
	      if (!listening) break;
	
	      listening.obj.off(name, callback, this);
	    }
	
	    return this;
	  };
	
	  // The reducing API that removes a callback from the `events` object.
	  var offApi = function(events, name, callback, options) {
	    if (!events) return;
	
	    var i = 0, listening;
	    var context = options.context, listeners = options.listeners;
	
	    // Delete all events listeners and "drop" events.
	    if (!name && !callback && !context) {
	      var ids = _.keys(listeners);
	      for (; i < ids.length; i++) {
	        listening = listeners[ids[i]];
	        delete listeners[listening.id];
	        delete listening.listeningTo[listening.objId];
	      }
	      return;
	    }
	
	    var names = name ? [name] : _.keys(events);
	    for (; i < names.length; i++) {
	      name = names[i];
	      var handlers = events[name];
	
	      // Bail out if there are no events stored.
	      if (!handlers) break;
	
	      // Replace events if there are any remaining.  Otherwise, clean up.
	      var remaining = [];
	      for (var j = 0; j < handlers.length; j++) {
	        var handler = handlers[j];
	        if (
	          callback && callback !== handler.callback &&
	            callback !== handler.callback._callback ||
	              context && context !== handler.context
	        ) {
	          remaining.push(handler);
	        } else {
	          listening = handler.listening;
	          if (listening && --listening.count === 0) {
	            delete listeners[listening.id];
	            delete listening.listeningTo[listening.objId];
	          }
	        }
	      }
	
	      // Update tail event if the list has any events.  Otherwise, clean up.
	      if (remaining.length) {
	        events[name] = remaining;
	      } else {
	        delete events[name];
	      }
	    }
	    return events;
	  };
	
	  // Bind an event to only be triggered a single time. After the first time
	  // the callback is invoked, its listener will be removed. If multiple events
	  // are passed in using the space-separated syntax, the handler will fire
	  // once for each event, not once for a combination of all events.
	  Events.once = function(name, callback, context) {
	    // Map the event into a `{event: once}` object.
	    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
	    if (typeof name === 'string' && context == null) callback = void 0;
	    return this.on(events, callback, context);
	  };
	
	  // Inversion-of-control versions of `once`.
	  Events.listenToOnce = function(obj, name, callback) {
	    // Map the event into a `{event: once}` object.
	    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
	    return this.listenTo(obj, events);
	  };
	
	  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
	  // `offer` unbinds the `onceWrapper` after it has been called.
	  var onceMap = function(map, name, callback, offer) {
	    if (callback) {
	      var once = map[name] = _.once(function() {
	        offer(name, once);
	        callback.apply(this, arguments);
	      });
	      once._callback = callback;
	    }
	    return map;
	  };
	
	  // Trigger one or many events, firing all bound callbacks. Callbacks are
	  // passed the same arguments as `trigger` is, apart from the event name
	  // (unless you're listening on `"all"`, which will cause your callback to
	  // receive the true name of the event as the first argument).
	  Events.trigger = function(name) {
	    if (!this._events) return this;
	
	    var length = Math.max(0, arguments.length - 1);
	    var args = Array(length);
	    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];
	
	    eventsApi(triggerApi, this._events, name, void 0, args);
	    return this;
	  };
	
	  // Handles triggering the appropriate event callbacks.
	  var triggerApi = function(objEvents, name, callback, args) {
	    if (objEvents) {
	      var events = objEvents[name];
	      var allEvents = objEvents.all;
	      if (events && allEvents) allEvents = allEvents.slice();
	      if (events) triggerEvents(events, args);
	      if (allEvents) triggerEvents(allEvents, [name].concat(args));
	    }
	    return objEvents;
	  };
	
	  // A difficult-to-believe, but optimized internal dispatch function for
	  // triggering events. Tries to keep the usual cases speedy (most internal
	  // Backbone events have 3 arguments).
	  var triggerEvents = function(events, args) {
	    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
	    switch (args.length) {
	      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
	      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
	      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
	      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
	      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
	    }
	  };
	
	  // Aliases for backwards compatibility.
	  Events.bind   = Events.on;
	  Events.unbind = Events.off;
	
	  // Allow the `Backbone` object to serve as a global event bus, for folks who
	  // want global "pubsub" in a convenient place.
	  _.extend(Backbone, Events);
	
	  // Backbone.Model
	  // --------------
	
	  // Backbone **Models** are the basic data object in the framework --
	  // frequently representing a row in a table in a database on your server.
	  // A discrete chunk of data and a bunch of useful, related methods for
	  // performing computations and transformations on that data.
	
	  // Create a new model with the specified attributes. A client id (`cid`)
	  // is automatically generated and assigned for you.
	  var Model = Backbone.Model = function(attributes, options) {
	    var attrs = attributes || {};
	    options || (options = {});
	    this.cid = _.uniqueId(this.cidPrefix);
	    this.attributes = {};
	    if (options.collection) this.collection = options.collection;
	    if (options.parse) attrs = this.parse(attrs, options) || {};
	    var defaults = _.result(this, 'defaults');
	    attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
	    this.set(attrs, options);
	    this.changed = {};
	    this.initialize.apply(this, arguments);
	  };
	
	  // Attach all inheritable methods to the Model prototype.
	  _.extend(Model.prototype, Events, {
	
	    // A hash of attributes whose current and previous value differ.
	    changed: null,
	
	    // The value returned during the last failed validation.
	    validationError: null,
	
	    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
	    // CouchDB users may want to set this to `"_id"`.
	    idAttribute: 'id',
	
	    // The prefix is used to create the client id which is used to identify models locally.
	    // You may want to override this if you're experiencing name clashes with model ids.
	    cidPrefix: 'c',
	
	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},
	
	    // Return a copy of the model's `attributes` object.
	    toJSON: function(options) {
	      return _.clone(this.attributes);
	    },
	
	    // Proxy `Backbone.sync` by default -- but override this if you need
	    // custom syncing semantics for *this* particular model.
	    sync: function() {
	      return Backbone.sync.apply(this, arguments);
	    },
	
	    // Get the value of an attribute.
	    get: function(attr) {
	      return this.attributes[attr];
	    },
	
	    // Get the HTML-escaped value of an attribute.
	    escape: function(attr) {
	      return _.escape(this.get(attr));
	    },
	
	    // Returns `true` if the attribute contains a value that is not null
	    // or undefined.
	    has: function(attr) {
	      return this.get(attr) != null;
	    },
	
	    // Special-cased proxy to underscore's `_.matches` method.
	    matches: function(attrs) {
	      return !!_.iteratee(attrs, this)(this.attributes);
	    },
	
	    // Set a hash of model attributes on the object, firing `"change"`. This is
	    // the core primitive operation of a model, updating the data and notifying
	    // anyone who needs to know about the change in state. The heart of the beast.
	    set: function(key, val, options) {
	      if (key == null) return this;
	
	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      var attrs;
	      if (typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }
	
	      options || (options = {});
	
	      // Run validation.
	      if (!this._validate(attrs, options)) return false;
	
	      // Extract attributes and options.
	      var unset      = options.unset;
	      var silent     = options.silent;
	      var changes    = [];
	      var changing   = this._changing;
	      this._changing = true;
	
	      if (!changing) {
	        this._previousAttributes = _.clone(this.attributes);
	        this.changed = {};
	      }
	
	      var current = this.attributes;
	      var changed = this.changed;
	      var prev    = this._previousAttributes;
	
	      // For each `set` attribute, update or delete the current value.
	      for (var attr in attrs) {
	        val = attrs[attr];
	        if (!_.isEqual(current[attr], val)) changes.push(attr);
	        if (!_.isEqual(prev[attr], val)) {
	          changed[attr] = val;
	        } else {
	          delete changed[attr];
	        }
	        unset ? delete current[attr] : current[attr] = val;
	      }
	
	      // Update the `id`.
	      if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);
	
	      // Trigger all relevant attribute changes.
	      if (!silent) {
	        if (changes.length) this._pending = options;
	        for (var i = 0; i < changes.length; i++) {
	          this.trigger('change:' + changes[i], this, current[changes[i]], options);
	        }
	      }
	
	      // You might be wondering why there's a `while` loop here. Changes can
	      // be recursively nested within `"change"` events.
	      if (changing) return this;
	      if (!silent) {
	        while (this._pending) {
	          options = this._pending;
	          this._pending = false;
	          this.trigger('change', this, options);
	        }
	      }
	      this._pending = false;
	      this._changing = false;
	      return this;
	    },
	
	    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
	    // if the attribute doesn't exist.
	    unset: function(attr, options) {
	      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
	    },
	
	    // Clear all attributes on the model, firing `"change"`.
	    clear: function(options) {
	      var attrs = {};
	      for (var key in this.attributes) attrs[key] = void 0;
	      return this.set(attrs, _.extend({}, options, {unset: true}));
	    },
	
	    // Determine if the model has changed since the last `"change"` event.
	    // If you specify an attribute name, determine if that attribute has changed.
	    hasChanged: function(attr) {
	      if (attr == null) return !_.isEmpty(this.changed);
	      return _.has(this.changed, attr);
	    },
	
	    // Return an object containing all the attributes that have changed, or
	    // false if there are no changed attributes. Useful for determining what
	    // parts of a view need to be updated and/or what attributes need to be
	    // persisted to the server. Unset attributes will be set to undefined.
	    // You can also pass an attributes object to diff against the model,
	    // determining if there *would be* a change.
	    changedAttributes: function(diff) {
	      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
	      var old = this._changing ? this._previousAttributes : this.attributes;
	      var changed = {};
	      for (var attr in diff) {
	        var val = diff[attr];
	        if (_.isEqual(old[attr], val)) continue;
	        changed[attr] = val;
	      }
	      return _.size(changed) ? changed : false;
	    },
	
	    // Get the previous value of an attribute, recorded at the time the last
	    // `"change"` event was fired.
	    previous: function(attr) {
	      if (attr == null || !this._previousAttributes) return null;
	      return this._previousAttributes[attr];
	    },
	
	    // Get all of the attributes of the model at the time of the previous
	    // `"change"` event.
	    previousAttributes: function() {
	      return _.clone(this._previousAttributes);
	    },
	
	    // Fetch the model from the server, merging the response with the model's
	    // local attributes. Any changed attributes will trigger a "change" event.
	    fetch: function(options) {
	      options = _.extend({parse: true}, options);
	      var model = this;
	      var success = options.success;
	      options.success = function(resp) {
	        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
	        if (!model.set(serverAttrs, options)) return false;
	        if (success) success.call(options.context, model, resp, options);
	        model.trigger('sync', model, resp, options);
	      };
	      wrapError(this, options);
	      return this.sync('read', this, options);
	    },
	
	    // Set a hash of model attributes, and sync the model to the server.
	    // If the server returns an attributes hash that differs, the model's
	    // state will be `set` again.
	    save: function(key, val, options) {
	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      var attrs;
	      if (key == null || typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }
	
	      options = _.extend({validate: true, parse: true}, options);
	      var wait = options.wait;
	
	      // If we're not waiting and attributes exist, save acts as
	      // `set(attr).save(null, opts)` with validation. Otherwise, check if
	      // the model will be valid when the attributes, if any, are set.
	      if (attrs && !wait) {
	        if (!this.set(attrs, options)) return false;
	      } else if (!this._validate(attrs, options)) {
	        return false;
	      }
	
	      // After a successful server-side save, the client is (optionally)
	      // updated with the server-side state.
	      var model = this;
	      var success = options.success;
	      var attributes = this.attributes;
	      options.success = function(resp) {
	        // Ensure attributes are restored during synchronous saves.
	        model.attributes = attributes;
	        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
	        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
	        if (serverAttrs && !model.set(serverAttrs, options)) return false;
	        if (success) success.call(options.context, model, resp, options);
	        model.trigger('sync', model, resp, options);
	      };
	      wrapError(this, options);
	
	      // Set temporary attributes if `{wait: true}` to properly find new ids.
	      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);
	
	      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
	      if (method === 'patch' && !options.attrs) options.attrs = attrs;
	      var xhr = this.sync(method, this, options);
	
	      // Restore attributes.
	      this.attributes = attributes;
	
	      return xhr;
	    },
	
	    // Destroy this model on the server if it was already persisted.
	    // Optimistically removes the model from its collection, if it has one.
	    // If `wait: true` is passed, waits for the server to respond before removal.
	    destroy: function(options) {
	      options = options ? _.clone(options) : {};
	      var model = this;
	      var success = options.success;
	      var wait = options.wait;
	
	      var destroy = function() {
	        model.stopListening();
	        model.trigger('destroy', model, model.collection, options);
	      };
	
	      options.success = function(resp) {
	        if (wait) destroy();
	        if (success) success.call(options.context, model, resp, options);
	        if (!model.isNew()) model.trigger('sync', model, resp, options);
	      };
	
	      var xhr = false;
	      if (this.isNew()) {
	        _.defer(options.success);
	      } else {
	        wrapError(this, options);
	        xhr = this.sync('delete', this, options);
	      }
	      if (!wait) destroy();
	      return xhr;
	    },
	
	    // Default URL for the model's representation on the server -- if you're
	    // using Backbone's restful methods, override this to change the endpoint
	    // that will be called.
	    url: function() {
	      var base =
	        _.result(this, 'urlRoot') ||
	        _.result(this.collection, 'url') ||
	        urlError();
	      if (this.isNew()) return base;
	      var id = this.get(this.idAttribute);
	      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
	    },
	
	    // **parse** converts a response into the hash of attributes to be `set` on
	    // the model. The default implementation is just to pass the response along.
	    parse: function(resp, options) {
	      return resp;
	    },
	
	    // Create a new model with identical attributes to this one.
	    clone: function() {
	      return new this.constructor(this.attributes);
	    },
	
	    // A model is new if it has never been saved to the server, and lacks an id.
	    isNew: function() {
	      return !this.has(this.idAttribute);
	    },
	
	    // Check if the model is currently in a valid state.
	    isValid: function(options) {
	      return this._validate({}, _.extend({}, options, {validate: true}));
	    },
	
	    // Run validation against the next complete set of model attributes,
	    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
	    _validate: function(attrs, options) {
	      if (!options.validate || !this.validate) return true;
	      attrs = _.extend({}, this.attributes, attrs);
	      var error = this.validationError = this.validate(attrs, options) || null;
	      if (!error) return true;
	      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
	      return false;
	    }
	
	  });
	
	  // Underscore methods that we want to implement on the Model, mapped to the
	  // number of arguments they take.
	  var modelMethods = {keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
	      omit: 0, chain: 1, isEmpty: 1};
	
	  // Mix in each Underscore method as a proxy to `Model#attributes`.
	  addUnderscoreMethods(Model, modelMethods, 'attributes');
	
	  // Backbone.Collection
	  // -------------------
	
	  // If models tend to represent a single row of data, a Backbone Collection is
	  // more analogous to a table full of data ... or a small slice or page of that
	  // table, or a collection of rows that belong together for a particular reason
	  // -- all of the messages in this particular folder, all of the documents
	  // belonging to this particular author, and so on. Collections maintain
	  // indexes of their models, both in order, and for lookup by `id`.
	
	  // Create a new **Collection**, perhaps to contain a specific type of `model`.
	  // If a `comparator` is specified, the Collection will maintain
	  // its models in sort order, as they're added and removed.
	  var Collection = Backbone.Collection = function(models, options) {
	    options || (options = {});
	    if (options.model) this.model = options.model;
	    if (options.comparator !== void 0) this.comparator = options.comparator;
	    this._reset();
	    this.initialize.apply(this, arguments);
	    if (models) this.reset(models, _.extend({silent: true}, options));
	  };
	
	  // Default options for `Collection#set`.
	  var setOptions = {add: true, remove: true, merge: true};
	  var addOptions = {add: true, remove: false};
	
	  // Splices `insert` into `array` at index `at`.
	  var splice = function(array, insert, at) {
	    at = Math.min(Math.max(at, 0), array.length);
	    var tail = Array(array.length - at);
	    var length = insert.length;
	    var i;
	    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
	    for (i = 0; i < length; i++) array[i + at] = insert[i];
	    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
	  };
	
	  // Define the Collection's inheritable methods.
	  _.extend(Collection.prototype, Events, {
	
	    // The default model for a collection is just a **Backbone.Model**.
	    // This should be overridden in most cases.
	    model: Model,
	
	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},
	
	    // The JSON representation of a Collection is an array of the
	    // models' attributes.
	    toJSON: function(options) {
	      return this.map(function(model) { return model.toJSON(options); });
	    },
	
	    // Proxy `Backbone.sync` by default.
	    sync: function() {
	      return Backbone.sync.apply(this, arguments);
	    },
	
	    // Add a model, or list of models to the set. `models` may be Backbone
	    // Models or raw JavaScript objects to be converted to Models, or any
	    // combination of the two.
	    add: function(models, options) {
	      return this.set(models, _.extend({merge: false}, options, addOptions));
	    },
	
	    // Remove a model, or a list of models from the set.
	    remove: function(models, options) {
	      options = _.extend({}, options);
	      var singular = !_.isArray(models);
	      models = singular ? [models] : models.slice();
	      var removed = this._removeModels(models, options);
	      if (!options.silent && removed.length) {
	        options.changes = {added: [], merged: [], removed: removed};
	        this.trigger('update', this, options);
	      }
	      return singular ? removed[0] : removed;
	    },
	
	    // Update a collection by `set`-ing a new list of models, adding new ones,
	    // removing models that are no longer present, and merging models that
	    // already exist in the collection, as necessary. Similar to **Model#set**,
	    // the core operation for updating the data contained by the collection.
	    set: function(models, options) {
	      if (models == null) return;
	
	      options = _.extend({}, setOptions, options);
	      if (options.parse && !this._isModel(models)) {
	        models = this.parse(models, options) || [];
	      }
	
	      var singular = !_.isArray(models);
	      models = singular ? [models] : models.slice();
	
	      var at = options.at;
	      if (at != null) at = +at;
	      if (at > this.length) at = this.length;
	      if (at < 0) at += this.length + 1;
	
	      var set = [];
	      var toAdd = [];
	      var toMerge = [];
	      var toRemove = [];
	      var modelMap = {};
	
	      var add = options.add;
	      var merge = options.merge;
	      var remove = options.remove;
	
	      var sort = false;
	      var sortable = this.comparator && at == null && options.sort !== false;
	      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
	
	      // Turn bare objects into model references, and prevent invalid models
	      // from being added.
	      var model, i;
	      for (i = 0; i < models.length; i++) {
	        model = models[i];
	
	        // If a duplicate is found, prevent it from being added and
	        // optionally merge it into the existing model.
	        var existing = this.get(model);
	        if (existing) {
	          if (merge && model !== existing) {
	            var attrs = this._isModel(model) ? model.attributes : model;
	            if (options.parse) attrs = existing.parse(attrs, options);
	            existing.set(attrs, options);
	            toMerge.push(existing);
	            if (sortable && !sort) sort = existing.hasChanged(sortAttr);
	          }
	          if (!modelMap[existing.cid]) {
	            modelMap[existing.cid] = true;
	            set.push(existing);
	          }
	          models[i] = existing;
	
	        // If this is a new, valid model, push it to the `toAdd` list.
	        } else if (add) {
	          model = models[i] = this._prepareModel(model, options);
	          if (model) {
	            toAdd.push(model);
	            this._addReference(model, options);
	            modelMap[model.cid] = true;
	            set.push(model);
	          }
	        }
	      }
	
	      // Remove stale models.
	      if (remove) {
	        for (i = 0; i < this.length; i++) {
	          model = this.models[i];
	          if (!modelMap[model.cid]) toRemove.push(model);
	        }
	        if (toRemove.length) this._removeModels(toRemove, options);
	      }
	
	      // See if sorting is needed, update `length` and splice in new models.
	      var orderChanged = false;
	      var replace = !sortable && add && remove;
	      if (set.length && replace) {
	        orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {
	          return m !== set[index];
	        });
	        this.models.length = 0;
	        splice(this.models, set, 0);
	        this.length = this.models.length;
	      } else if (toAdd.length) {
	        if (sortable) sort = true;
	        splice(this.models, toAdd, at == null ? this.length : at);
	        this.length = this.models.length;
	      }
	
	      // Silently sort the collection if appropriate.
	      if (sort) this.sort({silent: true});
	
	      // Unless silenced, it's time to fire all appropriate add/sort/update events.
	      if (!options.silent) {
	        for (i = 0; i < toAdd.length; i++) {
	          if (at != null) options.index = at + i;
	          model = toAdd[i];
	          model.trigger('add', model, this, options);
	        }
	        if (sort || orderChanged) this.trigger('sort', this, options);
	        if (toAdd.length || toRemove.length || toMerge.length) {
	          options.changes = {
	            added: toAdd,
	            removed: toRemove,
	            merged: toMerge
	          };
	          this.trigger('update', this, options);
	        }
	      }
	
	      // Return the added (or merged) model (or models).
	      return singular ? models[0] : models;
	    },
	
	    // When you have more items than you want to add or remove individually,
	    // you can reset the entire set with a new list of models, without firing
	    // any granular `add` or `remove` events. Fires `reset` when finished.
	    // Useful for bulk operations and optimizations.
	    reset: function(models, options) {
	      options = options ? _.clone(options) : {};
	      for (var i = 0; i < this.models.length; i++) {
	        this._removeReference(this.models[i], options);
	      }
	      options.previousModels = this.models;
	      this._reset();
	      models = this.add(models, _.extend({silent: true}, options));
	      if (!options.silent) this.trigger('reset', this, options);
	      return models;
	    },
	
	    // Add a model to the end of the collection.
	    push: function(model, options) {
	      return this.add(model, _.extend({at: this.length}, options));
	    },
	
	    // Remove a model from the end of the collection.
	    pop: function(options) {
	      var model = this.at(this.length - 1);
	      return this.remove(model, options);
	    },
	
	    // Add a model to the beginning of the collection.
	    unshift: function(model, options) {
	      return this.add(model, _.extend({at: 0}, options));
	    },
	
	    // Remove a model from the beginning of the collection.
	    shift: function(options) {
	      var model = this.at(0);
	      return this.remove(model, options);
	    },
	
	    // Slice out a sub-array of models from the collection.
	    slice: function() {
	      return slice.apply(this.models, arguments);
	    },
	
	    // Get a model from the set by id, cid, model object with id or cid
	    // properties, or an attributes object that is transformed through modelId.
	    get: function(obj) {
	      if (obj == null) return void 0;
	      return this._byId[obj] ||
	        this._byId[this.modelId(obj.attributes || obj)] ||
	        obj.cid && this._byId[obj.cid];
	    },
	
	    // Returns `true` if the model is in the collection.
	    has: function(obj) {
	      return this.get(obj) != null;
	    },
	
	    // Get the model at the given index.
	    at: function(index) {
	      if (index < 0) index += this.length;
	      return this.models[index];
	    },
	
	    // Return models with matching attributes. Useful for simple cases of
	    // `filter`.
	    where: function(attrs, first) {
	      return this[first ? 'find' : 'filter'](attrs);
	    },
	
	    // Return the first model with matching attributes. Useful for simple cases
	    // of `find`.
	    findWhere: function(attrs) {
	      return this.where(attrs, true);
	    },
	
	    // Force the collection to re-sort itself. You don't need to call this under
	    // normal circumstances, as the set will maintain sort order as each item
	    // is added.
	    sort: function(options) {
	      var comparator = this.comparator;
	      if (!comparator) throw new Error('Cannot sort a set without a comparator');
	      options || (options = {});
	
	      var length = comparator.length;
	      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);
	
	      // Run sort based on type of `comparator`.
	      if (length === 1 || _.isString(comparator)) {
	        this.models = this.sortBy(comparator);
	      } else {
	        this.models.sort(comparator);
	      }
	      if (!options.silent) this.trigger('sort', this, options);
	      return this;
	    },
	
	    // Pluck an attribute from each model in the collection.
	    pluck: function(attr) {
	      return this.map(attr + '');
	    },
	
	    // Fetch the default set of models for this collection, resetting the
	    // collection when they arrive. If `reset: true` is passed, the response
	    // data will be passed through the `reset` method instead of `set`.
	    fetch: function(options) {
	      options = _.extend({parse: true}, options);
	      var success = options.success;
	      var collection = this;
	      options.success = function(resp) {
	        var method = options.reset ? 'reset' : 'set';
	        collection[method](resp, options);
	        if (success) success.call(options.context, collection, resp, options);
	        collection.trigger('sync', collection, resp, options);
	      };
	      wrapError(this, options);
	      return this.sync('read', this, options);
	    },
	
	    // Create a new instance of a model in this collection. Add the model to the
	    // collection immediately, unless `wait: true` is passed, in which case we
	    // wait for the server to agree.
	    create: function(model, options) {
	      options = options ? _.clone(options) : {};
	      var wait = options.wait;
	      model = this._prepareModel(model, options);
	      if (!model) return false;
	      if (!wait) this.add(model, options);
	      var collection = this;
	      var success = options.success;
	      options.success = function(m, resp, callbackOpts) {
	        if (wait) collection.add(m, callbackOpts);
	        if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
	      };
	      model.save(null, options);
	      return model;
	    },
	
	    // **parse** converts a response into a list of models to be added to the
	    // collection. The default implementation is just to pass it through.
	    parse: function(resp, options) {
	      return resp;
	    },
	
	    // Create a new collection with an identical list of models as this one.
	    clone: function() {
	      return new this.constructor(this.models, {
	        model: this.model,
	        comparator: this.comparator
	      });
	    },
	
	    // Define how to uniquely identify models in the collection.
	    modelId: function(attrs) {
	      return attrs[this.model.prototype.idAttribute || 'id'];
	    },
	
	    // Private method to reset all internal state. Called when the collection
	    // is first initialized or reset.
	    _reset: function() {
	      this.length = 0;
	      this.models = [];
	      this._byId  = {};
	    },
	
	    // Prepare a hash of attributes (or other model) to be added to this
	    // collection.
	    _prepareModel: function(attrs, options) {
	      if (this._isModel(attrs)) {
	        if (!attrs.collection) attrs.collection = this;
	        return attrs;
	      }
	      options = options ? _.clone(options) : {};
	      options.collection = this;
	      var model = new this.model(attrs, options);
	      if (!model.validationError) return model;
	      this.trigger('invalid', this, model.validationError, options);
	      return false;
	    },
	
	    // Internal method called by both remove and set.
	    _removeModels: function(models, options) {
	      var removed = [];
	      for (var i = 0; i < models.length; i++) {
	        var model = this.get(models[i]);
	        if (!model) continue;
	
	        var index = this.indexOf(model);
	        this.models.splice(index, 1);
	        this.length--;
	
	        // Remove references before triggering 'remove' event to prevent an
	        // infinite loop. #3693
	        delete this._byId[model.cid];
	        var id = this.modelId(model.attributes);
	        if (id != null) delete this._byId[id];
	
	        if (!options.silent) {
	          options.index = index;
	          model.trigger('remove', model, this, options);
	        }
	
	        removed.push(model);
	        this._removeReference(model, options);
	      }
	      return removed;
	    },
	
	    // Method for checking whether an object should be considered a model for
	    // the purposes of adding to the collection.
	    _isModel: function(model) {
	      return model instanceof Model;
	    },
	
	    // Internal method to create a model's ties to a collection.
	    _addReference: function(model, options) {
	      this._byId[model.cid] = model;
	      var id = this.modelId(model.attributes);
	      if (id != null) this._byId[id] = model;
	      model.on('all', this._onModelEvent, this);
	    },
	
	    // Internal method to sever a model's ties to a collection.
	    _removeReference: function(model, options) {
	      delete this._byId[model.cid];
	      var id = this.modelId(model.attributes);
	      if (id != null) delete this._byId[id];
	      if (this === model.collection) delete model.collection;
	      model.off('all', this._onModelEvent, this);
	    },
	
	    // Internal method called every time a model in the set fires an event.
	    // Sets need to update their indexes when models change ids. All other
	    // events simply proxy through. "add" and "remove" events that originate
	    // in other collections are ignored.
	    _onModelEvent: function(event, model, collection, options) {
	      if (model) {
	        if ((event === 'add' || event === 'remove') && collection !== this) return;
	        if (event === 'destroy') this.remove(model, options);
	        if (event === 'change') {
	          var prevId = this.modelId(model.previousAttributes());
	          var id = this.modelId(model.attributes);
	          if (prevId !== id) {
	            if (prevId != null) delete this._byId[prevId];
	            if (id != null) this._byId[id] = model;
	          }
	        }
	      }
	      this.trigger.apply(this, arguments);
	    }
	
	  });
	
	  // Underscore methods that we want to implement on the Collection.
	  // 90% of the core usefulness of Backbone Collections is actually implemented
	  // right here:
	  var collectionMethods = {forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,
	      foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,
	      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,
	      contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
	      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
	      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
	      isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
	      sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3};
	
	  // Mix in each Underscore method as a proxy to `Collection#models`.
	  addUnderscoreMethods(Collection, collectionMethods, 'models');
	
	  // Backbone.View
	  // -------------
	
	  // Backbone Views are almost more convention than they are actual code. A View
	  // is simply a JavaScript object that represents a logical chunk of UI in the
	  // DOM. This might be a single item, an entire list, a sidebar or panel, or
	  // even the surrounding frame which wraps your whole app. Defining a chunk of
	  // UI as a **View** allows you to define your DOM events declaratively, without
	  // having to worry about render order ... and makes it easy for the view to
	  // react to specific changes in the state of your models.
	
	  // Creating a Backbone.View creates its initial element outside of the DOM,
	  // if an existing element is not provided...
	  var View = Backbone.View = function(options) {
	    this.cid = _.uniqueId('view');
	    _.extend(this, _.pick(options, viewOptions));
	    this._ensureElement();
	    this.initialize.apply(this, arguments);
	  };
	
	  // Cached regex to split keys for `delegate`.
	  var delegateEventSplitter = /^(\S+)\s*(.*)$/;
	
	  // List of view options to be set as properties.
	  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];
	
	  // Set up all inheritable **Backbone.View** properties and methods.
	  _.extend(View.prototype, Events, {
	
	    // The default `tagName` of a View's element is `"div"`.
	    tagName: 'div',
	
	    // jQuery delegate for element lookup, scoped to DOM elements within the
	    // current view. This should be preferred to global lookups where possible.
	    $: function(selector) {
	      return this.$el.find(selector);
	    },
	
	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},
	
	    // **render** is the core function that your view should override, in order
	    // to populate its element (`this.el`), with the appropriate HTML. The
	    // convention is for **render** to always return `this`.
	    render: function() {
	      return this;
	    },
	
	    // Remove this view by taking the element out of the DOM, and removing any
	    // applicable Backbone.Events listeners.
	    remove: function() {
	      this._removeElement();
	      this.stopListening();
	      return this;
	    },
	
	    // Remove this view's element from the document and all event listeners
	    // attached to it. Exposed for subclasses using an alternative DOM
	    // manipulation API.
	    _removeElement: function() {
	      this.$el.remove();
	    },
	
	    // Change the view's element (`this.el` property) and re-delegate the
	    // view's events on the new element.
	    setElement: function(element) {
	      this.undelegateEvents();
	      this._setElement(element);
	      this.delegateEvents();
	      return this;
	    },
	
	    // Creates the `this.el` and `this.$el` references for this view using the
	    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
	    // context or an element. Subclasses can override this to utilize an
	    // alternative DOM manipulation API and are only required to set the
	    // `this.el` property.
	    _setElement: function(el) {
	      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
	      this.el = this.$el[0];
	    },
	
	    // Set callbacks, where `this.events` is a hash of
	    //
	    // *{"event selector": "callback"}*
	    //
	    //     {
	    //       'mousedown .title':  'edit',
	    //       'click .button':     'save',
	    //       'click .open':       function(e) { ... }
	    //     }
	    //
	    // pairs. Callbacks will be bound to the view, with `this` set properly.
	    // Uses event delegation for efficiency.
	    // Omitting the selector binds the event to `this.el`.
	    delegateEvents: function(events) {
	      events || (events = _.result(this, 'events'));
	      if (!events) return this;
	      this.undelegateEvents();
	      for (var key in events) {
	        var method = events[key];
	        if (!_.isFunction(method)) method = this[method];
	        if (!method) continue;
	        var match = key.match(delegateEventSplitter);
	        this.delegate(match[1], match[2], _.bind(method, this));
	      }
	      return this;
	    },
	
	    // Add a single event listener to the view's element (or a child element
	    // using `selector`). This only works for delegate-able events: not `focus`,
	    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
	    delegate: function(eventName, selector, listener) {
	      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
	      return this;
	    },
	
	    // Clears all callbacks previously bound to the view by `delegateEvents`.
	    // You usually don't need to use this, but may wish to if you have multiple
	    // Backbone views attached to the same DOM element.
	    undelegateEvents: function() {
	      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
	      return this;
	    },
	
	    // A finer-grained `undelegateEvents` for removing a single delegated event.
	    // `selector` and `listener` are both optional.
	    undelegate: function(eventName, selector, listener) {
	      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
	      return this;
	    },
	
	    // Produces a DOM element to be assigned to your view. Exposed for
	    // subclasses using an alternative DOM manipulation API.
	    _createElement: function(tagName) {
	      return document.createElement(tagName);
	    },
	
	    // Ensure that the View has a DOM element to render into.
	    // If `this.el` is a string, pass it through `$()`, take the first
	    // matching element, and re-assign it to `el`. Otherwise, create
	    // an element from the `id`, `className` and `tagName` properties.
	    _ensureElement: function() {
	      if (!this.el) {
	        var attrs = _.extend({}, _.result(this, 'attributes'));
	        if (this.id) attrs.id = _.result(this, 'id');
	        if (this.className) attrs['class'] = _.result(this, 'className');
	        this.setElement(this._createElement(_.result(this, 'tagName')));
	        this._setAttributes(attrs);
	      } else {
	        this.setElement(_.result(this, 'el'));
	      }
	    },
	
	    // Set attributes from a hash on this view's element.  Exposed for
	    // subclasses using an alternative DOM manipulation API.
	    _setAttributes: function(attributes) {
	      this.$el.attr(attributes);
	    }
	
	  });
	
	  // Backbone.sync
	  // -------------
	
	  // Override this function to change the manner in which Backbone persists
	  // models to the server. You will be passed the type of request, and the
	  // model in question. By default, makes a RESTful Ajax request
	  // to the model's `url()`. Some possible customizations could be:
	  //
	  // * Use `setTimeout` to batch rapid-fire updates into a single request.
	  // * Send up the models as XML instead of JSON.
	  // * Persist models via WebSockets instead of Ajax.
	  //
	  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
	  // as `POST`, with a `_method` parameter containing the true HTTP method,
	  // as well as all requests with the body as `application/x-www-form-urlencoded`
	  // instead of `application/json` with the model in a param named `model`.
	  // Useful when interfacing with server-side languages like **PHP** that make
	  // it difficult to read the body of `PUT` requests.
	  Backbone.sync = function(method, model, options) {
	    var type = methodMap[method];
	
	    // Default options, unless specified.
	    _.defaults(options || (options = {}), {
	      emulateHTTP: Backbone.emulateHTTP,
	      emulateJSON: Backbone.emulateJSON
	    });
	
	    // Default JSON-request options.
	    var params = {type: type, dataType: 'json'};
	
	    // Ensure that we have a URL.
	    if (!options.url) {
	      params.url = _.result(model, 'url') || urlError();
	    }
	
	    // Ensure that we have the appropriate request data.
	    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
	      params.contentType = 'application/json';
	      params.data = JSON.stringify(options.attrs || model.toJSON(options));
	    }
	
	    // For older servers, emulate JSON by encoding the request into an HTML-form.
	    if (options.emulateJSON) {
	      params.contentType = 'application/x-www-form-urlencoded';
	      params.data = params.data ? {model: params.data} : {};
	    }
	
	    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
	    // And an `X-HTTP-Method-Override` header.
	    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
	      params.type = 'POST';
	      if (options.emulateJSON) params.data._method = type;
	      var beforeSend = options.beforeSend;
	      options.beforeSend = function(xhr) {
	        xhr.setRequestHeader('X-HTTP-Method-Override', type);
	        if (beforeSend) return beforeSend.apply(this, arguments);
	      };
	    }
	
	    // Don't process data on a non-GET request.
	    if (params.type !== 'GET' && !options.emulateJSON) {
	      params.processData = false;
	    }
	
	    // Pass along `textStatus` and `errorThrown` from jQuery.
	    var error = options.error;
	    options.error = function(xhr, textStatus, errorThrown) {
	      options.textStatus = textStatus;
	      options.errorThrown = errorThrown;
	      if (error) error.call(options.context, xhr, textStatus, errorThrown);
	    };
	
	    // Make the request, allowing the user to override any Ajax options.
	    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
	    model.trigger('request', model, xhr, options);
	    return xhr;
	  };
	
	  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
	  var methodMap = {
	    'create': 'POST',
	    'update': 'PUT',
	    'patch': 'PATCH',
	    'delete': 'DELETE',
	    'read': 'GET'
	  };
	
	  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
	  // Override this if you'd like to use a different library.
	  Backbone.ajax = function() {
	    return Backbone.$.ajax.apply(Backbone.$, arguments);
	  };
	
	  // Backbone.Router
	  // ---------------
	
	  // Routers map faux-URLs to actions, and fire events when routes are
	  // matched. Creating a new one sets its `routes` hash, if not set statically.
	  var Router = Backbone.Router = function(options) {
	    options || (options = {});
	    if (options.routes) this.routes = options.routes;
	    this._bindRoutes();
	    this.initialize.apply(this, arguments);
	  };
	
	  // Cached regular expressions for matching named param parts and splatted
	  // parts of route strings.
	  var optionalParam = /\((.*?)\)/g;
	  var namedParam    = /(\(\?)?:\w+/g;
	  var splatParam    = /\*\w+/g;
	  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;
	
	  // Set up all inheritable **Backbone.Router** properties and methods.
	  _.extend(Router.prototype, Events, {
	
	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},
	
	    // Manually bind a single named route to a callback. For example:
	    //
	    //     this.route('search/:query/p:num', 'search', function(query, num) {
	    //       ...
	    //     });
	    //
	    route: function(route, name, callback) {
	      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
	      if (_.isFunction(name)) {
	        callback = name;
	        name = '';
	      }
	      if (!callback) callback = this[name];
	      var router = this;
	      Backbone.history.route(route, function(fragment) {
	        var args = router._extractParameters(route, fragment);
	        if (router.execute(callback, args, name) !== false) {
	          router.trigger.apply(router, ['route:' + name].concat(args));
	          router.trigger('route', name, args);
	          Backbone.history.trigger('route', router, name, args);
	        }
	      });
	      return this;
	    },
	
	    // Execute a route handler with the provided parameters.  This is an
	    // excellent place to do pre-route setup or post-route cleanup.
	    execute: function(callback, args, name) {
	      if (callback) callback.apply(this, args);
	    },
	
	    // Simple proxy to `Backbone.history` to save a fragment into the history.
	    navigate: function(fragment, options) {
	      Backbone.history.navigate(fragment, options);
	      return this;
	    },
	
	    // Bind all defined routes to `Backbone.history`. We have to reverse the
	    // order of the routes here to support behavior where the most general
	    // routes can be defined at the bottom of the route map.
	    _bindRoutes: function() {
	      if (!this.routes) return;
	      this.routes = _.result(this, 'routes');
	      var route, routes = _.keys(this.routes);
	      while ((route = routes.pop()) != null) {
	        this.route(route, this.routes[route]);
	      }
	    },
	
	    // Convert a route string into a regular expression, suitable for matching
	    // against the current location hash.
	    _routeToRegExp: function(route) {
	      route = route.replace(escapeRegExp, '\\$&')
	                   .replace(optionalParam, '(?:$1)?')
	                   .replace(namedParam, function(match, optional) {
	                     return optional ? match : '([^/?]+)';
	                   })
	                   .replace(splatParam, '([^?]*?)');
	      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
	    },
	
	    // Given a route, and a URL fragment that it matches, return the array of
	    // extracted decoded parameters. Empty or unmatched parameters will be
	    // treated as `null` to normalize cross-browser behavior.
	    _extractParameters: function(route, fragment) {
	      var params = route.exec(fragment).slice(1);
	      return _.map(params, function(param, i) {
	        // Don't decode the search params.
	        if (i === params.length - 1) return param || null;
	        return param ? decodeURIComponent(param) : null;
	      });
	    }
	
	  });
	
	  // Backbone.History
	  // ----------------
	
	  // Handles cross-browser history management, based on either
	  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
	  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
	  // and URL fragments. If the browser supports neither (old IE, natch),
	  // falls back to polling.
	  var History = Backbone.History = function() {
	    this.handlers = [];
	    this.checkUrl = _.bind(this.checkUrl, this);
	
	    // Ensure that `History` can be used outside of the browser.
	    if (typeof window !== 'undefined') {
	      this.location = window.location;
	      this.history = window.history;
	    }
	  };
	
	  // Cached regex for stripping a leading hash/slash and trailing space.
	  var routeStripper = /^[#\/]|\s+$/g;
	
	  // Cached regex for stripping leading and trailing slashes.
	  var rootStripper = /^\/+|\/+$/g;
	
	  // Cached regex for stripping urls of hash.
	  var pathStripper = /#.*$/;
	
	  // Has the history handling already been started?
	  History.started = false;
	
	  // Set up all inheritable **Backbone.History** properties and methods.
	  _.extend(History.prototype, Events, {
	
	    // The default interval to poll for hash changes, if necessary, is
	    // twenty times a second.
	    interval: 50,
	
	    // Are we at the app root?
	    atRoot: function() {
	      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
	      return path === this.root && !this.getSearch();
	    },
	
	    // Does the pathname match the root?
	    matchRoot: function() {
	      var path = this.decodeFragment(this.location.pathname);
	      var rootPath = path.slice(0, this.root.length - 1) + '/';
	      return rootPath === this.root;
	    },
	
	    // Unicode characters in `location.pathname` are percent encoded so they're
	    // decoded for comparison. `%25` should not be decoded since it may be part
	    // of an encoded parameter.
	    decodeFragment: function(fragment) {
	      return decodeURI(fragment.replace(/%25/g, '%2525'));
	    },
	
	    // In IE6, the hash fragment and search params are incorrect if the
	    // fragment contains `?`.
	    getSearch: function() {
	      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
	      return match ? match[0] : '';
	    },
	
	    // Gets the true hash value. Cannot use location.hash directly due to bug
	    // in Firefox where location.hash will always be decoded.
	    getHash: function(window) {
	      var match = (window || this).location.href.match(/#(.*)$/);
	      return match ? match[1] : '';
	    },
	
	    // Get the pathname and search params, without the root.
	    getPath: function() {
	      var path = this.decodeFragment(
	        this.location.pathname + this.getSearch()
	      ).slice(this.root.length - 1);
	      return path.charAt(0) === '/' ? path.slice(1) : path;
	    },
	
	    // Get the cross-browser normalized URL fragment from the path or hash.
	    getFragment: function(fragment) {
	      if (fragment == null) {
	        if (this._usePushState || !this._wantsHashChange) {
	          fragment = this.getPath();
	        } else {
	          fragment = this.getHash();
	        }
	      }
	      return fragment.replace(routeStripper, '');
	    },
	
	    // Start the hash change handling, returning `true` if the current URL matches
	    // an existing route, and `false` otherwise.
	    start: function(options) {
	      if (History.started) throw new Error('Backbone.history has already been started');
	      History.started = true;
	
	      // Figure out the initial configuration. Do we need an iframe?
	      // Is pushState desired ... is it available?
	      this.options          = _.extend({root: '/'}, this.options, options);
	      this.root             = this.options.root;
	      this._wantsHashChange = this.options.hashChange !== false;
	      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
	      this._useHashChange   = this._wantsHashChange && this._hasHashChange;
	      this._wantsPushState  = !!this.options.pushState;
	      this._hasPushState    = !!(this.history && this.history.pushState);
	      this._usePushState    = this._wantsPushState && this._hasPushState;
	      this.fragment         = this.getFragment();
	
	      // Normalize root to always include a leading and trailing slash.
	      this.root = ('/' + this.root + '/').replace(rootStripper, '/');
	
	      // Transition from hashChange to pushState or vice versa if both are
	      // requested.
	      if (this._wantsHashChange && this._wantsPushState) {
	
	        // If we've started off with a route from a `pushState`-enabled
	        // browser, but we're currently in a browser that doesn't support it...
	        if (!this._hasPushState && !this.atRoot()) {
	          var rootPath = this.root.slice(0, -1) || '/';
	          this.location.replace(rootPath + '#' + this.getPath());
	          // Return immediately as browser will do redirect to new url
	          return true;
	
	        // Or if we've started out with a hash-based route, but we're currently
	        // in a browser where it could be `pushState`-based instead...
	        } else if (this._hasPushState && this.atRoot()) {
	          this.navigate(this.getHash(), {replace: true});
	        }
	
	      }
	
	      // Proxy an iframe to handle location events if the browser doesn't
	      // support the `hashchange` event, HTML5 history, or the user wants
	      // `hashChange` but not `pushState`.
	      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
	        this.iframe = document.createElement('iframe');
	        this.iframe.src = 'javascript:0';
	        this.iframe.style.display = 'none';
	        this.iframe.tabIndex = -1;
	        var body = document.body;
	        // Using `appendChild` will throw on IE < 9 if the document is not ready.
	        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
	        iWindow.document.open();
	        iWindow.document.close();
	        iWindow.location.hash = '#' + this.fragment;
	      }
	
	      // Add a cross-platform `addEventListener` shim for older browsers.
	      var addEventListener = window.addEventListener || function(eventName, listener) {
	        return attachEvent('on' + eventName, listener);
	      };
	
	      // Depending on whether we're using pushState or hashes, and whether
	      // 'onhashchange' is supported, determine how we check the URL state.
	      if (this._usePushState) {
	        addEventListener('popstate', this.checkUrl, false);
	      } else if (this._useHashChange && !this.iframe) {
	        addEventListener('hashchange', this.checkUrl, false);
	      } else if (this._wantsHashChange) {
	        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
	      }
	
	      if (!this.options.silent) return this.loadUrl();
	    },
	
	    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
	    // but possibly useful for unit testing Routers.
	    stop: function() {
	      // Add a cross-platform `removeEventListener` shim for older browsers.
	      var removeEventListener = window.removeEventListener || function(eventName, listener) {
	        return detachEvent('on' + eventName, listener);
	      };
	
	      // Remove window listeners.
	      if (this._usePushState) {
	        removeEventListener('popstate', this.checkUrl, false);
	      } else if (this._useHashChange && !this.iframe) {
	        removeEventListener('hashchange', this.checkUrl, false);
	      }
	
	      // Clean up the iframe if necessary.
	      if (this.iframe) {
	        document.body.removeChild(this.iframe);
	        this.iframe = null;
	      }
	
	      // Some environments will throw when clearing an undefined interval.
	      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
	      History.started = false;
	    },
	
	    // Add a route to be tested when the fragment changes. Routes added later
	    // may override previous routes.
	    route: function(route, callback) {
	      this.handlers.unshift({route: route, callback: callback});
	    },
	
	    // Checks the current URL to see if it has changed, and if it has,
	    // calls `loadUrl`, normalizing across the hidden iframe.
	    checkUrl: function(e) {
	      var current = this.getFragment();
	
	      // If the user pressed the back button, the iframe's hash will have
	      // changed and we should use that for comparison.
	      if (current === this.fragment && this.iframe) {
	        current = this.getHash(this.iframe.contentWindow);
	      }
	
	      if (current === this.fragment) return false;
	      if (this.iframe) this.navigate(current);
	      this.loadUrl();
	    },
	
	    // Attempt to load the current URL fragment. If a route succeeds with a
	    // match, returns `true`. If no defined routes matches the fragment,
	    // returns `false`.
	    loadUrl: function(fragment) {
	      // If the root doesn't match, no routes can match either.
	      if (!this.matchRoot()) return false;
	      fragment = this.fragment = this.getFragment(fragment);
	      return _.some(this.handlers, function(handler) {
	        if (handler.route.test(fragment)) {
	          handler.callback(fragment);
	          return true;
	        }
	      });
	    },
	
	    // Save a fragment into the hash history, or replace the URL state if the
	    // 'replace' option is passed. You are responsible for properly URL-encoding
	    // the fragment in advance.
	    //
	    // The options object can contain `trigger: true` if you wish to have the
	    // route callback be fired (not usually desirable), or `replace: true`, if
	    // you wish to modify the current URL without adding an entry to the history.
	    navigate: function(fragment, options) {
	      if (!History.started) return false;
	      if (!options || options === true) options = {trigger: !!options};
	
	      // Normalize the fragment.
	      fragment = this.getFragment(fragment || '');
	
	      // Don't include a trailing slash on the root.
	      var rootPath = this.root;
	      if (fragment === '' || fragment.charAt(0) === '?') {
	        rootPath = rootPath.slice(0, -1) || '/';
	      }
	      var url = rootPath + fragment;
	
	      // Strip the hash and decode for matching.
	      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));
	
	      if (this.fragment === fragment) return;
	      this.fragment = fragment;
	
	      // If pushState is available, we use it to set the fragment as a real URL.
	      if (this._usePushState) {
	        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);
	
	      // If hash changes haven't been explicitly disabled, update the hash
	      // fragment to store history.
	      } else if (this._wantsHashChange) {
	        this._updateHash(this.location, fragment, options.replace);
	        if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
	          var iWindow = this.iframe.contentWindow;
	
	          // Opening and closing the iframe tricks IE7 and earlier to push a
	          // history entry on hash-tag change.  When replace is true, we don't
	          // want this.
	          if (!options.replace) {
	            iWindow.document.open();
	            iWindow.document.close();
	          }
	
	          this._updateHash(iWindow.location, fragment, options.replace);
	        }
	
	      // If you've told us that you explicitly don't want fallback hashchange-
	      // based history, then `navigate` becomes a page refresh.
	      } else {
	        return this.location.assign(url);
	      }
	      if (options.trigger) return this.loadUrl(fragment);
	    },
	
	    // Update the hash location, either replacing the current entry, or adding
	    // a new one to the browser history.
	    _updateHash: function(location, fragment, replace) {
	      if (replace) {
	        var href = location.href.replace(/(javascript:|#).*$/, '');
	        location.replace(href + '#' + fragment);
	      } else {
	        // Some browsers require that `hash` contains a leading #.
	        location.hash = '#' + fragment;
	      }
	    }
	
	  });
	
	  // Create the default Backbone.history.
	  Backbone.history = new History;
	
	  // Helpers
	  // -------
	
	  // Helper function to correctly set up the prototype chain for subclasses.
	  // Similar to `goog.inherits`, but uses a hash of prototype properties and
	  // class properties to be extended.
	  var extend = function(protoProps, staticProps) {
	    var parent = this;
	    var child;
	
	    // The constructor function for the new subclass is either defined by you
	    // (the "constructor" property in your `extend` definition), or defaulted
	    // by us to simply call the parent constructor.
	    if (protoProps && _.has(protoProps, 'constructor')) {
	      child = protoProps.constructor;
	    } else {
	      child = function(){ return parent.apply(this, arguments); };
	    }
	
	    // Add static properties to the constructor function, if supplied.
	    _.extend(child, parent, staticProps);
	
	    // Set the prototype chain to inherit from `parent`, without calling
	    // `parent`'s constructor function and add the prototype properties.
	    child.prototype = _.create(parent.prototype, protoProps);
	    child.prototype.constructor = child;
	
	    // Set a convenience property in case the parent's prototype is needed
	    // later.
	    child.__super__ = parent.prototype;
	
	    return child;
	  };
	
	  // Set up inheritance for the model, collection, router, view and history.
	  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
	
	  // Throw an error when a URL is needed, and none is supplied.
	  var urlError = function() {
	    throw new Error('A "url" property or function must be specified');
	  };
	
	  // Wrap an optional error callback with a fallback error event.
	  var wrapError = function(model, options) {
	    var error = options.error;
	    options.error = function(resp) {
	      if (error) error.call(options.context, model, resp, options);
	      model.trigger('error', model, resp, options);
	    };
	  };
	
	  return Backbone;
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function ($metadata, columns, hideHeaders, isApplyGroup, subSelect, undefined, value) {
	jade_mixins["columnHeader"] = jade_interp = function(column, isSubHeader){
	var block = (this && this.block), attributes = (this && this.attributes) || {};
	if ( column.headerBuilder)
	{
	buf.push(null == (jade_interp = column.headerBuilder(column, isSubHeader)) ? "" : jade_interp);
	}
	else
	{
	if ( column.$orderby)
	{
	if ( column.$orderby.dir > 0)
	{
	buf.push("<span class=\"grid-asc\"></span>");
	}
	else
	{
	buf.push("<span class=\"grid-des\"></span>");
	}
	}
	if ( (column && column.$html))
	{
	buf.push(null == (jade_interp = column.$html) ? "" : jade_interp);
	}
	else
	{
	if ( isSubHeader && column.config.subColTitle)
	{
	buf.push(jade.escape(null == (jade_interp = column.config.subColTitle) ? "" : jade_interp));
	}
	else
	{
	buf.push(jade.escape(null == (jade_interp = (typeof column.$text != 'undefined')? column.$text : (column.property || column)) ? "" : jade_interp));
	}
	}
	}
	};
	jade_mixins["th"] = jade_interp = function(column, hasGroup, isSubColumn){
	var block = (this && this.block), attributes = (this && this.attributes) || {};
	var attr = (column.$metadata || {})['attr.head'] || {}
	var colName = column.config && column.config.name || '';
	var cls = [];
	if ( (colName))
	{
	cls.push('col-' + colName);
	}
	if ( column.sortable)
	{
	cls.push('sortable');
	}
	if ( column.$orderby)
	{
	cls.push('orderby');
	}
	cls = cls.join(' ');
	if ( isSubColumn )
	{
	var colspan = 1, rowspan = 1;
	buf.push("<th" + (jade.attrs(jade.merge([{"colspan": jade.escape(colspan),"rowspan": jade.escape(rowspan),"class": (jade_interp = [true], jade.joinClasses([cls].map(jade.joinClasses).map(function (cls, i) {   return jade_interp[i] ? jade.escape(cls) : cls })))},attributes,attr]), true)) + ">");
	jade_mixins["columnHeader"](column, true);
	buf.push("</th>");
	}
	else if ( hasGroup && column.groupExpansion)
	{
	var colspan = column.group.length, rowspan = 1;
	buf.push("<th" + (jade.attrs(jade.merge([{"colspan": jade.escape(colspan),"rowspan": jade.escape(rowspan),"class": (jade_interp = [true], jade.joinClasses([cls].map(jade.joinClasses).map(function (cls, i) {   return jade_interp[i] ? jade.escape(cls) : cls })))},attributes,attr]), true)) + "><span class=\"pop-collapse glyphicon glyphicon-minus\"></span><div>");
	jade_mixins["columnHeader"](column);
	buf.push("</div></th>");
	}
	else if ( hasGroup && column.group)
	{
	var colspan = 1, rowspan = 2;
	buf.push("<th" + (jade.attrs(jade.merge([{"colspan": jade.escape(colspan),"rowspan": jade.escape(rowspan),"class": (jade_interp = [true], jade.joinClasses([cls].map(jade.joinClasses).map(function (cls, i) {   return jade_interp[i] ? jade.escape(cls) : cls })))},attributes,attr]), true)) + "><span class=\"pop-expand glyphicon glyphicon-plus\"></span><div>");
	jade_mixins["columnHeader"](column);
	buf.push("</div></th>");
	}
	else
	{
	var colspan = 1, rowspan = 2;
	buf.push("<th" + (jade.attrs(jade.merge([{"colspan": jade.escape(colspan),"rowspan": jade.escape(rowspan),"class": (jade_interp = [true], jade.joinClasses([cls].map(jade.joinClasses).map(function (cls, i) {   return jade_interp[i] ? jade.escape(cls) : cls })))},attributes,attr]), true)) + ">");
	jade_mixins["columnHeader"](column);
	buf.push("</th>");
	}
	};
	jade_mixins["td"] = jade_interp = function(row, column){
	var block = (this && this.block), attributes = (this && this.attributes) || {};
	var attr = (column.$metadata || {})['attr.body'] || {}
	var colName = column.config && column.config.name || '';
	var cls = colName ? 'col-' + colName : '';
	buf.push("<td" + (jade.attrs(jade.merge([{"class": (jade_interp = [true], jade.joinClasses([cls].map(jade.joinClasses).map(function (cls, i) {   return jade_interp[i] ? jade.escape(cls) : cls })))},attributes,attr]), true)) + ">");
	var res = row[column.property]
	if ( (res && res.$html))
	{
	buf.push(null == (jade_interp = res.$html) ? "" : jade_interp);
	}
	else
	{
	buf.push(jade.escape(null == (jade_interp = res) ? "" : jade_interp));
	}
	buf.push("</td>");
	};
	buf.push("<table" + (jade.attrs(jade.merge([{"role": "grid","class": "table table-hover grid"},$metadata || {}]), true)) + ">");
	if ( !hideHeaders)
	{
	buf.push("<thead>");
	if ( isApplyGroup && subSelect.length === 0)
	{
	buf.push("<tr class=\"table__row--header\">");
	// iterate locals['select'] || []
	;(function(){
	  var $$obj = locals['select'] || [];
	  if ('number' == typeof $$obj.length) {
	
	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var columnName = $$obj[$index];
	
	jade_mixins["th"](columns[columnName], true);
	    }
	
	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var columnName = $$obj[$index];
	
	jade_mixins["th"](columns[columnName], true);
	    }
	
	  }
	}).call(this);
	
	buf.push("</tr>");
	}
	else if ( isApplyGroup)
	{
	buf.push("<tr class=\"table__row--header\">");
	// iterate locals['select'] || []
	;(function(){
	  var $$obj = locals['select'] || [];
	  if ('number' == typeof $$obj.length) {
	
	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var columnName = $$obj[$index];
	
	jade_mixins["th"](columns[columnName], true);
	    }
	
	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var columnName = $$obj[$index];
	
	jade_mixins["th"](columns[columnName], true);
	    }
	
	  }
	}).call(this);
	
	buf.push("</tr><tr class=\"table__row--header table__row--sub-header\">");
	// iterate locals['subSelect']
	;(function(){
	  var $$obj = locals['subSelect'];
	  if ('number' == typeof $$obj.length) {
	
	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var columnName = $$obj[$index];
	
	jade_mixins["th"](columns[columnName], true, true);
	    }
	
	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var columnName = $$obj[$index];
	
	jade_mixins["th"](columns[columnName], true, true);
	    }
	
	  }
	}).call(this);
	
	buf.push("</tr>");
	}
	else
	{
	buf.push("<tr class=\"table__row--header\">");
	// iterate locals['select'] || []
	;(function(){
	  var $$obj = locals['select'] || [];
	  if ('number' == typeof $$obj.length) {
	
	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var columnName = $$obj[$index];
	
	jade_mixins["th"](columns[columnName]);
	    }
	
	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var columnName = $$obj[$index];
	
	jade_mixins["th"](columns[columnName]);
	    }
	
	  }
	}).call(this);
	
	buf.push("</tr>");
	}
	buf.push("</thead>");
	}
	buf.push("<tbody>");
	// iterate value
	;(function(){
	  var $$obj = value;
	  if ('number' == typeof $$obj.length) {
	
	    for (var i = 0, $$l = $$obj.length; i < $$l; i++) {
	      var row = $$obj[i];
	
	var attr = (row.$metadata || {}).attr || {}
	buf.push("<tr" + (jade.attrs(jade.merge([{"class": "table__row--body"},attr]), true)) + ">");
	// iterate locals['selectExpand'] || locals.select
	;(function(){
	  var $$obj = locals['selectExpand'] || locals.select;
	  if ('number' == typeof $$obj.length) {
	
	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var columnName = $$obj[$index];
	
	jade_mixins["td"](row, columns[columnName]);
	    }
	
	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var columnName = $$obj[$index];
	
	jade_mixins["td"](row, columns[columnName]);
	    }
	
	  }
	}).call(this);
	
	buf.push("</tr>");
	    }
	
	  } else {
	    var $$l = 0;
	    for (var i in $$obj) {
	      $$l++;      var row = $$obj[i];
	
	var attr = (row.$metadata || {}).attr || {}
	buf.push("<tr" + (jade.attrs(jade.merge([{"class": "table__row--body"},attr]), true)) + ">");
	// iterate locals['selectExpand'] || locals.select
	;(function(){
	  var $$obj = locals['selectExpand'] || locals.select;
	  if ('number' == typeof $$obj.length) {
	
	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var columnName = $$obj[$index];
	
	jade_mixins["td"](row, columns[columnName]);
	    }
	
	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var columnName = $$obj[$index];
	
	jade_mixins["td"](row, columns[columnName]);
	    }
	
	  }
	}).call(this);
	
	buf.push("</tr>");
	    }
	
	  }
	}).call(this);
	
	buf.push("</tbody></table>");}.call(this,"$metadata" in locals_for_with?locals_for_with.$metadata:typeof $metadata!=="undefined"?$metadata:undefined,"columns" in locals_for_with?locals_for_with.columns:typeof columns!=="undefined"?columns:undefined,"hideHeaders" in locals_for_with?locals_for_with.hideHeaders:typeof hideHeaders!=="undefined"?hideHeaders:undefined,"isApplyGroup" in locals_for_with?locals_for_with.isApplyGroup:typeof isApplyGroup!=="undefined"?isApplyGroup:undefined,"subSelect" in locals_for_with?locals_for_with.subSelect:typeof subSelect!=="undefined"?subSelect:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined,"value" in locals_for_with?locals_for_with.value:typeof value!=="undefined"?value:undefined));;return buf.join("");
	}

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Merge two attribute objects giving precedence
	 * to values in object `b`. Classes are special-cased
	 * allowing for arrays and merging/joining appropriately
	 * resulting in a string.
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object} a
	 * @api private
	 */
	
	exports.merge = function merge(a, b) {
	  if (arguments.length === 1) {
	    var attrs = a[0];
	    for (var i = 1; i < a.length; i++) {
	      attrs = merge(attrs, a[i]);
	    }
	    return attrs;
	  }
	  var ac = a['class'];
	  var bc = b['class'];
	
	  if (ac || bc) {
	    ac = ac || [];
	    bc = bc || [];
	    if (!Array.isArray(ac)) ac = [ac];
	    if (!Array.isArray(bc)) bc = [bc];
	    a['class'] = ac.concat(bc).filter(nulls);
	  }
	
	  for (var key in b) {
	    if (key != 'class') {
	      a[key] = b[key];
	    }
	  }
	
	  return a;
	};
	
	/**
	 * Filter null `val`s.
	 *
	 * @param {*} val
	 * @return {Boolean}
	 * @api private
	 */
	
	function nulls(val) {
	  return val != null && val !== '';
	}
	
	/**
	 * join array as classes.
	 *
	 * @param {*} val
	 * @return {String}
	 */
	exports.joinClasses = joinClasses;
	function joinClasses(val) {
	  return (Array.isArray(val) ? val.map(joinClasses) :
	    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
	    [val]).filter(nulls).join(' ');
	}
	
	/**
	 * Render the given classes.
	 *
	 * @param {Array} classes
	 * @param {Array.<Boolean>} escaped
	 * @return {String}
	 */
	exports.cls = function cls(classes, escaped) {
	  var buf = [];
	  for (var i = 0; i < classes.length; i++) {
	    if (escaped && escaped[i]) {
	      buf.push(exports.escape(joinClasses([classes[i]])));
	    } else {
	      buf.push(joinClasses(classes[i]));
	    }
	  }
	  var text = joinClasses(buf);
	  if (text.length) {
	    return ' class="' + text + '"';
	  } else {
	    return '';
	  }
	};
	
	
	exports.style = function (val) {
	  if (val && typeof val === 'object') {
	    return Object.keys(val).map(function (style) {
	      return style + ':' + val[style];
	    }).join(';');
	  } else {
	    return val;
	  }
	};
	/**
	 * Render the given attribute.
	 *
	 * @param {String} key
	 * @param {String} val
	 * @param {Boolean} escaped
	 * @param {Boolean} terse
	 * @return {String}
	 */
	exports.attr = function attr(key, val, escaped, terse) {
	  if (key === 'style') {
	    val = exports.style(val);
	  }
	  if ('boolean' == typeof val || null == val) {
	    if (val) {
	      return ' ' + (terse ? key : key + '="' + key + '"');
	    } else {
	      return '';
	    }
	  } else if (0 == key.indexOf('data') && 'string' != typeof val) {
	    if (JSON.stringify(val).indexOf('&') !== -1) {
	      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
	                   'will be escaped to `&amp;`');
	    };
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will eliminate the double quotes around dates in ' +
	                   'ISO form after 2.0.0');
	    }
	    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
	  } else if (escaped) {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + exports.escape(val) + '"';
	  } else {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + val + '"';
	  }
	};
	
	/**
	 * Render the given attributes object.
	 *
	 * @param {Object} obj
	 * @param {Object} escaped
	 * @return {String}
	 */
	exports.attrs = function attrs(obj, terse){
	  var buf = [];
	
	  var keys = Object.keys(obj);
	
	  if (keys.length) {
	    for (var i = 0; i < keys.length; ++i) {
	      var key = keys[i]
	        , val = obj[key];
	
	      if ('class' == key) {
	        if (val = joinClasses(val)) {
	          buf.push(' ' + key + '="' + val + '"');
	        }
	      } else {
	        buf.push(exports.attr(key, val, false, terse));
	      }
	    }
	  }
	
	  return buf.join('');
	};
	
	/**
	 * Escape the given string of `html`.
	 *
	 * @param {String} html
	 * @return {String}
	 * @api private
	 */
	
	var jade_encode_html_rules = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;'
	};
	var jade_match_html = /[&<>"]/g;
	
	function jade_encode_char(c) {
	  return jade_encode_html_rules[c] || c;
	}
	
	exports.escape = jade_escape;
	function jade_escape(html){
	  var result = String(html).replace(jade_match_html, jade_encode_char);
	  if (result === '' + html) return html;
	  else return result;
	};
	
	/**
	 * Re-throw the given `err` in context to the
	 * the jade in `filename` at the given `lineno`.
	 *
	 * @param {Error} err
	 * @param {String} filename
	 * @param {String} lineno
	 * @api private
	 */
	
	exports.rethrow = function rethrow(err, filename, lineno, str){
	  if (!(err instanceof Error)) throw err;
	  if ((typeof window != 'undefined' || !filename) && !str) {
	    err.message += ' on line ' + lineno;
	    throw err;
	  }
	  try {
	    str = str || __webpack_require__(13).readFileSync(filename, 'utf8')
	  } catch (ex) {
	    rethrow(err, null, lineno)
	  }
	  var context = 3
	    , lines = str.split('\n')
	    , start = Math.max(lineno - context, 0)
	    , end = Math.min(lines.length, lineno + context);
	
	  // Error context
	  var context = lines.slice(start, end).map(function(line, i){
	    var curr = i + start + 1;
	    return (curr == lineno ? '  > ' : '    ')
	      + curr
	      + '| '
	      + line;
	  }).join('\n');
	
	  // Alter exception message
	  err.path = filename;
	  err.message = (filename || 'Jade') + ':' + lineno
	    + '\n' + context + '\n\n' + err.message;
	  throw err;
	};
	
	exports.DebugItem = function DebugItem(lineno, filename) {
	  this.lineno = lineno;
	  this.filename = filename;
	}


/***/ },
/* 13 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = {
	  FixedHeader: __webpack_require__(15),
	  Virtualization: __webpack_require__(18)
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(5), __webpack_require__(16), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _, measure, px) {
	  var state = 'normal';
	
	  function Renderer(options) {
	    var _this = this;
	
	    this.options = options || {};
	
	    this.name = 'fixed-header';
	    this.layout = this.options.layout;
	    this.adjustColumnWidth = function () {
	      if (_.isFunction(_this.freezeColumnWidth)) {
	        _this.freezeColumnWidth();
	      }
	    };
	    $(window).on('resize', this.adjustColumnWidth);
	  }
	
	  Renderer.prototype.draw = function (data, cb) {
	    var _this2 = this;
	
	    var newState = 'normal';
	
	    data.vpMeasures = measure.viewport.call(this.layout);
	
	    // TODO [wewei] this is a hack to temporarily solve the sticky header doesn't
	    // respect the navbar problem.
	    // We need a better solution on this.
	    if (data.vpMeasures.viewportTop + (this.layout.top || 0) > data.vpMeasures.boundsTop) {
	      var $el = this.layout.$el;
	
	      newState = 'sticky';
	      // todo [akamel] assumes we have table rendered; measure/estimate otherwise
	
	      // a. compensate for header displacement
	      // .. as we set 'thead > tr' css position 'absolute'
	      var displacement = $el.find('thead tr').outerHeight();
	      _.extend(data.css, {
	        'padding-top': px.pixelify(px.parse(data.css['padding-top']) + displacement)
	      });
	
	      data.canSkipDraw = true;
	
	      // b. yield to render
	      cb(undefined, data);
	
	      // c. get newly rendered header
	      var $thead = $el.find('thead');
	      var $headTR = $el.find('thead > tr');
	      var $headTD = $headTR.first().children();
	      var $secondHeadTD = $headTR.eq(1).children();
	      var $bodyTD = $el.find('tbody > tr:first-child').children();
	
	      var $ref = $bodyTD;
	      var $target = $headTD;
	
	      this.freezeColumnWidth = function () {
	        // d. capture header col computed width
	        // todo [akamel] [perf] 16%
	        _this2.colWidth = _this2.colWidth || _.map($ref, function (td) {
	          return $(td).width();
	        });
	
	        // todo [akamel] [perf] 12% -- consider replacing with css rule generation
	        // e. freeze column width
	        // e.1 freeze col width
	        var colIndex = 0;
	        var secondHeadTDIndex = 0;
	        _.each($target, function (td) {
	          var colspan = parseInt($(td).attr('colspan'), 10);
	          var rowspan = parseInt($(td).attr('rowspan'), 10);
	          var width = 0;
	          for (var i = 0; i < colspan; ++i) {
	            var colWidth = px.pixelify(this.colWidth[colIndex + i]);
	            width += colWidth;
	            if (rowspan === 1) {
	              $secondHeadTD.eq(secondHeadTDIndex + i).width(colWidth);
	            }
	          }
	          $(td).width(width);
	          colIndex += colspan;
	          if (rowspan === 1) {
	            secondHeadTDIndex += colspan;
	          }
	        }.bind(_this2));
	
	        _.each($ref, function (td, index) {
	          $(td).width(px.pixelify(this.colWidth[index]));
	        }.bind(_this2));
	      };
	
	      this.freezeColumnWidth();
	
	      // f. set position 'fixed' and lock header at top of table
	      $thead.css({
	        'position': this.layout.container.el === window ? 'fixed' : 'absolute',
	        'top': px.pixelify(this.layout.container.el === window ? 0 : this.layout.container.$el.scrollTop()),
	        'margin-left': px.pixelify(-data.vpMeasures.offsetLeft),
	        'z-index': 1000
	      });
	    } else {
	      newState = 'normal';
	
	      _.extend(data.css, {
	        'padding-top': px.pixelify(px.parse(data.css['padding-top']))
	      });
	
	      cb(undefined, data);
	    }
	
	    if (state !== newState) {
	      this.layout.grid.trigger('change:header-state', newState);
	      state = newState;
	    }
	  };
	
	  Renderer.prototype.remove = function () {
	    $(window).off('resize', this.adjustColumnWidth);
	  };
	
	  Renderer.partial = function (options) {
	    return function (o) {
	      return new Renderer(_.defaults({}, o, options));
	    };
	  };
	
	  return Renderer;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _) {
	    function viewport(el, container) {
	        var $el = el ? $(el) : this.$el;
	
	        container = container || this.container;
	        var $viewport = container.$el;
	
	        var viewportTop = $viewport.scrollTop();
	        var viewportBottom = viewportTop + $viewport.height();
	        var viewportLeft = $viewport.scrollLeft();
	
	        var boundsTop = container.offset($el).top;
	        var boundsBottom = boundsTop + $el.innerHeight();
	        // var boundsLeft = $el.offset().left;
	
	        var visibleTop = Math.max(boundsTop, viewportTop);
	        var visibleBottom = Math.min(boundsBottom, viewportBottom);
	        // var visibleLeft = Math.max(boundsLeft, viewportLeft);
	
	        return {
	            boundsTop: boundsTop,
	            viewportTop: viewportTop,
	            top: visibleTop - boundsTop,
	            bottom: visibleBottom - boundsTop,
	            offsetLeft: viewportLeft
	        };
	    }
	
	    function dimensions(el) {
	        var $el = el ? $(el) : this.$el;
	
	        // calculate heights
	        // a. header
	        var ret = {
	            rows: [],
	            thead: $el.find('thead > tr').outerHeight()
	        };
	
	        // b. keep row info
	        $el.find('tbody').children('tr').each(function () {
	            ret.rows.push($(this).outerHeight());
	        });
	
	        // c. update average row height
	        var avg = _.reduce(ret.rows, function (memo, num) {
	            return memo + num;
	        }, 0) / (ret.rows.length === 0 ? 1 : ret.rows.length);
	
	        ret.avgRowHeight = avg;
	        ret.estimateHeight = _.size(this.data.value) * avg + ret.thead;
	
	        return ret;
	    }
	
	    function sample() {
	        // a. render test pass
	        var $tmpEl = $('<div style="visibility:hidden" />');
	        var sample = _.first(this.data.value, 20);
	
	        this.$el.append($tmpEl);
	
	        $tmpEl[0].innerHTML = this.toHTML(sample);
	
	        // b. take measures
	        var ret = dimensions.call(this, $tmpEl);
	
	        // c. clean-up
	        $tmpEl.remove();
	
	        return ret;
	    }
	
	    return {
	        viewport: viewport,
	        dimensions: dimensions,
	        sample: sample
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	// todo [akamel] move to /component
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {
	  function parse(a) {
	    return abs(parseFloat(a));
	  }
	
	  function abs(a) {
	    return _.isFinite(a) ? a : 0;
	  }
	
	  function pixelify(a) {
	    return abs(a) + 'px';
	  }
	
	  return {
	    parse: parse,
	    pixelify: pixelify
	  };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	// TODO [akamel] [bug] with large data set, jitters when scrolling to bottom
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(5), __webpack_require__(16), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _, measure, px) {
	  function rowHeight(row) {
	    return _.isNumber(row.__height) ? row.__height : this.__measures.avgRowHeight;
	  }
	
	  function estimateHeight(first, last) {
	    var rows = this.layout.data.value;
	
	    var ret = 0;
	    for (var i = first; i <= last; i++) {
	      ret += rowHeight.call(this, rows[i]);
	    }
	
	    return ret;
	  }
	
	  function rowAtOffset(offset) {
	    var rem = offset;
	
	    if (rem <= 0) {
	      return 0;
	    }
	
	    var ret = -1;
	    var count = _.size(this.layout.data.value);
	
	    while (rem > 0 && ret < count - 1) {
	      ret++;
	      rem -= rowHeight.call(this, ret);
	    }
	
	    return ret < count ? ret : -1;
	  }
	
	  function Renderer(options) {
	    this.options = options || {};
	
	    this.name = 'virtualization';
	    this.layout = this.options.layout;
	  }
	
	  Renderer.prototype.draw = function (data, cb) {
	    // a. define data set
	    var value = this.layout.data.value;
	    var count = _.size(value);
	    var first = 0;
	    var last = count - 1;
	
	    // b. render test pass / take initial measures
	    if (!this.__measures) {
	      var smpl = measure.sample.call(this.layout);
	      this.__measures = _.pick(smpl, 'avgRowHeight', 'estimateHeight', 'thead');
	
	      // b.1 set height based on measures estimate
	      this.layout.$el.css({
	        'padding-top': px.pixelify(this.__measures.estimateHeight)
	      });
	    }
	
	    // c. find visible viewport
	    data.vpMeasures = data.vpMeasures || measure.viewport.call(this.layout);
	
	    // d. find rendable rows
	    first = rowAtOffset.call(this, data.vpMeasures.top - this.__measures.thead);
	    last = rowAtOffset.call(this, data.vpMeasures.bottom - this.__measures.thead);
	
	    // d.1 add a few rows before and after our calculations to account for measurment estimation err
	    var errMarginRowCount = 5;
	
	    first -= errMarginRowCount;
	    last += errMarginRowCount;
	
	    first = Math.max(0, first);
	    last = Math.min(last < 0 ? count - 1 : last, count - 1);
	
	    var pTop = estimateHeight.call(this, 0, first - 1);
	    var pBottom = estimateHeight.call(this, last + 1, count - 1);
	
	    data.rows = value.slice(first, last + 1);
	
	    _.extend(data.css, {
	      'padding-top': px.pixelify(pTop + px.parse(data.css['padding-top'])),
	      'padding-bottom': px.pixelify(pBottom + px.parse(data.css['padding-bottom']))
	    });
	
	    if (this.first === first && this.last === last) {
	      data.canSkipDraw = true;
	    }
	
	    // e. yield to render
	    cb(undefined, data);
	
	    // f. take new measures and update avg row height
	    // todo [akamel] [perf] 7.5%
	    var tblMeasure = measure.dimensions.call(this.layout);
	    _.each(tblMeasure.rows, function (height, i) {
	      value[i + first].__height = height;
	    });
	
	    var heights = _.chain(value).map(function (row) {
	      return row.__height;
	    }).compact().value();
	
	    if (_.size(heights)) {
	      this.__measures.avgRowHeight = _.reduce(heights, function (memo, num) {
	        return memo + num;
	      }, 0) / _.size(heights);
	    }
	
	    this.first = first;
	    this.last = last;
	  };
	
	  Renderer.prototype.update = function () {
	    delete this.__measures;
	  };
	
	  Renderer.prototype.remove = _.noop;
	
	  Renderer.partial = function (options) {
	    return function (o) {
	      return new Renderer(_.defaults({}, o, options));
	    };
	  };
	
	  return Renderer;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _backbone = __webpack_require__(10);
	
	var _backbone2 = _interopRequireDefault(_backbone);
	
	var _index = __webpack_require__(20);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _utility = __webpack_require__(61);
	
	var _index3 = __webpack_require__(34);
	
	var _index4 = _interopRequireDefault(_index3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var projectionConfigs = {
	  A11y: function A11y(config) {
	    var accConfig = {};
	
	    // temp config to fix a11y bug of latency projection grid, should not to reuse it. 
	    if (_underscore2.default.has(config.a11y, 'selection') && _underscore2.default.has(config.a11y.selection, 'selectAllLabel')) {
	      accConfig['a11y.selection.selectAllLabel'] = config.a11y.selection.selectAllLabel;
	    }
	
	    return accConfig;
	  },
	  AggregateRow: function AggregateRow(config) {
	    var configAgg = {};
	
	    if (_underscore2.default.has(config.aggregate, 'top')) {
	      configAgg['aggregate.top'] = config.aggregate.top;
	    }
	
	    if (_underscore2.default.has(config.aggregate, 'bottom')) {
	      configAgg['aggregate.bottom'] = config.aggregate.bottom;
	    }
	
	    return configAgg;
	  },
	  JSData: function JSData(config) {
	    return _underscore2.default.extend(_underscore2.default.pick(config.dataSource, ['skip', 'take', 'filter', 'orderby', 'select']), {
	      'jsdata.entity': config.dataSource.resource,
	      'jsdata.query': config.dataSource.query,
	      'jsdata.options': config.dataSource.options
	    });
	  },
	  Map: function Map(config) {
	    var properties = _underscore2.default.reduce(config.columns, function (memo, _ref) {
	      var name = _ref.name;
	      var value = _ref.value;
	      var field = _ref.field;
	
	      memo[name] = value || function (item) {
	        return _underscore2.default.reduce((field || name).split('/'), function (memo, prop) {
	          return _underscore2.default.result(memo, prop);
	        }, item);
	      };
	      return memo;
	    }, {});
	
	    return {
	      map: function map(item) {
	        return _underscore2.default.reduce(config.columns, function (memo, _ref2) {
	          var name = _ref2.name;
	
	          memo[name] = properties[name](item);
	          return memo;
	        }, {});
	      }
	    };
	  },
	  Columns: function Columns(config) {
	    var columns = _underscore2.default.reduce(config.columns, function (columns, column) {
	      var $metadata = {};
	
	      if (column.attributes) {
	        $metadata['attr.body'] = column.attributes;
	      }
	
	      if (column.headerAttributes) {
	        $metadata['attr.head'] = column.headerAttributes;
	      }
	
	      columns[column.name] = {
	        sortable: column.sortable,
	        $metadata: $metadata,
	        headerBuilder: column.headerBuilder,
	        config: column
	      };
	
	      return columns;
	    }, {});
	
	    if (config.selectable) {
	      columns.checkbox = {
	        config: { name: 'selection' }
	      };
	    }
	
	    if (_underscore2.default.has(config.columnShifter, 'totalColumns')) {
	      columns['column.skip.less'] = {
	        config: { name: 'skip-less' }
	      };
	      columns['column.skip.more'] = {
	        config: { name: 'skip-more' }
	      };
	    }
	
	    return { columns: columns };
	  },
	  ColumnI18n: function ColumnI18n(config) {
	    return _underscore2.default.reduce(config.columns, function (columnI18n, column) {
	      columnI18n['column.i18n'][column.name] = column.title || column.name;
	      columnI18n['subColumn.i18n'][column.name] = column.subColTitle;
	      return columnI18n;
	    }, { 'column.i18n': {}, 'subColumn.i18n': {} });
	  },
	  ColumnQueryable: function ColumnQueryable(config) {
	    var columnIn = _underscore2.default.chain(config.columns).reject(_underscore2.default.property('hidden')).map(_underscore2.default.property('name')).value();
	    var columnLock = _underscore2.default.chain(config.columns).filter(_underscore2.default.property('locked')).map(_underscore2.default.property('name')).value();
	    var colqConfig = {
	      'column.lock': columnLock,
	      'column.in': columnIn
	    };
	
	    if (config.selectable) {
	      columnIn.unshift('checkbox');
	      columnLock.unshift('checkbox');
	    }
	
	    if (_underscore2.default.has(config.columnShifter, 'totalColumns')) {
	      colqConfig['column.take'] = config.columnShifter.totalColumns;
	    }
	    return colqConfig;
	  },
	  ColumnGroup: function ColumnGroup(config) {
	    return {
	      'column.group': config.columnGroup
	    };
	  },
	  ColumnShifter: function ColumnShifter() {},
	  ColumnTemplate: function ColumnTemplate(config) {
	    return {
	      'column.template': _underscore2.default.reduce(config.columns, function (columnTmpl, column) {
	        if (column.headerTemplate) {
	          columnTmpl[column.name] = column.headerTemplate;
	        }
	        return columnTmpl;
	      }, {})
	    };
	  },
	  ColumnHoverText: function ColumnHoverText() {},
	  Editable: function Editable(config) {
	    var editableOptions = {};
	
	    _underscore2.default.each(config.columns, function (column) {
	      if (column.editable) {
	        var options = editableOptions[column.name] = {
	          condition: function condition() {
	            return true;
	          },
	          editor: _index4.default
	        };
	
	        if (_underscore2.default.isFunction(column.editable)) {
	          options.condition = column.editable;
	        } else if (_underscore2.default.isObject(column.editable)) {
	          _underscore2.default.extend(options, column.editable);
	        }
	      }
	    });
	
	    var tooltipText = _underscore2.default.result(config.editable, 'tooltipText', 'Edit');
	    var iconClasses = _underscore2.default.result(config.editable, 'iconClasses', ['glyphicon', 'glyphicon-pencil']);
	
	    return {
	      'column.editable': editableOptions,
	      'editable.tooltip.text': tooltipText,
	      'editable.icon.class': iconClasses
	    };
	  },
	  MemoryQueryable: function MemoryQueryable(config) {
	    return {
	      'column.sortable': _underscore2.default.reduce(config.columns, function (columnSortable, column) {
	        if (column.sortable) {
	          columnSortable[column.name] = column.sortable;
	        }
	        return columnSortable;
	      }, {})
	    };
	  },
	  Odata: function Odata(config) {
	    return _underscore2.default.extend(_underscore2.default.pick(config.dataSource, ['url', 'skip', 'take', 'filter', 'orderby', 'select']));
	  },
	  PropertyTemplate: function PropertyTemplate(config) {
	    return {
	      'property.template': _underscore2.default.reduce(config.columns, function (propTmpl, column) {
	        if (column.template) {
	          propTmpl[column.name] = column.template;
	        }
	        return propTmpl;
	      }, {})
	    };
	  },
	  RowIndex: function RowIndex() {},
	  Row: function Row(config) {
	    return {
	      'row.classes': _underscore2.default.result(config.rows, 'classes')
	    };
	  },
	  RowCheckbox: function RowCheckbox(config) {
	    return {
	      'row.check.id': _underscore2.default.chain(config).result('dataSource').result('schema').result('key', 'rowIndex').value(),
	      'row.check.single': config.selectable === 'single',
	      'column.checked': 'checkbox',
	      'row.check.allow': function rowCheckAllow(model) {
	        var type = _underscore2.default.chain(model).result('$metadata').result('type').value();
	
	        return !_underscore2.default.contains(['segmentation', 'aggregate'], type);
	      }
	    };
	  },
	  Page: function Page(config) {
	    return {
	      'page.size': config.pageable.pageSize,
	      'page.number': 0
	    };
	  },
	  Sink: function Sink(config) {
	    var data = _underscore2.default.result(config.dataSource, 'data', []);
	
	    if (_underscore2.default.isArray(data)) {
	      return { seed: data };
	    } else if (data instanceof _backbone2.default.Collection) {
	      return { seed: data.toJSON() };
	    }
	  }
	};
	
	exports.default = function (definePlugin) {
	  return definePlugin('projection', ['config'], function (config) {
	    var projection = null;
	
	    function pipeProjection(name) {
	      var Projection = _index2.default[name];
	      var configProj = projectionConfigs[name](config);
	      var projectionDest = new Projection(configProj);
	
	      if (projection) {
	        projection = projection.pipe(projectionDest);
	      } else {
	        projection = projectionDest;
	      }
	    }
	
	    var dataSourceType = config.dataSource.type || 'memory';
	    if (dataSourceType === 'js-data') {
	      pipeProjection('JSData');
	    } else if (dataSourceType === 'memory') {
	      pipeProjection('Sink');
	      pipeProjection('MemoryQueryable');
	      if (config.dataSource.data instanceof _backbone2.default.Collection) {
	        (function () {
	          var updating = false;
	          var scheduleUpdate = function scheduleUpdate() {
	            if (!updating) {
	              updating = true;
	              window.setTimeout(function () {
	                projection.set('seed', config.dataSource.data.toJSON());
	                updating = false;
	              }, 0);
	            }
	          };
	          config.dataSource.data.on('all', scheduleUpdate);
	        })();
	      }
	    } else if (dataSourceType === 'odata') {
	      pipeProjection('Odata');
	    } else {
	      throw new Error('dataSource.type "' + config.dataSource.type + '" is not supported');
	    }
	
	    var dataSourceProjection = projection;
	
	    pipeProjection('A11y');
	    pipeProjection('Columns');
	    pipeProjection('Map');
	    if (config.aggregate) {
	      pipeProjection('AggregateRow');
	    }
	    pipeProjection('ColumnQueryable');
	    pipeProjection('ColumnI18n');
	    if (config.enablePoP) {
	      pipeProjection('ColumnGroup');
	    }
	    if (_underscore2.default.has(config.columnShifter, 'totalColumns')) {
	      pipeProjection('ColumnShifter');
	    }
	    pipeProjection('ColumnTemplate');
	    pipeProjection('ColumnHoverText');
	    pipeProjection('PropertyTemplate');
	    if (config.selectable) {
	      pipeProjection('RowIndex');
	      pipeProjection('RowCheckbox');
	    }
	    if (config.rows || config.selectable) {
	      pipeProjection('Row');
	    }
	    if (_underscore2.default.has(config.pageable, 'pageSize')) {
	      pipeProjection('Page');
	    }
	    if (_underscore2.default.find(config.columns, _underscore2.default.property('editable'))) {
	      pipeProjection('Editable');
	    }
	
	    (0, _utility.delegateEvents)({
	      from: dataSourceProjection,
	      to: projection,
	      events: ['update:beginning', 'update:finished']
	    });
	
	    return projection;
	  });
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = {
	  A11y: __webpack_require__(21),
	  AggregateRow: __webpack_require__(24),
	  Base: __webpack_require__(22),
	  ColumnI18n: __webpack_require__(25),
	  ColumnQueryable: __webpack_require__(27),
	  ColumnShifter: __webpack_require__(28),
	  ColumnTemplate: __webpack_require__(29),
	  EditableString: __webpack_require__(30),
	  Editable: __webpack_require__(32),
	  JSData: __webpack_require__(43),
	  Map: __webpack_require__(44),
	  MemoryQueryable: __webpack_require__(45),
	  Memory: __webpack_require__(46),
	  Mock: __webpack_require__(47),
	  Odata: __webpack_require__(48),
	  Page: __webpack_require__(49),
	  PropertyTemplate: __webpack_require__(50),
	  RowCheckbox: __webpack_require__(51),
	  Row: __webpack_require__(53),
	  RowTriStateCheckboxProjection: __webpack_require__(54),
	  RowIndex: __webpack_require__(56),
	  Sink: __webpack_require__(57),
	  ColumnGroup: __webpack_require__(58),
	  ColumnHoverText: __webpack_require__(59),
	  Columns: __webpack_require__(60).default
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection /* , schemaProperties, Response */) {
	  var defaultselectAllLabel = 'Select All';
	  var Model = BaseProjection.extend({
	    defaults: {
	      'a11y.selection.selectAllLabel': 'Select All'
	    },
	    name: 'a11y',
	    update: function update(options) {
	      var selectAllLabel = this.get('a11y.selection.selectAllLabel');
	      if (Model.__super__.update.call(this, options)) {
	        this.patch({
	          'a11y.selection.uniqueId': _.uniqueId().concat('-'),
	          'a11y.selection.selectAllLabel': _.isString(selectAllLabel) ? selectAllLabel : defaultselectAllLabel
	        });
	      }
	    }
	  });
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(23)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, Response) {
	  var Model = Backbone.Model.extend({
	    initialize: function initialize() {
	      _.bindAll(this, 'onSrcUpdate', 'beforeSet', 'afterSet', 'update');
	      this.data = new Response();
	      this.src = undefined;
	      this.on('change', function (model) {
	        // todo [akamel] the model here is the settings model
	        this.update({ model: model });
	      }.bind(this));
	    },
	
	    constructor: function constructor() {
	      // used to figure out which options to set localy and which ones to pass down the pipe
	      this.localKeys = _.keys(this.defaults);
	      // todo [akamel] this might prevent us from overriding initialize
	      Model.__super__.constructor.apply(this, arguments);
	    },
	
	    pipe: function pipe(to) {
	      if (to) {
	        to.setSrc(this);
	      }
	
	      return to;
	    },
	
	    setSrc: function setSrc(src) {
	      this.src = src;
	      if (this.src) {
	        this.src.data.off('change', this.onSrcUpdate);
	        this.src.off('all', this.bubble);
	      }
	
	      if (this.src) {
	        this.src.data.on('change', this.onSrcUpdate);
	        this.src.on('all', this.bubble);
	      }
	
	      this.update();
	    },
	
	    patch: function patch(delta) {
	      var src = this.src ? this.src.data.toJSON() : {};
	      delta = _.isObject(delta) ? delta : {};
	
	      this.data.set(_.defaults(delta, this.attributes, src));
	    },
	
	    beforeSet: function beforeSet() /* local, other */{},
	    afterSet: function afterSet() {},
	
	    onSrcUpdate: function onSrcUpdate() /* model */{
	      this.update();
	    },
	    bubble: function bubble() {
	      var key = _.first(arguments);
	
	      if (_.has(this.events, key)) {
	        var fct = this[this.events[key]];
	        if (_.isFunction(fct)) {
	          fct.apply(this, _.rest(arguments));
	        }
	      }
	
	      // todo [akamel] can this result in multiple redraw calls?
	      if (this.src) {
	        this.src.bubble.apply(this.src, _.toArray(arguments));
	      }
	    },
	
	    update: function update(options) {
	      options = options || {};
	
	      if (this.src) {
	        if (options.deep) {
	          this.src.update(options);
	          return false;
	        }
	
	        return true;
	      }
	
	      return false;
	    }
	  });
	
	  Model.prototype.set = function (key, value, options) {
	    var obj = {};
	
	    if (_.isString(key)) {
	      obj[key] = value;
	    } else {
	      obj = key;
	      options = value;
	    }
	
	    var local = _.pick(obj, this.localKeys);
	    var other = _.omit(obj, this.localKeys);
	
	    this.beforeSet(local, other);
	
	    var ret = Model.__super__.set.call(this, local, options);
	
	    // todo [akamel] if we set options that span multiple data sources we will trigger change multiple times in the chain??
	    // pass along non-local options
	    if (_.size(other)) {
	      if (this.src) {
	        this.src.set(other, options);
	      }
	    }
	    this.afterSet();
	
	    return ret;
	  };
	
	  Model.keyRegex = /^([\w_\-$]+):(.+)$/;
	
	  Model.prototype.get = function (key) {
	    var match = Model.keyRegex.exec(key);
	
	    if (match) {
	      var type = match[1];
	      var name = match[2];
	
	      switch (type) {
	        case 'projection':
	          {
	            var p = this;
	            do {
	              if (p.name === name) {
	                return p;
	              }
	              p = p.src;
	            } while (p);
	            break;
	          }
	        default:
	          {
	            throw new Error('unknown special get key type');
	          }
	      }
	    } else {
	      var ret = Model.__super__.get.apply(this, arguments);
	
	      if (_.isUndefined(ret)) {
	        if (this.src) {
	          ret = this.src.get.apply(this.src, arguments);
	        }
	      }
	
	      return ret;
	    }
	  };
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone) {
	  return Backbone.Model.extend({
	    defaults: {
	      value: [],
	      select: null,
	      count: 0,
	      aggregate: []
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection) {
	  var createRows = function createRows(fn, data) {
	    var rows = fn(data);
	
	    _.each(rows, function (row) {
	      row.$metadata = _.extend({}, row.$metadata, { type: 'aggregate' });
	    });
	
	    return rows;
	  };
	
	  var Model = BaseProjection.extend({
	
	    defaults: {
	      'aggregate.top': null,
	      'aggregate.bottom': null
	    },
	
	    name: 'aggregate-row',
	
	    update: function update(options) {
	      var value, topFn, rowTop, bottomFn, rowBottom;
	
	      if (Model.__super__.update.call(this, options)) {
	        value = this.src.data.get('value');
	
	        if (value) {
	          topFn = this.get('aggregate.top');
	          bottomFn = this.get('aggregate.bottom');
	          rowTop = _.isFunction(topFn) ? createRows(topFn, this.src.data) : null;
	          rowBottom = _.isFunction(bottomFn) ? createRows(bottomFn, this.src.data) : null;
	
	          if (rowTop) {
	            value = _.flatten(rowTop).concat(value);
	          }
	
	          if (rowBottom) {
	            value = value.concat(_.flatten(rowBottom));
	          }
	
	          this.patch({
	            value: value
	          });
	        }
	      }
	    }
	
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22), __webpack_require__(26), __webpack_require__(23)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection /* , schemaProperties, Response */) {
	  var Model = BaseProjection.extend({
	    defaults: {
	      'column.i18n': {
	        '': function _(name) {
	          return name;
	        }
	      },
	      'subColumn.i18n': {}
	    },
	    name: 'column-i18n',
	    beforeSet: function beforeSet(local) {
	      if (_.has(local, 'column.i18n')) {
	        if (!_.isObject(local['column.i18n'])) {
	          local['column.i18n'] = this.defaults['column.i18n'];
	        }
	      }
	    },
	    update: function update(options) {
	      // todo [akamel] when calling a deep update; suppress onchange event based updates
	      // Model.__super__.update.call(this, options);
	
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        var colOptions = this.get('column.i18n');
	        var subColOptions = this.get('subColumn.i18n');
	        var columns = model.get('columns') || {};
	        var $default = colOptions[''];
	
	        var i18nColumns = {};
	        _.each(_.keys(columns), function (element) {
	          var opt = colOptions[element];
	          if (_.isUndefined(opt)) {
	            opt = $default;
	          }
	
	          i18nColumns[element] = _.defaults({
	            $text: _.isFunction(opt) ? opt(element) : opt,
	            property: element
	          }, columns[element]);
	
	          i18nColumns[element].config = i18nColumns[element].config || {};
	          i18nColumns[element].config.subColTitle = subColOptions[element];
	        });
	
	        this.patch({
	          columns: i18nColumns
	        });
	      } else {
	        // todo [akamel] unset our properties only
	        // this.unset();
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {
	  function from(arr) {
	    var obj = _.first(arr);
	
	    return _.keys(obj || {});
	  }
	
	  return { from: from };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22), __webpack_require__(26), __webpack_require__(23)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection /* , schemaProperties, Response */) {
	  var Model = BaseProjection.extend({
	    defaults: {
	      'column.skip': 0,
	      'column.take': Number.MAX_VALUE,
	      'column.lock': [],
	      'column.filter': function columnFilter() {
	        return true;
	      },
	      'column.in': undefined
	    },
	    name: 'column-queryable',
	    update: function update(options) {
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        var take = this.get('column.take');
	        var skip = this.get('column.skip');
	        var lock = this.get('column.lock') || [];
	        var filter = this.get('column.filter');
	        // todo [akamel] consider renaming to column.select
	        var $in = this.get('column.in');
	        var select = _.size(model.get('columns')) ? _.map(model.get('columns'), function (i) {
	          return i.property;
	        }) : model.get('select');
	        var unlocked = _.isFunction(filter) ? _.filter($in || select, filter) : $in || select;
	        var lookup = model.get('columns');
	        var set = _.chain(unlocked).difference(lock).value();
	        var col = set;
	
	        if (!_.isNumber(take)) {
	          take = Number.MAX_VALUE;
	        }
	
	        take = Math.max(take - _.size(lock), 0);
	        if (_.size(set) < skip) {
	          skip = 0;
	          // this.set({ 'columns.skip' : 0 }, { silent : true });
	        }
	
	        // start query
	        var skipped = _.first(set, skip);
	
	        if (skip) {
	          col = _.rest(set, skip);
	        }
	
	        var remaining = _.rest(col, take);
	
	        col = _.union(lock, _.first(col, take));
	        // end query
	
	        _.each(col, function (element) {
	          if (!lookup[element]) {
	            lookup[element] = { property: element };
	          }
	          lookup[element].$lock = _.contains(lock, element);
	        });
	
	        this.patch({
	          'select': col,
	          // todo [akamel] rename to column.in???
	          // , 'columns.select'  : set
	          'columns.skipped': skipped,
	          'columns.remaining': remaining,
	          // , 'columns.count'   : _.size(res)
	          // todo [akamel] do we still need to update skip?
	          'column.skip': skip
	        });
	      } else {
	        // todo [akamel] unset our properties only
	        // this.unset();
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22), __webpack_require__(26), __webpack_require__(23)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection /* , schemaProperties, Response */) {
	  var Model = BaseProjection.extend({
	    defaults: {},
	    name: 'column-shifter',
	    events: {
	      'layout:click:header': 'thClick'
	    },
	    update: function update(options) {
	      // todo [akamel] when calling a deep update; suppress onchange event based updates
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        // todo [akamel] have 'columns' crated at the source so we don't have to put this all over the place
	        var columns = model.get('columns');
	        var select = model.get('select');
	        var colSkipped = model.get('columns.skipped');
	        var colRemaining = model.get('columns.remaining');
	
	        var unlockedAt = Math.max(_.findIndex(select, function (col) {
	          return columns[col] && !columns[col].$lock;
	        }), 0);
	
	        var hasLess = _.size(colSkipped);
	        var hasMore = _.size(colRemaining);
	
	        var colLess = {
	          property: 'column.skip.less',
	          $metadata: {
	            'attr.head': { class: ['skip-less'] },
	            'enabled': hasLess
	          },
	          $html: '<span class="glyphicon glyphicon-triangle-left" />'
	        };
	        var colMore = {
	          property: 'column.skip.more',
	          $metadata: {
	            'attr.head': { class: ['skip-more'] },
	            'enabled': hasMore
	          },
	          $html: '<span class="glyphicon glyphicon-triangle-right" />'
	        };
	
	        if (!hasLess) {
	          colLess.$metadata['attr.head'].class.push('disabled');
	        }
	
	        if (!hasMore) {
	          colMore.$metadata['attr.head'].class.push('disabled');
	        }
	
	        select.splice(unlockedAt, 0, colLess.property);
	        columns[colLess.property] = _.defaults(colLess, columns[colLess.property]);
	        select.push(colMore.property);
	        columns[colMore.property] = _.defaults(colMore, columns[colMore.property]);
	
	        this.patch({
	          columns: columns,
	          select: select
	        });
	      } else {
	        // todo [akamel] unset our properties only
	        // this.unset();
	      }
	    },
	    thClick: function thClick(e, arg) {
	      if (_.has(arg.column, '$metadata') && arg.column.$metadata.enabled) {
	        var ret = 0;
	        var skip = this.get('column.skip');
	
	        // todo [akamel] is this logic solid?
	        switch (arg.property) {
	          case 'column.skip.less':
	            {
	              ret = _.isNumber(skip) ? Math.max(skip - 1, 0) : 0;
	              break;
	            }
	          case 'column.skip.more':
	            {
	              ret = _.isNumber(skip) ? skip + 1 : 0;
	              break;
	            }
	          default:
	        }
	
	        this.set({ 'column.skip': ret });
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, BaseProjection) {
	  'use strict';
	
	  var Model = BaseProjection.extend({
	    defaults: {
	      'column.template': {}
	    },
	    name: 'column-template',
	    update: function update(options) {
	      // todo [akamel] when calling a deep update; suppress onchange event based updates
	      // Model.__super__.update.call(this, options);
	
	      // TODO [imang]: columns: ideally we should not need to read from select.
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        var colTemplate = this.get('column.template');
	        var columns = model.get('columns');
	        _.each(columns, function (item, property) {
	          var ret = _.clone(item);
	          var templateValue = colTemplate[property];
	
	          if (_.has(colTemplate, property)) {
	            ret.$html = _.isFunction(templateValue) ? templateValue(ret) : templateValue;
	          }
	
	          columns[property] = ret;
	        });
	
	        this.patch({ columns: columns });
	      } else {
	        // todo [akamel] unset our properties only
	        // this.unset();
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	/**
	 *
	 * Important!!!
	 *
	 * The initial check-in is for unblock the simple grid in advanced campaign creation and
	 * may cause bugs if you try to use it with some more complex grid. Please DO NOT use this
	 * projection until we update this and remove the comments here.
	 *
	 * todo [yucongj, wewei] add the model to maintail the input data.
	 *
	 */
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(9), __webpack_require__(22), __webpack_require__(31)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, jquery, BaseProjection, editableTemplate) {
	  'use strict';
	
	  var Model = BaseProjection.extend({
	    defaults: {
	      'column.editable.string': {}
	    },
	    name: 'column-editable-string',
	    update: function update(options) {
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        var columnEditable = this.get('column.editable.string');
	        var value = _.map(model.get('value'), function (item) {
	          var ret = _.clone(item);
	
	          _.each(columnEditable, function (value, key) {
	            if (_.has(ret, key)) {
	              if (!_.isObject(ret[key])) {
	                var obj = new Object(ret[key]); //eslint-disable-line
	
	                if (_.isUndefined(ret[key])) {
	                  obj.$undefined = true;
	                }
	
	                if (_.isNull(ret[key])) {
	                  obj.$null = true;
	                }
	
	                ret[key] = obj;
	              }
	
	              var defaultValue = ret[key].$undefined || ret[key].$null ? value.defaultValue : ret[key];
	
	              ret[key].$html = editableTemplate({ defaultValue: defaultValue });
	            }
	          });
	
	          return ret;
	        });
	
	        this.patch({ value: value });
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (defaultValue) {
	buf.push("<input type=\"text\"" + (jade.attr("value", defaultValue, true, true)) + " style=\"width:100%\" class=\"grid-text-input\">");}.call(this,"defaultValue" in locals_for_with?locals_for_with.defaultValue:typeof defaultValue!=="undefined"?defaultValue:undefined));;return buf.join("");
	}

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(9), __webpack_require__(22), __webpack_require__(33), __webpack_require__(34), __webpack_require__(39)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, BaseProjection, defaultEditableTemplate, prompt) {
	  'use strict';
	
	  function isReadonlyRow(item) {
	    return !item || item.$metadata && _.contains(['aggregate', 'segmentation'], item.$metadata.type);
	  }
	
	  return BaseProjection.extend({
	    defaults: {
	      'column.editable': [],
	      'editable.icon.class': ['glyphicon', 'glyphicon-pencil'],
	      'editable.tooltip.text': 'Edit',
	      'editable.template': defaultEditableTemplate
	    },
	    name: 'column-editable',
	    events: {
	      'layout:click:cell': 'tdClick'
	    },
	
	    beforeSet: function beforeSet(local) {
	      var _this = this;
	
	      var editable = function editable() {
	        return true;
	      };
	
	      if (_.has(local, 'column.editable')) {
	        (function () {
	          var editableOptions = local['column.editable'];
	          var viewConfig = {};
	          var conditions = {};
	
	          if (_.isArray(editableOptions)) {
	            _.each(editableOptions, function (editableColumn) {
	              if (_.isString(editableColumn)) {
	                conditions[editableColumn] = editable;
	              } else if (_.isObject(editableColumn) && _.isString(editableColumn.name)) {
	                conditions[editableColumn.name] = _.isFunction(editableColumn.condition) ? editableColumn.condition : editable;
	              }
	              viewConfig[editableColumn] = null;
	            });
	          } else {
	            _.each(editableOptions, function (options, columnName) {
	              if (_.isFunction(options)) {
	                conditions[columnName] = editable;
	                viewConfig[columnName] = options;
	              } else if (_.isObject(options)) {
	                conditions[columnName] = options.condition;
	                viewConfig[columnName] = options.editor;
	              }
	            });
	          }
	
	          _this.viewConfig = viewConfig;
	          _this.isEditable = function (key, item) {
	            return _.isFunction(conditions[key]) && conditions[key](item);
	          };
	        })();
	      }
	    },
	
	    update: function update(options) {
	      if (BaseProjection.prototype.update.call(this, options)) {
	        var model = this.src.data;
	        var columns = model.get('columns');
	        var iconClasses = this.get('editable.icon.class');
	        var tooltipText = this.get('editable.tooltip.text');
	        var editableTemplate = this.get('editable.template');
	
	        _.each(this.viewConfig, function (view, key) {
	          var column = columns[key] || { property: key };
	          var $metadata = column.$metadata = column.$metadata || {};
	          var attrBody = $metadata['attr.body'] = $metadata['attr.body'] || {};
	          var className = attrBody.class || [];
	
	          if (_.isString(className)) {
	            className = className.split(/\s+/);
	          }
	          attrBody.class = _.union(className, ['grid-editable-cell']);
	
	          columns[key] = column;
	        });
	
	        var value = _.map(model.get('value'), function (item) {
	          return isReadonlyRow(item) ? item : _.mapObject(item, function (value, key) {
	            if (this.isEditable(key, item)) {
	              var $html = null;
	              var text = null;
	
	              if (_.isObject(value)) {
	                $html = value.$html;
	              } else {
	                text = value;
	                value = {};
	              }
	
	              value.$html = editableTemplate({
	                $html: $html,
	                text: text,
	                tooltipText: tooltipText,
	                classes: iconClasses
	              });
	            }
	            return value;
	          }, this);
	        }, this);
	
	        this.patch({ value: value });
	      }
	    },
	
	    tdClick: function tdClick(e, arg) {
	      var _this2 = this;
	
	      var schema = null;
	      var metadata = arg.column.$metadata;
	      // TODO: wewei
	      // let's rethink this
	      var property = metadata && metadata.map || arg.property;
	
	      if (!isReadonlyRow(arg.model) && this.isEditable(arg.property, arg.model) && e.target.tagName !== 'A' && $(e.target).closest('.is-not-trigger').length === 0) {
	        schema = arg.grid.options.get('schema');
	        var editor = this.viewConfig[arg.property] || prompt;
	        var position = arg.grid.layout.container.offset(e.currentTarget);
	        var $td = $(e.currentTarget);
	
	        position.right = position.left + $td.outerWidth();
	        position.bottom = position.top + $td.outerHeight();
	        editor({
	          model: arg.model,
	          schema: schema,
	          position: position,
	          property: property,
	          onSubmit: function onSubmit(model) {
	            _this2.trigger('edit', model, property);
	          }
	        });
	      }
	    }
	
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function ($html, classes, text, tooltipText) {
	buf.push("<div" + (jade.attr("title", tooltipText, true, true)) + (jade.cls(['grid-edit-icon',classes], [null,true])) + "></div>" + (null == (jade_interp = $html) ? "" : jade_interp) + (jade.escape(null == (jade_interp = text) ? "" : jade_interp)));}.call(this,"$html" in locals_for_with?locals_for_with.$html:typeof $html!=="undefined"?$html:undefined,"classes" in locals_for_with?locals_for_with.classes:typeof classes!=="undefined"?classes:undefined,"text" in locals_for_with?locals_for_with.text:typeof text!=="undefined"?text:undefined,"tooltipText" in locals_for_with?locals_for_with.tooltipText:typeof tooltipText!=="undefined"?tooltipText:undefined));;return buf.join("");
	}

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(35), __webpack_require__(10), __webpack_require__(5), __webpack_require__(38)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, Promise, Backbone, _, template) {
	  var PopupEditor = Backbone.View.extend({
	    events: {
	      'click .save': function clickSave() {
	        this.trigger('save', this.model);
	      },
	      'click .cancel': function clickCancel() {
	        this.trigger('cancel');
	      },
	      'change .editor': function changeEditor(e) {
	        this.setValue(e.target.value);
	      },
	      'click form': function clickForm(e) {
	        e.stopPropagation();
	      },
	      'submit form': function submitForm() {
	        this.trigger('save', this.model);
	        return false;
	      }
	    },
	
	    initialize: function initialize(options) {
	      this.position = options.position;
	      this.model = options.model;
	      this.property = options.property;
	      this.saveButtonText = options.saveButtonText || 'Save';
	      this.cancelButtonText = options.cancelButtonText || 'Cancel';
	    },
	
	    getValue: function getValue() {
	      if (this.property && _.isObject(this.property)) {
	        var _property = this.property;
	        var name = _property.name;
	        var value = _property.value;
	
	        return value(this.model)[name];
	      }
	
	      return (this.model || {})[this.property];
	    },
	
	    setValue: function setValue(val) {
	      if (this.property && _.isObject(this.property)) {
	        var _property2 = this.property;
	        var name = _property2.name;
	        var value = _property2.value;
	
	        value(this.model)[name] = val;
	      } else {
	        this.model[this.property] = val;
	      }
	    },
	
	    render: function render() {
	      var _this = this;
	
	      var val = this.getValue();
	
	      this.$el.html(template({
	        value: val,
	        saveButtonText: this.saveButtonText,
	        cancelButtonText: this.cancelButtonText
	      }));
	      this.$el.css({ position: 'absolute' });
	
	      if (this.position.left) {
	        this.$el.css({ left: this.position.left });
	      } else {
	        this.$el.css({ right: this.position.right });
	      }
	      if (this.position.top) {
	        this.$el.css({ top: this.position.top });
	      } else {
	        this.$el.css({ bottom: this.position.bottom });
	      }
	
	      this.dismiss = function () {
	        this.trigger('cancel');
	      }.bind(this);
	
	      window.setTimeout(function () {
	        $(window).on('click', _this.dismiss);
	      }, 0);
	
	      return this;
	    },
	
	    remove: function remove() {
	      $(window).off('click', this.dismiss);
	      Backbone.View.prototype.remove.apply(this, arguments);
	    },
	
	    focus: function focus() {
	      var input = this.$el.find('.editor');
	      input.select();
	    }
	
	  });
	
	  return function (options) {
	    var editor = new PopupEditor(options);
	
	    document.body.appendChild(editor.render().el);
	
	    editor.focus();
	
	    editor.on('save', function (model) {
	      editor.remove();
	      options.onSubmit && options.onSubmit(model);
	    });
	
	    editor.on('cancel', function () {
	      editor.remove();
	      options.onCancel && options.onCancel();
	    });
	  };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2013-2015 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */
	/**
	 * bluebird build version 3.4.6
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
	*/
	!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}
	
	Promise.any = function (promises) {
	    return any(promises);
	};
	
	Promise.prototype.any = function () {
	    return any(this);
	};
	
	};
	
	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = _dereq_("./schedule");
	var Queue = _dereq_("./queue");
	var util = _dereq_("./util");
	
	function Async() {
	    this._customScheduler = false;
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._haveDrainedQueues = false;
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule = schedule;
	}
	
	Async.prototype.setScheduler = function(fn) {
	    var prev = this._schedule;
	    this._schedule = fn;
	    this._customScheduler = true;
	    return prev;
	};
	
	Async.prototype.hasCustomScheduler = function() {
	    return this._customScheduler;
	};
	
	Async.prototype.enableTrampoline = function() {
	    this._trampolineEnabled = true;
	};
	
	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};
	
	Async.prototype.haveItemsQueued = function () {
	    return this._isTickUsed || this._haveDrainedQueues;
	};
	
	
	Async.prototype.fatalError = function(e, isNode) {
	    if (isNode) {
	        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
	            "\n");
	        process.exit(2);
	    } else {
	        this.throwLater(e);
	    }
	};
	
	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	};
	
	function AsyncInvokeLater(fn, receiver, arg) {
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncInvoke(fn, receiver, arg) {
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncSettlePromises(promise) {
	    this._normalQueue._pushOne(promise);
	    this._queueTick();
	}
	
	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                setTimeout(function() {
	                    fn.call(receiver, arg);
	                }, 100);
	            });
	        }
	    };
	
	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                fn.call(receiver, arg);
	            });
	        }
	    };
	
	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            this._schedule(function() {
	                promise._settlePromises();
	            });
	        }
	    };
	}
	
	Async.prototype.invokeFirst = function (fn, receiver, arg) {
	    this._normalQueue.unshift(fn, receiver, arg);
	    this._queueTick();
	};
	
	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};
	
	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._haveDrainedQueues = true;
	    this._drainQueue(this._lateQueue);
	};
	
	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};
	
	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};
	
	module.exports = Async;
	module.exports.firstLineError = firstLineError;
	
	},{"./queue":26,"./schedule":29,"./util":36}],3:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
	var calledBind = false;
	var rejectThis = function(_, e) {
	    this._reject(e);
	};
	
	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};
	
	var bindingResolved = function(thisArg, context) {
	    if (((this._bitField & 50397184) === 0)) {
	        this._resolveCallback(context.target);
	    }
	};
	
	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};
	
	Promise.prototype.bind = function (thisArg) {
	    if (!calledBind) {
	        calledBind = true;
	        Promise.prototype._propagateFrom = debug.propagateFromFunction();
	        Promise.prototype._boundValue = debug.boundValueFunction();
	    }
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();
	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, undefined, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, undefined, ret, context);
	        ret._setOnCancel(maybePromise);
	    } else {
	        ret._resolveCallback(target);
	    }
	    return ret;
	};
	
	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 2097152;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~2097152);
	    }
	};
	
	Promise.prototype._isBound = function () {
	    return (this._bitField & 2097152) === 2097152;
	};
	
	Promise.bind = function (thisArg, value) {
	    return Promise.resolve(value).bind(thisArg);
	};
	};
	
	},{}],4:[function(_dereq_,module,exports){
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = _dereq_("./promise")();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;
	
	},{"./promise":22}],5:[function(_dereq_,module,exports){
	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}
	
	module.exports = function(Promise) {
	var util = _dereq_("./util");
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;
	
	var getMethodCaller;
	var getGetter;
	if (false) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};
	
	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};
	
	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};
	
	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};
	
	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}
	
	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}
	
	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var args = [].slice.call(arguments, 1);;
	    if (false) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};
	
	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};
	
	},{"./util":36}],6:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, PromiseArray, apiRejection, debug) {
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;
	
	Promise.prototype["break"] = Promise.prototype.cancel = function() {
	    if (!debug.cancellation()) return this._warn("cancellation is disabled");
	
	    var promise = this;
	    var child = promise;
	    while (promise._isCancellable()) {
	        if (!promise._cancelBy(child)) {
	            if (child._isFollowing()) {
	                child._followee().cancel();
	            } else {
	                child._cancelBranched();
	            }
	            break;
	        }
	
	        var parent = promise._cancellationParent;
	        if (parent == null || !parent._isCancellable()) {
	            if (promise._isFollowing()) {
	                promise._followee().cancel();
	            } else {
	                promise._cancelBranched();
	            }
	            break;
	        } else {
	            if (promise._isFollowing()) promise._followee().cancel();
	            promise._setWillBeCancelled();
	            child = promise;
	            promise = parent;
	        }
	    }
	};
	
	Promise.prototype._branchHasCancelled = function() {
	    this._branchesRemainingToCancel--;
	};
	
	Promise.prototype._enoughBranchesHaveCancelled = function() {
	    return this._branchesRemainingToCancel === undefined ||
	           this._branchesRemainingToCancel <= 0;
	};
	
	Promise.prototype._cancelBy = function(canceller) {
	    if (canceller === this) {
	        this._branchesRemainingToCancel = 0;
	        this._invokeOnCancel();
	        return true;
	    } else {
	        this._branchHasCancelled();
	        if (this._enoughBranchesHaveCancelled()) {
	            this._invokeOnCancel();
	            return true;
	        }
	    }
	    return false;
	};
	
	Promise.prototype._cancelBranched = function() {
	    if (this._enoughBranchesHaveCancelled()) {
	        this._cancel();
	    }
	};
	
	Promise.prototype._cancel = function() {
	    if (!this._isCancellable()) return;
	    this._setCancelled();
	    async.invoke(this._cancelPromises, this, undefined);
	};
	
	Promise.prototype._cancelPromises = function() {
	    if (this._length() > 0) this._settlePromises();
	};
	
	Promise.prototype._unsetOnCancel = function() {
	    this._onCancelField = undefined;
	};
	
	Promise.prototype._isCancellable = function() {
	    return this.isPending() && !this._isCancelled();
	};
	
	Promise.prototype.isCancellable = function() {
	    return this.isPending() && !this.isCancelled();
	};
	
	Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
	    if (util.isArray(onCancelCallback)) {
	        for (var i = 0; i < onCancelCallback.length; ++i) {
	            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
	        }
	    } else if (onCancelCallback !== undefined) {
	        if (typeof onCancelCallback === "function") {
	            if (!internalOnly) {
	                var e = tryCatch(onCancelCallback).call(this._boundValue());
	                if (e === errorObj) {
	                    this._attachExtraTrace(e.e);
	                    async.throwLater(e.e);
	                }
	            }
	        } else {
	            onCancelCallback._resultCancelled(this);
	        }
	    }
	};
	
	Promise.prototype._invokeOnCancel = function() {
	    var onCancelCallback = this._onCancel();
	    this._unsetOnCancel();
	    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
	};
	
	Promise.prototype._invokeInternalOnCancel = function() {
	    if (this._isCancellable()) {
	        this._doInvokeOnCancel(this._onCancel(), true);
	        this._unsetOnCancel();
	    }
	};
	
	Promise.prototype._resultCancelled = function() {
	    this.cancel();
	};
	
	};
	
	},{"./util":36}],7:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = _dereq_("./util");
	var getKeys = _dereq_("./es5").keys;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	function catchFilter(instances, cb, promise) {
	    return function(e) {
	        var boundTo = promise._boundValue();
	        predicateLoop: for (var i = 0; i < instances.length; ++i) {
	            var item = instances[i];
	
	            if (item === Error ||
	                (item != null && item.prototype instanceof Error)) {
	                if (e instanceof item) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (typeof item === "function") {
	                var matchesPredicate = tryCatch(item).call(boundTo, e);
	                if (matchesPredicate === errorObj) {
	                    return matchesPredicate;
	                } else if (matchesPredicate) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (util.isObject(e)) {
	                var keys = getKeys(item);
	                for (var j = 0; j < keys.length; ++j) {
	                    var key = keys[j];
	                    if (item[key] != e[key]) {
	                        continue predicateLoop;
	                    }
	                }
	                return tryCatch(cb).call(boundTo, e);
	            }
	        }
	        return NEXT_FILTER;
	    };
	}
	
	return catchFilter;
	};
	
	},{"./es5":13,"./util":36}],8:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var longStackTraces = false;
	var contextStack = [];
	
	Promise.prototype._promiseCreated = function() {};
	Promise.prototype._pushContext = function() {};
	Promise.prototype._popContext = function() {return null;};
	Promise._peekContext = Promise.prototype._peekContext = function() {};
	
	function Context() {
	    this._trace = new Context.CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (this._trace !== undefined) {
	        this._trace._promiseCreated = null;
	        contextStack.push(this._trace);
	    }
	};
	
	Context.prototype._popContext = function () {
	    if (this._trace !== undefined) {
	        var trace = contextStack.pop();
	        var ret = trace._promiseCreated;
	        trace._promiseCreated = null;
	        return ret;
	    }
	    return null;
	};
	
	function createContext() {
	    if (longStackTraces) return new Context();
	}
	
	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}
	Context.CapturedTrace = null;
	Context.create = createContext;
	Context.deactivateLongStackTraces = function() {};
	Context.activateLongStackTraces = function() {
	    var Promise_pushContext = Promise.prototype._pushContext;
	    var Promise_popContext = Promise.prototype._popContext;
	    var Promise_PeekContext = Promise._peekContext;
	    var Promise_peekContext = Promise.prototype._peekContext;
	    var Promise_promiseCreated = Promise.prototype._promiseCreated;
	    Context.deactivateLongStackTraces = function() {
	        Promise.prototype._pushContext = Promise_pushContext;
	        Promise.prototype._popContext = Promise_popContext;
	        Promise._peekContext = Promise_PeekContext;
	        Promise.prototype._peekContext = Promise_peekContext;
	        Promise.prototype._promiseCreated = Promise_promiseCreated;
	        longStackTraces = false;
	    };
	    longStackTraces = true;
	    Promise.prototype._pushContext = Context.prototype._pushContext;
	    Promise.prototype._popContext = Context.prototype._popContext;
	    Promise._peekContext = Promise.prototype._peekContext = peekContext;
	    Promise.prototype._promiseCreated = function() {
	        var ctx = this._peekContext();
	        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
	    };
	};
	return Context;
	};
	
	},{}],9:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, Context) {
	var getDomain = Promise._getDomain;
	var async = Promise._async;
	var Warning = _dereq_("./errors").Warning;
	var util = _dereq_("./util");
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
	var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
	var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var printWarning;
	var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
	                        (true ||
	                         util.env("BLUEBIRD_DEBUG") ||
	                         util.env("NODE_ENV") === "development"));
	
	var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
	    (debugging || util.env("BLUEBIRD_WARNINGS")));
	
	var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
	    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
	
	var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
	    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
	
	Promise.prototype.suppressUnhandledRejections = function() {
	    var target = this._target();
	    target._bitField = ((target._bitField & (~1048576)) |
	                      524288);
	};
	
	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    if ((this._bitField & 524288) !== 0) return;
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};
	
	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};
	
	Promise.prototype._setReturnedNonUndefined = function() {
	    this._bitField = this._bitField | 268435456;
	};
	
	Promise.prototype._returnedNonUndefined = function() {
	    return (this._bitField & 268435456) !== 0;
	};
	
	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._settledValue();
	        this._setUnhandledRejectionIsNotified();
	        fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};
	
	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 262144;
	};
	
	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~262144);
	};
	
	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 262144) > 0;
	};
	
	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 1048576;
	};
	
	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~1048576);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};
	
	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 1048576) > 0;
	};
	
	Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
	    return warn(message, shouldUseOwnTrace, promise || this);
	};
	
	Promise.onPossiblyUnhandledRejection = function (fn) {
	    var domain = getDomain();
	    possiblyUnhandledRejection =
	        typeof fn === "function" ? (domain === null ?
	                                            fn : util.domainBind(domain, fn))
	                                 : undefined;
	};
	
	Promise.onUnhandledRejectionHandled = function (fn) {
	    var domain = getDomain();
	    unhandledRejectionHandled =
	        typeof fn === "function" ? (domain === null ?
	                                            fn : util.domainBind(domain, fn))
	                                 : undefined;
	};
	
	var disableLongStackTraces = function() {};
	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() && !config.longStackTraces) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    if (!config.longStackTraces && longStackTracesIsSupported()) {
	        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
	        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
	        config.longStackTraces = true;
	        disableLongStackTraces = function() {
	            if (async.haveItemsQueued() && !config.longStackTraces) {
	                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	            }
	            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
	            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
	            Context.deactivateLongStackTraces();
	            async.enableTrampoline();
	            config.longStackTraces = false;
	        };
	        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
	        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
	        Context.activateLongStackTraces();
	        async.disableTrampolineIfNecessary();
	    }
	};
	
	Promise.hasLongStackTraces = function () {
	    return config.longStackTraces && longStackTracesIsSupported();
	};
	
	var fireDomEvent = (function() {
	    try {
	        if (typeof CustomEvent === "function") {
	            var event = new CustomEvent("CustomEvent");
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = new CustomEvent(name.toLowerCase(), {
	                    detail: event,
	                    cancelable: true
	                });
	                return !util.global.dispatchEvent(domEvent);
	            };
	        } else if (typeof Event === "function") {
	            var event = new Event("CustomEvent");
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = new Event(name.toLowerCase(), {
	                    cancelable: true
	                });
	                domEvent.detail = event;
	                return !util.global.dispatchEvent(domEvent);
	            };
	        } else {
	            var event = document.createEvent("CustomEvent");
	            event.initCustomEvent("testingtheevent", false, true, {});
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = document.createEvent("CustomEvent");
	                domEvent.initCustomEvent(name.toLowerCase(), false, true,
	                    event);
	                return !util.global.dispatchEvent(domEvent);
	            };
	        }
	    } catch (e) {}
	    return function() {
	        return false;
	    };
	})();
	
	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function() {
	            return process.emit.apply(process, arguments);
	        };
	    } else {
	        if (!util.global) {
	            return function() {
	                return false;
	            };
	        }
	        return function(name) {
	            var methodName = "on" + name.toLowerCase();
	            var method = util.global[methodName];
	            if (!method) return false;
	            method.apply(util.global, [].slice.call(arguments, 1));
	            return true;
	        };
	    }
	})();
	
	function generatePromiseLifecycleEventObject(name, promise) {
	    return {promise: promise};
	}
	
	var eventToObjectGenerator = {
	    promiseCreated: generatePromiseLifecycleEventObject,
	    promiseFulfilled: generatePromiseLifecycleEventObject,
	    promiseRejected: generatePromiseLifecycleEventObject,
	    promiseResolved: generatePromiseLifecycleEventObject,
	    promiseCancelled: generatePromiseLifecycleEventObject,
	    promiseChained: function(name, promise, child) {
	        return {promise: promise, child: child};
	    },
	    warning: function(name, warning) {
	        return {warning: warning};
	    },
	    unhandledRejection: function (name, reason, promise) {
	        return {reason: reason, promise: promise};
	    },
	    rejectionHandled: generatePromiseLifecycleEventObject
	};
	
	var activeFireEvent = function (name) {
	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent.apply(null, arguments);
	    } catch (e) {
	        async.throwLater(e);
	        globalEventFired = true;
	    }
	
	    var domEventFired = false;
	    try {
	        domEventFired = fireDomEvent(name,
	                    eventToObjectGenerator[name].apply(null, arguments));
	    } catch (e) {
	        async.throwLater(e);
	        domEventFired = true;
	    }
	
	    return domEventFired || globalEventFired;
	};
	
	Promise.config = function(opts) {
	    opts = Object(opts);
	    if ("longStackTraces" in opts) {
	        if (opts.longStackTraces) {
	            Promise.longStackTraces();
	        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
	            disableLongStackTraces();
	        }
	    }
	    if ("warnings" in opts) {
	        var warningsOption = opts.warnings;
	        config.warnings = !!warningsOption;
	        wForgottenReturn = config.warnings;
	
	        if (util.isObject(warningsOption)) {
	            if ("wForgottenReturn" in warningsOption) {
	                wForgottenReturn = !!warningsOption.wForgottenReturn;
	            }
	        }
	    }
	    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
	        if (async.haveItemsQueued()) {
	            throw new Error(
	                "cannot enable cancellation after promises are in use");
	        }
	        Promise.prototype._clearCancellationData =
	            cancellationClearCancellationData;
	        Promise.prototype._propagateFrom = cancellationPropagateFrom;
	        Promise.prototype._onCancel = cancellationOnCancel;
	        Promise.prototype._setOnCancel = cancellationSetOnCancel;
	        Promise.prototype._attachCancellationCallback =
	            cancellationAttachCancellationCallback;
	        Promise.prototype._execute = cancellationExecute;
	        propagateFromFunction = cancellationPropagateFrom;
	        config.cancellation = true;
	    }
	    if ("monitoring" in opts) {
	        if (opts.monitoring && !config.monitoring) {
	            config.monitoring = true;
	            Promise.prototype._fireEvent = activeFireEvent;
	        } else if (!opts.monitoring && config.monitoring) {
	            config.monitoring = false;
	            Promise.prototype._fireEvent = defaultFireEvent;
	        }
	    }
	};
	
	function defaultFireEvent() { return false; }
	
	Promise.prototype._fireEvent = defaultFireEvent;
	Promise.prototype._execute = function(executor, resolve, reject) {
	    try {
	        executor(resolve, reject);
	    } catch (e) {
	        return e;
	    }
	};
	Promise.prototype._onCancel = function () {};
	Promise.prototype._setOnCancel = function (handler) { ; };
	Promise.prototype._attachCancellationCallback = function(onCancel) {
	    ;
	};
	Promise.prototype._captureStackTrace = function () {};
	Promise.prototype._attachExtraTrace = function () {};
	Promise.prototype._clearCancellationData = function() {};
	Promise.prototype._propagateFrom = function (parent, flags) {
	    ;
	    ;
	};
	
	function cancellationExecute(executor, resolve, reject) {
	    var promise = this;
	    try {
	        executor(resolve, reject, function(onCancel) {
	            if (typeof onCancel !== "function") {
	                throw new TypeError("onCancel must be a function, got: " +
	                                    util.toString(onCancel));
	            }
	            promise._attachCancellationCallback(onCancel);
	        });
	    } catch (e) {
	        return e;
	    }
	}
	
	function cancellationAttachCancellationCallback(onCancel) {
	    if (!this._isCancellable()) return this;
	
	    var previousOnCancel = this._onCancel();
	    if (previousOnCancel !== undefined) {
	        if (util.isArray(previousOnCancel)) {
	            previousOnCancel.push(onCancel);
	        } else {
	            this._setOnCancel([previousOnCancel, onCancel]);
	        }
	    } else {
	        this._setOnCancel(onCancel);
	    }
	}
	
	function cancellationOnCancel() {
	    return this._onCancelField;
	}
	
	function cancellationSetOnCancel(onCancel) {
	    this._onCancelField = onCancel;
	}
	
	function cancellationClearCancellationData() {
	    this._cancellationParent = undefined;
	    this._onCancelField = undefined;
	}
	
	function cancellationPropagateFrom(parent, flags) {
	    if ((flags & 1) !== 0) {
	        this._cancellationParent = parent;
	        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
	        if (branchesRemainingToCancel === undefined) {
	            branchesRemainingToCancel = 0;
	        }
	        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
	    }
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}
	
	function bindingPropagateFrom(parent, flags) {
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}
	var propagateFromFunction = bindingPropagateFrom;
	
	function boundValueFunction() {
	    var ret = this._boundTo;
	    if (ret !== undefined) {
	        if (ret instanceof Promise) {
	            if (ret.isFulfilled()) {
	                return ret.value();
	            } else {
	                return undefined;
	            }
	        }
	    }
	    return ret;
	}
	
	function longStackTracesCaptureStackTrace() {
	    this._trace = new CapturedTrace(this._peekContext());
	}
	
	function longStackTracesAttachExtraTrace(error, ignoreSelf) {
	    if (canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	}
	
	function checkForgottenReturns(returnValue, promiseCreated, name, promise,
	                               parent) {
	    if (returnValue === undefined && promiseCreated !== null &&
	        wForgottenReturn) {
	        if (parent !== undefined && parent._returnedNonUndefined()) return;
	        if ((promise._bitField & 65535) === 0) return;
	
	        if (name) name = name + " ";
	        var handlerLine = "";
	        var creatorLine = "";
	        if (promiseCreated._trace) {
	            var traceLines = promiseCreated._trace.stack.split("\n");
	            var stack = cleanStack(traceLines);
	            for (var i = stack.length - 1; i >= 0; --i) {
	                var line = stack[i];
	                if (!nodeFramePattern.test(line)) {
	                    var lineMatches = line.match(parseLinePattern);
	                    if (lineMatches) {
	                        handlerLine  = "at " + lineMatches[1] +
	                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
	                    }
	                    break;
	                }
	            }
	
	            if (stack.length > 0) {
	                var firstUserLine = stack[0];
	                for (var i = 0; i < traceLines.length; ++i) {
	
	                    if (traceLines[i] === firstUserLine) {
	                        if (i > 0) {
	                            creatorLine = "\n" + traceLines[i - 1];
	                        }
	                        break;
	                    }
	                }
	
	            }
	        }
	        var msg = "a promise was created in a " + name +
	            "handler " + handlerLine + "but was not returned from it, " +
	            "see http://goo.gl/rRqMUw" +
	            creatorLine;
	        promise._warn(msg, true, promiseCreated);
	    }
	}
	
	function deprecated(name, replacement) {
	    var message = name +
	        " is deprecated and will be removed in a future version.";
	    if (replacement) message += " Use " + replacement + " instead.";
	    return warn(message);
	}
	
	function warn(message, shouldUseOwnTrace, promise) {
	    if (!config.warnings) return;
	    var warning = new Warning(message);
	    var ctx;
	    if (shouldUseOwnTrace) {
	        promise._attachExtraTrace(warning);
	    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }
	
	    if (!activeFireEvent("warning", warning)) {
	        formatAndLogError(warning, "", true);
	    }
	}
	
	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}
	
	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}
	
	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;
	
	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }
	
	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}
	
	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = "    (No stack trace)" === line ||
	            stackFramePattern.test(line);
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}
	
	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0) {
	        stack = stack.slice(i);
	    }
	    return stack;
	}
	
	function parseStackAndMessage(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: cleanStack(stack)
	    };
	}
	
	function formatAndLogError(error, title, isSoft) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (util.isObject(error)) {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof printWarning === "function") {
	            printWarning(message, isSoft);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	}
	
	function fireRejectionEvent(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }
	
	    if (name === "unhandledRejection") {
	        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
	            formatAndLogError(reason, "Unhandled rejection ");
	        }
	    } else {
	        activeFireEvent(name, promise);
	    }
	}
	
	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj && typeof obj.toString === "function"
	            ? obj.toString() : util.toString(obj);
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {
	
	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}
	
	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}
	
	function longStackTracesIsSupported() {
	    return typeof captureStackTrace === "function";
	}
	
	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}
	
	function setBounds(firstLineError, lastLineError) {
	    if (!longStackTracesIsSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }
	
	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	}
	
	function CapturedTrace(parent) {
	    this._parent = parent;
	    this._promisesCreated = 0;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);
	Context.CapturedTrace = CapturedTrace;
	
	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};
	
	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
	
	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};
	
	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];
	
	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};
	
	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit += 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;
	
	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit += 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit -= 6;
	        };
	    }
	    var err = new Error();
	
	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }
	
	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow &&
	        typeof Error.stackTraceLimit === "number") {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit += 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit -= 6;
	        };
	    }
	
	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    return null;
	
	})([]);
	
	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    printWarning = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        printWarning = function(message, isSoft) {
	            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
	            console.warn(color + message + "\u001b[0m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        printWarning = function(message, isSoft) {
	            console.warn("%c" + message,
	                        isSoft ? "color: darkorange" : "color: red");
	        };
	    }
	}
	
	var config = {
	    warnings: warnings,
	    longStackTraces: false,
	    cancellation: false,
	    monitoring: false
	};
	
	if (longStackTraces) Promise.longStackTraces();
	
	return {
	    longStackTraces: function() {
	        return config.longStackTraces;
	    },
	    warnings: function() {
	        return config.warnings;
	    },
	    cancellation: function() {
	        return config.cancellation;
	    },
	    monitoring: function() {
	        return config.monitoring;
	    },
	    propagateFromFunction: function() {
	        return propagateFromFunction;
	    },
	    boundValueFunction: function() {
	        return boundValueFunction;
	    },
	    checkForgottenReturns: checkForgottenReturns,
	    setBounds: setBounds,
	    warn: warn,
	    deprecated: deprecated,
	    CapturedTrace: CapturedTrace,
	    fireDomEvent: fireDomEvent,
	    fireGlobalEvent: fireGlobalEvent
	};
	};
	
	},{"./errors":12,"./util":36}],10:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function returner() {
	    return this.value;
	}
	function thrower() {
	    throw this.reason;
	}
	
	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (value instanceof Promise) value.suppressUnhandledRejections();
	    return this._then(
	        returner, undefined, undefined, {value: value}, undefined);
	};
	
	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    return this._then(
	        thrower, undefined, undefined, {reason: reason}, undefined);
	};
	
	Promise.prototype.catchThrow = function (reason) {
	    if (arguments.length <= 1) {
	        return this._then(
	            undefined, thrower, undefined, {reason: reason}, undefined);
	    } else {
	        var _reason = arguments[1];
	        var handler = function() {throw _reason;};
	        return this.caught(reason, handler);
	    }
	};
	
	Promise.prototype.catchReturn = function (value) {
	    if (arguments.length <= 1) {
	        if (value instanceof Promise) value.suppressUnhandledRejections();
	        return this._then(
	            undefined, returner, undefined, {value: value}, undefined);
	    } else {
	        var _value = arguments[1];
	        if (_value instanceof Promise) _value.suppressUnhandledRejections();
	        var handler = function() {return _value;};
	        return this.caught(value, handler);
	    }
	};
	};
	
	},{}],11:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;
	var PromiseAll = Promise.all;
	
	function promiseAllThis() {
	    return PromiseAll(this);
	}
	
	function PromiseMapSeries(promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
	}
	
	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, 0)
	              ._then(promiseAllThis, undefined, undefined, this, undefined);
	};
	
	Promise.prototype.mapSeries = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
	};
	
	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, 0)
	              ._then(promiseAllThis, undefined, undefined, promises, undefined);
	};
	
	Promise.mapSeries = PromiseMapSeries;
	};
	
	
	},{}],12:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5");
	var Objectfreeze = es5.freeze;
	var util = _dereq_("./util");
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;
	
	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}
	
	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}
	
	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
	
	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}
	
	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};
	
	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;
	
	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }
	
	}
	inherits(OperationalError, Error);
	
	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
	        value: errorTypes,
	        writable: false,
	        enumerable: false,
	        configurable: false
	    });
	}
	
	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};
	
	},{"./es5":13,"./util":36}],13:[function(_dereq_,module,exports){
	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();
	
	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;
	
	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };
	
	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };
	
	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };
	
	    var ObjectFreeze = function (obj) {
	        return obj;
	    };
	
	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };
	
	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };
	
	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}
	
	},{}],14:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;
	
	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};
	
	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};
	
	},{}],15:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, tryConvertToPromise) {
	var util = _dereq_("./util");
	var CancellationError = Promise.CancellationError;
	var errorObj = util.errorObj;
	
	function PassThroughHandlerContext(promise, type, handler) {
	    this.promise = promise;
	    this.type = type;
	    this.handler = handler;
	    this.called = false;
	    this.cancelPromise = null;
	}
	
	PassThroughHandlerContext.prototype.isFinallyHandler = function() {
	    return this.type === 0;
	};
	
	function FinallyHandlerCancelReaction(finallyHandler) {
	    this.finallyHandler = finallyHandler;
	}
	
	FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
	    checkCancel(this.finallyHandler);
	};
	
	function checkCancel(ctx, reason) {
	    if (ctx.cancelPromise != null) {
	        if (arguments.length > 1) {
	            ctx.cancelPromise._reject(reason);
	        } else {
	            ctx.cancelPromise._cancel();
	        }
	        ctx.cancelPromise = null;
	        return true;
	    }
	    return false;
	}
	
	function succeed() {
	    return finallyHandler.call(this, this.promise._target()._settledValue());
	}
	function fail(reason) {
	    if (checkCancel(this, reason)) return;
	    errorObj.e = reason;
	    return errorObj;
	}
	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;
	
	    if (!this.called) {
	        this.called = true;
	        var ret = this.isFinallyHandler()
	            ? handler.call(promise._boundValue())
	            : handler.call(promise._boundValue(), reasonOrValue);
	        if (ret !== undefined) {
	            promise._setReturnedNonUndefined();
	            var maybePromise = tryConvertToPromise(ret, promise);
	            if (maybePromise instanceof Promise) {
	                if (this.cancelPromise != null) {
	                    if (maybePromise._isCancelled()) {
	                        var reason =
	                            new CancellationError("late cancellation observer");
	                        promise._attachExtraTrace(reason);
	                        errorObj.e = reason;
	                        return errorObj;
	                    } else if (maybePromise.isPending()) {
	                        maybePromise._attachCancellationCallback(
	                            new FinallyHandlerCancelReaction(this));
	                    }
	                }
	                return maybePromise._then(
	                    succeed, fail, undefined, this, undefined);
	            }
	        }
	    }
	
	    if (promise.isRejected()) {
	        checkCancel(this);
	        errorObj.e = reasonOrValue;
	        return errorObj;
	    } else {
	        checkCancel(this);
	        return reasonOrValue;
	    }
	}
	
	Promise.prototype._passThrough = function(handler, type, success, fail) {
	    if (typeof handler !== "function") return this.then();
	    return this._then(success,
	                      fail,
	                      undefined,
	                      new PassThroughHandlerContext(this, type, handler),
	                      undefined);
	};
	
	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThrough(handler,
	                             0,
	                             finallyHandler,
	                             finallyHandler);
	};
	
	Promise.prototype.tap = function (handler) {
	    return this._passThrough(handler, 1, finallyHandler);
	};
	
	return PassThroughHandlerContext;
	};
	
	},{"./util":36}],16:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise,
	                          Proxyable,
	                          debug) {
	var errors = _dereq_("./errors");
	var TypeError = errors.TypeError;
	var util = _dereq_("./util");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];
	
	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}
	
	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    if (debug.cancellation()) {
	        var internal = new Promise(INTERNAL);
	        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
	        this._promise = internal.lastly(function() {
	            return _finallyPromise;
	        });
	        internal._captureStackTrace();
	        internal._setOnCancel(this);
	    } else {
	        var promise = this._promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	    }
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	    this._yieldedPromise = null;
	    this._cancellationPhase = false;
	}
	util.inherits(PromiseSpawn, Proxyable);
	
	PromiseSpawn.prototype._isResolved = function() {
	    return this._promise === null;
	};
	
	PromiseSpawn.prototype._cleanup = function() {
	    this._promise = this._generator = null;
	    if (debug.cancellation() && this._finallyPromise !== null) {
	        this._finallyPromise._fulfill();
	        this._finallyPromise = null;
	    }
	};
	
	PromiseSpawn.prototype._promiseCancelled = function() {
	    if (this._isResolved()) return;
	    var implementsReturn = typeof this._generator["return"] !== "undefined";
	
	    var result;
	    if (!implementsReturn) {
	        var reason = new Promise.CancellationError(
	            "generator .return() sentinel");
	        Promise.coroutine.returnSentinel = reason;
	        this._promise._attachExtraTrace(reason);
	        this._promise._pushContext();
	        result = tryCatch(this._generator["throw"]).call(this._generator,
	                                                         reason);
	        this._promise._popContext();
	    } else {
	        this._promise._pushContext();
	        result = tryCatch(this._generator["return"]).call(this._generator,
	                                                          undefined);
	        this._promise._popContext();
	    }
	    this._cancellationPhase = true;
	    this._yieldedPromise = null;
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._promiseFulfilled = function(value) {
	    this._yieldedPromise = null;
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._promiseRejected = function(reason) {
	    this._yieldedPromise = null;
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._resultCancelled = function() {
	    if (this._yieldedPromise instanceof Promise) {
	        var promise = this._yieldedPromise;
	        this._yieldedPromise = null;
	        promise.cancel();
	    }
	};
	
	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._promiseFulfilled(undefined);
	};
	
	PromiseSpawn.prototype._continue = function (result) {
	    var promise = this._promise;
	    if (result === errorObj) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._rejectCallback(result.e, false);
	        }
	    }
	
	    var value = result.value;
	    if (result.done === true) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._resolveCallback(value);
	        }
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._promiseRejected(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise = maybePromise._target();
	        var bitField = maybePromise._bitField;
	        ;
	        if (((bitField & 50397184) === 0)) {
	            this._yieldedPromise = maybePromise;
	            maybePromise._proxy(this, null);
	        } else if (((bitField & 33554432) !== 0)) {
	            Promise._async.invoke(
	                this._promiseFulfilled, this, maybePromise._value()
	            );
	        } else if (((bitField & 16777216) !== 0)) {
	            Promise._async.invoke(
	                this._promiseRejected, this, maybePromise._reason()
	            );
	        } else {
	            this._promiseCancelled();
	        }
	    }
	};
	
	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        var ret = spawn.promise();
	        spawn._generator = generator;
	        spawn._promiseFulfilled(undefined);
	        return ret;
	    };
	};
	
	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    yieldHandlers.push(fn);
	};
	
	Promise.spawn = function (generatorFunction) {
	    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};
	
	},{"./errors":12,"./util":36}],17:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
	         getDomain) {
	var util = _dereq_("./util");
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;
	
	if (false) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };
	
	    var promiseSetter = function(i) {
	        return new Function("promise", "holder", "                           \n\
	            'use strict';                                                    \n\
	            holder.pIndex = promise;                                         \n\
	            ".replace(/Index/g, i));
	    };
	
	    var generateHolderClass = function(total) {
	        var props = new Array(total);
	        for (var i = 0; i < props.length; ++i) {
	            props[i] = "this.p" + (i+1);
	        }
	        var assignment = props.join(" = ") + " = null;";
	        var cancellationCode= "var promise;\n" + props.map(function(prop) {
	            return "                                                         \n\
	                promise = " + prop + ";                                      \n\
	                if (promise instanceof Promise) {                            \n\
	                    promise.cancel();                                        \n\
	                }                                                            \n\
	            ";
	        }).join("\n");
	        var passedArguments = props.join(", ");
	        var name = "Holder$" + total;
	
	
	        var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
	            'use strict';                                                    \n\
	            function [TheName](fn) {                                         \n\
	                [TheProperties]                                              \n\
	                this.fn = fn;                                                \n\
	                this.asyncNeeded = true;                                     \n\
	                this.now = 0;                                                \n\
	            }                                                                \n\
	                                                                             \n\
	            [TheName].prototype._callFunction = function(promise) {          \n\
	                promise._pushContext();                                      \n\
	                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
	                promise._popContext();                                       \n\
	                if (ret === errorObj) {                                      \n\
	                    promise._rejectCallback(ret.e, false);                   \n\
	                } else {                                                     \n\
	                    promise._resolveCallback(ret);                           \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype.checkFulfillment = function(promise) {       \n\
	                var now = ++this.now;                                        \n\
	                if (now === [TheTotal]) {                                    \n\
	                    if (this.asyncNeeded) {                                  \n\
	                        async.invoke(this._callFunction, this, promise);     \n\
	                    } else {                                                 \n\
	                        this._callFunction(promise);                         \n\
	                    }                                                        \n\
	                                                                             \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype._resultCancelled = function() {              \n\
	                [CancellationCode]                                           \n\
	            };                                                               \n\
	                                                                             \n\
	            return [TheName];                                                \n\
	        }(tryCatch, errorObj, Promise, async);                               \n\
	        ";
	
	        code = code.replace(/\[TheName\]/g, name)
	            .replace(/\[TheTotal\]/g, total)
	            .replace(/\[ThePassedArguments\]/g, passedArguments)
	            .replace(/\[TheProperties\]/g, assignment)
	            .replace(/\[CancellationCode\]/g, cancellationCode);
	
	        return new Function("tryCatch", "errorObj", "Promise", "async", code)
	                           (tryCatch, errorObj, Promise, async);
	    };
	
	    var holderClasses = [];
	    var thenCallbacks = [];
	    var promiseSetters = [];
	
	    for (var i = 0; i < 8; ++i) {
	        holderClasses.push(generateHolderClass(i + 1));
	        thenCallbacks.push(thenCallback(i + 1));
	        promiseSetters.push(promiseSetter(i + 1));
	    }
	
	    reject = function (reason) {
	        this._reject(reason);
	    };
	}}
	
	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (false) {
	            if (last <= 8 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var HolderClass = holderClasses[last - 1];
	                var holder = new HolderClass(fn);
	                var callbacks = thenCallbacks;
	
	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        var bitField = maybePromise._bitField;
	                        ;
	                        if (((bitField & 50397184) === 0)) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                            promiseSetters[i](maybePromise, holder);
	                            holder.asyncNeeded = false;
	                        } else if (((bitField & 33554432) !== 0)) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else if (((bitField & 16777216) !== 0)) {
	                            ret._reject(maybePromise._reason());
	                        } else {
	                            ret._cancel();
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }
	
	                if (!ret._isFateSealed()) {
	                    if (holder.asyncNeeded) {
	                        var domain = getDomain();
	                        if (domain !== null) {
	                            holder.fn = util.domainBind(domain, holder.fn);
	                        }
	                    }
	                    ret._setAsyncGuaranteed();
	                    ret._setOnCancel(holder);
	                }
	                return ret;
	            }
	        }
	    }
	    var args = [].slice.call(arguments);;
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};
	
	};
	
	},{"./util":36}],18:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;
	
	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    var domain = getDomain();
	    this._callback = domain === null ? fn : util.domainBind(domain, fn);
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = [];
	    async.invoke(this._asyncInit, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);
	
	MappingPromiseArray.prototype._asyncInit = function() {
	    this._init$(undefined, -2);
	};
	
	MappingPromiseArray.prototype._init = function () {};
	
	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	
	    if (index < 0) {
	        index = (index * -1) - 1;
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return true;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return false;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;
	
	        var promise = this._promise;
	        var callback = this._callback;
	        var receiver = promise._boundValue();
	        promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        var promiseCreated = promise._popContext();
	        debug.checkForgottenReturns(
	            ret,
	            promiseCreated,
	            preservedValues !== null ? "Promise.filter" : "Promise.map",
	            promise
	        );
	        if (ret === errorObj) {
	            this._reject(ret.e);
	            return true;
	        }
	
	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            var bitField = maybePromise._bitField;
	            ;
	            if (((bitField & 50397184) === 0)) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = maybePromise;
	                maybePromise._proxy(this, (index + 1) * -1);
	                return false;
	            } else if (((bitField & 33554432) !== 0)) {
	                ret = maybePromise._value();
	            } else if (((bitField & 16777216) !== 0)) {
	                this._reject(maybePromise._reason());
	                return true;
	            } else {
	                this._cancel();
	                return true;
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }
	        return true;
	    }
	    return false;
	};
	
	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};
	
	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};
	
	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};
	
	function map(promises, fn, options, _filter) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	
	    var limit = 0;
	    if (options !== undefined) {
	        if (typeof options === "object" && options !== null) {
	            if (typeof options.concurrency !== "number") {
	                return Promise.reject(
	                    new TypeError("'concurrency' must be a number but it is " +
	                                    util.classString(options.concurrency)));
	            }
	            limit = options.concurrency;
	        } else {
	            return Promise.reject(new TypeError(
	                            "options argument must be an object but it is " +
	                             util.classString(options)));
	        }
	    }
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
	}
	
	Promise.prototype.map = function (fn, options) {
	    return map(this, fn, options, null);
	};
	
	Promise.map = function (promises, fn, options, _filter) {
	    return map(promises, fn, options, _filter);
	};
	
	
	};
	
	},{"./util":36}],19:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;
	
	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        var promiseCreated = ret._popContext();
	        debug.checkForgottenReturns(
	            value, promiseCreated, "Promise.method", ret);
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};
	
	Promise.attempt = Promise["try"] = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value;
	    if (arguments.length > 1) {
	        debug.deprecated("calling Promise.try with more than 1 argument");
	        var arg = arguments[1];
	        var ctx = arguments[2];
	        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
	                                  : tryCatch(fn).call(ctx, arg);
	    } else {
	        value = tryCatch(fn)();
	    }
	    var promiseCreated = ret._popContext();
	    debug.checkForgottenReturns(
	        value, promiseCreated, "Promise.try", ret);
	    ret._resolveFromSyncValue(value);
	    return ret;
	};
	
	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};
	
	},{"./util":36}],20:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util");
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = _dereq_("./errors");
	var OperationalError = errors.OperationalError;
	var es5 = _dereq_("./es5");
	
	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}
	
	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}
	
	function nodebackForPromise(promise, multiArgs) {
	    return function(err, value) {
	        if (promise === null) return;
	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (!multiArgs) {
	            promise._fulfill(value);
	        } else {
	            var args = [].slice.call(arguments, 1);;
	            promise._fulfill(args);
	        }
	        promise = null;
	    };
	}
	
	module.exports = nodebackForPromise;
	
	},{"./errors":12,"./es5":13,"./util":36}],21:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var util = _dereq_("./util");
	var async = Promise._async;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret =
	        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundValue();
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var newReason = new Error(reason + "");
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
	                                                                     options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};
	
	},{"./util":36}],22:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var reflectHandler = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	function Proxyable() {}
	var UNDEFINED_BINDING = {};
	var util = _dereq_("./util");
	
	var getDomain;
	if (util.isNode) {
	    getDomain = function() {
	        var ret = process.domain;
	        if (ret === undefined) ret = null;
	        return ret;
	    };
	} else {
	    getDomain = function() {
	        return null;
	    };
	}
	util.notEnumerableProp(Promise, "_getDomain", getDomain);
	
	var es5 = _dereq_("./es5");
	var Async = _dereq_("./async");
	var async = new Async();
	es5.defineProperty(Promise, "_async", {value: async});
	var errors = _dereq_("./errors");
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	var CancellationError = Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {};
	var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
	var PromiseArray =
	    _dereq_("./promise_array")(Promise, INTERNAL,
	                               tryConvertToPromise, apiRejection, Proxyable);
	var Context = _dereq_("./context")(Promise);
	 /*jshint unused:false*/
	var createContext = Context.create;
	var debug = _dereq_("./debuggability")(Promise, Context);
	var CapturedTrace = debug.CapturedTrace;
	var PassThroughHandlerContext =
	    _dereq_("./finally")(Promise, tryConvertToPromise);
	var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
	var nodebackForPromise = _dereq_("./nodeback");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function check(self, executor) {
	    if (typeof executor !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(executor));
	    }
	    if (self.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	}
	
	function Promise(executor) {
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    if (executor !== INTERNAL) {
	        check(this, executor);
	        this._resolveFromExecutor(executor);
	    }
	    this._promiseCreated();
	    this._fireEvent("promiseCreated", this);
	}
	
	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};
	
	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (util.isObject(item)) {
	                catchInstances[j++] = item;
	            } else {
	                return apiRejection("expecting an object but got " +
	                    "A catch statement predicate " + util.classString(item));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        return this.then(undefined, catchFilter(catchInstances, fn, this));
	    }
	    return this.then(undefined, fn);
	};
	
	Promise.prototype.reflect = function () {
	    return this._then(reflectHandler,
	        reflectHandler, undefined, this, undefined);
	};
	
	Promise.prototype.then = function (didFulfill, didReject) {
	    if (debug.warnings() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, undefined, undefined, undefined);
	};
	
	Promise.prototype.done = function (didFulfill, didReject) {
	    var promise =
	        this._then(didFulfill, didReject, undefined, undefined, undefined);
	    promise._setIsFinal();
	};
	
	Promise.prototype.spread = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
	};
	
	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};
	
	Promise.prototype.all = function () {
	    if (arguments.length > 0) {
	        this._warn(".all() was passed arguments but it does not take any");
	    }
	    return new PromiseArray(this).promise();
	};
	
	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};
	
	Promise.getNewLibraryCopy = module.exports;
	
	Promise.is = function (val) {
	    return val instanceof Promise;
	};
	
	Promise.fromNode = Promise.fromCallback = function(fn) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
	                                         : false;
	    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true);
	    }
	    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
	    return ret;
	};
	
	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};
	
	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._setFulfilled();
	        ret._rejectionHandler0 = obj;
	    }
	    return ret;
	};
	
	Promise.resolve = Promise.fulfilled = Promise.cast;
	
	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};
	
	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return async.setScheduler(fn);
	};
	
	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    _,    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
	    var target = this._target();
	    var bitField = target._bitField;
	
	    if (!haveInternalData) {
	        promise._propagateFrom(this, 3);
	        promise._captureStackTrace();
	        if (receiver === undefined &&
	            ((this._bitField & 2097152) !== 0)) {
	            if (!((bitField & 50397184) === 0)) {
	                receiver = this._boundValue();
	            } else {
	                receiver = target === this ? undefined : this._boundTo;
	            }
	        }
	        this._fireEvent("promiseChained", this, promise);
	    }
	
	    var domain = getDomain();
	    if (!((bitField & 50397184) === 0)) {
	        var handler, value, settler = target._settlePromiseCtx;
	        if (((bitField & 33554432) !== 0)) {
	            value = target._rejectionHandler0;
	            handler = didFulfill;
	        } else if (((bitField & 16777216) !== 0)) {
	            value = target._fulfillmentHandler0;
	            handler = didReject;
	            target._unsetRejectionIsUnhandled();
	        } else {
	            settler = target._settlePromiseLateCancellationObserver;
	            value = new CancellationError("late cancellation observer");
	            target._attachExtraTrace(value);
	            handler = didReject;
	        }
	
	        async.invoke(settler, target, {
	            handler: domain === null ? handler
	                : (typeof handler === "function" &&
	                    util.domainBind(domain, handler)),
	            promise: promise,
	            receiver: receiver,
	            value: value
	        });
	    } else {
	        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
	    }
	
	    return promise;
	};
	
	Promise.prototype._length = function () {
	    return this._bitField & 65535;
	};
	
	Promise.prototype._isFateSealed = function () {
	    return (this._bitField & 117506048) !== 0;
	};
	
	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 67108864) === 67108864;
	};
	
	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -65536) |
	        (len & 65535);
	};
	
	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 33554432;
	    this._fireEvent("promiseFulfilled", this);
	};
	
	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 16777216;
	    this._fireEvent("promiseRejected", this);
	};
	
	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 67108864;
	    this._fireEvent("promiseResolved", this);
	};
	
	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 4194304;
	};
	
	Promise.prototype._isFinal = function () {
	    return (this._bitField & 4194304) > 0;
	};
	
	Promise.prototype._unsetCancelled = function() {
	    this._bitField = this._bitField & (~65536);
	};
	
	Promise.prototype._setCancelled = function() {
	    this._bitField = this._bitField | 65536;
	    this._fireEvent("promiseCancelled", this);
	};
	
	Promise.prototype._setWillBeCancelled = function() {
	    this._bitField = this._bitField | 8388608;
	};
	
	Promise.prototype._setAsyncGuaranteed = function() {
	    if (async.hasCustomScheduler()) return;
	    this._bitField = this._bitField | 134217728;
	};
	
	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0 ? this._receiver0 : this[
	            index * 4 - 4 + 3];
	    if (ret === UNDEFINED_BINDING) {
	        return undefined;
	    } else if (ret === undefined && this._isBound()) {
	        return this._boundValue();
	    }
	    return ret;
	};
	
	Promise.prototype._promiseAt = function (index) {
	    return this[
	            index * 4 - 4 + 2];
	};
	
	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 0];
	};
	
	Promise.prototype._rejectionHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 1];
	};
	
	Promise.prototype._boundValue = function() {};
	
	Promise.prototype._migrateCallback0 = function (follower) {
	    var bitField = follower._bitField;
	    var fulfill = follower._fulfillmentHandler0;
	    var reject = follower._rejectionHandler0;
	    var promise = follower._promise0;
	    var receiver = follower._receiverAt(0);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};
	
	Promise.prototype._migrateCallbackAt = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};
	
	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    promise,
	    receiver,
	    domain
	) {
	    var index = this._length();
	
	    if (index >= 65535 - 4) {
	        index = 0;
	        this._setLength(0);
	    }
	
	    if (index === 0) {
	        this._promise0 = promise;
	        this._receiver0 = receiver;
	        if (typeof fulfill === "function") {
	            this._fulfillmentHandler0 =
	                domain === null ? fulfill : util.domainBind(domain, fulfill);
	        }
	        if (typeof reject === "function") {
	            this._rejectionHandler0 =
	                domain === null ? reject : util.domainBind(domain, reject);
	        }
	    } else {
	        var base = index * 4 - 4;
	        this[base + 2] = promise;
	        this[base + 3] = receiver;
	        if (typeof fulfill === "function") {
	            this[base + 0] =
	                domain === null ? fulfill : util.domainBind(domain, fulfill);
	        }
	        if (typeof reject === "function") {
	            this[base + 1] =
	                domain === null ? reject : util.domainBind(domain, reject);
	        }
	    }
	    this._setLength(index + 1);
	    return index;
	};
	
	Promise.prototype._proxy = function (proxyable, arg) {
	    this._addCallbacks(undefined, undefined, arg, proxyable, null);
	};
	
	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (((this._bitField & 117506048) !== 0)) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);
	
	    if (shouldBind) this._propagateFrom(maybePromise, 2);
	
	    var promise = maybePromise._target();
	
	    if (promise === this) {
	        this._reject(makeSelfResolutionError());
	        return;
	    }
	
	    var bitField = promise._bitField;
	    if (((bitField & 50397184) === 0)) {
	        var len = this._length();
	        if (len > 0) promise._migrateCallback0(this);
	        for (var i = 1; i < len; ++i) {
	            promise._migrateCallbackAt(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (((bitField & 33554432) !== 0)) {
	        this._fulfill(promise._value());
	    } else if (((bitField & 16777216) !== 0)) {
	        this._reject(promise._reason());
	    } else {
	        var reason = new CancellationError("late cancellation observer");
	        promise._attachExtraTrace(reason);
	        this._reject(reason);
	    }
	};
	
	Promise.prototype._rejectCallback =
	function(reason, synchronous, ignoreNonErrorWarnings) {
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
	        var message = "a promise was rejected with a non-error: " +
	            util.classString(reason);
	        this._warn(message, true);
	    }
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason);
	};
	
	Promise.prototype._resolveFromExecutor = function (executor) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = this._execute(executor, function(value) {
	        promise._resolveCallback(value);
	    }, function (reason) {
	        promise._rejectCallback(reason, synchronous);
	    });
	    synchronous = false;
	    this._popContext();
	
	    if (r !== undefined) {
	        promise._rejectCallback(r, true);
	    }
	};
	
	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    var bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY) {
	        if (!value || typeof value.length !== "number") {
	            x = errorObj;
	            x.e = new TypeError("cannot .spread() a non-array: " +
	                                    util.classString(value));
	        } else {
	            x = tryCatch(handler).apply(this._boundValue(), value);
	        }
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    var promiseCreated = promise._popContext();
	    bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;
	
	    if (x === NEXT_FILTER) {
	        promise._reject(value);
	    } else if (x === errorObj) {
	        promise._rejectCallback(x.e, false);
	    } else {
	        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
	        promise._resolveCallback(x);
	    }
	};
	
	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};
	
	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};
	
	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};
	
	Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
	    var isPromise = promise instanceof Promise;
	    var bitField = this._bitField;
	    var asyncGuaranteed = ((bitField & 134217728) !== 0);
	    if (((bitField & 65536) !== 0)) {
	        if (isPromise) promise._invokeInternalOnCancel();
	
	        if (receiver instanceof PassThroughHandlerContext &&
	            receiver.isFinallyHandler()) {
	            receiver.cancelPromise = promise;
	            if (tryCatch(handler).call(receiver, value) === errorObj) {
	                promise._reject(errorObj.e);
	            }
	        } else if (handler === reflectHandler) {
	            promise._fulfill(reflectHandler.call(receiver));
	        } else if (receiver instanceof Proxyable) {
	            receiver._promiseCancelled(promise);
	        } else if (isPromise || promise instanceof PromiseArray) {
	            promise._cancel();
	        } else {
	            receiver.cancel();
	        }
	    } else if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            if (asyncGuaranteed) promise._setAsyncGuaranteed();
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof Proxyable) {
	        if (!receiver._isResolved()) {
	            if (((bitField & 33554432) !== 0)) {
	                receiver._promiseFulfilled(value, promise);
	            } else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (asyncGuaranteed) promise._setAsyncGuaranteed();
	        if (((bitField & 33554432) !== 0)) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value);
	        }
	    }
	};
	
	Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
	    var handler = ctx.handler;
	    var promise = ctx.promise;
	    var receiver = ctx.receiver;
	    var value = ctx.value;
	    if (typeof handler === "function") {
	        if (!(promise instanceof Promise)) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (promise instanceof Promise) {
	        promise._reject(value);
	    }
	};
	
	Promise.prototype._settlePromiseCtx = function(ctx) {
	    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
	};
	
	Promise.prototype._settlePromise0 = function(handler, value, bitField) {
	    var promise = this._promise0;
	    var receiver = this._receiverAt(0);
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settlePromise(promise, handler, receiver, value);
	};
	
	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    var base = index * 4 - 4;
	    this[base + 2] =
	    this[base + 3] =
	    this[base + 0] =
	    this[base + 1] = undefined;
	};
	
	Promise.prototype._fulfill = function (value) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._reject(err);
	    }
	    this._setFulfilled();
	    this._rejectionHandler0 = value;
	
	    if ((bitField & 65535) > 0) {
	        if (((bitField & 134217728) !== 0)) {
	            this._settlePromises();
	        } else {
	            async.settlePromises(this);
	        }
	    }
	};
	
	Promise.prototype._reject = function (reason) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    this._setRejected();
	    this._fulfillmentHandler0 = reason;
	
	    if (this._isFinal()) {
	        return async.fatalError(reason, util.isNode);
	    }
	
	    if ((bitField & 65535) > 0) {
	        async.settlePromises(this);
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};
	
	Promise.prototype._fulfillPromises = function (len, value) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._fulfillmentHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, value);
	    }
	};
	
	Promise.prototype._rejectPromises = function (len, reason) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._rejectionHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, reason);
	    }
	};
	
	Promise.prototype._settlePromises = function () {
	    var bitField = this._bitField;
	    var len = (bitField & 65535);
	
	    if (len > 0) {
	        if (((bitField & 16842752) !== 0)) {
	            var reason = this._fulfillmentHandler0;
	            this._settlePromise0(this._rejectionHandler0, reason, bitField);
	            this._rejectPromises(len, reason);
	        } else {
	            var value = this._rejectionHandler0;
	            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
	            this._fulfillPromises(len, value);
	        }
	        this._setLength(0);
	    }
	    this._clearCancellationData();
	};
	
	Promise.prototype._settledValue = function() {
	    var bitField = this._bitField;
	    if (((bitField & 33554432) !== 0)) {
	        return this._rejectionHandler0;
	    } else if (((bitField & 16777216) !== 0)) {
	        return this._fulfillmentHandler0;
	    }
	};
	
	function deferResolve(v) {this.promise._resolveCallback(v);}
	function deferReject(v) {this.promise._rejectCallback(v, false);}
	
	Promise.defer = Promise.pending = function() {
	    debug.deprecated("Promise.defer", "new Promise");
	    var promise = new Promise(INTERNAL);
	    return {
	        promise: promise,
	        resolve: deferResolve,
	        reject: deferReject
	    };
	};
	
	util.notEnumerableProp(Promise,
	                       "_makeSelfResolutionError",
	                       makeSelfResolutionError);
	
	_dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection,
	    debug);
	_dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
	_dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
	_dereq_("./direct_resolve")(Promise);
	_dereq_("./synchronous_inspection")(Promise);
	_dereq_("./join")(
	    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
	Promise.Promise = Promise;
	Promise.version = "3.4.6";
	_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	_dereq_('./call_get.js')(Promise);
	_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
	_dereq_('./timers.js')(Promise, INTERNAL, debug);
	_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
	_dereq_('./nodeify.js')(Promise);
	_dereq_('./promisify.js')(Promise, INTERNAL);
	_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	_dereq_('./settle.js')(Promise, PromiseArray, debug);
	_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
	_dereq_('./filter.js')(Promise, INTERNAL);
	_dereq_('./each.js')(Promise, INTERNAL);
	_dereq_('./any.js')(Promise);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    debug.setBounds(Async.firstLineError, util.lastLineError);               
	    return Promise;                                                          
	
	};
	
	},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36}],23:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection, Proxyable) {
	var util = _dereq_("./util");
	var isArray = util.isArray;
	
	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}
	
	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    if (values instanceof Promise) {
	        promise._propagateFrom(values, 3);
	    }
	    promise._setOnCancel(this);
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	util.inherits(PromiseArray, Proxyable);
	
	PromiseArray.prototype.length = function () {
	    return this._length;
	};
	
	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        var bitField = values._bitField;
	        ;
	        this._values = values;
	
	        if (((bitField & 50397184) === 0)) {
	            this._promise._setAsyncGuaranteed();
	            return values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	        } else if (((bitField & 33554432) !== 0)) {
	            values = values._value();
	        } else if (((bitField & 16777216) !== 0)) {
	            return this._reject(values._reason());
	        } else {
	            return this._cancel();
	        }
	    }
	    values = util.asArray(values);
	    if (values === null) {
	        var err = apiRejection(
	            "expecting an array or an iterable object but got " + util.classString(values)).reason();
	        this._promise._rejectCallback(err, false);
	        return;
	    }
	
	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    this._iterate(values);
	};
	
	PromiseArray.prototype._iterate = function(values) {
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var result = this._promise;
	    var isResolved = false;
	    var bitField = null;
	    for (var i = 0; i < len; ++i) {
	        var maybePromise = tryConvertToPromise(values[i], result);
	
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            bitField = maybePromise._bitField;
	        } else {
	            bitField = null;
	        }
	
	        if (isResolved) {
	            if (bitField !== null) {
	                maybePromise.suppressUnhandledRejections();
	            }
	        } else if (bitField !== null) {
	            if (((bitField & 50397184) === 0)) {
	                maybePromise._proxy(this, i);
	                this._values[i] = maybePromise;
	            } else if (((bitField & 33554432) !== 0)) {
	                isResolved = this._promiseFulfilled(maybePromise._value(), i);
	            } else if (((bitField & 16777216) !== 0)) {
	                isResolved = this._promiseRejected(maybePromise._reason(), i);
	            } else {
	                isResolved = this._promiseCancelled(i);
	            }
	        } else {
	            isResolved = this._promiseFulfilled(maybePromise, i);
	        }
	    }
	    if (!isResolved) result._setAsyncGuaranteed();
	};
	
	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};
	
	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};
	
	PromiseArray.prototype._cancel = function() {
	    if (this._isResolved() || !this._promise._isCancellable()) return;
	    this._values = null;
	    this._promise._cancel();
	};
	
	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false);
	};
	
	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};
	
	PromiseArray.prototype._promiseCancelled = function() {
	    this._cancel();
	    return true;
	};
	
	PromiseArray.prototype._promiseRejected = function (reason) {
	    this._totalResolved++;
	    this._reject(reason);
	    return true;
	};
	
	PromiseArray.prototype._resultCancelled = function() {
	    if (this._isResolved()) return;
	    var values = this._values;
	    this._cancel();
	    if (values instanceof Promise) {
	        values.cancel();
	    } else {
	        for (var i = 0; i < values.length; ++i) {
	            if (values[i] instanceof Promise) {
	                values[i].cancel();
	            }
	        }
	    }
	};
	
	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};
	
	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};
	
	return PromiseArray;
	};
	
	},{"./util":36}],24:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = _dereq_("./util");
	var nodebackForPromise = _dereq_("./nodeback");
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = _dereq_("./errors").TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyProps = [
	    "arity",    "length",
	    "name",
	    "arguments",
	    "caller",
	    "callee",
	    "prototype",
	    "__isPromisified__"
	];
	var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
	
	var defaultFilter = function(name) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        name !== "constructor";
	};
	
	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}
	
	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}
	
	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}
	
	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}
	
	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};
	
	var makeNodePromisifiedEval;
	if (false) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};
	
	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};
	
	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};
	
	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};
	
	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn, _, multiArgs) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;
	
	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }
	
	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }
	
	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }
	
	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";
	    var body = "'use strict';                                                \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode);
	    body = body.replace("Parameters", parameterDeclaration(newParameterCount));
	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "notEnumerableProp",
	                        "INTERNAL",
	                        body)(
	                    Promise,
	                    fn,
	                    receiver,
	                    withAppended,
	                    maybeWrapAsError,
	                    nodebackForPromise,
	                    util.tryCatch,
	                    util.errorObj,
	                    util.notEnumerableProp,
	                    INTERNAL);
	};
	}
	
	function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise, multiArgs);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
	        return promise;
	    }
	    util.notEnumerableProp(promisified, "__isPromisified__", true);
	    return promisified;
	}
	
	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;
	
	function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);
	
	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        if (promisifier === makeNodePromisified) {
	            obj[promisifiedKey] =
	                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
	        } else {
	            var promisified = promisifier(fn, function() {
	                return makeNodePromisified(key, THIS, key,
	                                           fn, suffix, multiArgs);
	            });
	            util.notEnumerableProp(promisified, "__isPromisified__", true);
	            obj[promisifiedKey] = promisified;
	        }
	    }
	    util.toFastProperties(obj);
	    return obj;
	}
	
	function promisify(callback, receiver, multiArgs) {
	    return makeNodePromisified(callback, receiver, undefined,
	                                callback, null, multiArgs);
	}
	
	Promise.promisify = function (fn, options) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    options = Object(options);
	    var receiver = options.context === undefined ? THIS : options.context;
	    var multiArgs = !!options.multiArgs;
	    var ret = promisify(fn, receiver, multiArgs);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};
	
	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    options = Object(options);
	    var multiArgs = !!options.multiArgs;
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;
	
	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	
	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier,
	                multiArgs);
	            promisifyAll(value, suffix, filter, promisifier, multiArgs);
	        }
	    }
	
	    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
	};
	};
	
	
	},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util");
	var isObject = util.isObject;
	var es5 = _dereq_("./es5");
	var Es6Map;
	if (typeof Map === "function") Es6Map = Map;
	
	var mapToEntries = (function() {
	    var index = 0;
	    var size = 0;
	
	    function extractEntry(value, key) {
	        this[index] = value;
	        this[index + size] = key;
	        index++;
	    }
	
	    return function mapToEntries(map) {
	        size = map.size;
	        index = 0;
	        var ret = new Array(map.size * 2);
	        map.forEach(extractEntry, ret);
	        return ret;
	    };
	})();
	
	var entriesToMap = function(entries) {
	    var ret = new Es6Map();
	    var length = entries.length / 2 | 0;
	    for (var i = 0; i < length; ++i) {
	        var key = entries[length + i];
	        var value = entries[i];
	        ret.set(key, value);
	    }
	    return ret;
	};
	
	function PropertiesPromiseArray(obj) {
	    var isMap = false;
	    var entries;
	    if (Es6Map !== undefined && obj instanceof Es6Map) {
	        entries = mapToEntries(obj);
	        isMap = true;
	    } else {
	        var keys = es5.keys(obj);
	        var len = keys.length;
	        entries = new Array(len * 2);
	        for (var i = 0; i < len; ++i) {
	            var key = keys[i];
	            entries[i] = obj[key];
	            entries[i + len] = key;
	        }
	    }
	    this.constructor$(entries);
	    this._isMap = isMap;
	    this._init$(undefined, -3);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);
	
	PropertiesPromiseArray.prototype._init = function () {};
	
	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val;
	        if (this._isMap) {
	            val = entriesToMap(this._values);
	        } else {
	            val = {};
	            var keyOffset = this.length();
	            for (var i = 0, len = this.length(); i < len; ++i) {
	                val[this._values[i + keyOffset]] = this._values[i];
	            }
	        }
	        this._resolve(val);
	        return true;
	    }
	    return false;
	};
	
	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};
	
	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};
	
	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);
	
	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }
	
	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 2);
	    }
	    return ret;
	}
	
	Promise.prototype.props = function () {
	    return props(this);
	};
	
	Promise.props = function (promises) {
	    return props(promises);
	};
	};
	
	},{"./es5":13,"./util":36}],26:[function(_dereq_,module,exports){
	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}
	
	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}
	
	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};
	
	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};
	
	Queue.prototype._unshiftOne = function(value) {
	    var capacity = this._capacity;
	    this._checkCapacity(this.length() + 1);
	    var front = this._front;
	    var i = (((( front - 1 ) &
	                    ( capacity - 1) ) ^ capacity ) - capacity );
	    this[i] = value;
	    this._front = i;
	    this._length = this.length() + 1;
	};
	
	Queue.prototype.unshift = function(fn, receiver, arg) {
	    this._unshiftOne(arg);
	    this._unshiftOne(receiver);
	    this._unshiftOne(fn);
	};
	
	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};
	
	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];
	
	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};
	
	Queue.prototype.length = function () {
	    return this._length;
	};
	
	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};
	
	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};
	
	module.exports = Queue;
	
	},{}],27:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util");
	
	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};
	
	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);
	
	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else {
	        promises = util.asArray(promises);
	        if (promises === null)
	            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
	    }
	
	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 3);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];
	
	        if (val === undefined && !(i in promises)) {
	            continue;
	        }
	
	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}
	
	Promise.race = function (promises) {
	    return race(promises, undefined);
	};
	
	Promise.prototype.race = function () {
	    return race(this, undefined);
	};
	
	};
	
	},{"./util":36}],28:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;
	
	function ReductionPromiseArray(promises, fn, initialValue, _each) {
	    this.constructor$(promises);
	    var domain = getDomain();
	    this._fn = domain === null ? fn : util.domainBind(domain, fn);
	    if (initialValue !== undefined) {
	        initialValue = Promise.resolve(initialValue);
	        initialValue._attachCancellationCallback(this);
	    }
	    this._initialValue = initialValue;
	    this._currentCancellable = null;
	    if(_each === INTERNAL) {
	        this._eachValues = Array(this._length);
	    } else if (_each === 0) {
	        this._eachValues = null;
	    } else {
	        this._eachValues = undefined;
	    }
	    this._promise._captureStackTrace();
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);
	
	ReductionPromiseArray.prototype._gotAccum = function(accum) {
	    if (this._eachValues !== undefined && 
	        this._eachValues !== null && 
	        accum !== INTERNAL) {
	        this._eachValues.push(accum);
	    }
	};
	
	ReductionPromiseArray.prototype._eachComplete = function(value) {
	    if (this._eachValues !== null) {
	        this._eachValues.push(value);
	    }
	    return this._eachValues;
	};
	
	ReductionPromiseArray.prototype._init = function() {};
	
	ReductionPromiseArray.prototype._resolveEmptyArray = function() {
	    this._resolve(this._eachValues !== undefined ? this._eachValues
	                                                 : this._initialValue);
	};
	
	ReductionPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};
	
	ReductionPromiseArray.prototype._resolve = function(value) {
	    this._promise._resolveCallback(value);
	    this._values = null;
	};
	
	ReductionPromiseArray.prototype._resultCancelled = function(sender) {
	    if (sender === this._initialValue) return this._cancel();
	    if (this._isResolved()) return;
	    this._resultCancelled$();
	    if (this._currentCancellable instanceof Promise) {
	        this._currentCancellable.cancel();
	    }
	    if (this._initialValue instanceof Promise) {
	        this._initialValue.cancel();
	    }
	};
	
	ReductionPromiseArray.prototype._iterate = function (values) {
	    this._values = values;
	    var value;
	    var i;
	    var length = values.length;
	    if (this._initialValue !== undefined) {
	        value = this._initialValue;
	        i = 0;
	    } else {
	        value = Promise.resolve(values[0]);
	        i = 1;
	    }
	
	    this._currentCancellable = value;
	
	    if (!value.isRejected()) {
	        for (; i < length; ++i) {
	            var ctx = {
	                accum: null,
	                value: values[i],
	                index: i,
	                length: length,
	                array: this
	            };
	            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
	        }
	    }
	
	    if (this._eachValues !== undefined) {
	        value = value
	            ._then(this._eachComplete, undefined, undefined, this, undefined);
	    }
	    value._then(completed, completed, undefined, value, this);
	};
	
	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};
	
	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	
	function completed(valueOrReason, array) {
	    if (this.isFulfilled()) {
	        array._resolve(valueOrReason);
	    } else {
	        array._reject(valueOrReason);
	    }
	}
	
	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}
	
	function gotAccum(accum) {
	    this.accum = accum;
	    this.array._gotAccum(accum);
	    var value = tryConvertToPromise(this.value, this.array._promise);
	    if (value instanceof Promise) {
	        this.array._currentCancellable = value;
	        return value._then(gotValue, undefined, undefined, this, undefined);
	    } else {
	        return gotValue.call(this, value);
	    }
	}
	
	function gotValue(value) {
	    var array = this.array;
	    var promise = array._promise;
	    var fn = tryCatch(array._fn);
	    promise._pushContext();
	    var ret;
	    if (array._eachValues !== undefined) {
	        ret = fn.call(promise._boundValue(), value, this.index, this.length);
	    } else {
	        ret = fn.call(promise._boundValue(),
	                              this.accum, value, this.index, this.length);
	    }
	    if (ret instanceof Promise) {
	        array._currentCancellable = ret;
	    }
	    var promiseCreated = promise._popContext();
	    debug.checkForgottenReturns(
	        ret,
	        promiseCreated,
	        array._eachValues !== undefined ? "Promise.each" : "Promise.reduce",
	        promise
	    );
	    return ret;
	}
	};
	
	},{"./util":36}],29:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util");
	var schedule;
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var NativePromise = util.getNativePromise();
	if (util.isNode && typeof MutationObserver === "undefined") {
	    var GlobalSetImmediate = global.setImmediate;
	    var ProcessNextTick = process.nextTick;
	    schedule = util.isRecentNode
	                ? function(fn) { GlobalSetImmediate.call(global, fn); }
	                : function(fn) { ProcessNextTick.call(process, fn); };
	} else if (typeof NativePromise === "function" &&
	           typeof NativePromise.resolve === "function") {
	    var nativePromise = NativePromise.resolve();
	    schedule = function(fn) {
	        nativePromise.then(fn);
	    };
	} else if ((typeof MutationObserver !== "undefined") &&
	          !(typeof window !== "undefined" &&
	            window.navigator &&
	            (window.navigator.standalone || window.cordova))) {
	    schedule = (function() {
	        var div = document.createElement("div");
	        var opts = {attributes: true};
	        var toggleScheduled = false;
	        var div2 = document.createElement("div");
	        var o2 = new MutationObserver(function() {
	            div.classList.toggle("foo");
	            toggleScheduled = false;
	        });
	        o2.observe(div2, opts);
	
	        var scheduleToggle = function() {
	            if (toggleScheduled) return;
	                toggleScheduled = true;
	                div2.classList.toggle("foo");
	            };
	
	            return function schedule(fn) {
	            var o = new MutationObserver(function() {
	                o.disconnect();
	                fn();
	            });
	            o.observe(div, opts);
	            scheduleToggle();
	        };
	    })();
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;
	
	},{"./util":36}],30:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	    function(Promise, PromiseArray, debug) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = _dereq_("./util");
	
	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);
	
	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};
	
	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 33554432;
	    ret._settledValueField = value;
	    return this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 16777216;
	    ret._settledValueField = reason;
	    return this._promiseResolved(index, ret);
	};
	
	Promise.settle = function (promises) {
	    debug.deprecated(".settle()", ".reflect()");
	    return new SettledPromiseArray(promises).promise();
	};
	
	Promise.prototype.settle = function () {
	    return Promise.settle(this);
	};
	};
	
	},{"./util":36}],31:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = _dereq_("./util");
	var RangeError = _dereq_("./errors").RangeError;
	var AggregateError = _dereq_("./errors").AggregateError;
	var isArray = util.isArray;
	var CANCELLATION = {};
	
	
	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);
	
	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};
	
	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};
	
	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};
	
	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};
	
	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};
	
	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	        return true;
	    }
	    return false;
	
	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    return this._checkOutcome();
	};
	
	SomePromiseArray.prototype._promiseCancelled = function () {
	    if (this._values instanceof Promise || this._values == null) {
	        return this._cancel();
	    }
	    this._addRejected(CANCELLATION);
	    return this._checkOutcome();
	};
	
	SomePromiseArray.prototype._checkOutcome = function() {
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            if (this._values[i] !== CANCELLATION) {
	                e.push(this._values[i]);
	            }
	        }
	        if (e.length > 0) {
	            this._reject(e);
	        } else {
	            this._cancel();
	        }
	        return true;
	    }
	    return false;
	};
	
	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};
	
	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};
	
	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};
	
	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};
	
	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};
	
	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};
	
	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};
	
	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}
	
	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};
	
	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};
	
	Promise._SomePromiseArray = SomePromiseArray;
	};
	
	},{"./errors":12,"./util":36}],32:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValueField = promise._isFateSealed()
	            ? promise._settledValue() : undefined;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValueField = undefined;
	    }
	}
	
	PromiseInspection.prototype._settledValue = function() {
	    return this._settledValueField;
	};
	
	var value = PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};
	
	var reason = PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};
	
	var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
	    return (this._bitField & 33554432) !== 0;
	};
	
	var isRejected = PromiseInspection.prototype.isRejected = function () {
	    return (this._bitField & 16777216) !== 0;
	};
	
	var isPending = PromiseInspection.prototype.isPending = function () {
	    return (this._bitField & 50397184) === 0;
	};
	
	var isResolved = PromiseInspection.prototype.isResolved = function () {
	    return (this._bitField & 50331648) !== 0;
	};
	
	PromiseInspection.prototype.isCancelled = function() {
	    return (this._bitField & 8454144) !== 0;
	};
	
	Promise.prototype.__isCancelled = function() {
	    return (this._bitField & 65536) === 65536;
	};
	
	Promise.prototype._isCancelled = function() {
	    return this._target().__isCancelled();
	};
	
	Promise.prototype.isCancelled = function() {
	    return (this._target()._bitField & 8454144) !== 0;
	};
	
	Promise.prototype.isPending = function() {
	    return isPending.call(this._target());
	};
	
	Promise.prototype.isRejected = function() {
	    return isRejected.call(this._target());
	};
	
	Promise.prototype.isFulfilled = function() {
	    return isFulfilled.call(this._target());
	};
	
	Promise.prototype.isResolved = function() {
	    return isResolved.call(this._target());
	};
	
	Promise.prototype.value = function() {
	    return value.call(this._target());
	};
	
	Promise.prototype.reason = function() {
	    var target = this._target();
	    target._unsetRejectionIsUnhandled();
	    return reason.call(target);
	};
	
	Promise.prototype._value = function() {
	    return this._settledValue();
	};
	
	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue();
	};
	
	Promise.PromiseInspection = PromiseInspection;
	};
	
	},{}],33:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util");
	var errorObj = util.errorObj;
	var isObject = util.isObject;
	
	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) return obj;
	        var then = getThen(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            if (isAnyBluebirdPromise(obj)) {
	                var ret = new Promise(INTERNAL);
	                obj._then(
	                    ret._fulfill,
	                    ret._reject,
	                    undefined,
	                    ret,
	                    null
	                );
	                return ret;
	            }
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}
	
	function doGetThen(obj) {
	    return obj.then;
	}
	
	function getThen(obj) {
	    try {
	        return doGetThen(obj);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	
	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    try {
	        return hasProp.call(obj, "_promise0");
	    } catch (e) {
	        return false;
	    }
	}
	
	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x, resolve, reject);
	    synchronous = false;
	
	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }
	
	    function resolve(value) {
	        if (!promise) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }
	
	    function reject(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }
	    return ret;
	}
	
	return tryConvertToPromise;
	};
	
	},{"./util":36}],34:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, debug) {
	var util = _dereq_("./util");
	var TimeoutError = Promise.TimeoutError;
	
	function HandleWrapper(handle)  {
	    this.handle = handle;
	}
	
	HandleWrapper.prototype._resultCancelled = function() {
	    clearTimeout(this.handle);
	};
	
	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (ms, value) {
	    var ret;
	    var handle;
	    if (value !== undefined) {
	        ret = Promise.resolve(value)
	                ._then(afterValue, null, null, ms, undefined);
	        if (debug.cancellation() && value instanceof Promise) {
	            ret._setOnCancel(value);
	        }
	    } else {
	        ret = new Promise(INTERNAL);
	        handle = setTimeout(function() { ret._fulfill(); }, +ms);
	        if (debug.cancellation()) {
	            ret._setOnCancel(new HandleWrapper(handle));
	        }
	        ret._captureStackTrace();
	    }
	    ret._setAsyncGuaranteed();
	    return ret;
	};
	
	Promise.prototype.delay = function (ms) {
	    return delay(ms, this);
	};
	
	var afterTimeout = function (promise, message, parent) {
	    var err;
	    if (typeof message !== "string") {
	        if (message instanceof Error) {
	            err = message;
	        } else {
	            err = new TimeoutError("operation timed out");
	        }
	    } else {
	        err = new TimeoutError(message);
	    }
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._reject(err);
	
	    if (parent != null) {
	        parent.cancel();
	    }
	};
	
	function successClear(value) {
	    clearTimeout(this.handle);
	    return value;
	}
	
	function failureClear(reason) {
	    clearTimeout(this.handle);
	    throw reason;
	}
	
	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret, parent;
	
	    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
	        if (ret.isPending()) {
	            afterTimeout(ret, message, parent);
	        }
	    }, ms));
	
	    if (debug.cancellation()) {
	        parent = this.then();
	        ret = parent._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	        ret._setOnCancel(handleWrapper);
	    } else {
	        ret = this._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	    }
	
	    return ret;
	};
	
	};
	
	},{"./util":36}],35:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext, INTERNAL, debug) {
	    var util = _dereq_("./util");
	    var TypeError = _dereq_("./errors").TypeError;
	    var inherits = _dereq_("./util").inherits;
	    var errorObj = util.errorObj;
	    var tryCatch = util.tryCatch;
	    var NULL = {};
	
	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }
	
	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = new Promise(INTERNAL);
	        function iterator() {
	            if (i >= len) return ret._fulfill();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret;
	    }
	
	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }
	
	    Disposer.prototype.data = function () {
	        return this._data;
	    };
	
	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };
	
	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return NULL;
	    };
	
	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== NULL
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };
	
	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };
	
	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);
	
	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };
	
	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }
	
	    function ResourceList(length) {
	        this.length = length;
	        this.promise = null;
	        this[length-1] = null;
	    }
	
	    ResourceList.prototype._resultCancelled = function() {
	        var len = this.length;
	        for (var i = 0; i < len; ++i) {
	            var item = this[i];
	            if (item instanceof Promise) {
	                item.cancel();
	            }
	        }
	    };
	
	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") {
	            return apiRejection("expecting a function but got " + util.classString(fn));
	        }
	        var input;
	        var spreadArgs = true;
	        if (len === 2 && Array.isArray(arguments[0])) {
	            input = arguments[0];
	            len = input.length;
	            spreadArgs = false;
	        } else {
	            input = arguments;
	            len--;
	        }
	        var resources = new ResourceList(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = input[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }
	
	        var reflectedResources = new Array(resources.length);
	        for (var i = 0; i < reflectedResources.length; ++i) {
	            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
	        }
	
	        var resultPromise = Promise.all(reflectedResources)
	            .then(function(inspections) {
	                for (var i = 0; i < inspections.length; ++i) {
	                    var inspection = inspections[i];
	                    if (inspection.isRejected()) {
	                        errorObj.e = inspection.error();
	                        return errorObj;
	                    } else if (!inspection.isFulfilled()) {
	                        resultPromise.cancel();
	                        return;
	                    }
	                    inspections[i] = inspection.value();
	                }
	                promise._pushContext();
	
	                fn = tryCatch(fn);
	                var ret = spreadArgs
	                    ? fn.apply(undefined, inspections) : fn(inspections);
	                var promiseCreated = promise._popContext();
	                debug.checkForgottenReturns(
	                    ret, promiseCreated, "Promise.using", promise);
	                return ret;
	            });
	
	        var promise = resultPromise.lastly(function() {
	            var inspection = new Promise.PromiseInspection(resultPromise);
	            return dispose(resources, inspection);
	        });
	        resources.promise = promise;
	        promise._setOnCancel(resources);
	        return promise;
	    };
	
	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 131072;
	        this._disposer = disposer;
	    };
	
	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 131072) > 0;
	    };
	
	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };
	
	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~131072);
	        this._disposer = undefined;
	    };
	
	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };
	
	};
	
	},{"./errors":12,"./util":36}],36:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5");
	var canEvaluate = typeof navigator == "undefined";
	
	var errorObj = {e: {}};
	var tryCatchTarget;
	var globalObject = typeof self !== "undefined" ? self :
	    typeof window !== "undefined" ? window :
	    typeof global !== "undefined" ? global :
	    this !== undefined ? this : null;
	
	function tryCatcher() {
	    try {
	        var target = tryCatchTarget;
	        tryCatchTarget = null;
	        return target.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	
	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;
	
	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};
	
	
	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";
	
	}
	
	function isObject(value) {
	    return typeof value === "function" ||
	           typeof value === "object" && value !== null;
	}
	
	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;
	
	    return new Error(safeToString(maybeError));
	}
	
	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}
	
	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);
	
	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}
	
	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}
	
	function thrower(r) {
	    throw r;
	}
	
	var inheritedDataKeys = (function() {
	    var excludedPrototypes = [
	        Array.prototype,
	        Object.prototype,
	        Function.prototype
	    ];
	
	    var isExcludedProto = function(val) {
	        for (var i = 0; i < excludedPrototypes.length; ++i) {
	            if (excludedPrototypes[i] === val) {
	                return true;
	            }
	        }
	        return false;
	    };
	
	    if (es5.isES5) {
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && !isExcludedProto(obj)) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        var hasProp = {}.hasOwnProperty;
	        return function(obj) {
	            if (isExcludedProto(obj)) return [];
	            var ret = [];
	
	            /*jshint forin:false */
	            enumeration: for (var key in obj) {
	                if (hasProp.call(obj, key)) {
	                    ret.push(key);
	                } else {
	                    for (var i = 0; i < excludedPrototypes.length; ++i) {
	                        if (hasProp.call(excludedPrototypes[i], key)) {
	                            continue enumeration;
	                        }
	                    }
	                    ret.push(key);
	                }
	            }
	            return ret;
	        };
	    }
	
	})();
	
	var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);
	
	            var hasMethods = es5.isES5 && keys.length > 1;
	            var hasMethodsOtherThanConstructor = keys.length > 0 &&
	                !(keys.length === 1 && keys[0] === "constructor");
	            var hasThisAssignmentAndStaticMethods =
	                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
	
	            if (hasMethods || hasMethodsOtherThanConstructor ||
	                hasThisAssignmentAndStaticMethods) {
	                return true;
	            }
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}
	
	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function FakeConstructor() {}
	    FakeConstructor.prototype = obj;
	    var l = 8;
	    while (l--) new FakeConstructor();
	    return obj;
	    eval(obj);
	}
	
	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}
	
	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}
	
	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}
	
	function isError(obj) {
	    return obj !== null &&
	           typeof obj === "object" &&
	           typeof obj.message === "string" &&
	           typeof obj.name === "string";
	}
	
	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}
	
	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}
	
	function canAttachTrace(obj) {
	    return isError(obj) && es5.propertyIsWritable(obj, "stack");
	}
	
	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();
	
	function classString(obj) {
	    return {}.toString.call(obj);
	}
	
	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            try {
	                es5.defineProperty(to, key, es5.getDescriptor(from, key));
	            } catch (ignore) {}
	        }
	    }
	}
	
	var asArray = function(v) {
	    if (es5.isArray(v)) {
	        return v;
	    }
	    return null;
	};
	
	if (typeof Symbol !== "undefined" && Symbol.iterator) {
	    var ArrayFrom = typeof Array.from === "function" ? function(v) {
	        return Array.from(v);
	    } : function(v) {
	        var ret = [];
	        var it = v[Symbol.iterator]();
	        var itResult;
	        while (!((itResult = it.next()).done)) {
	            ret.push(itResult.value);
	        }
	        return ret;
	    };
	
	    asArray = function(v) {
	        if (es5.isArray(v)) {
	            return v;
	        } else if (v != null && typeof v[Symbol.iterator] === "function") {
	            return ArrayFrom(v);
	        }
	        return null;
	    };
	}
	
	var isNode = typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]";
	
	function env(key, def) {
	    return isNode ? process.env[key] : def;
	}
	
	function getNativePromise() {
	    if (typeof Promise === "function") {
	        try {
	            var promise = new Promise(function(){});
	            if ({}.toString.call(promise) === "[object Promise]") {
	                return Promise;
	            }
	        } catch (e) {}
	    }
	}
	
	function domainBind(self, cb) {
	    return self.bind(cb);
	}
	
	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    asArray: asArray,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    isError: isError,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: isNode,
	    env: env,
	    global: globalObject,
	    getNativePromise: getNativePromise,
	    domainBind: domainBind
	};
	ret.isRecentNode = ret.isNode && (function() {
	    var version = process.versions.node.split(".").map(Number);
	    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
	})();
	
	if (ret.isNode) ret.toFastProperties(process);
	
	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;
	
	},{"./es5":13}]},{},[4])(4)
	});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36), (function() { return this; }()), __webpack_require__(37).setImmediate))

/***/ },
/* 36 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(36).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37).setImmediate, __webpack_require__(37).clearImmediate))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (cancelButtonText, saveButtonText, value) {
	buf.push("<form style=\"padding: 5px; background: #e0e0e0\" role=\"dialog\" class=\"form-inline\"><input type=\"text\"" + (jade.attr("value", value, true, true)) + " class=\"form-control editor\">&nbsp<button type=\"button\" class=\"btn btn-primary save\">" + (jade.escape(null == (jade_interp = saveButtonText) ? "" : jade_interp)) + "</button>&nbsp<button type=\"button\" class=\"btn btn-default cancel\">" + (jade.escape(null == (jade_interp = cancelButtonText) ? "" : jade_interp)) + "</button></form>");}.call(this,"cancelButtonText" in locals_for_with?locals_for_with.cancelButtonText:typeof cancelButtonText!=="undefined"?cancelButtonText:undefined,"saveButtonText" in locals_for_with?locals_for_with.saveButtonText:typeof saveButtonText!=="undefined"?saveButtonText:undefined,"value" in locals_for_with?locals_for_with.value:typeof value!=="undefined"?value:undefined));;return buf.join("");
	}

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(40);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(42)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/less-loader/index.js!./editable.less", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/less-loader/index.js!./editable.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(41)();
	// imports
	
	
	// module
	exports.push([module.id, "table.grid td.grid-editable-cell {\n  position: relative;\n}\ntable.grid td.grid-editable-cell .grid-edit-icon {\n  display: none;\n  position: absolute;\n  top: 2px;\n  right: 2px;\n  font-size: 10px;\n}\ntable.grid td.grid-editable-cell:hover .grid-edit-icon {\n  display: block;\n}\n", ""]);
	
	// exports


/***/ },
/* 41 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(35), __webpack_require__(5), __webpack_require__(22), __webpack_require__(26)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Promise, _, BaseProjection, schemaProperties) {
	  var Model = BaseProjection.extend({
	    defaults: {
	      'jsdata.query': undefined,
	      'jsdata.entity': undefined,
	      'jsdata.options': undefined,
	      'skip': undefined,
	      'take': undefined,
	      'filter': undefined,
	      'orderby': [],
	      'select': []
	    },
	    name: 'jsdata',
	
	    update: function update() {
	      var entity = this.get('jsdata.entity');
	      var options = _.defaults(this.get('jsdata.options'), { all: true });
	      var op = {};
	
	      this.p$fetchData || this.trigger('update:beginning');
	
	      var take = this.get('take');
	
	      if (take) {
	        op.limit = take;
	      }
	
	      var skip = this.get('skip');
	
	      if (skip) {
	        op.offset = skip;
	      }
	
	      var filter = this.get('filter');
	
	      if (filter) {
	        op.where = filter;
	      }
	
	      var query = this.get('jsdata.query');
	
	      if (query) {
	        op.query = query;
	      }
	
	      var orderby = this.get('orderby');
	
	      if (orderby && orderby.length) {
	        op.orderBy = _.reduce(orderby, function (arr, obj) {
	          _.each(obj, function (value, key) {
	            arr.push([key, value > 0 ? 'ASC' : 'DESC']);
	          });
	          return arr;
	        }, []);
	      }
	
	      var p$fetchData = this.p$fetchData = entity.findAll(op, options).then(function (data) {
	        if (this.p$fetchData === p$fetchData) {
	          var delta = {
	            value: data,
	            count: data.totalCount,
	            select: schemaProperties.from(data),
	            error: undefined
	          };
	          if (_.has(data, 'raw')) {
	            delta.rawValue = data.raw;
	          }
	          this.patch(delta);
	        }
	      }.bind(this)).catch(function (error) {
	        if (this.p$fetchData === p$fetchData) {
	          this.patch({ error: error });
	        }
	      }.bind(this)).finally(function () {
	        if (this.p$fetchData === p$fetchData) {
	          this.trigger('update:finished', this.data.get('error'));
	          this.p$fetchData = null;
	        }
	      }.bind(this));
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22), __webpack_require__(26), __webpack_require__(23)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection, schemaProperties /* , Response */) {
	  var Model = BaseProjection.extend({
	    defaults: {
	      // todo [akamel] consider supporting a select on this level?
	      map: _.identity
	    },
	    name: 'map',
	    update: function update(options) {
	      // Model.__super__.update.call(this, options);
	
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        var map = this.get('map');
	        var value = _.isFunction(map) ? _.map(model.get('value'), map) : model.get('value');
	
	        value = _.flatten(value);
	
	        this.patch({
	          value: value,
	          select: _.without(schemaProperties.from(value), '$metadata')
	        });
	      } else {
	        // todo [akamel] unset our properties only
	        // this.unset();
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22), __webpack_require__(26), __webpack_require__(23)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection, schemaProperties /* , Response */) {
	  var Model = BaseProjection.extend({
	    defaults: {
	      'skip': 0,
	      'take': Number.MAX_VALUE,
	      'filter': function filter() {
	        return true;
	      },
	      'orderby': [],
	      'select': [],
	      'column.sortable': {}
	    },
	    name: 'map-queryable',
	    beforeSet: function beforeSet(local) {
	      if (_.has(local, 'filter')) {
	        if (!_.isFunction(local.filter)) {
	          local.filter = this.defaults.filter;
	        }
	      }
	    },
	    update: function update(options) {
	      // Model.__super__.update.call(this, options);
	
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        var order = _.chain(this.get('orderby')).first().pairs().first().value();
	
	        var orderKey = _.first(order);
	        var orderDir = _.last(order);
	
	        var value = _.chain(model.get('value')).filter(this.get('filter'));
	        var sortFunc = this.get('column.sortable')[orderKey];
	
	        if (orderKey) {
	          if (_.isFunction(sortFunc)) {
	            value = _.chain(sortFunc(value.value(), orderDir));
	          } else {
	            value = value.sortBy(orderKey);
	            if (orderDir === -1) {
	              value = value.reverse();
	            }
	          }
	        }
	
	        value = value.rest(this.get('skip')).first(this.get('take')).value();
	
	        var select = this.get('select');
	        if (!_.size(select)) {
	          select = schemaProperties.from(value);
	        }
	
	        this.patch({
	          value: value,
	          select: select
	        });
	      } else {
	        // todo [akamel] unset our properties only
	        // this.unset();
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (BaseProjection) {
	  var Model = BaseProjection.extend({
	    defaults: {
	      seed: []
	    },
	    update: function update() {
	      this.trigger('update:beginning');
	
	      var value = this.get('seed');
	
	      this.data.set({
	        value: value,
	        count: value.length
	      });
	
	      this.trigger('update:finished');
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection) {
	  var wrds = ['troubles', 'kahlua', 'poncho', 'suzie', 'baheyya'];
	  var idx = 0;
	
	  function randomRow() {
	    var wrd1 = wrds[_.random(0, wrds.length - 1)];
	    var wrd2 = wrds[_.random(0, wrds.length - 1)];
	
	    return {
	      index: idx++,
	      name: wrd1 + ' ' + wrd2,
	      age: _.random(0, 22)
	    };
	  }
	
	  var Model = BaseProjection.extend({
	    defaults: {
	      n: 5000
	    },
	    name: 'mock',
	    update: function update() {
	      this.trigger('update:beginning');
	      var value = [];
	
	      _(this.get('n')).times(function () {
	        value.push(randomRow());
	      });
	
	      this.data.set({
	        value: value,
	        count: value.length
	      });
	      this.trigger('update:finished');
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(35), __webpack_require__(5), __webpack_require__(10), __webpack_require__(9), __webpack_require__(22), __webpack_require__(26)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Promise, _, Backbone, $, BaseProjection, schemaProperties) {
	  var Model = BaseProjection.extend({
	    defaults: {
	      verb: 'get',
	      url: undefined,
	      skip: undefined,
	      take: undefined,
	      filter: undefined,
	      orderby: [],
	      select: []
	    },
	    name: 'odata',
	    update: function update() {
	      this.p$fetchData || this.trigger('update:beginning');
	
	      var url = this.get('url');
	
	      url = _.isFunction(url) ? url() : url;
	      var op = {
	        url: url,
	        $format: 'json',
	        // todo [akamel] this is odata v3 specific
	        $count: true
	      };
	
	      var take = this.get('take');
	      if (take) {
	        op.$top = take;
	      }
	
	      var skip = this.get('skip');
	      if (skip) {
	        op.$skip = skip;
	      }
	
	      // todo [akamel] only supports one order column
	      var orderby = this.get('orderby');
	      if (_.size(orderby)) {
	        var col = _.first(orderby);
	        var key = _.keys(col)[0];
	        var dir = col[key];
	
	        op.$orderby = key + ' ' + (dir > 0 ? 'asc' : 'desc');
	      }
	
	      var p$fetchData = this.p$fetchData = new Promise(function (resolve, reject) {
	        $.getJSON(op.url, _.omit(op, 'url')).success(resolve).fail(function (jqXHR, textStatus, errorThrown) {
	          reject(new Error(errorThrown));
	        });
	      }).then(function (data) {
	        if (p$fetchData === this.p$fetchData) {
	          var delta = {
	            value: data.value,
	            rawValue: data,
	            select: schemaProperties.from(data.value),
	            count: data['@odata.count'],
	            error: undefined
	          };
	          this.patch(delta);
	        }
	      }.bind(this)).catch(function (error) {
	        if (p$fetchData === this.p$fetchData) {
	          this.patch({ error: error });
	        }
	      }.bind(this)).finally(function () {
	        if (p$fetchData === this.p$fetchData) {
	          this.trigger('update:finished', this.data.get('error'));
	          this.p$fetchData = null;
	        }
	      }.bind(this));
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22), __webpack_require__(26), __webpack_require__(23)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection /* , schemaProperties, Response */) {
	  var Model = BaseProjection.extend({
	    defaults: {
	      'page.size': 20,
	      'page.number': 0 },
	    name: 'page',
	    // todo [akamel] what if we piped after the data was set?
	    beforeSet: function beforeSet(local, other) {
	      var size = _.has(local, 'page.size') ? local['page.size'] : this.get('page.size');
	      var number = _.has(local, 'page.number') ? local['page.number'] : this.get('page.number');
	
	      // todo [akamel] sanetize size and number here
	      size = Math.max(size, 0);
	      number = Math.max(number, 0);
	
	      _.extend(other, {
	        take: size,
	        skip: size * number
	      });
	    },
	    update: function update(options) {
	      var model = this.src.data;
	      var size = Math.max(this.get('page.size'), 0);
	      var count = Math.max(1, model.get('count'));
	      var number = Math.max(this.get('page.number'), 0);
	      var pageCount = Math.ceil(count / size);
	      var pageNumber = Math.min(number, pageCount - 1);
	
	      options = options || {};
	
	      if (options.deep) {
	        if (this.src) {
	          this.src.set({
	            take: size,
	            skip: size * pageNumber
	          }, { silent: true });
	        }
	      }
	
	      // Model.__super__.update.call(this, options);
	
	      // if we came in with an update:deep
	      if (Model.__super__.update.call(this, options)) {
	        this.patch({ 'page.count': pageCount });
	      } else {
	        // todo [akamel] unset our properties only
	        // this.unset();
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22), __webpack_require__(26), __webpack_require__(23)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection /* , schemaProperties, Response */) {
	  var Model = BaseProjection.extend({
	    defaults: {
	      'property.template': {}
	    },
	    name: 'property-template',
	    update: function update(options) {
	      // Model.__super__.update.call(this, options);
	
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        var opt = this.get('property.template');
	        var value = _.map(model.get('value'), function (item) {
	          var ret = _.clone(item);
	
	          _.each(opt, function (value, key) {
	            if (_.has(ret, key)) {
	              var res = value({
	                model: item,
	                property: key
	              });
	
	              if (!_.isObject(ret[key])) {
	                var obj = new Object(ret[key]); // eslint-disable-line
	
	                if (_.isUndefined(ret[key])) {
	                  obj.$undefined = true;
	                }
	
	                if (_.isNull(ret[key])) {
	                  obj.$null = true;
	                }
	
	                ret[key] = obj;
	              }
	
	              ret[key].$html = res;
	            }
	          });
	
	          return ret;
	        });
	
	        this.patch({ value: value });
	      } else {
	        // todo [akamel] unset our properties only
	        // this.unset();
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22), __webpack_require__(52)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection, selectableTemplate) {
	  'use strict';
	
	  var Model = BaseProjection.extend({
	    defaults: {
	      'column.checked': 'checkbox', // the checkbox column
	      'row.check.id': 'Id',
	      'row.check.list': [],
	      'row.check.checked.all': false, // used to store user's check value for the special case no rows or all rows is disabled
	      'row.check.single': false,
	      'row.check.allow': function rowCheckAllow() {
	        return true;
	      }
	    },
	    name: 'row-check',
	    events: {
	      'layout:click:cell': 'tdClick',
	      'layout:click:header': 'thClick'
	    },
	    reset: function reset() {
	      this.set({
	        'row.check.checked.all': false,
	        'row.check.list': []
	      });
	    },
	    update: function update(options) {
	      // Model.__super__.update.call(this, options);
	
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        var checkId = this.get('row.check.id');
	        var value = model.get('value');
	        var ids = _.pluck(value, checkId);
	        var checked = _.intersection(this.get('row.check.list'), ids);
	        var checkedLookup = _.object(checked, []);
	        var col = this.get('column.checked');
	        var columns = _.clone(model.get('columns'));
	        var checkedAll = value.length > 0;
	        var hasCheckboxable = false;
	        var checkboxAllow = this.get('row.check.allow');
	        var checkboxColumn = _.find(columns, function (item) {
	          return item.property === col;
	        });
	        var isSingle = this.get('row.check.single');
	
	        this.set('row.check.list', checked, { silent: true });
	
	        // todo [akamel] it is not clear how 'hasCheckboxable' is used
	        value = _.map(value, function (item) {
	          var ret = _.clone(item);
	          var checked = false;
	          var disabled = true;
	          var isAllowed = _.isFunction(checkboxAllow) ? checkboxAllow(ret) : checkboxAllow;
	
	          if (isAllowed) {
	            checked = _.has(checkedLookup, ret[checkId]);
	            checkedAll = checkedAll && checked;
	            disabled = false;
	            hasCheckboxable = true;
	
	            var uniqueId = model.get('a11y.selection.uniqueId');
	            var labelledId = (uniqueId || '').concat(ret[checkId]);
	
	            ret[col] = _.extend({}, ret[col], {
	              $html: selectableTemplate(_.pick({
	                type: isSingle ? 'radio' : 'checkbox',
	                checked: checked,
	                disabled: disabled,
	                labelledId: labelledId
	              }, Boolean))
	            });
	          }
	
	          return ret;
	        });
	
	        // set the checkbox in th
	        if (!_.isUndefined(checkboxColumn)) {
	          if (isSingle) {
	            checkboxColumn.$html = '<span/>';
	          } else {
	            var disabled = _.size(ids) === 0;
	            var labelString = model.get('a11y.selection.selectAllLabel');
	            if (hasCheckboxable) {
	              checkboxColumn.$html = selectableTemplate(_.pick({
	                type: 'checkbox',
	                checked: checkedAll,
	                disabled: disabled,
	                labelString: labelString
	              }, Boolean));
	              if (!checkedAll) {
	                this.attributes['row.check.checked.all'] = false;
	              }
	            } else {
	              checkboxColumn.$html = selectableTemplate(_.pick({
	                type: 'checkbox',
	                checked: this.get('row.check.checked.all'),
	                disabled: disabled,
	                labelString: labelString
	              }, Boolean));
	            }
	          }
	        }
	
	        this.patch({
	          value: value,
	          columns: columns,
	          'row.check.allow': checkboxAllow
	        });
	      } else {
	        // todo [akamel] unset our properties only
	        // this.unset();
	      }
	    },
	    tdClick: function tdClick(e, arg) {
	      var checkboxProperty = this.get('column.checked');
	      var isSingle = this.get('row.check.single');
	
	      if (arg.property === checkboxProperty) {
	        var list = this.get('row.check.list');
	        var id = arg.model[this.get('row.check.id')];
	
	        if (isSingle) {
	          this.set({ 'row.check.list': [id] });
	        } else {
	          this.set({
	            'row.check.list': arg.checked ? list.concat([id]) : _.without(list, id)
	          });
	        }
	
	        this.update();
	      }
	    },
	    thClick: function thClick(e, arg) {
	      var checkboxProperty = this.get('column.checked');
	
	      if (arg.property === checkboxProperty) {
	        var list = [];
	
	        if (arg.checked) {
	          var checkId = this.get('row.check.id');
	          // TODO [akamel] this concept of check allow is strange
	          var checkboxAllow = this.get('row.check.allow');
	
	          // get the list of allowed rows' id
	          list = _.chain(this.data.get('value')).filter(function (item) {
	            return (_.isFunction(checkboxAllow) ? checkboxAllow(item) : checkboxAllow) && !_.isUndefined(item[checkId]);
	          }).map(function (item) {
	            return item[checkId];
	          }).value();
	        }
	
	        this.set({
	          'row.check.list': list,
	          'row.check.checked.all': arg.checked
	        });
	
	        this.update();
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (checked, disabled, labelString, labelledId, type) {
	buf.push("<input" + (jade.attr("type", type, true, true)) + (jade.attr("checked", checked, true, true)) + (jade.attr("disabled", disabled, true, true)) + (jade.attr("aria-labelledby", labelledId, true, true)) + (jade.attr("aria-label", labelString, true, true)) + " class=\"column-selection\">");}.call(this,"checked" in locals_for_with?locals_for_with.checked:typeof checked!=="undefined"?checked:undefined,"disabled" in locals_for_with?locals_for_with.disabled:typeof disabled!=="undefined"?disabled:undefined,"labelString" in locals_for_with?locals_for_with.labelString:typeof labelString!=="undefined"?labelString:undefined,"labelledId" in locals_for_with?locals_for_with.labelledId:typeof labelledId!=="undefined"?labelledId:undefined,"type" in locals_for_with?locals_for_with.type:typeof type!=="undefined"?type:undefined));;return buf.join("");
	}

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection) {
	  var Model = BaseProjection.extend({
	    defaults: {
	      'row.classes': {}
	    },
	    name: 'row',
	    update: function update(options) {
	      var _this = this;
	
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        var rows = model.get('value');
	
	        _.each(rows, function (row) {
	          var type = _.chain(row).result('$metadata').result('type').value();
	
	          if (_.isUndefined(type)) {
	            row.$metadata = _.extend({}, row.$metadata, {
	              type: 'row'
	            });
	          }
	        });
	
	        _.each(rows, function (row) {
	          var classArr = [];
	          var originClass = _.chain(row).result('$metadata').result('attr').result('class').value();
	
	          if (originClass) {
	            classArr.push(originClass);
	          }
	
	          var classesRule = _this.get('row.classes');
	
	          var checkId = _this.get('row.check.id');
	          var checkboxAllow = model.get('row.check.allow');
	
	          _.each(classesRule, function (func, key) {
	            var type = _.chain(row).result('$metadata').result('type').value();
	
	            if (_.isFunction(func) && func(row, type)) {
	              classArr.push(key);
	            }
	          });
	
	          //attr info from meta 
	          var originId = _.chain(row).result('$metadate').result('attr').result('id').value();
	
	          if (_.isFunction(checkboxAllow) ? checkboxAllow(row) : checkboxAllow) {
	            var uniqueId = model.get('a11y.selection.uniqueId');
	            var id = row[checkId] || originId;
	            var a11yId = uniqueId.concat(id);
	            var role = 'row';
	          }
	
	          _.extend(row, {
	            $metadata: {
	              attr: _.pick({
	                class: _.flatten(classArr).join(' '),
	                id: a11yId,
	                role: role
	              }, Boolean)
	            }
	          });
	        });
	
	        this.patch({ value: rows });
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22), __webpack_require__(55)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection, defaultRowCheckTemp) {
	  'use strict';
	
	  var CheckTransitionRule = {};
	
	  // CheckTransitionRule functions determine the state transition of a checkbox.
	  // State transition depends on the current state and wheather a short or full cycle is requested.
	  // When the short  cycle is requested the checkbox cannot return to the indeterminate state,
	  // event if it started in this state.
	  // Two directions of transition are available:
	  // ... -> indeterminate -> checked -> unchecked -> ...
	  // ... -> indeterminate -> unchecked -> checked -> ...
	  CheckTransitionRule.indeterminateToChecked = function () {
	    var nextState = {
	      unchecked: function unchecked(shortCycle) {
	        return shortCycle ? 'checked' : 'indeterminate';
	      },
	      checked: _.constant('unchecked'),
	      indeterminate: _.constant('checked')
	    };
	
	    return function (shortCycle, currentState) {
	      return _.has(nextState, currentState) && nextState[currentState](shortCycle) || 'unchecked';
	    };
	  }();
	
	  CheckTransitionRule.indeterminateToUnchecked = function () {
	    var nextState = {
	      unchecked: _.constant('checked'),
	      checked: function checked(shortCycle) {
	        return shortCycle ? 'unchecked' : 'indeterminate';
	      },
	      indeterminate: _.constant('unchecked')
	    };
	
	    return function (shortCycle, currentState) {
	      return _.has(nextState, currentState) && nextState[currentState](shortCycle) || 'unchecked';
	    };
	  }();
	
	  CheckTransitionRule.indeterminateToCheckedFullCycle = function (currentState) {
	    return CheckTransitionRule.indeterminateToChecked(false, currentState);
	  };
	
	  CheckTransitionRule.indeterminateToUncheckedFullCycle = function (currentState) {
	    return CheckTransitionRule.indeterminateToUnchecked(false, currentState);
	  };
	
	  CheckTransitionRule.indeterminateToCheckedShortCycle = function (currentState) {
	    return CheckTransitionRule.indeterminateToChecked(true, currentState);
	  };
	
	  CheckTransitionRule.indeterminateToUncheckedShortCycle = function (currentState) {
	    return CheckTransitionRule.indeterminateToUnchecked(true, currentState);
	  };
	
	  function getAllCheckState(checkStateCounters, count) {
	    return _.findKey(checkStateCounters, function (c) {
	      return c === count;
	    }) || 'unchecked';
	  }
	
	  var Model = BaseProjection.extend({
	    defaults: {
	      'column.checked': 'checkbox', // the checkbox column
	      'row.check.id': 'Id',
	      'row.check.map': {},
	      'row.check.all': { state: 'unchecked' }, // used to store user's check value for the special case no rows or all rows is disabled
	      'row.check.allow': function rowCheckAllow() {
	        return true;
	      },
	      'row.check.click-anywhere': false,
	      'row.check.transition': CheckTransitionRule.indeterminateToCheckedShortCycle,
	      'row.check.all.transition': CheckTransitionRule.indeterminateToCheckedShortCycle,
	      'row.check.template': defaultRowCheckTemp
	    },
	    name: 'row-check',
	    events: {
	      'layout:click:cell': 'tdClick',
	      'layout:click:header': 'thClick'
	    },
	    reset: function reset() {
	      this.set({
	        'row.check.checked.all': false,
	        'row.check.map': {}
	      });
	    },
	    update: function update(options) {
	      if (!Model.__super__.update.call(this, options)) {
	        return;
	      }
	
	      var checkId = this.get('row.check.id');
	      var ids = _.pluck(this.src.data.get('value'), checkId);
	      var checkMap = this.get('row.check.map');
	      var col = this.get('column.checked');
	      var columns = _.clone(this.src.data.get('columns'));
	      var checkStateCounters = _.object(['unchecked', 'checked', 'indeterminate'], [0, 0, 0]);
	      var hasCheckboxable = false;
	      var checkboxAllow = this.get('row.check.allow');
	      var checkboxColumn = _.find(columns, function (item) {
	        return item.property === col;
	      });
	      var rowCheckTemp = this.get('row.check.template');
	
	      var value = _.map(this.src.data.get('value'), function (item) {
	        var ret = _.clone(item);
	        var check = checkMap[ret[checkId]] || { state: 'unchecked' };
	        var disabled = true;
	        var isAllowed = _.isFunction(checkboxAllow) ? checkboxAllow(ret) : checkboxAllow;
	
	        checkStateCounters[check.state]++;
	
	        if (isAllowed) {
	          disabled = false;
	          hasCheckboxable = true;
	        }
	
	        ret[col] = _.extend({}, ret[col], {
	          $html: rowCheckTemp({ checkState: check.state, disabled: disabled })
	        });
	
	        return ret;
	      });
	
	      // set the checkbox in th
	      if (!_.isUndefined(checkboxColumn)) {
	        var disabledAllCheck = _.size(ids) === 0;
	
	        if (hasCheckboxable) {
	          var checkState = getAllCheckState(checkStateCounters, ids.length);
	
	          checkboxColumn.$html = rowCheckTemp({ checkState: checkState, disabled: disabledAllCheck });
	          this.attributes['row.check.all'] = _.extend(this.attributes['row.check.all'], { state: checkState });
	        } else {
	          checkboxColumn.$html = rowCheckTemp({ checkState: this.get('row.check.all').state, disabled: disabledAllCheck });
	        }
	      }
	
	      this.patch({
	        value: value,
	        columns: columns
	      });
	    },
	    tdClick: function tdClick(e, arg) {
	      var checkboxProperty = this.get('column.checked');
	      var clickAnywhere = this.get('row.check.click-anywhere');
	
	      if (arg.property === checkboxProperty || clickAnywhere) {
	        var checkMap = _.clone(this.get('row.check.map'));
	        var id = arg.model[this.get('row.check.id')];
	        var defaultTransition = this.get('row.check.transition');
	        var check = _.extend({
	          id: id,
	          transition: defaultTransition,
	          state: 'unchecked'
	        }, checkMap[id]);
	
	        check.state = check.transition(check.state);
	        checkMap[id] = check;
	
	        this.set({
	          'row.check.map': checkMap
	        });
	
	        e.stopImmediatePropagation();
	      }
	    },
	    thClick: function thClick(e, arg) {
	      var checkboxProperty = this.get('column.checked');
	
	      if (arg.property === checkboxProperty) {
	        var checkMap = _.clone(this.get('row.check.map'));
	        var checkId = this.get('row.check.id');
	        var allCheck = this.get('row.check.all');
	        var checkState = allCheck.state;
	        var allCheckTransitionRule = this.get('row.check.all.transition');
	        var CheckTransitionRule = this.get('row.check.transition');
	
	        allCheck.state = allCheckTransitionRule(checkState);
	
	        checkMap = _.object(this.data.get('value').map(function (item) {
	          var id = item[checkId];
	          var check = _.extend({
	            id: id,
	            transition: CheckTransitionRule
	          }, checkMap[id], { state: allCheck.state });
	
	          return [id, check];
	        }));
	
	        this.set({
	          'row.check.map': checkMap,
	          'row.check.all': allCheck
	        });
	
	        e.stopImmediatePropagation();
	      }
	    }
	  });
	
	  function CheckDiff(added, changed, removed, unchanged) {
	    this.added = added || {};
	    this.changed = changed || {};
	    this.removed = removed || {};
	    this.unchanged = unchanged || {};
	  }
	
	  CheckDiff.prototype.hasChanges = function () {
	    return _.keys(this.changed).length + _.keys(this.added).length > 0;
	  };
	
	  function diffCheckMap(before, after, defaultState) {
	    defaultState = defaultState || { state: 'unchecked' };
	
	    var checkDiff = new CheckDiff();
	
	    _.keys(before).forEach(function (key) {
	      var beforeState = before[key];
	      var afterState = after[key];
	
	      if (!afterState) {
	        checkDiff.removed[key] = beforeState;
	      } else if (beforeState.state === afterState.state) {
	        checkDiff.unchanged[key] = afterState;
	      } else {
	        checkDiff.changed[key] = { before: beforeState, after: afterState };
	      }
	    });
	
	    _.keys(after).forEach(function (key) {
	      var afterState = after[key];
	      var beforeState = before[key];
	
	      if (!beforeState && defaultState.state !== afterState.state) {
	        checkDiff.added[key] = afterState;
	      }
	    });
	
	    return checkDiff;
	  }
	
	  function statCheckMap(checkMap, defaultState) {
	    defaultState = defaultState || { state: 'unchecked' };
	    var checked = [];
	    var indeterminate = [];
	    var unchecked = [];
	
	    _.keys(checkMap).forEach(function (key) {
	      var check = checkMap[key];
	
	      if (check.state === 'checked' && check.state !== defaultState.state) {
	        checked.push(check);
	      } else if (check.state === 'unchecked' && check.state !== defaultState.state) {
	        unchecked.push(check);
	      } else if (check.state !== defaultState.state) {
	        indeterminate.push(check);
	      }
	    });
	
	    return {
	      checked: checked,
	      unchecked: unchecked,
	      indeterminate: indeterminate
	    };
	  }
	
	  function fullStatCheckMap(before, after, defaultState) {
	    return _.extend(statCheckMap(after, defaultState), diffCheckMap(before, after, defaultState));
	  }
	
	  Model.CheckTransitionRule = CheckTransitionRule;
	  Model.fullStatCheckMap = fullStatCheckMap;
	  Model.statCheckMap = statCheckMap;
	  Model.diffCheckMap = diffCheckMap;
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (checkState) {
	var classes = [].concat(checkState === 'indeterminate' ? ['glyphicon', 'glyphicon-minus'] : checkState === 'checked' ? ['glyphicon', 'glyphicon-ok'] : [])
	buf.push("<div class=\"column-tri-state-checkbox\"><span" + (jade.cls([classes], [true])) + "></span></div>");}.call(this,"checkState" in locals_for_with?locals_for_with.checkState:typeof checkState!=="undefined"?checkState:undefined));;return buf.join("");
	}

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22), __webpack_require__(26), __webpack_require__(23)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection /* , schemaProperties, Response */) {
	  var Model = BaseProjection.extend({
	    defaults: {},
	    name: 'row-index',
	    update: function update(options) {
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        var skip = this.get('skip');
	        var value = _.map(model.get('value'), function (i, idx) {
	          var ret = _.clone(i);
	          ret.rowIndex = idx + (_.isFinite(skip) ? skip : 0) + 1;
	          return ret;
	        });
	
	        this.patch({ value: value });
	      } else {
	        // todo [akamel] unset our properties only
	        // this.unset();
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(22), __webpack_require__(26)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, BaseProjection, schemaProperties) {
	  var Model = BaseProjection.extend({
	
	    defaults: {
	      seed: null
	    },
	
	    name: 'sink',
	
	    update: function update() {
	      var value;
	
	      value = this.get('seed');
	
	      if (value) {
	        var select = schemaProperties.from(value);
	        this.patch({
	          value: value,
	          select: select,
	          count: _.size(value)
	        });
	      }
	    }
	
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22), __webpack_require__(23)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection) {
	  var Model = BaseProjection.extend({
	    defaults: {
	      'column.group': {},
	      'column.groupExpansion': [],
	      'column.select': null
	    },
	    name: 'column-group',
	
	    events: {
	      'layout:click:header': 'onClickHeader'
	    },
	
	    update: function update(options) {
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        var columnGroup = this.get('column.group') || {};
	        var groupExpansion = {};
	        _.each(this.get('column.groupExpansion') || [], function (columnName) {
	          groupExpansion[columnName] = true;
	        });
	        var select = this.get('column.select') || model.get('select');
	        var columns = model.get('columns');
	        var date = model.get('jsdata.query');
	        var subSelect = [];
	        var isApplyGroup = date && date.startDate2 && date.endDate2;
	
	        _.chain(columns).keys().each(function (key) {
	          if (isApplyGroup && _.has(columnGroup, key)) {
	            columns[key].group = columnGroup[key];
	            columns[key].groupExpansion = _.has(groupExpansion, key);
	          } else {
	            columns[key].group = null;
	            columns[key].groupExpansion = false;
	          }
	        });
	
	        var selectExpand = select.slice(0);
	
	        _.each(select, function (columnName) {
	          var column = columns[columnName];
	          var subColumns = column.group;
	          if (column.groupExpansion) {
	            var nameIndex = selectExpand.indexOf(columnName);
	            selectExpand.splice.apply(selectExpand, [nameIndex, 1].concat(subColumns));
	            subSelect = subSelect.concat(subColumns);
	          }
	        }, this);
	
	        this.patch({
	          columns: columns,
	          select: select,
	          subSelect: subSelect,
	          selectExpand: selectExpand,
	          isApplyGroup: isApplyGroup
	        });
	      } else {
	        // todo [akamel] unset our properties only
	        // this.unset();
	      }
	    },
	
	    onClickHeader: function onClickHeader(e, arg) {
	      if (!e.target.classList.contains('glyphicon')) {
	        return;
	      }
	      var column = arg.column;
	      if (_.isArray(column.group)) {
	        var groupExpansion = this.get('column.groupExpansion') || [];
	        if (column.groupExpansion) {
	          groupExpansion = _.without(groupExpansion, column.property);
	        } else {
	          groupExpansion = _.union(groupExpansion, [column.property]);
	        }
	        this.set({ 'column.groupExpansion': groupExpansion });
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, BaseProjection) {
	  var Model = BaseProjection.extend({
	    name: 'column-hovertext',
	    update: function update(options) {
	      if (Model.__super__.update.call(this, options)) {
	        var model = this.src.data;
	        var columns = model.get('columns');
	
	        _.each(columns, function (column) {
	          column.$metadata = _.result(column, '$metadata', {});
	          column.$metadata['attr.head'] = _.result(column.$metadata, 'attr.head', {});
	          column.$metadata['attr.head'].title = _.result(column.config, 'hoverText') || _.result(column.config, 'title') || '';
	        });
	
	        this.patch({ columns: columns });
	      }
	    }
	  });
	
	  return Model;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _base = __webpack_require__(22);
	
	var _base2 = _interopRequireDefault(_base);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ColumnsProjection = _base2.default.extend({
	  defaults: {
	    columns: {}
	  },
	
	  name: 'columns',
	
	  update: function update(options) {
	    if (_base2.default.prototype.update.call(this, options)) {
	      this.patch({
	        columns: this.get('columns')
	      });
	    }
	  }
	});
	
	exports.default = ColumnsProjection;

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.delegateEvents = delegateEvents;
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function delegateEvents(_ref) {
	  var from = _ref.from;
	  var to = _ref.to;
	  var events = _ref.events;
	
	  _underscore2.default.each(events, function (event) {
	    return from.on(event, function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      return to.trigger.apply(to, [event].concat(args));
	    });
	  });
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _gridView = __webpack_require__(63);
	
	var _gridView2 = _interopRequireDefault(_gridView);
	
	var _index = __webpack_require__(7);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _utility = __webpack_require__(61);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (definePlugin) {
	  return definePlugin('gridView', ['config', 'projection', 'renderers'], function (config, projection, renderers) {
	    var gridView = new _gridView2.default({
	      projection: projection,
	      el: config.el,
	      container: _underscore2.default.chain(config).result('scrollable').result('fixedHeader').result('container').value(),
	      schema: config.dataSource.schema,
	      Layout: _index2.default.TableLayout.partial({
	        renderers: renderers,
	        template: _index2.default.templates.table,
	        hideHeaders: config.hideHeaders,
	        $metadata: config.layoutOptions || {}
	      })
	    });
	
	    (0, _utility.delegateEvents)({
	      from: projection,
	      to: gridView,
	      events: ['update:beginning', 'update:finished']
	    });
	
	    return gridView;
	  });
	};

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10), __webpack_require__(64), __webpack_require__(65), __webpack_require__(67)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, Options, WindowContainer, ElementContainer) {
	  var GridView = Backbone.View.extend({
	    // todo [akamel] document available options
	    initialize: function initialize(options) {
	      options = options || {};
	
	      this.options = new Options(options);
	
	      var container = selectContainer(options.container);
	
	      // todo [akamel] assert that layout is a ctor
	      this.layout = new options.Layout({
	        el: this.el,
	        grid: this,
	        container: container
	      });
	
	      this.projection = options.projection;
	
	      this.projection.data.on('change', function () {
	        this.trigger.apply(this, ['change:data'].concat(_.toArray(arguments)));
	      }.bind(this));
	
	      this.options.on('change', function () {
	        this.trigger.apply(this, ['change:options'].concat(_.toArray(arguments)));
	      }.bind(this));
	
	      this.projection.on('all', function () {
	        this.trigger.apply(this, ['data:' + _.first(arguments)].concat(_.rest(arguments)));
	      }.bind(this));
	
	      this.layout.on('all', function () {
	        var key = 'layout:' + _.first(arguments);
	        var arg = [key].concat(_.rest(arguments));
	
	        this.projection.bubble.apply(this.projection, arg);
	        this.trigger.apply(this, arg);
	      }.bind(this));
	
	      // todo [akamel] this is a temporary implementation of orderby; should be in layout not in grid
	      this.on('layout:click:header', function (e, arg) {
	        var column = arg.column;
	
	        if (column.sortable) {
	          var orderby = this.projection.get('orderby') || [];
	          orderby = _.filter(orderby, function (item) {
	            return item.scope === 'global';
	          });
	
	          var key = _.isString(column.sortable) ? column.sortable : column.property;
	
	          var orderItem = {};
	          orderItem[key] = column.$orderby ? column.$orderby.dir * -1 : 1;
	          orderby.push(orderItem);
	
	          this.projection.set({ 'orderby': orderby, 'page.number': 0 });
	        }
	      }.bind(this));
	
	      var local = _.omit(options, 'projection', 'layout');
	      this.options.set(local);
	    },
	
	    remove: function remove() {
	      this.layout.remove();
	      Backbone.View.prototype.remove.apply(this, arguments);
	    },
	
	    set: function set() {
	      this.options.set.apply(this.options, _.toArray(arguments));
	    },
	
	    render: function render(options) {
	      options = options || {};
	
	      this.layout.render();
	
	      if (options.fetch) {
	        this.projection.update({ deep: true });
	      }
	
	      return this;
	    },
	
	    getSelection: function getSelection() {
	      return this.projection.get('row.check.list') || [];
	    }
	
	  });
	
	  function selectContainer(userContainer) {
	    if (userContainer && window !== userContainer && ElementContainer.isValidContainer(userContainer)) {
	      return new ElementContainer({ el: userContainer });
	    }
	
	    return new WindowContainer();
	  }
	
	  return GridView;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone) {
	  return Backbone.Model.extend({
	    defaults: {
	      layout: undefined,
	      projection: undefined
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(9), __webpack_require__(66)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, ContainerBase) {
	  var WindowContainer = ContainerBase.extend({
	    constructor: function constructor(options) {
	      options = _.extend({}, options, { el: window });
	      ContainerBase.prototype.constructor.apply(this, [options].concat(_.rest(arguments)));
	    },
	
	    offset: function offset(element) {
	      return $(element).offset();
	    }
	  });
	
	  return WindowContainer;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(9), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, Backbone) {
	  var ContainerBase = Backbone.View.extend({
	    events: {
	      scroll: 'onScroll',
	      resize: 'onResize'
	    },
	
	    onScroll: function onScroll(e) {
	      this.trigger('scroll:container', e);
	    },
	
	    onResize: function onResize(e) {
	      this.trigger('resize:container', e);
	    },
	
	    offset: function offset() /* element, scrollTop, scrollLeft */{
	      throw new Error("Offset function not implemented");
	    }
	  });
	
	  return ContainerBase;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(9), __webpack_require__(66)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, ContainerBase) {
	  var ElementContainer = ContainerBase.extend({
	    offset: function offset(element) {
	      var position = $(element).position();
	
	      return {
	        top: position.top + this.$el.scrollTop(),
	        left: position.left + this.$el.scrollLeft()
	      };
	    }
	  });
	
	  ElementContainer.isValidContainer = function (userContainer) {
	    return ['absolute', 'relative', 'fixed'].indexOf($(userContainer).css('position')) >= 0;
	  };
	
	  return ElementContainer;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _dataSource = __webpack_require__(69);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @typedef DataSourceConfig
	 * @type {DataSource|BuiltinDataSourceConfig}
	 */
	
	/**
	 * @typedef BuiltinDataSourceConfig
	 * @type {Object}
	 * @property {string} type
	 *    The builtin data source type, available values are 'odata', 'js-data'
	 *    and 'memory'.
	 * @property {string?} primaryKey
	 *    The primaryKey for the data source. Required by 'odata' and 'memory'
	 *    data sources.
	 * @property {JSDataResource?} entity
	 *    The JSDataResource representing the entity set. Required by 'js-data'
	 *    data source.
	 * @property {string?} url
	 *    The URL for the entity set. Required by 'odata' data source.
	 * @property {Object[]?} data
	 *    The in-memory data set. Required by 'memory' data source.
	 *
	 */
	
	exports.default = function (definePlugin) {
	  return definePlugin('dataSource', ['config'], function (config) {
	    var dataSource = _underscore2.default.result(config, 'dataSource', {});
	
	    if (dataSource instanceof _dataSource.DataSource) {
	      return dataSource;
	    }
	
	    var type = dataSource.type;
	    var primaryKey = dataSource.primaryKey;
	
	
	    if (type === 'memory') {
	      return new _dataSource.MemoryDataSource(dataSource.data, primaryKey);
	    }
	
	    if (type === 'odata') {
	      return new _dataSource.ODataDataSource(dataSource.url, primaryKey);
	    }
	
	    if (_underscore2.default.contains(['jsdata', 'js-data'], type)) {
	      return new _dataSource.JSDataDataSource(dataSource.entity, dataSource.options);
	    }
	
	    throw new Error('Unsupported data source type');
	  });
	};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _base = __webpack_require__(70);
	
	Object.defineProperty(exports, 'DataSource', {
	  enumerable: true,
	  get: function get() {
	    return _base.DataSource;
	  }
	});
	
	var _odata = __webpack_require__(71);
	
	Object.defineProperty(exports, 'ODataDataSource', {
	  enumerable: true,
	  get: function get() {
	    return _odata.ODataDataSource;
	  }
	});
	
	var _jsData = __webpack_require__(72);
	
	Object.defineProperty(exports, 'JSDataDataSource', {
	  enumerable: true,
	  get: function get() {
	    return _jsData.JSDataDataSource;
	  }
	});
	
	var _memory = __webpack_require__(73);
	
	Object.defineProperty(exports, 'MemoryDataSource', {
	  enumerable: true,
	  get: function get() {
	    return _memory.MemoryDataSource;
	  }
	});

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DataSource = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var defaultPrimaryKey = '__primary_key__';
	
	/**
	 * The base class for all data sources.
	 * @class DataSource
	 * @param {string} [primaryKey='__primary_key__']
	 *    The primary key of the entity set.
	 */
	
	var DataSource = exports.DataSource = function () {
	  function DataSource() {
	    var primaryKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultPrimaryKey;
	
	    _classCallCheck(this, DataSource);
	
	    this._primaryKey = primaryKey;
	  }
	
	  /**
	   * The primary key of the data source.
	   * @type {string}
	   */
	
	
	  _createClass(DataSource, [{
	    key: 'query',
	
	
	    /**
	     * Query the data source with given parameters
	     * @param {object} params - The query parameters
	     */
	    value: function query(params) {
	      return {
	        items: [],
	        totalCount: 0
	      };
	    }
	
	    /**
	     * The order-by configuration for the data source.
	     * @typedef OrderByConfig
	     * @type {OrderByItem|OrderByItem[]}
	     */
	
	    /**
	     * A [key: string, direction: number] pair.
	     * @typedef NormalizedOrderByPair
	     * @type {array}
	     */
	
	    /**
	     * Normalize the orderby parameter for data source.
	     * @param {OrderByConfig} orderBy
	     * @return {NormalizedOrderByPair[]}
	     */
	
	  }, {
	    key: 'normalizeOrderBy',
	    value: function normalizeOrderBy() {
	      var _this = this;
	
	      var orderBy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	
	
	      /**
	       * A single order-by item with key and direction.
	       * @typedef OrderByItem
	       * @type {OrderByObject|OrderByPair}
	       */
	      return _underscore2.default.reduce(_underscore2.default.isArray(orderBy) ? orderBy : [orderBy], function (memo, item) {
	        var key = null;
	        var direction = null;
	        var dirString = null;
	
	        /**
	         * A [key: OrderByKey, direction: number] pair.
	         * @typedef OrderByPair
	         * @type {array}
	         */
	        if (_underscore2.default.isArray(item)) {
	          key = item[0];
	          direction = item[1];
	        }
	
	        /**
	         * @typedef OrderByObject
	         * @type {object}
	         * @property {OrderByKey} key - The key off the order by item
	         * @property {number} direction - The direction of the order by item, positive
	         * for ascending, non-positive for descending
	         */
	        if (_underscore2.default.isObject(item)) {
	          key = item.key;
	          direction = item.direction;
	        }
	
	        if (!_underscore2.default.isNumber(direction)) {
	          throw new Error('Invalid direction option for orderBy');
	        }
	
	        if (!direction) {
	          return memo;
	        }
	
	        /**
	         * Represents an order by key
	         *  * When it's a string, it's the key path of the sorting value.
	         *  * When it's a callback, it takes a direction, and return a normalized
	         *    order config.
	         * @typedef OrderByKey
	         * @type {string|OrderByCallback}
	         */
	        if (_underscore2.default.isFunction(key)) {
	          /**
	           * @callback OrderByCallback
	           * @param {number} direction - The direction of the order by item
	           * @return {OrderByConfig}
	           */
	          return memo.concat(_this.normalizeOrderBy(key(direction)));
	        }
	
	        if (_underscore2.default.isString(key)) {
	          memo.push([key, direction]);
	          return memo;
	        }
	
	        throw new Error('Invalid key option for orderBy');
	      }, []);
	    }
	  }, {
	    key: 'primaryKey',
	    get: function get() {
	      return this._primaryKey;
	    }
	  }]);

	  return DataSource;
	}();

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ODataDataSource = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _jquery = __webpack_require__(9);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _bluebird = __webpack_require__(35);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _base = __webpack_require__(70);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function translateOrderBy(dataSource, orderByParams) {
	  return _underscore2.default.chain(dataSource.normalizeOrderBy(orderByParams)).map(function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 2);
	
	    var key = _ref2[0];
	    var direction = _ref2[1];
	    return key + ' ' + (direction > 0 ? 'asc' : 'desc');
	  }).join(',').value();
	}
	
	function translateParams(dataSource, params) {
	  return _underscore2.default.chain(params).omit('skip', 'take', 'filter', 'orderby').extend(_underscore2.default.pick({
	    $skip: params.skip,
	    $top: params.take,
	    $filter: params.filter,
	    $orderby: translateOrderBy(dataSource, params.orderby),
	    $count: true
	  }, Boolean)).value();
	}
	
	/**
	 * Data source from an OData service.
	 * @class ODataDataSource
	 * @param {string} url
	 *    The root URL of the OData entity set.
	 * @param {string} primaryKey
	 *    The primary key of the entity set.
	 */
	
	var ODataDataSource = exports.ODataDataSource = function (_DataSource) {
	  _inherits(ODataDataSource, _DataSource);
	
	  function ODataDataSource(url, primaryKey) {
	    _classCallCheck(this, ODataDataSource);
	
	    var _this = _possibleConstructorReturn(this, (ODataDataSource.__proto__ || Object.getPrototypeOf(ODataDataSource)).call(this, primaryKey));
	
	    _this._url = url;
	    return _this;
	  }
	
	  _createClass(ODataDataSource, [{
	    key: 'query',
	    value: function query(params) {
	      var _this2 = this;
	
	      return new _bluebird2.default(function (resolve, reject) {
	        _jquery2.default.getJSON(_this2._url, translateParams(_this2, params)).success(resolve).fail(function (jqXHR, textStatus, errorThrown) {
	          reject(new Error(errorThrown));
	        });
	      }).then(function (data) {
	        return {
	          items: data.value || [],
	          totalCount: data['@odata.count'] || 0
	        };
	      });
	    }
	  }, {
	    key: 'url',
	    get: function get() {
	      return this._url;
	    }
	  }]);

	  return ODataDataSource;
	}(_base.DataSource);

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.JSDataDataSource = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _base = __webpack_require__(70);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function translateOrderBy(dataSource, orderByParams) {
	  var orderBy = _underscore2.default.chain(dataSource.normalizeOrderBy(orderByParams)).map(function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 2);
	
	    var key = _ref2[0];
	    var direction = _ref2[1];
	    return [key, direction > 0 ? 'ASC' : 'DESC'];
	  }).value();
	
	  return _underscore2.default.isEmpty(orderBy) ? null : orderBy;
	}
	
	function translateParams(dataSource, params) {
	  return _underscore2.default.chain(params).omit('skip', 'take', 'filter', 'orderby').extend(_underscore2.default.pick({
	    offset: params.skip,
	    limit: params.take,
	    where: params.filter,
	    orderBy: translateOrderBy(dataSource, params.orderby)
	  }, Boolean)).value();
	}
	
	/**
	 * Data source from a JSData resource
	 * @class JSDataDataSource
	 * @param {JSDataResource} resource
	 *    The JSData resource representing the entity set.
	 * @param {Object} options
	 *    The query options. You can use it add JSData life cycle hooks.
	 */
	
	var JSDataDataSource = exports.JSDataDataSource = function (_DataSource) {
	  _inherits(JSDataDataSource, _DataSource);
	
	  function JSDataDataSource(resource) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	    _classCallCheck(this, JSDataDataSource);
	
	    var _this = _possibleConstructorReturn(this, (JSDataDataSource.__proto__ || Object.getPrototypeOf(JSDataDataSource)).call(this, resource.idAttribute));
	
	    _this._resource = resource;
	    _this._options = options;
	    return _this;
	  }
	
	  _createClass(JSDataDataSource, [{
	    key: 'query',
	    value: function query(params) {
	      var options = _underscore2.default.defaults({}, params.options, this._options);
	
	      return this._resource.findAll(translateParams(this, _underscore2.default.omit(params, 'options')), options).then(function (data) {
	        return {
	          items: data.slice(),
	          totalCount: data.totalCount || 0
	        };
	      });
	    }
	  }, {
	    key: 'resource',
	    get: function get() {
	      return this._resource;
	    }
	  }]);

	  return JSDataDataSource;
	}(_base.DataSource);

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MemoryDataSource = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _base = __webpack_require__(70);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Data source from an in-memory array.
	 * @class MemoryDataSource
	 * @param {Object[]} data
	 *    The in-memory array for the data set.
	 * @param {string} primaryKey
	 *    The primary key of the data set.
	 */
	var MemoryDataSource = exports.MemoryDataSource = function (_DataSource) {
	  _inherits(MemoryDataSource, _DataSource);
	
	  function MemoryDataSource(data, primaryKey) {
	    _classCallCheck(this, MemoryDataSource);
	
	    var _this = _possibleConstructorReturn(this, (MemoryDataSource.__proto__ || Object.getPrototypeOf(MemoryDataSource)).call(this, primaryKey));
	
	    _this.data = data;
	    return _this;
	  }
	
	  _createClass(MemoryDataSource, [{
	    key: 'query',
	    value: function query(params) {
	      var _ref = params || {};
	
	      var _ref$skip = _ref.skip;
	      var skip = _ref$skip === undefined ? 0 : _ref$skip;
	      var _ref$take = _ref.take;
	      var take = _ref$take === undefined ? this.data.length - skip : _ref$take;
	      var _ref$filter = _ref.filter;
	      var filter = _ref$filter === undefined ? function () {
	        return true;
	      } : _ref$filter;
	      var _ref$orderby = _ref.orderby;
	      var orderby = _ref$orderby === undefined ? [] : _ref$orderby;
	
	      var _ref2 = _underscore2.default.first(orderby) || {};
	
	      var key = _ref2.key;
	      var direction = _ref2.direction;
	
	      var sortIteratee = null;
	
	      if (_underscore2.default.isFunction(key)) {
	        sortIteratee = key;
	      } else if (_underscore2.default.isString(key)) {
	        (function () {
	          var segs = key.split(/[\.\/]/);
	          sortIteratee = function sortIteratee(item) {
	            return _underscore2.default.reduce(segs, function (memo, seg) {
	              return _underscore2.default.result(memo, seg);
	            }, item);
	          };
	        })();
	      }
	
	      var data = _underscore2.default.filter(this.data, filter);
	
	      if (sortIteratee) {
	        data = _underscore2.default.sortBy(data, sortIteratee);
	
	        if (direction < 0) {
	          data.reverse();
	        }
	      }
	
	      return {
	        totalCount: data.length,
	        items: data.slice(skip, skip + take)
	      };
	    }
	  }]);

	  return MemoryDataSource;
	}(_base.DataSource);

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _gridView = __webpack_require__(75);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var CONSTRUCTOR_OPTIONS = ['el', 'scrolling', 'tableClasses'];
	var NONE_PROJECTION_OPTIONS = CONSTRUCTOR_OPTIONS.concat(['plugins']);
	
	/**
	 * @typedef GridViewConfig
	 * @type {Object}
	 * @property {string} name
	 *    Name of the grid
	 * @property {string|HTMLElement|jQuery} el
	 *    The root element of the grid view.
	 * @property {ScrollingConfig} scrolling
	 *    The scrolling behavior configuratoin.
	 * @property {strings[]} tableClasses
	 *    An array of classes to be applied to `TABLE` elements.
	 * @property {Object.<string,Object>} plugins
	 *    The plugin configurations. The keys are the plugin names, and the values
	 *    are the configuation objects.
	 * @property {RowsConfig} rows
	 *    The structure of the head/body/foot rows.
	 * @property {ColumnConfig[]} columns
	 *    Array of the columns configurations.
	 * @property {DataSourceConfig} dataSource
	 *    The data source configurations. Tells the grid how to fetch data.
	 * @property {QueryConfig} query
	 *    The query parameters for data fetch.
	 * @property {SelectionConfig} selection
	 *    Config the behavior for row selection.
	 * @property {SortableHeaderConfig} sortableHeader
	 *    Config the state and visual of the click-to-sort column headers.
	 * @property {external:BackboneViewEventHash} events
	 *    Customized event hash in form of `Backbone.View#events`.
	 *    It can be set to handle
	 *    * The DOM events inside the `GridView`.
	 *    * The `GridView` events, e.g. {@link GridView#willUpdate},
	 *      {@link GridView#didUpdate}.
	 */
	
	exports.default = function (definePlugin) {
	  return definePlugin('gridView', ['config', 'dataSource'], function (config, dataSource) {
	    var options = _underscore2.default.chain(config).pick(CONSTRUCTOR_OPTIONS).extend({ dataSource: dataSource }).value();
	    var gridView = new _gridView.GridView(options);
	
	    gridView.set(_underscore2.default.omit(config, NONE_PROJECTION_OPTIONS));
	
	    return gridView;
	  });
	};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GridView = undefined;
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _jquery = __webpack_require__(9);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _backbone = __webpack_require__(10);
	
	var _backbone2 = _interopRequireDefault(_backbone);
	
	var _bluebird = __webpack_require__(35);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _projection = __webpack_require__(76);
	
	var _layout = __webpack_require__(96);
	
	var _dataSource = __webpack_require__(69);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function defaultsDeep(dest, src) {
	  if (_underscore2.default.isObject(dest) && !_underscore2.default.isArray(dest)) {
	    _underscore2.default.defaults(dest, src);
	    _underscore2.default.each(src, function (value, key) {
	      if (dest[key] !== value) {
	        defaultsDeep(dest[key], value);
	      }
	    });
	  }
	  return dest;
	}
	
	function nextTick() {
	  return new _bluebird2.default(function (resolve, reject) {
	    return window.setTimeout(resolve, 0);
	  });
	}
	
	var ProjectionChain = function () {
	  function ProjectionChain(model) {
	    _classCallCheck(this, ProjectionChain);
	
	    this.model = model;
	    this.projections = [];
	    this.state = null;
	    this.input = null;
	  }
	
	  /*
	   * When updating, execute each function in projections successively
	   */
	
	
	  _createClass(ProjectionChain, [{
	    key: 'update',
	    value: function update(input) {
	      var _this = this;
	
	      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	      var updated = force || input !== this.input;
	
	      this.input = input;
	
	      return _underscore2.default.reduce(this.projections, function (_ref, proj) {
	        var updated = _ref.updated;
	        var p$state = _ref.p$state;
	        var name = proj.name;
	        var handler = proj.handler;
	        var p$output = proj.p$output;
	
	        var result = {};
	
	        if (updated || !p$output || _underscore2.default.has(_this.model.changed, name)) {
	          result.updated = true;
	          result.p$state = proj.p$output = p$state.then(function (state) {
	            return handler(state, _this.model.get(name));
	          });
	        } else {
	          result.updated = false;
	          result.p$state = p$output;
	        }
	
	        return result;
	      }, {
	        updated: updated,
	        p$state: _bluebird2.default.resolve(input)
	      }).p$state.tap(function (state) {
	        _this.state = state;
	      });
	    }
	
	    /*
	     * Add projection functions to model.projections
	     */
	
	  }, {
	    key: 'pipe',
	    value: function pipe() {
	      var _this2 = this;
	
	      for (var _len = arguments.length, projs = Array(_len), _key = 0; _key < _len; _key++) {
	        projs[_key] = arguments[_key];
	      }
	
	      _underscore2.default.chain(projs).flatten().each(function (proj) {
	        var config = _this2.model.get(proj.name) || proj.defaults;
	
	        _this2.projections.push(proj);
	        _this2.model.set(proj.name, proj.normalize(config));
	      }).value();
	      return this;
	    }
	  }]);
	
	  return ProjectionChain;
	}();
	
	/**
	 * Class of a projection grid view
	 * @class GridView
	 * @extends Backbone.View
	 * @param {Object} options
	 *    The constructor options.
	 * @param {string[]} [options.tableClasses=[]]
	 *    The classes for the TABLE elements (content table and sticky/fixed header)
	 * @param {ScrollingConfig} [options.scrolling={virtualized: false, header: 'static'}]
	 *    The scrolling related configurations
	 */
	
	
	var GridView = exports.GridView = function (_Backbone$View) {
	  _inherits(GridView, _Backbone$View);
	
	  function GridView() {
	    _classCallCheck(this, GridView);
	
	    return _possibleConstructorReturn(this, (GridView.__proto__ || Object.getPrototypeOf(GridView)).apply(this, arguments));
	  }
	
	  _createClass(GridView, [{
	    key: 'initialize',
	    value: function initialize(_ref2) {
	      var _this4 = this;
	
	      var scrolling = _ref2.scrolling;
	      var tableClasses = _ref2.tableClasses;
	      var dataSource = _ref2.dataSource;
	
	      this._tableView = new _layout.TableView({
	        el: this.$el,
	        scrolling: scrolling,
	        classes: tableClasses
	      });
	      this.model = new _backbone2.default.Model();
	
	      this._dataSource = dataSource;
	
	      var projections = this._projections = {};
	
	      this._registerProjection = function (proj) {
	        var name = proj.name;
	
	        if (_underscore2.default.has(projections, ['name'])) {
	          throw new Error('Duplication projectons');
	        }
	
	        /**
	         * @callback ProjectionHandler
	         * @param {DataChainState|StructureChainState|ContentChainState} state
	         *    The input state.
	         * @param {Object} config
	         *    The projection configuration object.
	         * @return {DataChainState|StructureChainState|ContentChainState|Promise}
	         *    The output state or the `Promise` of the output state.
	         */
	
	        /**
	         * @typedef ProjectionDefinition
	         * @type {Object}
	         * @property {string} name - name of the projection
	         * @property {ProjectionHandler} handler
	         *    The callback to transform the state
	         * @property {Object} defaults
	         *    The default configuration of the projection
	         * @property {function} normalize
	         *    The callback to normalize the projection configurations.
	         */
	        projections[name] = {
	          name: name,
	          handler: (_underscore2.default.isFunction(proj) ? proj : proj.handler).bind(_this4),
	          defaults: proj.defaults,
	          normalize: (proj.normalize || _underscore2.default.identity).bind(_this4)
	        };
	
	        return projections[name];
	      };
	
	      /**
	       * @typedef DataChainState
	       * @type {Object}
	       * @property {string} uniqueId
	       *    The unique id for the set of data items. It changes each time new
	       *    query is made to the server.
	       * @property {string} primaryKey
	       *    The primary key of the data items.
	       * @property {(Object[]|FakeArray)} items
	       *    An array or a fake array of data items.
	       * @property {number} totalCount
	       *    The total item count on the server.
	       * @property {Object.<string, Object>} itemIndex
	       *    The items indexed by primary key.
	       * @property {external:BackboneViewEventHash} events
	       *    The event has in form of `Backbone.View#events`. Any projection can
	       *    response to the DOM events by adding its own event handlers.
	       */
	      this._chainData = new ProjectionChain(this.model);
	
	      /**
	       * It extends the {@link DataChainState} with extra properties.
	       * @typedef StructureChainState
	       * @type {DataChainState}
	       * @property {ColumnConfig[]} columns
	       *    The array of column configurations.
	       * @property {RowConfig[]} headRows
	       *    The row configurations for `THEAD`.
	       * @property {RowConfig[]} bodyRows
	       *    The row configurations for `TBODY`.
	       * @property {RowConfig[]} footRows
	       *    The row configurations for `TFOOT`.
	       */
	      this._chainStructure = new ProjectionChain(this.model);
	
	      /**
	       * It extends the {@link StructureChainState} with extra properties, and
	       * overrides some of the properties.
	       * @typedef ContentChainState
	       * @type {StructureChainState}
	       * @property {ColumnGroup} columnGroup
	       *    The column group object, represents the compiled column hierarchy.
	       * @property {ColContent[]} cols
	       *    The content for `COL` elements in `COLGROUP`.
	       * @property {RowContent} headRows
	       *    The content for rows in `THEAD`.
	       * @property {RowContent} bodyRows
	       *    The content for rows in `TBODY`.
	       * @property {RowContent} footRows
	       *    The content for rows in `TFOOT`.
	       */
	      this._chainContent = new ProjectionChain(this.model);
	
	      this.pipeDataProjections(_projection.query, _projection.buffer);
	      this.pipeStructureProjections([_projection.columns, _projection.rows, _projection.selection]);
	      this.pipeContentProjections([_projection.columnGroup, _projection.cells, _projection.editable, _projection.sortableHeader, _projection.events]);
	
	      var patchEvents = function patchEvents(state) {
	        return _underscore2.default.extend(state, {
	          events: _underscore2.default.mapObject(state.events, function (handler) {
	            return handler.bind(_this4);
	          })
	        });
	      };
	      var refreshState = {
	        changes: null,
	        promise: null
	      };
	
	      this._isRendered = false;
	      /**
	       * Refresh the GridView
	       * @function refresh
	       * @memberof GridView
	       * @instance
	       * @param {boolean} [force=false]
	       *    True for force refresh ignoring the cached states.
	       */
	      var refresh = this.refresh = function (force) {
	        var changes = refreshState.changes;
	
	        refreshState.changes = null;
	
	        /**
	         * The `GridView` will update its configuration and redraw.
	         * @event GridView#willUpdate
	         */
	        _this4.trigger('willUpdate', changes);
	
	        // Don't refresh before the view is rendered
	        if (!_this4._isRendered) {
	          _this4.trigger('didUpdate', changes);
	          return;
	        }
	
	        _underscore2.default.reduce([_this4._chainData, _this4._chainStructure, _this4._chainContent], function (memo, chain) {
	          return chain.update(memo, force);
	        }, null).then(patchEvents).then(function (state) {
	          return new _bluebird2.default(function (resolve, reject) {
	            _this4._tableView.set(state, resolve);
	          });
	        }).then(nextTick).finally(function () {
	          /**
	           * The `GridView` did update its configuration and redraw.
	           * @event GridView#didUpdate
	           */
	          _this4.trigger('didUpdate', changes);
	        });
	      };
	
	      var scheduleUpdate = function scheduleUpdate() {
	        if (refreshState.changes) {
	          _underscore2.default.extend(refreshState.changes, _this4.model.changedAttributes());
	        } else {
	          refreshState.changes = _this4.model.changedAttributes();
	
	          if (refreshState.promise) {
	            refreshState.promise = refreshState.promise.then(refresh);
	          } else {
	            refreshState.promise = refresh();
	          }
	        }
	      };
	
	      this.model.on('change', scheduleUpdate);
	
	      _underscore2.default.each([
	      /**
	       * The `GridView` will redraw the DOM. This event may trigger frequently
	       * when virtualization is enabled.
	       * @event GridView#willRedraw
	       */
	      'willRedraw',
	
	      /**
	       * The `GridView` did redraw the DOM. This event may trigger frequently
	       * when virtualization is enabled.
	       * @event GridView#didRedraw
	       */
	      'didRedraw'], function (event) {
	        _this4._tableView.on(event, function () {
	          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	            args[_key2] = arguments[_key2];
	          }
	
	          _this4.trigger.apply(_this4, [event].concat(args));
	        });
	      });
	
	      this.on('all', function (event) {
	        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	          args[_key3 - 1] = arguments[_key3];
	        }
	
	        var events = _underscore2.default.chain(_this4._chainContent).result('state').result('events').value();
	        var handler = events && events[event];
	
	        if (_underscore2.default.isFunction(handler)) {
	          handler.apply(undefined, args);
	        }
	      });
	    }
	
	    /**
	     * Pipe a projection to procceed the grid data
	     * @param {...ProjectionDefinition} projs - A list of projection definitions
	     * @return {GridView} - This grid view
	     */
	
	  }, {
	    key: 'pipeDataProjections',
	    value: function pipeDataProjections() {
	      for (var _len4 = arguments.length, projs = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	        projs[_key4] = arguments[_key4];
	      }
	
	      this._chainData.pipe(_underscore2.default.map(_underscore2.default.flatten(projs), this._registerProjection));
	      return this;
	    }
	
	    /**
	     * Pipe a projection to procceed the grid structure
	     * @param {...ProjectionDefinition} projs - A list of projection definitions
	     * @return {GridView} - This grid view
	     */
	
	  }, {
	    key: 'pipeStructureProjections',
	    value: function pipeStructureProjections() {
	      for (var _len5 = arguments.length, projs = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	        projs[_key5] = arguments[_key5];
	      }
	
	      this._chainStructure.pipe(_underscore2.default.map(_underscore2.default.flatten(projs), this._registerProjection));
	      return this;
	    }
	
	    /**
	     * Pipe a projection to procceed the grid visual content
	     * @param {...ProjectionDefinition} projs - A list of projection definitions
	     * @return {GridView} - This grid view
	     */
	
	  }, {
	    key: 'pipeContentProjections',
	    value: function pipeContentProjections() {
	      for (var _len6 = arguments.length, projs = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	        projs[_key6] = arguments[_key6];
	      }
	
	      this._chainContent.pipe(_underscore2.default.map(_underscore2.default.flatten(projs), this._registerProjection));
	      return this;
	    }
	
	    /**
	     * Change the grid(projection) configuratons
	     * @param {Object.<string, Object>} config
	     *    A hash of configurations to change. The keys are projection names while
	     *    the values are the projection configurations
	     * @param {function} [callback]
	     *    A callback to notify the update is completed
	     * @return {GridView}
	     *    This grid view.
	     */
	
	  }, {
	    key: 'set',
	    value: function set() {
	      var _this5 = this;
	
	      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _underscore2.default.noop;
	
	      // backward compatibility
	      if (_underscore2.default.has(config, 'dataSource')) {
	        var dataSource = config.dataSource;
	
	        config.query = _underscore2.default.defaults({}, config.query, _underscore2.default.pick(dataSource, ['skip', 'take', 'orderby', 'filter', 'options', 'query']));
	
	        if (dataSource.type === 'memory' && dataSource.data !== this._dataSource.data) {
	          this._dataSource.data = dataSource.data;
	          this.refresh(true);
	        }
	        delete config.dataSource;
	      }
	
	      this.model.set(_underscore2.default.mapObject(config, function (value, key) {
	        var projection = _this5._projections[key];
	
	        return projection ? projection.normalize(value) : value;
	      }));
	      this.once('didUpdate', callback);
	      return this;
	    }
	
	    /**
	     * Read the grid(projection)_configuration
	     * @param {string} name - name of the projection
	     * @return {object}
	     */
	
	  }, {
	    key: 'get',
	    value: function get(name) {
	      // backward compatibility
	      if (name === 'dataSource') {
	        var result = _underscore2.default.defaults({}, this.model.get('dataSource'), this.model.get('query'));
	
	        if (this._dataSource instanceof _dataSource.MemoryDataSource) {
	          result.type = 'memory';
	          result.data = this._dataSource.data;
	        } else if (this._dataSource instanceof _dataSource.JSDataDataSource) {
	          result.type = 'js-data';
	          result.entity = this._dataSource.resource;
	        } else if (this._dataSource instanceof _dataSource.ODataDataSource) {
	          result.type = 'odata';
	          result.url = this._dataSource.url;
	        }
	
	        return result;
	      }
	      return this.model.get(name);
	    }
	
	    /**
	     * Patch the grid(projection) configurations.
	     * It's similar to {@link GridView#set}, but instead of replacing the
	     * projection configurations, `patch` do deep object merge.
	     * @param {Object.<string, Object>} config
	     *    A hash of configurations to change. The keys are projection names
	     *    while the values are the projection configurations
	     * @param {function} callback
	     *    A callback to notify the update is completed
	     * @return {GridView}
	     *    This grid view.
	     */
	
	  }, {
	    key: 'patch',
	    value: function patch() {
	      var _this6 = this;
	
	      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _underscore2.default.noop;
	
	      this.set(_underscore2.default.reduce(_underscore2.default.keys(state), function (memo, key) {
	        var value = state[key];
	        var valueCur = _this6.get(key);
	
	        memo[key] = defaultsDeep(value, valueCur);
	        return memo;
	      }, {}), callback);
	    }
	
	    /**
	     * Render the grid view.
	     * @param {function} [callback]
	     *    A callback to notify the render is completed.
	     * @return {GridView}
	     *    This grid view.
	     */
	
	  }, {
	    key: 'render',
	    value: function render(callback) {
	      var _this7 = this;
	
	      this._tableView.render(function () {
	        _this7._isRendered = true;
	        _this7.refresh(true);
	        _this7.once('didRedraw', callback);
	      });
	      return this;
	    }
	
	    /**
	     * Destroy and detach the view from DOM.
	     */
	
	  }, {
	    key: 'remove',
	    value: function remove() {
	      this._tableView.remove();
	      _get(GridView.prototype.__proto__ || Object.getPrototypeOf(GridView.prototype), 'remove', this).call(this);
	    }
	
	    /* Helper functions */
	
	    /**
	     * A object implements a minimal interface of array to lazy fetch items.
	     * We use this structure a lot in projections, so that we don't need to
	     * procceed all the rows when virtualization is on.
	     * @typedef FakeArray
	     * @type {Object}
	     * @property {function} slice
	     *    a callback to get a slice of the items. It has the same signature as
	     *    `Array.slice()`.
	     * @property {number} length
	     *    length of the array
	     */
	
	    /**
	     * The data items. It's a fake array of original model.
	     * @type {(Object[]|FakeArray)}
	     */
	
	  }, {
	    key: 'query',
	
	
	    /**
	     * Make query to the data source
	     * @param {object} params - The query parameters
	     * @return {QueryResult}
	     */
	    value: function query(params) {
	      return this._dataSource.query(params);
	    }
	
	    /**
	     * The array data items.
	     * @type {Object[]}
	     */
	
	  }, {
	    key: 'getItemCount',
	
	
	    // Backward compatibility
	    value: function getItemCount() {
	      return this.totalCountRows;
	    }
	
	    /**
	     * Query the data item with its primary key.
	     * @param {string} key - the primary key.
	     * @return {Object}
	     */
	
	  }, {
	    key: 'itemWithKey',
	    value: function itemWithKey(key) {
	      return _underscore2.default.chain(this._chainData.state).result('itemIndex').result(key, null).value();
	    }
	
	    /**
	     * Get the primary key from a DOM element in a certain row.
	     * @param {HTMLElement|jQuery|string} el
	     *    The DOM element. It can be an `HTMLElement`, a jQuery object or a
	     *    jQuery selector.
	     * @return {string} - The primary key for the row.
	     */
	
	  }, {
	    key: 'keyOfElement',
	    value: function keyOfElement(el) {
	      var $tr = (0, _jquery2.default)(el).closest('tr', this.$el);
	
	      if ($tr.length > 0) {
	        return $tr.attr('data-key') || null;
	      }
	
	      return null;
	    }
	
	    /**
	     * Get the data item with its index in the items array.
	     * @param {number} index - The index of the item.
	     * @return {Object}
	     */
	
	  }, {
	    key: 'itemAt',
	    value: function itemAt(index) {
	      return _underscore2.default.result(this._chainData.state, 'items', []).slice(index, index + 1)[0];
	    }
	
	    /**
	     * Given an element in the data rows, get the index of the corresponding
	     * data item.
	     *
	     * __NOTE__: It's not recommended to use this API to find the data item for
	     * a given element. It could be incorrect if there're custom projections
	     * changes the TR sequence of TBODY. Insteadly, you should use
	     * {@link GridView#keyOfElement}.
	     *
	     * @param {HTMLElement|jQuery|string} el
	     *    The DOM element. It can be an `HTMLElement`, a jQuery object or a
	     *    jQuery selector.
	     * @return {number} - The index of the data row.
	     */
	
	  }, {
	    key: 'indexOfElement',
	    value: function indexOfElement(el) {
	      return this._tableView.indexOfElement(el);
	    }
	
	    /**
	     * Get the primary keys of the selected items.
	     * @return {string[]} - An array of the selected keys.
	     */
	
	  }, {
	    key: 'selectedKeys',
	    value: function selectedKeys() {
	      return _underscore2.default.result(this.get('selection'), 'selected', []);
	    }
	
	    /**
	     * Get the selected items.
	     * @return {Object[]} - An array of the selected data items.
	     */
	
	  }, {
	    key: 'selectedItems',
	    value: function selectedItems() {
	      var itemIndex = _underscore2.default.result(this._chainData.state, 'itemIndex', {});
	
	      return _underscore2.default.chain(this.selectedKeys()).map(function (key) {
	        return _underscore2.default.result(itemIndex, key);
	      }).compact().value();
	    }
	
	    /**
	     * Select a row with the given primary key.
	     * @param {string} key - The primary key for the row.
	     */
	
	  }, {
	    key: 'selectRow',
	    value: function selectRow(key) {
	      (0, _projection.setSelectRow)(this, key, true);
	    }
	
	    /**
	     * Deselect a row with the given primary key.
	     * @param {string} key - The primary key for the row.
	     */
	
	  }, {
	    key: 'deselectRow',
	    value: function deselectRow(key) {
	      (0, _projection.setSelectRow)(this, key, false);
	    }
	
	    /**
	     * Select all the selectable items.
	     */
	
	  }, {
	    key: 'selectAll',
	    value: function selectAll() {
	      (0, _projection.setSelectAll)(this, true);
	    }
	
	    /**
	     * Deselect all the selectable items.
	     */
	
	  }, {
	    key: 'deselectAll',
	    value: function deselectAll() {
	      (0, _projection.setSelectAll)(this, false);
	    }
	
	    /**
	     * Get the finalized column configuration with a given column name.
	     * @param {string} name - The name of the column.
	     * @return {ExtendedColumnConfig}
	     */
	
	  }, {
	    key: 'columnWithName',
	    value: function columnWithName(name) {
	      var columnGroup = _underscore2.default.result(this._chainContent.state, 'columnGroup');
	      return columnGroup ? columnGroup.columnWithName(name) : null;
	    }
	
	    /**
	     * Get the row configurations for `THEAD`
	     * @return {RowConfig[]}
	     */
	
	  }, {
	    key: 'getHeadRows',
	    value: function getHeadRows() {
	      return _underscore2.default.result(this.get('rows'), 'headRows', ['column-header-rows']);
	    }
	
	    /**
	     * @callback SetRowsCallback
	     * @param {RowConfig[]} rows - The current row configurations.
	     * @return {RowConfig[]} - The new row configurations.
	     */
	
	    /**
	     * Set the row configurations for `THEAD`
	     * @param {RowConfig[]|SetRowsCallback} value
	     *    The new header rows or a function to transform the header rows.
	     */
	
	  }, {
	    key: 'setHeadRows',
	    value: function setHeadRows(value) {
	      var headRows = _underscore2.default.isFunction(value) ? value(this.getHeadRows()) : value;
	      this.patch({ rows: { headRows: headRows } });
	    }
	
	    /**
	     * Prepend a set header rows
	     * @param {RowConfig[]} rows - The rows to prepend
	     */
	
	  }, {
	    key: 'prependHeadRows',
	    value: function prependHeadRows(rows) {
	      this.setHeadRows(function (headRows) {
	        return rows.concat(headRows);
	      });
	    }
	
	    /**
	     * Append a set header rows
	     * @param {RowConfig[]} rows - The rows to append
	     */
	
	  }, {
	    key: 'appendHeadRows',
	    value: function appendHeadRows(rows) {
	      this.setHeadRows(function (headRows) {
	        return headRows.concat(rows);
	      });
	    }
	
	    /**
	     * Get the row configurations for `TBODY`
	     * @return {RowConfig[]}
	     */
	
	  }, {
	    key: 'getBodyRows',
	    value: function getBodyRows() {
	      return _underscore2.default.result(this.get('rows'), 'bodyRows', ['data-rows']);
	    }
	
	    /**
	     * Set the row configurations for `TBODY`
	     * @param {RowConfig[]|SetRowsCallback} value
	     *    The new body rows or a function to transform the body rows.
	     */
	
	  }, {
	    key: 'setBodyRows',
	    value: function setBodyRows(value) {
	      var bodyRows = _underscore2.default.isFunction(value) ? value(this.getBodyRows()) : value;
	      this.patch({ rows: { bodyRows: bodyRows } });
	    }
	
	    /**
	     * Prepend a set body rows
	     * @param {RowConfig[]} rows - The rows to prepend
	     */
	
	  }, {
	    key: 'prependBodyRows',
	    value: function prependBodyRows(rows) {
	      this.setBodyRows(function (bodyRows) {
	        return rows.concat(bodyRows);
	      });
	    }
	
	    /**
	     * Append a set body rows
	     * @param {RowConfig[]} rows - The rows to append
	     */
	
	  }, {
	    key: 'appendBodyRows',
	    value: function appendBodyRows(rows) {
	      this.setBodyRows(function (bodyRows) {
	        return bodyRows.concat(rows);
	      });
	    }
	
	    /**
	     * Get the row configurations for `TFOOT`
	     * @return {RowConfig[]}
	     */
	
	  }, {
	    key: 'getFootRows',
	    value: function getFootRows() {
	      return _underscore2.default.result(this.get('rows'), 'footRows', []);
	    }
	
	    /**
	     * Set the row configurations for `TFOOT`
	     * @param {RowConfig[]|SetRowsCallback} value
	     *    The new footer rows or a function to transform the footer rows.
	     */
	
	  }, {
	    key: 'setFootRows',
	    value: function setFootRows(value) {
	      var footRows = _underscore2.default.isFunction(value) ? value(this.getFootRows()) : value;
	      this.patch({ rows: { footRows: footRows } });
	    }
	
	    /**
	     * Prepend a set footer rows
	     * @param {RowConfig[]} rows - The rows to prepend
	     */
	
	  }, {
	    key: 'prependFootRows',
	    value: function prependFootRows(rows) {
	      this.setFootRows(function (footRows) {
	        return rows.concat(footRows);
	      });
	    }
	
	    /**
	     * Append a set footer rows
	     * @param {RowConfig[]} rows - The rows to append
	     */
	
	  }, {
	    key: 'appendFootRows',
	    value: function appendFootRows(rows) {
	      this.setFootRows(function (footRows) {
	        return footRows.concat(rows);
	      });
	    }
	  }, {
	    key: 'items',
	    get: function get() {
	      return _underscore2.default.result(this._chainData.state, 'items', []);
	    }
	  }, {
	    key: 'itemArray',
	    get: function get() {
	      return this.items.slice();
	    }
	
	    /**
	     * The count of data rows.
	     * @type {number}
	     */
	
	  }, {
	    key: 'countRows',
	    get: function get() {
	      return this.items.length;
	    }
	
	    /**
	     * The primary key of data items.
	     * @type {string}
	     */
	
	  }, {
	    key: 'primaryKey',
	    get: function get() {
	      return this._dataSource.primaryKey;
	    }
	
	    /**
	     * The total count of data items. This represents the server side state.
	     * @type {number}
	     */
	
	  }, {
	    key: 'totalCountRows',
	    get: function get() {
	      return _underscore2.default.result(this._chainData.state, 'totalCount', 0);
	    }
	  }]);
	
	  return GridView;
	}(_backbone2.default.View);

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _query = __webpack_require__(77);
	
	Object.defineProperty(exports, 'query', {
	  enumerable: true,
	  get: function get() {
	    return _query.query;
	  }
	});
	
	var _buffer = __webpack_require__(78);
	
	Object.defineProperty(exports, 'buffer', {
	  enumerable: true,
	  get: function get() {
	    return _buffer.buffer;
	  }
	});
	
	var _selection = __webpack_require__(79);
	
	Object.defineProperty(exports, 'selection', {
	  enumerable: true,
	  get: function get() {
	    return _selection.selection;
	  }
	});
	Object.defineProperty(exports, 'setSelectAll', {
	  enumerable: true,
	  get: function get() {
	    return _selection.setSelectAll;
	  }
	});
	Object.defineProperty(exports, 'setSelectRow', {
	  enumerable: true,
	  get: function get() {
	    return _selection.setSelectRow;
	  }
	});
	
	var _columns = __webpack_require__(85);
	
	Object.defineProperty(exports, 'columns', {
	  enumerable: true,
	  get: function get() {
	    return _columns.columns;
	  }
	});
	
	var _rows = __webpack_require__(86);
	
	Object.defineProperty(exports, 'rows', {
	  enumerable: true,
	  get: function get() {
	    return _rows.rows;
	  }
	});
	
	var _columnGroup = __webpack_require__(88);
	
	Object.defineProperty(exports, 'columnGroup', {
	  enumerable: true,
	  get: function get() {
	    return _columnGroup.columnGroup;
	  }
	});
	
	var _cells = __webpack_require__(90);
	
	Object.defineProperty(exports, 'cells', {
	  enumerable: true,
	  get: function get() {
	    return _cells.cells;
	  }
	});
	
	var _sortableHeader = __webpack_require__(91);
	
	Object.defineProperty(exports, 'sortableHeader', {
	  enumerable: true,
	  get: function get() {
	    return _sortableHeader.sortableHeader;
	  }
	});
	
	var _editable = __webpack_require__(93);
	
	Object.defineProperty(exports, 'editable', {
	  enumerable: true,
	  get: function get() {
	    return _editable.editable;
	  }
	});
	
	var _events = __webpack_require__(95);
	
	Object.defineProperty(exports, 'events', {
	  enumerable: true,
	  get: function get() {
	    return _events.events;
	  }
	});

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.query = undefined;
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _jquery = __webpack_require__(9);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _bluebird = __webpack_require__(35);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The data source configurations.
	 * @typedef QueryConfig
	 * @type {Object}
	 * @property {OrderByConfig} orderby
	 *    The sorting parameter.
	 * @property {Object} filter
	 *    The filter object in MangoDB format.
	 * @property {number} skip
	 *    The number of item to skip from the query result.
	 * @property {number} take
	 *    The number of item to take from the query result.
	 */
	
	/**
	 * Fetching data from the data source
	 * @param {DataChainState} state
	 * @param {QueryConfig} params 
	 *    The data source configurations.
	 * @return {DataChainState}
	 */
	function queryProjectionHandler(state, params) {
	  var _this = this;
	
	  var primaryKey = this.primaryKey;
	
	  /**
	   * The `GridView` will reload data from the data source.
	   * @event GridView#willReload
	   */
	  this.trigger('willReload');
	
	  return _bluebird2.default.resolve(this.query(params)).catch(function (error) {
	    console.warn(error);
	    return {
	      totalCount: 0,
	      items: [],
	      error: error
	    };
	  }).then(function (_ref) {
	    var totalCount = _ref.totalCount;
	    var items = _ref.items;
	
	    var itemIndex = {};
	
	    _underscore2.default.each(items, function (item) {
	      if (!_underscore2.default.has(item, primaryKey)) {
	        item[primaryKey] = _underscore2.default.uniqueId('grid-item-');
	      }
	      itemIndex[item[primaryKey]] = item;
	    });
	
	    return {
	      uniqueId: _underscore2.default.uniqueId('grid-data-'),
	      items: items,
	      itemIndex: itemIndex,
	      primaryKey: primaryKey,
	      totalCount: totalCount
	    };
	  }).finally(function () {
	    /**
	     * The `GridView` did reload data from the data source.
	     * @event GridView#didReload
	     */
	    _this.trigger('didReload');
	  });
	}
	
	var query = exports.query = {
	  name: 'query',
	  handler: queryProjectionHandler,
	  defaults: {}
	};

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.buffer = undefined;
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _jquery = __webpack_require__(9);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _bluebird = __webpack_require__(35);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function updateItemState(gridView, item, state) {
	  var buffer = gridView.get('buffer');
	  var changed = {};
	  var key = _underscore2.default.result(item, gridView.primaryKey);
	
	  changed[key] = {
	    item: item,
	    state: state
	  };
	  _underscore2.default.defaults(changed, buffer.changed);
	
	  gridView.set({
	    buffer: _underscore2.default.defaults({ changed: changed }, buffer)
	  });
	}
	
	var buffer = exports.buffer = {
	  name: 'buffer',
	  handler: function handler(state, buffer) {
	    var _this = this;
	
	    var primaryKey = state.primaryKey;
	    var uniqueId = state.uniqueId;
	    var update = state.update;
	
	
	    if (buffer.uniqueId !== uniqueId) {
	      buffer.uniqueId = uniqueId;
	      buffer.changed = {};
	    }
	
	    var items = {
	      length: state.items.length,
	      slice: function slice() {
	        var begin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	        var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : state.items.length;
	
	        return state.items.slice(begin, end).map(function (item) {
	          var key = item[primaryKey];
	
	          if (_underscore2.default.has(buffer.changed, key)) {
	            return buffer.changed[key].item;
	          }
	          return item;
	        });
	      }
	    };
	
	    var onCommit = function onCommit(item) {
	      if (item) {
	        updateItemState(_this, item, 'committed');
	      }
	    };
	
	    var onEdit = function onEdit(item) {
	      if (item) {
	        updateItemState(_this, item, 'changed');
	        if (_underscore2.default.isFunction(update)) {
	          update(item).then(onCommit);
	        }
	      }
	    };
	
	    var events = _underscore2.default.defaults({ didEdit: onEdit }, state.events);
	
	    return _underscore2.default.defaults({ items: items, events: events }, state);
	  },
	
	  defaults: {}
	};

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.selection = undefined;
	exports.setSelectAll = setSelectAll;
	exports.setSelectRow = setSelectRow;
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _singleSelectionResolver = __webpack_require__(80);
	
	var _multipleSelectionResolver = __webpack_require__(82);
	
	var _selectionHead = __webpack_require__(83);
	
	var _selectionHead2 = _interopRequireDefault(_selectionHead);
	
	var _selectionBody = __webpack_require__(84);
	
	var _selectionBody2 = _interopRequireDefault(_selectionBody);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function updateSelection(gridView, selection) {
	  gridView.trigger('willSelect', selection.selected);
	  gridView.set({ selection: selection }, function () {
	    gridView.trigger('didSelect', selection.selected);
	  });
	}
	
	function setSelectAll(gridView, checked) {
	  var _gridView$get = gridView.get('selection');
	
	  var resolver = _gridView$get.resolver;
	
	  var selection = checked ? resolver.selectAll() : resolver.deselectAll();
	
	  updateSelection(gridView, selection);
	}
	
	function changeSelectAll(e) {
	  setSelectAll(this, e.target.checked);
	  e.preventDefault();
	}
	
	function setSelectRow(gridView, key, checked) {
	  var _gridView$get2 = gridView.get('selection');
	
	  var resolver = _gridView$get2.resolver;
	
	  var selection = checked ? resolver.selectRow(key) : resolver.deselectRow(key);
	
	  updateSelection(gridView, selection);
	}
	
	function changeSelectRow(e) {
	  var key = this.keyOfElement(e.target);
	
	  setSelectRow(this, key, e.target.checked);
	  e.preventDefault();
	}
	
	/**
	 * Add selection box to rows
	 * @param {StructureChainState} state
	 *    The input state.
	 * @param {boolean|SelectionConfig} selection
	 *    The selection configuration. It can be
	 *    * A boolean to indicate whether the grid has the selection column.
	 *    * A detailed {@link SelectionConfig} object.
	 */
	function selectionProjectionHandler(state, _ref) {
	  var _this = this;
	
	  var enabled = _ref.enabled;
	  var resolver = _ref.resolver;
	
	  if (!enabled) {
	    return state;
	  }
	
	  var _resolver$updateItems = resolver.updateItems(state.items);
	
	  var selected = _resolver$updateItems.selected;
	  var single = _resolver$updateItems.single;
	  var colClasses = _resolver$updateItems.colClasses;
	  var headClasses = _resolver$updateItems.headClasses;
	  var bodyClasses = _resolver$updateItems.bodyClasses;
	  var footClasses = _resolver$updateItems.footClasses;
	  var selectable = _resolver$updateItems.selectable;
	
	
	  var selectedIndex = _underscore2.default.reduce(selected, function (memo, key) {
	    memo[key] = true;
	    return memo;
	  }, {});
	  var primaryKey = state.primaryKey;
	  var selectedAll = false;
	
	  /**
	   * Callback to decide whether a row is selectable.
	   * @callback SelectableCallback
	   * @param {Object} item
	   *    The data item of the row.
	   * @return {boolean} 
	   */
	  if (!single) {
	    var selectableCount = _underscore2.default.filter(state.items.slice(), selectable).length;
	    var selectedCount = _underscore2.default.filter(selected, function (key) {
	      return selectable(_this.itemWithKey(key));
	    }).length;
	
	    selectedAll = selectedCount === selectableCount;
	  }
	
	  var columns = [{
	    name: 'selection',
	    html: (0, _selectionHead2.default)({
	      single: single,
	      checked: selectedAll
	    }),
	    template: _selectionBody2.default,
	    property: function property(item) {
	      return {
	        single: single,
	        selectable: selectable(item),
	        checked: selectedIndex[item[primaryKey]]
	      };
	    },
	    sortable: false,
	    colClasses: colClasses,
	    headClasses: headClasses,
	    bodyClasses: bodyClasses,
	    footClasses: footClasses
	  }].concat(state.columns);
	
	  var events = _underscore2.default.defaults({
	    'change th input.select-all': changeSelectAll,
	    'change td input.select-row': changeSelectRow
	  }, state.events);
	
	  return _underscore2.default.defaults({ columns: columns, events: events }, state);
	}
	
	/**
	 * Normalize the selection config
	 * @param {boolean|SelectionConfig} selection
	 *    The selection configuration.
	 */
	function normalizeSelectionConfig(selection) {
	  var _this2 = this;
	
	  if (!selection) {
	    return { enabled: false };
	  }
	
	  /**
	   * @typedef SelectionConfig
	   * @type {Object}
	   * @property {boolean} enabled
	   *    Whether the selection feature is enabled.
	   * @property {boolean} single
	   *    True if only 1 row can be selected at the same time.
	   * @property {string[]} selected
	   *    The primary key of rows being selected.
	   * @property {SelectableCallback} selectable
	   *    A callback to decide whether a row is selectable.
	   * @property {ClassesConfig} colClasses
	   *    The classes of the 'COL' element for the selection column.
	   * @property {ClassesConfig} headClasses
	   *    The classes of the 'TH' element in 'THEAD' of the selection column.
	   * @property {ClassesConfig} bodyClasses
	   *    The classes of the 'TD' elements in 'TBODY' of the selection column.
	   * @property {ClassesConfig} footClasses
	   *    The classes of the 'TD' elements in 'TFOOT' of the selection column.
	   */
	  var config = _underscore2.default.defaults({}, _underscore2.default.isObject(selection) ? selection : {}, {
	    enabled: true,
	    single: false,
	    selected: [],
	    selectable: function selectable(item) {
	      return _underscore2.default.has(item, _this2.primaryKey);
	    },
	    colClasses: [],
	    headClasses: [],
	    bodyClasses: [],
	    footClasses: []
	  });
	
	  if (!_underscore2.default.isFunction(config.Resolver)) {
	    config.Resolver = config.single ? _singleSelectionResolver.SingleSelectionResolver : _multipleSelectionResolver.MultipleSelectionResolver;
	  }
	
	  if (!(config.resolver instanceof config.Resolver)) {
	    config.resolver = new config.Resolver(this);
	  }
	
	  return config;
	}
	
	var selection = exports.selection = {
	  name: 'selection',
	  handler: selectionProjectionHandler,
	  normalize: normalizeSelectionConfig,
	  defaults: false
	};

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SingleSelectionResolver = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _selectionResolver = __webpack_require__(81);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SingleSelectionResolver = exports.SingleSelectionResolver = function (_SelectionResolver) {
	  _inherits(SingleSelectionResolver, _SelectionResolver);
	
	  function SingleSelectionResolver() {
	    _classCallCheck(this, SingleSelectionResolver);
	
	    return _possibleConstructorReturn(this, (SingleSelectionResolver.__proto__ || Object.getPrototypeOf(SingleSelectionResolver)).apply(this, arguments));
	  }
	
	  _createClass(SingleSelectionResolver, [{
	    key: 'selectRow',
	    value: function selectRow(key) {
	      return this.patch({ selected: [key.toString()] });
	    }
	  }]);

	  return SingleSelectionResolver;
	}(_selectionResolver.SelectionResolver);

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SelectionResolver = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SelectionResolver = exports.SelectionResolver = function () {
	  function SelectionResolver(gridView) {
	    _classCallCheck(this, SelectionResolver);
	
	    this.gridView = gridView;
	  }
	
	  _createClass(SelectionResolver, [{
	    key: 'updateItems',
	    value: function updateItems() {
	      return this.patch({});
	    }
	  }, {
	    key: 'selectRow',
	    value: function selectRow() {
	      throw new Error('Not Supported');
	    }
	  }, {
	    key: 'deselectRow',
	    value: function deselectRow() {
	      throw new Error('Not Supported');
	    }
	  }, {
	    key: 'selectAll',
	    value: function selectAll() {
	      throw new Error('Not Supported');
	    }
	  }, {
	    key: 'deselectAll',
	    value: function deselectAll() {
	      throw new Error('Not Supported');
	    }
	  }, {
	    key: 'patch',
	    value: function patch(options) {
	      var selectionCur = this.gridView.get('selection');
	      var selection = _underscore2.default.isFunction(options) ? options(selectionCur) : options;
	
	      return _underscore2.default.defaults(selection, selectionCur);
	    }
	  }]);

	  return SelectionResolver;
	}();

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MultipleSelectionResolver = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _selectionResolver = __webpack_require__(81);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MultipleSelectionResolver = exports.MultipleSelectionResolver = function (_SelectionResolver) {
	  _inherits(MultipleSelectionResolver, _SelectionResolver);
	
	  function MultipleSelectionResolver() {
	    _classCallCheck(this, MultipleSelectionResolver);
	
	    return _possibleConstructorReturn(this, (MultipleSelectionResolver.__proto__ || Object.getPrototypeOf(MultipleSelectionResolver)).apply(this, arguments));
	  }
	
	  _createClass(MultipleSelectionResolver, [{
	    key: 'selectRow',
	    value: function selectRow(key) {
	      return this.patch(function (_ref) {
	        var selected = _ref.selected;
	        return {
	          selected: _underscore2.default.union(selected, [key.toString()])
	        };
	      });
	    }
	  }, {
	    key: 'deselectRow',
	    value: function deselectRow(key) {
	      return this.patch(function (_ref2) {
	        var selected = _ref2.selected;
	        return {
	          selected: _underscore2.default.without(selected, key.toString())
	        };
	      });
	    }
	
	    // Select all selectalbe items
	
	  }, {
	    key: 'selectAll',
	    value: function selectAll() {
	      var _this2 = this;
	
	      return this.patch(function (_ref3) {
	        var selectable = _ref3.selectable;
	        var selected = _ref3.selected;
	
	        var patch = {};
	
	        patch.selected = _underscore2.default.chain(_this2.gridView.items.slice()).filter(selectable).map(_underscore2.default.property(_this2.gridView.primaryKey)).map(String).union(selected).value();
	
	        return patch;
	      });
	    }
	
	    // Deselect all selectable items
	
	  }, {
	    key: 'deselectAll',
	    value: function deselectAll() {
	      var _this3 = this;
	
	      return this.patch(function (_ref4) {
	        var selectable = _ref4.selectable;
	        var selected = _ref4.selected;
	
	        var patch = {};
	
	        patch.selected = _underscore2.default.filter(selected, function (key) {
	          var item = _this3.gridView.itemWithKey(key);
	
	          return !(item && selectable(item));
	        });
	
	        return patch;
	      });
	    }
	  }]);

	  return MultipleSelectionResolver;
	}(_selectionResolver.SelectionResolver);

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (checked, single) {
	if ( single)
	{
	buf.push("<span></span>");
	}
	else
	{
	buf.push("<input type=\"checkbox\"" + (jade.attr("checked", checked, true, true)) + " class=\"select-all\">");
	}}.call(this,"checked" in locals_for_with?locals_for_with.checked:typeof checked!=="undefined"?checked:undefined,"single" in locals_for_with?locals_for_with.single:typeof single!=="undefined"?single:undefined));;return buf.join("");
	}

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (value) {
	if ( value.selectable)
	{
	if ( value.single)
	{
	buf.push("<input type=\"radio\"" + (jade.attr("checked", value.checked, true, true)) + " class=\"select-row\">");
	}
	else
	{
	buf.push("<input type=\"checkbox\"" + (jade.attr("checked", value.checked, true, true)) + " class=\"select-row\">");
	}
	}
	else
	{
	buf.push("<span class=\"unselectable\"></span>");
	}}.call(this,"value" in locals_for_with?locals_for_with.value:typeof value!=="undefined"?value:undefined));;return buf.join("");
	}

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.columns = undefined;
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @typedef ColumnConfig
	 * @type {Object}
	 * @property {string} name
	 *    Name of the column.
	 * @property {string} title
	 *    The localized column title. The `name` will be used if `title` is omitted.
	 * @property {string} html
	 *    The HTML string to be rendered in the column header. The `title` string
	 *    will be rendered in the column header if `html` is omitted.
	 * @property {(string|PropertyCallback|PropertyConfig)} property
	 *    The data property of the column. It defines how to get/set values with
	 *    a data item. If it's omitted, will use the column `name` as the key path.
	 *    It could be
	 *
	 *    * A key path string. E.g. 'Foo/Bar'.
	 *    * A {@link PropertyCallback} function
	 *    * A {@link PropertyConfig} object
	 *
	 * @property {CellTemplate} template
	 *    The template to render a cell for the column.
	 *
	 * @property {(boolean|number|OrderByKey)} sortable
	 *    The ordering configuration. If it's omitted, the column is unsortable.
	 *    It could be
	 *
	 *    * A boolean simply say the column is sortable or not.
	 *    * A number, positive for ascending first, otherwise descending first.
	 *    * A string, the key path of the sorting values.
	 *    * A {@link PropertyGetter} to get the sorting values from data items.
	 *      Only available for memory data source.
	 *    * A detailed {@link SortableConfig} object.
	 *
	 * @property {bool} editable
	 *    Indicates whether the column is editable.
	 * @property {ClassesConfig} colClasses
	 *    The classes for the `COL` element in `COLGROUP`.
	 * @property {ClassesConfig} headClasses
	 *    The classes for the `TH` element in `THEAD`.
	 * @property {ClassesConfig} bodyClasses
	 *    The classes for the `TD` elements in `TBODY`.
	 * @property {ClassesConfig} footClasses
	 *    The classes for the `TD` elements in `TFOOT`.
	 * @property {ColumnConfig[]} columns
	 *    The children columns.
	 */
	
	/**
	 * Columns projection handling columns configuration
	 * @param {Object} state
	 * @param {(object[]|FakeArray)} [state.items]
	 *    Original data items from data source.
	 * @param {ColumnConfig[]} [columns]
	 *    Columns configuration defined by user. If omitted, all columns in original
	 *    data will be shown.
	 */
	function columnsProjectionHandler(state, columns) {
	  return _underscore2.default.defaults({
	    columns: columns || _underscore2.default.chain(state.items.slice(0, 1)).first().keys().map(function (name) {
	      return {
	        name: name,
	        sortable: true
	      };
	    }).value()
	  }, state);
	}
	
	var columns = exports.columns = {
	  name: 'columns',
	  handler: columnsProjectionHandler,
	  defaults: null
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.rows = undefined;
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _common = __webpack_require__(87);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var bufferStateClasses = {
	  'changed': ['row-buffer-changed'],
	  'committed': ['row-buffer-committed']
	};
	
	/**
	 * Configuration for a row. It can be an object or a special
	 * @typedef RowConfig
	 * @type {(string|Object)}
	 * @property {?string} type
	 *    Optional parameter to define the type of the row. Special values are
	 *    * `'data-rows'`. A row configuration which will be expanded into
	 *      multiple rows representing each of the data items.
	 *    * `'data'`. Indicating the row is expanded from the `'data-rows'`.
	 *
	 * @property {?ClassesConfig} classes
	 *    Classes of the `TR` element.
	 * @property {?Object} item
	 *    The data item for the row.
	 * @property {?string} html
	 *    The HTML string rendered in a cell taking the entire row.
	 * @property {?Backbone.View} view
	 *    The Backbone View take the place of the entire row. This is is only for
	 *    the header and footer rows.
	 */
	
	/**
	 * The configuration for rows projection. When defining header rows, it can be
	 * a special string `'column-header-rows'`, representing all the column header
	 * rows.
	 * @typedef RowsConfig
	 * @type {(string|Object)}
	 * @property {RowConfig[]} headRows
	 *    Row configurations for `THEAD`. It can take a special string value
	 *    `column-header-rows`, which will be expanded into the column headers.
	 * @property {RowConfig[]} bodyRows
	 *    Row configurations for `TBODY`. It can take a special row with type
	 *    `data-rows`. This row will be expanded, one for each data item.
	 * @property {RowConfig[]} footRows - Row configurations for `TFOOT`.
	 */
	
	/**
	 * Handling bodyRows and adding headRows, bodyRows, footRows to state
	 * @param {StructureChainState} state - The input state.
	 * @param {RowsConfig} options - The configuration for rows projection.
	 * @return {StructureChainState}
	 */
	function rowsProjectionHandler(state) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	  var _ref$headRows = _ref.headRows;
	  var headRows = _ref$headRows === undefined ? ['column-header-rows'] : _ref$headRows;
	  var _ref$footRows = _ref.footRows;
	  var footRows = _ref$footRows === undefined ? [] : _ref$footRows;
	  var _ref$bodyRows = _ref.bodyRows;
	  var bodyRows = _ref$bodyRows === undefined ? ['data-rows'] : _ref$bodyRows;
	
	  var patch = { headRows: headRows, footRows: footRows };
	
	  var primaryKey = state.primaryKey;
	  var changed = this.get('buffer').changed || {};
	
	  // TODO [wewei], use Fake items for better performance.
	  var items = state.items.slice(0, state.items.length);
	
	  patch.bodyRows = _underscore2.default.reduce(bodyRows, function (memo, row) {
	    if (row === 'data-rows' || row.type === 'data-rows') {
	      _underscore2.default.each(items, function (item) {
	        var key = item[primaryKey];
	        var bufferState = _underscore2.default.chain(changed).result(key).result('state').value();
	        var classes = _underscore2.default.union((0, _common.normalizeClasses)(row.classes, item), _underscore2.default.result(bufferStateClasses, bufferState, []));
	
	        memo.push({ item: item, classes: classes, type: 'data' });
	      });
	    } else if (row.view) {
	      throw new Error('Body row cannot have subviews');
	    } else {
	      memo.push(row);
	    }
	
	    return memo;
	  }, []);
	
	  return _underscore2.default.defaults(patch, state);
	}
	
	var rows = exports.rows = {
	  name: 'rows',
	  handler: rowsProjectionHandler,
	  defaluts: {}
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.normalizeClasses = normalizeClasses;
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The classes configuration. It could be
	 *    * A array of class strings
	 *    * A space separated classes string
	 *    * A hash from class names to {@link ClassPredicate}
	 * @typedef ClassesConfig
	 * @type {(string[]|string|Object.<string, ClassPredicate>)}
	 */
	
	/**
	 * Normalize the classes configuration
	 * @param {ClassesConfig} classes
	 *    The classes configuration.
	 * @param {Object} context
	 *    The context for the classes. It could be
	 *    * A {@link ColumnConfig} for a column's headClasses/colClasses
	 *    * A {@link RowConfig} for a column or row's bodyClasses/footClasses
	 *
	 * @return {string[]}
	 *    The normalized classes configuration.
	 */
	function normalizeClasses(classes, context) {
	  if (_underscore2.default.isArray(classes)) {
	    return classes;
	  } else if (_underscore2.default.isString(classes)) {
	    return classes.split(/\s+/);
	  } else if (_underscore2.default.isFunction(classes)) {
	    return classes(context);
	  } else if (_underscore2.default.isObject(classes)) {
	    return _underscore2.default.chain(classes).pairs().filter(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 2);
	
	      var key = _ref2[0];
	      var value = _ref2[1];
	
	      /**
	       * A boolean or a callback to decide whether or not a class is applied.
	       * When it's a function, it takes the context and return a boolean.
	       * @typedef ClassPredicate
	       * @type {(boolean|ClassPredicateCallback)}
	       */
	      var isFunc = _underscore2.default.isFunction(value);
	
	      /**
	       * @callback ClassPredicateCallback
	       * @param {Object} context
	       *    Refer to the `context` of {@link normalizeClasses}.
	       * @return {boolean}
	       *    Whether or not the class is applied.
	       */
	      return isFunc && value(context) || !isFunc && Boolean(value);
	    }).map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2);
	
	      var key = _ref4[0];
	      var value = _ref4[1];
	      return key;
	    }).value();
	  }
	  return [];
	}

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.columnGroup = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _common = __webpack_require__(87);
	
	var _defaultCell = __webpack_require__(89);
	
	var _defaultCell2 = _interopRequireDefault(_defaultCell);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function stringProperty(property) {
	  var segs = property.split('/');
	
	  return {
	    key: property,
	    get: function get(item) {
	      return _underscore2.default.reduce(segs, function (memo, key) {
	        return (memo || {})[key];
	      }, item);
	    },
	    set: function set(item, value) {
	      return _underscore2.default.reduce(segs, function (memo, seg, index) {
	        if (index < segs.length - 1) {
	          if (!_underscore2.default.isObject(memo[seg])) {
	            memo[seg] = {};
	          }
	        } else {
	          memo[seg] = value;
	        }
	      }, item);
	    }
	  };
	}
	
	/**
	 * @typedef PropertyConfig
	 * @type {Object}
	 * @property {PropertyGetter} get - The getter function.
	 * @property {PropertySetter} set - The setter function.
	 */
	
	/**
	 * @callback PropertyGetter
	 * @param {Object} item - The data item.
	 * @return {} - The value for the property.
	 */
	
	/**
	 * @callback PropertySetter
	 * @param {Object} item - The data item.
	 * @param {} value - The value for the property.
	 */
	
	/**
	 * It behaves as a {@link PropertyGetter} when passed 1 argument, and behaves
	 * as a {@link PropertySetter} when passed 2 arguments.
	 * @callback PropertyCallback
	 * @param {Object} item - The data item.
	 * @param {} [value] - The new value for the property.
	 * @return {} - The value for the property.
	 */
	
	function normalizeProperty(property, column) {
	  if (!property) {
	    return stringProperty(column.name);
	  }
	
	  if (_underscore2.default.isString(property)) {
	    return stringProperty(property);
	  }
	
	  if (_underscore2.default.isFunction(property)) {
	    return {
	      get: property,
	      set: property
	    };
	  }
	
	  return property;
	}
	
	/**
	 * @typedef SortableConfig
	 * @type {Object}
	 * @property {string|PropertyGetter} key
	 *    The sort key. It could be
	 *    * A string, the key path of the sorting values.
	 *    * A {@link PropertyGetter} to get the sorting values from data items.
	 *      Only available for memory data source.
	 *
	 * @property {number} direction
	 *    A number indicating the order on first click. Positive for ascending,
	 *    otherwise descending.
	 * @property {SortableHeaderTemplate} template
	 *    A customized template to render the sortable column header.
	 */
	
	function normalizeSortable(sortable, column) {
	  var columnKey = column.property.key || column.property.get;
	
	  if (sortable === true) {
	    return {
	      key: columnKey,
	      direction: 1
	    };
	  }
	
	  if (_underscore2.default.isString(sortable) || _underscore2.default.isFunction(sortable)) {
	    return {
	      key: sortable,
	      direction: 1
	    };
	  }
	
	  if (_underscore2.default.isNumber(sortable) && sortable) {
	    return {
	      key: columnKey,
	      direction: sortable > 0 ? 1 : -1
	    };
	  }
	
	  if (_underscore2.default.isObject(sortable)) {
	    return _underscore2.default.extend({
	      key: columnKey,
	      direction: 1
	    }, sortable);
	  }
	
	  return null;
	}
	
	/**
	 * The column group class.
	 *
	 * It takes columns configuration as input and generates headerRows, leafColumns,
	 * columnIndex and root(a tree-like column structure).
	 *
	 * @param {ColumnConfig[]} columns
	 *    The columns configuration
	 */
	
	var ColumnGroup = function () {
	  function ColumnGroup(columns) {
	    var _this = this;
	
	    _classCallCheck(this, ColumnGroup);
	
	    /**
	     * The column header rows
	     * @type {RowContent[]}
	     */
	    this.headerRows = [];
	
	    /**
	     * The leaf columns
	     * @type {ExtendedColumnConfig[]}
	     */
	    this.leafColumns = [];
	
	    /**
	     * The columns indexed by name
	     * @type {Object.<string,ExtendedColumnConfig>}
	     */
	    this.columnIndex = {};
	
	    /*
	     * Build tree-like columns structure using DFS
	     */
	    var buildColumn = function buildColumn(col) {
	      /**
	       * An extended internal representation of columns. It extends
	       * {@link ColumnConfig} with several extra properties.
	       * @typedef ExtendedColumnConfig
	       * @type ColumnConfig
	       * @property {ExtendedColumnConfig} parent
	       *    The parent column if there's a column hierarchy.
	       * @property {ExtendedColumnConfig[]} columns
	       *    The children columns.
	       * @property {CellContent} cell
	       *    The configuration of the header cell.
	       * @property {number} height
	       *    The rowspan of the header cell.
	       * @property {number} treeWidth
	       *    The colspan of the header cell. The tree width of the column
	       *    subtree in number of columns.
	       * @property {number} treeHeight
	       *    The height of the column subtree in number of rows.
	       */
	      var parent = col.parent;
	      var columns = col.columns;
	      var height = col.height;
	      var name = col.name;
	      var property = col.property;
	      var sortable = col.sortable;
	
	
	      _this.columnIndex[name] = col;
	
	      col.property = normalizeProperty(property, col);
	      col.sortable = normalizeSortable(sortable, col);
	
	      if (!_underscore2.default.isFunction(col.template)) {
	        col.template = _defaultCell2.default;
	      }
	      col.height = _underscore2.default.isNumber(height) ? height : 1;
	      col.rowIndex = parent ? parent.rowIndex + parent.height : 0;
	      col.columns = _underscore2.default.map(columns, function (c) {
	        return buildColumn(_underscore2.default.extend({ parent: col }, c));
	      });
	      col.treeHeight = col.height;
	      col.treeWidth = 1;
	      if (!_underscore2.default.isEmpty(col.columns)) {
	        col.treeHeight += _underscore2.default.chain(col.columns).map(_underscore2.default.property('treeHeight')).max().value();
	        col.treeWidth = _underscore2.default.chain(col.columns).map(_underscore2.default.property('treeWidth')).reduce(function (a, b) {
	          return a + b;
	        }, 0).value();
	      } else {
	        _this.leafColumns.push(col);
	      }
	
	      return col;
	    };
	
	    /*
	     * Build column header with DFS
	     */
	    var buildColumnHeader = function buildColumnHeader(col) {
	      if (col.parent) {
	        var colspan = col.treeWidth;
	        var rowspan = _underscore2.default.isEmpty(col.columns) ? _this.root.treeHeight - col.rowIndex : col.height;
	        var name = col.name;
	        var html = col.html || col.title || col.name;
	
	        while (_this.headerRows.length <= col.rowIndex) {
	          _this.headerRows.push({ cells: [], attributes: {} });
	        }
	
	        var classes = _underscore2.default.union((0, _common.normalizeClasses)(col.headClasses, col), ['column-header']);
	        if (_underscore2.default.isEmpty(col.columns)) {
	          classes.push('column-header-leaf');
	        }
	        var attributes = {
	          colspan: colspan,
	          rowspan: rowspan,
	          'data-name': name
	        };
	        col.cell = { html: html, name: name, classes: classes, attributes: attributes };
	        _this.headerRows[col.rowIndex].cells.push(col.cell);
	      }
	      _underscore2.default.each(col.columns, buildColumnHeader);
	    };
	
	    /**
	     * The root column
	     * @type {ExtendedColumnConfig}
	     */
	    this.root = buildColumn({
	      name: '__root__',
	      height: 0,
	      columns: columns
	    });
	
	    buildColumnHeader(this.root);
	  }
	
	  _createClass(ColumnGroup, [{
	    key: 'columnWithName',
	    value: function columnWithName(name) {
	      return this.columnIndex[name];
	    }
	  }, {
	    key: 'height',
	    get: function get() {
	      return this.root.treeHeight;
	    }
	  }, {
	    key: 'width',
	    get: function get() {
	      return this.root.treeWidth;
	    }
	  }]);
	
	  return ColumnGroup;
	}();
	
	function translateColumnGroup(columnGroup) {
	  return _underscore2.default.map(columnGroup.leafColumns, function (col) {
	    var colClasses = _underscore2.default.union((0, _common.normalizeClasses)(col.colClasses, col), ['col-' + col.name]);
	    /**
	     * The content of a `COL` element in `COLGROUP`.
	     * @typedef ColContent
	     * @type {Object}
	     * @property {string[]} classes
	     *    The classes of the `COL` element.
	     * @property {number|string} width
	     *    The CSS width for the column.
	     */
	    return {
	      classes: colClasses,
	      width: _underscore2.default.isNumber(col.width) ? col.width + 'px' : col.width
	    };
	  });
	}
	
	/**
	 * Resolve grid structure from columns configuration and build the
	 * {@link ColumnGroup} object.
	 *
	 * @param {ContentChainState} state
	 *    The input content chain state.
	 * @return {ContentChainState}
	 */
	function columnGroupProjectionHandler(state) {
	  var columnGroup = new ColumnGroup(state.columns || []);
	  return _underscore2.default.defaults({
	    columnGroup: columnGroup,
	    cols: translateColumnGroup(columnGroup)
	  }, state);
	}
	
	var columnGroup = exports.columnGroup = {
	  name: 'columnGroup',
	  handler: columnGroupProjectionHandler,
	  defaults: {}
	};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (value) {
	buf.push("<span>" + (jade.escape(null == (jade_interp = value) ? "" : jade_interp)) + "</span>");}.call(this,"value" in locals_for_with?locals_for_with.value:typeof value!=="undefined"?value:undefined));;return buf.join("");
	}

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.cells = undefined;
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _common = __webpack_require__(87);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Translate the {@link RowConfig} into {@link RowContent}
	 * @param {Object} options
	 * @param {ColumnGroup} options.columnGroup
	 *    The column group.
	 * @param {RowConfig} options.row
	 *    The {@link RowConfig} to translate.
	 * @param {string} rowType
	 *    Which group the row belongs to. It could be 'head', 'body' or 'foot'.
	 * @param {string} primaryKey
	 *    The primary key of the data items.
	 * @return {RowContent}
	 */
	function translateRow(_ref) {
	  var columnGroup = _ref.columnGroup;
	  var row = _ref.row;
	  var rowType = _ref.rowType;
	  var primaryKey = _ref.primaryKey;
	
	  var patch = {};
	
	  if (_underscore2.default.has(row, 'html')) {
	    patch.cells = [{
	      attributes: {
	        rowspan: 1,
	        colspan: columnGroup.width
	      },
	      html: row.html
	    }];
	  }
	  if (_underscore2.default.has(row, 'view')) {
	    patch.cells = [{
	      attributes: {
	        rowspan: 1,
	        colspan: columnGroup.width
	      },
	      view: row.view
	    }];
	  }
	  if (_underscore2.default.has(row, 'item')) {
	    patch.cells = _underscore2.default.map(columnGroup.leafColumns, function (col) {
	      var cellClasses = void 0;
	      if (rowType === 'foot') {
	        cellClasses = (0, _common.normalizeClasses)(col.footClasses, row);
	      } else if (rowType === 'body') {
	        cellClasses = (0, _common.normalizeClasses)(col.bodyClasses, row);
	      } else if (rowType === 'head') {
	        cellClasses = (0, _common.normalizeClasses)(col.headClasses, row);
	      }
	      /**
	       * The object represents a cell.
	       * @typedef CellContent
	       * @type {Object}
	       * @property {string[]} classes
	       *    The classes for the `TD`/`TH` element
	       * @property {Object.<string,string>} attributes
	       *    The HTML attributes for the `TD`/`TH` element.
	       * @property {string} html
	       *    The HTML string to be rendered inside the cell.
	       * @property {Backbone.View} view
	       *    The Backbone View to be filled into the cell. Unsupported for
	       *    the body cells.
	       */
	      var cell = { classes: cellClasses, attributes: {} };
	      cell.value = col.property.get(row.item);
	      cell.html = col.template(_underscore2.default.pick(cell, 'value'));
	
	      return cell;
	    });
	
	    patch.attributes = _underscore2.default.defaults({
	      'data-key': row.item[primaryKey]
	    }, row.attributes);
	  }
	
	  /**
	   * Extends the {@link RowConfig} with extra properties
	   * @typedef RowContent
	   * @type {RowConfig}
	   * @property {CellContent[]} cells
	   *    The cells in the row.
	   * @property {Object.<string,string>} attributes
	   *    The HTML attributes for the `TR` element.
	   */
	  return _underscore2.default.defaults(patch, row, { attributes: {} });
	}
	
	/**
	 * Fill the headRows, bodyRows and footRows with cells.
	 * @param {ContentChainState} state
	 *    All data, configurations and events needed in grid cells.
	 * @return {ContentChainState}
	 */
	function cellsProjectionHandler(state) {
	  var columnGroup = state.columnGroup;
	  var primaryKey = this.primaryKey;
	
	  var headRows = _underscore2.default.reduce(state.headRows, function (memo, row) {
	    if (row === 'column-header-rows') {
	      return memo.concat(columnGroup.headerRows);
	    }
	    memo.push(translateRow({
	      columnGroup: columnGroup,
	      row: row,
	      rowType: 'head',
	      primaryKey: primaryKey
	    }));
	    return memo;
	  }, []);
	
	  var bodyRows = {
	    length: state.bodyRows.length,
	    slice: function slice() {
	      var begin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : state.bodyRows.length;
	
	      return state.bodyRows.slice(begin, end).map(function (row) {
	        return translateRow({
	          columnGroup: columnGroup,
	          row: row,
	          rowType: 'body',
	          primaryKey: primaryKey
	        });
	      });
	    }
	  };
	
	  var footRows = _underscore2.default.map(state.footRows, function (row) {
	    return translateRow({
	      columnGroup: columnGroup,
	      row: row,
	      rowType: 'foot',
	      primaryKey: primaryKey
	    });
	  });
	
	  return _underscore2.default.defaults({
	    headRows: headRows,
	    bodyRows: bodyRows,
	    footRows: footRows
	  }, state);
	}
	
	var cells = exports.cells = {
	  name: 'cells',
	  handler: cellsProjectionHandler,
	  defaults: {}
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.sortableHeader = undefined;
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _sortableHeader = __webpack_require__(92);
	
	var _sortableHeader2 = _interopRequireDefault(_sortableHeader);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var regexKey = /\s*(-)?\s*(\w+)/;
	
	// Reorder column data referring to 'column.sortable'.
	// 'column.sortable' takes four types of values: boolean, number, string and function.
	function reorder(e) {
	  var name = this.$(e.target).closest('th').attr('data-name');
	  var sortable = this.columnWithName(name).sortable;
	
	  if (sortable) {
	    var sortableHeaderCur = this.get('sortableHeader') || {};
	    var direction = sortable.direction;
	
	    if (sortableHeaderCur.name === name) {
	      direction = -sortableHeaderCur.direction;
	    }
	
	    this.patch({
	      query: {
	        orderby: [{
	          key: sortable.key,
	          direction: direction
	        }]
	      },
	      sortableHeader: { name: name, direction: direction }
	    });
	  }
	}
	
	/**
	 * Add click event to sortable column and wrap sortable column's head with a template
	 * @param {ContentChainState} state
	 *    The input state.
	 * @param {SortableHeaderConfig} options
	 *    The sortable header configurations.
	 */
	function sortableHeaderProjectionHandler(state) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	  var name = _ref.name;
	  var direction = _ref.direction;
	  var _ref$template = _ref.template;
	  var template = _ref$template === undefined ? _sortableHeader2.default : _ref$template;
	
	  /**
	   * @typedef SortableHeaderConfig
	   * @type {Object}
	   * @property {string} name
	   *    The name of the ordered column.
	   * @property {number} direction
	   *    The order direction. Positive for ascending, otherwise descending.
	   * @property {?SortableHeaderTemplate} template
	   *    The template to render the sortable column headers.
	   */
	  var patch = {};
	  var leafColumns = state.columnGroup.leafColumns;
	  var leafColumnIndex = _underscore2.default.reduce(leafColumns, function (memo, col) {
	    memo[col.name] = col;
	    return memo;
	  }, {});
	
	  patch.headRows = _underscore2.default.map(state.headRows, function (row) {
	    var cells = _underscore2.default.map(row.cells, function (cell) {
	      var patchCell = {};
	      var column = leafColumnIndex[cell.name];
	
	      if (column && column.sortable) {
	        patchCell.classes = cell.classes.concat('column-header-sortable');
	
	        var decorationTemplate = column.sortable.template || template;
	
	        /**
	         * @callback SortableHeaderTemplate
	         * @param {Object} locals
	         * @param {string} locals.html
	         *    The original HTML string for the column header.
	         * @param {number} locals.direction
	         *    The sort state.
	         *    * Positive value for ascending.
	         *    * Negative value for descending.
	         *    * 0 for not sorted.
	         */
	        patchCell.html = decorationTemplate({
	          html: cell.html,
	          direction: column.name === name ? direction : 0
	        });
	      }
	
	      return _underscore2.default.defaults(patchCell, cell);
	    });
	
	    return _underscore2.default.defaults({ cells: cells }, row);
	  });
	
	  patch.events = _underscore2.default.defaults({
	    'click th.column-header-sortable': reorder
	  }, state.events);
	
	  return _underscore2.default.defaults(patch, state);
	}
	
	var sortableHeader = exports.sortableHeader = {
	  name: 'sortableHeader',
	  handler: sortableHeaderProjectionHandler,
	  defaults: {}
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (direction, html) {
	if ( direction < 0)
	{
	buf.push("<span class=\"sort-indicator glyphicon glyphicon-arrow-down\"></span>");
	}
	else if ( direction > 0)
	{
	buf.push("<span class=\"sort-indicator glyphicon glyphicon-arrow-up\"></span>");
	}
	buf.push(null == (jade_interp = html) ? "" : jade_interp);}.call(this,"direction" in locals_for_with?locals_for_with.direction:typeof direction!=="undefined"?direction:undefined,"html" in locals_for_with?locals_for_with.html:typeof html!=="undefined"?html:undefined));;return buf.join("");
	}

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.editable = undefined;
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _jquery = __webpack_require__(9);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _editable = __webpack_require__(94);
	
	var _editable2 = _interopRequireDefault(_editable);
	
	var _index = __webpack_require__(34);
	
	var _index2 = _interopRequireDefault(_index);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function deepClone(obj) {
	  if (_underscore2.default.isArray(obj)) {
	    return _underscore2.default.map(obj, deepClone);
	  } else if (_underscore2.default.isObject(obj)) {
	    return _underscore2.default.mapObject(obj, deepClone);
	  }
	  return obj;
	}
	
	function editInColumn(column) {
	  return function (e) {
	    var _this = this;
	
	    var $td = (0, _jquery2.default)(e.target).closest('td');
	    var key = this.keyOfElement(e.target);
	    var item = this.itemWithKey(key);
	
	    if ($td.hasClass('grid-editable-cell')) {
	      this.trigger('willEdit', item);
	
	      var promptPos = {};
	      var offset = $td.offset();
	      if (offset.left > window.innerWidth * 0.9) {
	        promptPos.right = document.body.clientWidth - offset.left;
	      } else {
	        promptPos.left = offset.left;
	      }
	
	      promptPos.top = offset.top;
	
	      (0, _index2.default)({
	        model: deepClone(item),
	        position: promptPos,
	        property: column.name,
	        onSubmit: function onSubmit(model) {
	          _this.trigger('didEdit', _underscore2.default.isEqual(model, item) ? null : model);
	        },
	        onCancel: function onCancel(model) {
	          _this.trigger('didEdit', null);
	        }
	      });
	    }
	  };
	}
	
	var editable = exports.editable = {
	  name: 'editable',
	
	  /**
	   * Enable editing and wrap each editable cell with a template
	   *
	   * @param {Object} state
	   * @param {ColumnGroup} [state.columnGroup] Column group information
	   * @param {Object} [state.bodyRows]
	   * @param {Number} [state.bodyRows.length] bodyRows' length
	   * @param {Function} [state.bodyRows.slice] Get bodyRows element
	   * @param {Object} [state.events] Backbone view events handler
	   * 
	   */
	  handler: function handler(state) {
	    var leafColumns = state.columnGroup.leafColumns;
	    var iconClasses = ['glyphicon', 'glyphicon-pencil'];
	    var events = _underscore2.default.reduce(leafColumns, function (memo, col) {
	      memo['click td.grid-editable-cell.grid-column-' + col.name] = editInColumn(col);
	      return memo;
	    }, {});
	    var bodyRows = {
	      length: state.bodyRows.length,
	      slice: function slice() {
	        var _state$bodyRows;
	
	        return (_state$bodyRows = state.bodyRows).slice.apply(_state$bodyRows, arguments).map(function (row) {
	          if (row.type !== 'data') {
	            return row;
	          }
	
	          var cells = _underscore2.default.map(row.cells, function (cell, index) {
	            var col = leafColumns[index];
	
	            if (col.editable) {
	              var classes = _underscore2.default.union(cell.classes, ['grid-editable-cell', 'grid-column-' + col.name]);
	              var html = (0, _editable2.default)({ $html: cell.html, classes: iconClasses });
	              return _underscore2.default.defaults({ classes: classes, html: html }, cell);
	            }
	            return cell;
	          });
	          return _underscore2.default.defaults({ cells: cells }, row);
	        });
	      }
	    };
	
	    _underscore2.default.defaults(events, state.events);
	
	    return _underscore2.default.defaults({ events: events, bodyRows: bodyRows }, state);
	  },
	
	  defaults: {}
	};

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function ($html, classes, text) {
	buf.push("<div title=\"Edit\"" + (jade.cls(['grid-edit-icon',classes], [null,true])) + "></div>" + (null == (jade_interp = $html) ? "" : jade_interp) + (jade.escape(null == (jade_interp = text) ? "" : jade_interp)));}.call(this,"$html" in locals_for_with?locals_for_with.$html:typeof $html!=="undefined"?$html:undefined,"classes" in locals_for_with?locals_for_with.classes:typeof classes!=="undefined"?classes:undefined,"text" in locals_for_with?locals_for_with.text:typeof text!=="undefined"?text:undefined));;return buf.join("");
	}

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.events = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function sequence() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	
	  var callbacks = _underscore2.default.filter(args, _underscore2.default.isFunction);
	  return function () {
	    var _this = this;
	
	    for (var _len2 = arguments.length, argsInner = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      argsInner[_key2] = arguments[_key2];
	    }
	
	    _underscore2.default.each(callbacks, function (cb) {
	      return cb.apply(_this, argsInner);
	    });
	  };
	}
	
	/**
	 * @external BackboneViewEventHash
	 * @see {@link http://backbonejs.org/#View-events}
	 */
	
	/**
	 * Merge the customized events with the projection injected events.
	 * @param {ContentChainState} state
	 *    The input state.
	 * @param {external:BackboneViewEventHash} eventsOptions 
	 *    The customized events in form of `Backbone.View#events`.
	 */
	function eventsProjectionHandler(state, eventsOptions) {
	  var pairs = _underscore2.default.pairs(state.events).concat(_underscore2.default.pairs(eventsOptions));
	  var events = _underscore2.default.reduce(pairs, function (memo, _ref) {
	    var _ref2 = _slicedToArray(_ref, 2);
	
	    var key = _ref2[0];
	    var handler = _ref2[1];
	
	    return _underscore2.default.extend(memo, _defineProperty({}, key, sequence(memo[key], handler)));
	  }, {});
	
	  return _underscore2.default.defaults({ events: events }, state);
	}
	
	var events = exports.events = {
	  name: 'events',
	  handler: eventsProjectionHandler,
	  defaults: {}
	};

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _tableView = __webpack_require__(97);
	
	Object.defineProperty(exports, 'TableView', {
	  enumerable: true,
	  get: function get() {
	    return _tableView.TableView;
	  }
	});

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TableView = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _backbone = __webpack_require__(10);
	
	var _backbone2 = _interopRequireDefault(_backbone);
	
	var _backboneVirtualizedListview = __webpack_require__(98);
	
	var _backboneVirtualizedListview2 = _interopRequireDefault(_backboneVirtualizedListview);
	
	var _headerFooterView = __webpack_require__(100);
	
	var _row = __webpack_require__(102);
	
	var _row2 = _interopRequireDefault(_row);
	
	var _tableFixed = __webpack_require__(103);
	
	var _tableFixed2 = _interopRequireDefault(_tableFixed);
	
	var _tableStatic = __webpack_require__(104);
	
	var _tableStatic2 = _interopRequireDefault(_tableStatic);
	
	var _tableSticky = __webpack_require__(105);
	
	var _tableSticky2 = _interopRequireDefault(_tableSticky);
	
	var _columnGroup = __webpack_require__(106);
	
	var _columnGroup2 = _interopRequireDefault(_columnGroup);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var STATE_OPTIONS = ['cols', 'headRows', 'bodyRows', 'footRows', 'events'];
	var HEADER_TYPES = ['static', 'fixed', 'sticky'];
	
	/**
	 * Table view with virtualization support
	 * @class TableView
	 * @extends Backbone.View
	 * @param {Object} options
	 *  the constructor options
	 * @param {string[]} [options.classes=[]]
	 *  the classes for the TABLE elements (content table and sticky/fixed header)
	 * @param {ScrollingConfig} [options.scrolling={virtualized: false, header: 'static'}]
	 *  the scrolling related configurations
	 */
	
	var TableView = exports.TableView = function (_Backbone$View) {
	  _inherits(TableView, _Backbone$View);
	
	  function TableView() {
	    _classCallCheck(this, TableView);
	
	    return _possibleConstructorReturn(this, (TableView.__proto__ || Object.getPrototypeOf(TableView)).apply(this, arguments));
	  }
	
	  _createClass(TableView, [{
	    key: 'initialize',
	    value: function initialize(_ref) {
	      var _this2 = this;
	
	      var _ref$scrolling = _ref.scrolling;
	      var scrolling = _ref$scrolling === undefined ? {} : _ref$scrolling;
	      var _ref$classes = _ref.classes;
	      var classes = _ref$classes === undefined ? [] : _ref$classes;
	
	      this._props = {
	        scrolling: this._normalizeScrollingConfig(scrolling),
	        classes: classes
	      };
	
	      this._state = {
	        cols: [],
	        headRows: [],
	        bodyRows: [],
	        footRows: [],
	        events: {}
	      };
	
	      this._listView = new _backboneVirtualizedListview2.default({
	        el: this.$el,
	        virtualized: this._props.scrolling.virtualized,
	        viewport: this._props.scrolling.viewport
	      });
	
	      this._headerView = new _headerFooterView.HeaderView({ tableView: this });
	      this._footerView = new _headerFooterView.FooterView({ tableView: this });
	
	      _underscore2.default.each(['willRedraw', 'didRedraw'], function (event) {
	        _this2._listView.on(event, function () {
	          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	          }
	
	          _this2.trigger.apply(_this2, [event].concat(args));
	        });
	      });
	    }
	  }, {
	    key: '_normalizeHeaderConfig',
	    value: function _normalizeHeaderConfig(config) {
	      var header = {};
	
	      if (_underscore2.default.isString(config)) {
	        header.type = config;
	      } else if (_underscore2.default.isFunction(config) || _underscore2.default.isFinite(config)) {
	        header.type = 'sticky';
	        header.offset = config;
	      } else if (_underscore2.default.isObject(config) && _underscore2.default.isString(config.type)) {
	        _underscore2.default.extend(header, _underscore2.default.pick(config, 'type', 'offset'));
	      }
	
	      if (!_underscore2.default.contains(HEADER_TYPES, header.type)) {
	        header.type = 'static';
	      }
	
	      if (header.type === 'sticky' && !_underscore2.default.isFinite(_underscore2.default.result(header, 'offset'))) {
	        header.offset = 0;
	      }
	
	      return header;
	    }
	
	    /**
	     * @typedef ScrollingConfig
	     * @type {Object}
	     *
	     * @property {boolean} virtualized
	     *  flag for virtualization.
	     *
	     * @property {(string|HTMLElement|jQuery|window)} viewport
	     *  the scrolling viewport. If omit, the table view will auto detect the
	     *  closest ancestor of the $el with 'overflowY' style being 'auto' or
	     *  'scroll'. Use the window viewport if found none.
	     *
	     *  NOTE: the viewport takes no effect when using fixed header. Tables with
	     *  fixed header render its viewport inside, as the container of the body
	     *  and footer.
	     *
	     * @property {(string|HeaderConfig)} header
	     *  the header scrolling behavior configurations. It can be a string to
	     *  indicate the header type (`'static'`, `'sticky'` or `'fixed'`). Or an
	     *  detailed configuration object.
	     *
	     */
	
	    /**
	     * @typedef HeaderConfig
	     * @type {Object}
	     * @property {string} type
	     * the header type. It can have the following values
	     *
	     *  * `'static'`: static header, the normal case, the header is rendered to
	     *    the top of the grid.
	     *  * `'sticky'`: sticky header, the header will stick to the viewport with
	     *    a given offset.
	     *  * `'fixed'`: fixed header, the header will be outside the viewport. Only
	     *    the body and footer are scrollable.
	     *
	     * @property {number|function} offset
	     * special configuration for sticky header indicating its position. It's can
	     * be a number or a function returning a number, represents number of pixels
	     * below the viewport top.
	     */
	
	  }, {
	    key: '_normalizeScrollingConfig',
	    value: function _normalizeScrollingConfig(_ref2) {
	      var viewport = _ref2.viewport;
	      var _ref2$virtualized = _ref2.virtualized;
	      var virtualized = _ref2$virtualized === undefined ? false : _ref2$virtualized;
	      var _ref2$header = _ref2.header;
	      var header = _ref2$header === undefined ? 'static' : _ref2$header;
	
	      var scrolling = { viewport: viewport, virtualized: virtualized };
	
	      scrolling.header = this._normalizeHeaderConfig(header);
	
	      if (scrolling.header.type === 'fixed') {
	        scrolling.viewport = '.viewport';
	      }
	
	      return scrolling;
	    }
	  }, {
	    key: 'set',
	    value: function set() {
	      var _this3 = this;
	
	      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _underscore2.default.noop;
	
	      var isSet = function isSet(key) {
	        return !_underscore2.default.isUndefined(state[key]);
	      };
	      var listState = {};
	
	      _underscore2.default.extend(this._state, _underscore2.default.pick(state, STATE_OPTIONS));
	
	      if (isSet('bodyRows')) {
	        (function () {
	          var bodyRows = _this3._state.bodyRows;
	
	          listState.items = {
	            length: bodyRows.length,
	            slice: function slice(start, stop) {
	              return _underscore2.default.map(bodyRows.slice(start, stop), function (row) {
	                return { row: row };
	              });
	            }
	          };
	        })();
	      }
	
	      if (isSet('events')) {
	        listState.events = state.events;
	      }
	
	      this._renderColumnGroup();
	
	      if (this._headerView) {
	        this._headerView.redraw();
	      }
	
	      if (this._footerView) {
	        this._footerView.redraw();
	      }
	
	      this._listView.set(listState, callback);
	
	      return this;
	    }
	  }, {
	    key: '_renderColumnGroup',
	    value: function _renderColumnGroup() {
	      this.$colgroup = this.$('colgroup.column-group');
	      this.$colgroup.html((0, _columnGroup2.default)(this._state));
	    }
	  }, {
	    key: '_renderHeader',
	    value: function _renderHeader() {
	      this._headerView.setElement(this.$('thead.header'));
	      this._headerView.render();
	    }
	  }, {
	    key: '_renderFooter',
	    value: function _renderFooter() {
	      this._footerView.setElement(this.$('tfoot.footer'));
	      this._footerView.render();
	    }
	
	    /**
	     * This is simulating `{ position: sticky }`, but it's still far from perfect.
	     *
	     * 1. For window viewport
	     *    * Use `{ postion: fixed }`
	     *    * Adjust the width and the horizontal location on the fly
	     *    * Put an dummy filler into the content flow to take the place of header
	     *
	     * The issues are
	     *    * If the subviews in header changes, they have to notify the grid
	     *    manually to update the filler's size
	     *    * The header doesn't follow the table tightly on horizontal scroll, as
	     *    the `scroll` event is triggered after repaint for most browsers
	     *
	     * 2. For element viewport
	     *    * Use `{ position: relative }`
	     *    * Adjust the vertical location on the fly
	     *
	     * The issues are
	     *    * The header doesn't follow the table tightly on vertical scroll, as
	     *    the `scroll` event is triggered after repaint for most browsers. The
	     *    sticky header could be very jumpy on IE and Edge.
	     *
	     * We wish all browsers support `{ position: sticky }` in a not too far
	     * future. So that we can have a perfect solution with native support.
	     *
	     */
	
	  }, {
	    key: '_hookUpStickyHeader',
	    value: function _hookUpStickyHeader(listView) {
	      var _this4 = this;
	
	      var viewport = listView.viewport;
	      var isWindow = viewport.$el.get(0) === window;
	      var $tableContainer = this.$('.table-container');
	      var $stickyHeader = this.$('.sticky-header');
	      var $stickyHeaderFiller = this.$('.sticky-header-filler');
	      var $table = this.$('.sticky-header-filler + table');
	      var viewportSize = { width: 0, height: 0 };
	
	      var adjustStickyHeader = function adjustStickyHeader() {
	        if (!_this4.$el.is(':visible')) {
	          return;
	        }
	
	        var metricsVP = listView.viewport.getMetrics();
	        var topVP = metricsVP.outer.top;
	        var offset = _underscore2.default.result(_this4._props.scrolling.header, 'offset', 0);
	        var rectContainer = $tableContainer.get(0).getBoundingClientRect();
	        var topCur = rectContainer.top;
	
	        if (isWindow) {
	          var sticky = topCur < topVP + offset;
	          $stickyHeaderFiller.css({
	            display: sticky ? 'block' : 'none',
	            height: sticky ? $stickyHeader.height() : ''
	          });
	
	          var style = {
	            position: sticky ? 'fixed' : 'static',
	            top: sticky ? topVP + offset : '',
	            left: sticky ? rectContainer.left : ''
	          };
	
	          var deltaWidth = Math.abs(metricsVP.outer.width - viewportSize.width);
	          var deltaHeight = Math.abs(metricsVP.outer.height - viewportSize.height);
	          var resize = deltaWidth >= 1 || deltaHeight >= 1;
	
	          if (resize) {
	            // Update the viewportSize
	            viewportSize.width = metricsVP.outer.width;
	            viewportSize.height = metricsVP.outer.height;
	
	            // Let the content table layout freely, then sync the width to sticky header
	            $stickyHeader.css({ width: 'auto' });
	            $table.css({ width: 'auto' });
	            var width = $tableContainer.width();
	            style.width = width;
	            $table.css({ width: width });
	          }
	
	          $stickyHeader.css(style);
	        } else {
	          $stickyHeaderFiller.css({
	            display: 'none'
	          });
	          $stickyHeader.css({
	            position: 'relative',
	            top: Math.min(Math.max(topVP + offset - topCur, 0), $table.height())
	          });
	        }
	      };
	
	      listView.viewport.on('resize', _underscore2.default.partial(adjustStickyHeader, true));
	      listView.viewport.on('scroll', _underscore2.default.partial(adjustStickyHeader, false));
	      listView.on('didRedraw', _underscore2.default.partial(adjustStickyHeader, true));
	    }
	  }, {
	    key: '_renderStatic',
	    value: function _renderStatic(callback) {
	      var _this5 = this;
	
	      this._listView.set({
	        model: {
	          classes: this._props.classes
	        },
	        listTemplate: _tableStatic2.default,
	        itemTemplate: _row2.default
	      }).render(function () {
	        _this5._renderColumnGroup();
	        _this5._renderHeader();
	        _this5._renderFooter();
	        callback();
	      });
	    }
	  }, {
	    key: '_renderFixed',
	    value: function _renderFixed(callback) {
	      var _this6 = this;
	
	      this._listView.set({
	        model: {
	          classes: this._props.classes
	        },
	        listTemplate: _tableFixed2.default,
	        itemTemplate: _row2.default
	      }).render(function () {
	        _this6._renderColumnGroup();
	        _this6._renderHeader();
	        _this6._renderFooter();
	        callback();
	      });
	
	      this._listView.on('didRedraw', function () {
	        var widthViewport = _this6.$('.viewport').get(0).clientWidth;
	        var widthContainer = _this6.el.clientWidth;
	        var widthScrollbar = widthContainer - widthViewport;
	        var widthTable = _this6.$('.viewport > table').get(0).offsetWidth;
	
	        _this6.$el.width(widthTable + widthScrollbar);
	        _this6.$('.fixed-header').width(widthTable);
	      });
	    }
	  }, {
	    key: '_renderSticky',
	    value: function _renderSticky(callback) {
	      var _this7 = this;
	
	      this._listView.set({
	        model: {
	          classes: this._props.classes
	        },
	        listTemplate: _tableSticky2.default,
	        itemTemplate: _row2.default
	      }).render(function () {
	        _this7._renderColumnGroup();
	        _this7._renderHeader();
	        _this7._hookUpStickyHeader(_this7._listView);
	        _this7._renderFooter();
	        callback();
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _underscore2.default.noop;
	
	      var header = this._props.scrolling.header;
	
	      switch (header.type) {
	        default:
	        case 'static':
	          this._renderStatic(callback);
	          break;
	        case 'fixed':
	          this._renderFixed(callback);
	          break;
	        case 'sticky':
	          this._renderSticky(callback);
	          break;
	      }
	
	      return this;
	    }
	  }, {
	    key: 'remove',
	    value: function remove() {
	      if (this._headerView) {
	        this._headerView.remove();
	      }
	
	      if (this._listView) {
	        this._listView.remove();
	      }
	
	      if (this._footerView) {
	        this._footerView.remove();
	      }
	
	      _get(TableView.prototype.__proto__ || Object.getPrototypeOf(TableView.prototype), 'remove', this).call(this);
	    }
	  }, {
	    key: 'scrollToItem',
	    value: function scrollToItem() {
	      var _listView;
	
	      (_listView = this._listView).scrollToItem.apply(_listView, arguments);
	    }
	  }, {
	    key: 'indexOfElement',
	    value: function indexOfElement(el) {
	      var $elTr = this._listView.$(el).closest('tr', this._listView.$container);
	      if ($elTr.length > 0) {
	        return $elTr.index() + this._listView.indexFirst - 1;
	      }
	      return null;
	    }
	  }, {
	    key: 'headerType',
	    get: function get() {
	      return this._props.scrolling.header.type;
	    }
	  }]);
	
	  return TableView;
	}(_backbone2.default.View);

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(5), __webpack_require__(9), __webpack_require__(10), __webpack_require__(99));
		else if(typeof define === 'function' && define.amd)
			define(["underscore", "jquery", "backbone", "fast-binary-indexed-tree"], factory);
		else if(typeof exports === 'object')
			exports["backbone-virtualized-listview"] = factory(require("underscore"), require("jquery"), require("backbone"), require("fast-binary-indexed-tree"));
		else
			root["backbone-virtualized-listview"] = factory(root["underscore"], root["jquery"], root["backbone"], root["fast-binary-indexed-tree"]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _underscore = __webpack_require__(1);
		
		var _underscore2 = _interopRequireDefault(_underscore);
		
		var _jquery = __webpack_require__(2);
		
		var _jquery2 = _interopRequireDefault(_jquery);
		
		var _backbone = __webpack_require__(3);
		
		var _backbone2 = _interopRequireDefault(_backbone);
		
		var _fastBinaryIndexedTree = __webpack_require__(4);
		
		var _fastBinaryIndexedTree2 = _interopRequireDefault(_fastBinaryIndexedTree);
		
		var _defaultList = __webpack_require__(5);
		
		var _defaultList2 = _interopRequireDefault(_defaultList);
		
		var _defaultItem = __webpack_require__(8);
		
		var _defaultItem2 = _interopRequireDefault(_defaultItem);
		
		var _viewport = __webpack_require__(9);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		// Helper function to created a scoped while loop
		var whileTrue = function whileTrue(func) {
		  while (func()) {}
		};
		
		var INVALIDATION_NONE = 0;
		var INVALIDATION_ITEMS = 0x1;
		var INVALIDATION_EVENTS = 0x2;
		var INVALIDATION_LIST = 0x4;
		var INVALIDATION_ALL = 0x7;
		
		var LIST_VIEW_EVENTS = ['willRedraw', 'didRedraw'];
		
		/**
		 * The virtualized list view class.
		 *
		 * In addition to ordinary Backbone View options, the constructor also takes
		 *
		 * __virtualized__: whether or not the virtualization is enabled.
		 *
		 * __viewport__: the option locate the scrollable viewport. It can be
		 *
		 *  * Omitted, auto detect the closest ancestor of the `$el` with 'overflowY'
		 *    style being 'auto' or 'scroll'. Use the window viewport if found none.
		 *  * A `string`, use it as a selector to select an __internal__ element as
		 *    the viewport.
		 *  * An `HTMLElement` or `jQuery`, use it as the viewport element.
		 *  * The `window`, use the window viewport.
		 *
		 * @param {Object} options The constructor options.
		 * @param {boolean} [options.virtualized=true]
		 * @param {string | HTMLElement | jQuery | window} [options.viewport]
		 *
		 */
		
		var ListView = function (_Backbone$View) {
		  _inherits(ListView, _Backbone$View);
		
		  function ListView() {
		    _classCallCheck(this, ListView);
		
		    return _possibleConstructorReturn(this, Object.getPrototypeOf(ListView).apply(this, arguments));
		  }
		
		  _createClass(ListView, [{
		    key: 'initialize',
		
		
		    /**
		     * Backbone view initializer
		     * @see ListView
		     */
		    value: function initialize() {
		      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		
		      var _ref$virtualized = _ref.virtualized;
		      var virtualized = _ref$virtualized === undefined ? true : _ref$virtualized;
		      var _ref$viewport = _ref.viewport;
		      var viewport = _ref$viewport === undefined ? null : _ref$viewport;
		
		      this._props = { virtualized: virtualized, viewport: viewport };
		      this.options = {
		        model: {},
		        listTemplate: _defaultList2.default,
		        events: {},
		        items: [],
		        itemTemplate: _defaultItem2.default,
		        defaultItemHeight: 20
		      };
		
		      // States
		      this._state = {
		        indexFirst: 0,
		        indexLast: 0,
		        anchor: null,
		        invalidation: INVALIDATION_NONE,
		        removed: false,
		        eventsListView: {}
		      };
		
		      this._scheduleRedraw = _underscore2.default.noop;
		    }
		  }, {
		    key: '_initViewport',
		    value: function _initViewport() {
		      var viewport = this._props.viewport;
		
		      if (_underscore2.default.isString(viewport)) {
		        return new _viewport.ElementViewport(this.$(viewport));
		      } else if (viewport instanceof _jquery2.default) {
		        if (viewport.get(0) === window) {
		          return new _viewport.WindowViewport();
		        }
		        return new _viewport.ElementViewport(viewport);
		      } else if (viewport instanceof HTMLElement) {
		        return new _viewport.ElementViewport(viewport);
		      } else if (viewport === window) {
		        return new _viewport.WindowViewport();
		      }
		
		      var $el = this.$el;
		      while ($el.length > 0 && !$el.is(document)) {
		        if (_underscore2.default.contains(['auto', 'scroll'], $el.css('overflowY'))) {
		          return new _viewport.ElementViewport($el);
		        }
		        $el = $el.parent();
		      }
		      return new _viewport.WindowViewport();
		    }
		  }, {
		    key: '_hookUpViewport',
		    value: function _hookUpViewport() {
		      var _this2 = this;
		
		      this.viewport = this._initViewport();
		
		      if (this.virtualized) {
		        (function () {
		          var blockUntil = 0;
		
		          var onViewportChange = function onViewportChange() {
		            if (performance.now() > blockUntil) {
		              _this2._scheduleRedraw();
		            } else if (!_this2._state.removed) {
		              // If the scroll events are blocked, we shouldn't just swallow them.
		              // Wait for 0.1 second and give another try.
		              window.setTimeout(onViewportChange, 100);
		            }
		          };
		
		          _this2.viewport.on('change', onViewportChange);
		
		          //
		          // On keypress, we want to block the scroll events for 0.2 second to wait
		          // for the animation to complete. Otherwise, the scroll would change the
		          // geometry metrics and break the animation. The worst thing we may get is,
		          // for 'HOME' and 'END' keys, the view doesn't scroll to the right position.
		          //
		          _this2.viewport.on('keypress', function () {
		            blockUntil = performance.now() + 200;
		          });
		        })();
		      }
		    }
		
		    /**
		     * Whether or not the list view is virtualized
		     */
		
		  }, {
		    key: 'remove',
		
		
		    /**
		     * Remove the view and unregister the event listeners.
		     */
		    value: function remove() {
		      this._state.removed = true;
		      if (this.viewport) {
		        this.viewport.remove();
		      }
		      _get(Object.getPrototypeOf(ListView.prototype), 'remove', this).call(this);
		    }
		  }, {
		    key: '_applyPaddings',
		    value: function _applyPaddings(_ref2) {
		      var paddingTop = _ref2.paddingTop;
		      var paddingBottom = _ref2.paddingBottom;
		
		      if (this.$topFiller && this.$bottomFiller) {
		        this.$topFiller.height(paddingTop);
		        this.$bottomFiller.height(paddingBottom);
		      }
		    }
		  }, {
		    key: '_processInvalidation',
		    value: function _processInvalidation() {
		      var _this3 = this;
		
		      var _options = this.options;
		      var items = _options.items;
		      var events = _options.events;
		      var listTemplate = _options.listTemplate;
		      var model = _options.model;
		      var invalidation = this._state.invalidation;
		
		      var eventsDOM = _underscore2.default.omit(events, LIST_VIEW_EVENTS);
		      var eventsListView = _underscore2.default.pick(events, LIST_VIEW_EVENTS);
		
		      if (invalidation & INVALIDATION_EVENTS) {
		        this.undelegateEvents();
		        _underscore2.default.each(this._state.eventsListView || {}, function (handler, event) {
		          _this3.off(event, handler);
		        });
		      }
		      if (invalidation & INVALIDATION_LIST) {
		        var isInternalViewport = _underscore2.default.isString(this._props.viewport);
		        if (isInternalViewport && this.viewport) {
		          this.viewport.remove();
		          this.viewport = null;
		        }
		        this.$el.html(listTemplate(model));
		        if (!this.viewport) {
		          this._hookUpViewport();
		        }
		        this.$topFiller = this.$('.top-filler');
		        this.$bottomFiller = this.$('.bottom-filler');
		        this._applyPaddings({
		          paddingTop: 0,
		          paddingBottom: this.itemHeights.read(items.length)
		        });
		        _underscore2.default.extend(this._state, { indexFirst: 0, indexLast: 0 });
		      }
		      if (invalidation & INVALIDATION_EVENTS) {
		        this.delegateEvents(eventsDOM);
		        _underscore2.default.each(eventsListView, function (handler, event) {
		          _this3.on(event, handler);
		        });
		        this._state.eventsListView = eventsListView;
		      }
		      var invalidateItems = invalidation & INVALIDATION_ITEMS;
		
		      _underscore2.default.extend(this._state, { invalidation: INVALIDATION_NONE });
		      return invalidateItems;
		    }
		
		    // Private API, redraw immediately
		
		  }, {
		    key: '_redraw',
		    value: function _redraw() {
		      var _this4 = this;
		
		      var invalidateItems = this._processInvalidation();
		      var _options2 = this.options;
		      var items = _options2.items;
		      var itemTemplate = _options2.itemTemplate;
		      var viewport = this.viewport;
		      var itemHeights = this.itemHeights;
		      var $topFiller = this.$topFiller;
		      var $bottomFiller = this.$bottomFiller;
		      var virtualized = this.virtualized;
		      var _state = this._state;
		      var indexFirst = _state.indexFirst;
		      var indexLast = _state.indexLast;
		      var anchor = _state.anchor;
		
		
		      if (!invalidateItems && items.length === 0) {
		        return;
		      }
		
		      /**
		       * The event indicates the list will start redraw.
		       * @event ListView#willRedraw
		       */
		      this.trigger('willRedraw');
		
		      whileTrue(function () {
		        var isCompleted = true;
		
		        var metricsViewport = viewport.getMetrics();
		        var visibleTop = metricsViewport.outer.top;
		        var visibleBot = metricsViewport.outer.bottom;
		        var listTopCur = _this4.$topFiller.get(0).getBoundingClientRect().top;
		        var scrollRatio = metricsViewport.scroll.ratioY;
		
		        var renderTop = false;
		        var renderBot = false;
		
		        whileTrue(function () {
		          var listTop = anchor ? anchor.top - itemHeights.read(anchor.index) : listTopCur;
		          var targetFirst = virtualized ? itemHeights.lowerBound(visibleTop - listTop) : 0;
		          var targetLast = virtualized ? Math.min(itemHeights.upperBound(visibleBot - listTop) + 1, items.length) : items.length;
		          var renderFirst = Math.max(targetFirst - 10, 0);
		          var renderLast = Math.min(targetLast + 10, items.length);
		
		          var renderMore = false;
		
		          // Clean up
		          if (targetFirst >= indexLast || targetLast <= indexFirst || invalidateItems) {
		            $topFiller.nextUntil($bottomFiller).remove();
		            indexFirst = indexLast = targetFirst;
		            if (targetFirst !== targetLast && items.length > 0) {
		              renderMore = true;
		            }
		            if (!anchor) {
		              var index = Math.round(targetFirst * (1 - scrollRatio) + targetLast * scrollRatio);
		              var top = listTopCur + itemHeights.read(index);
		              anchor = { index: index, top: top };
		            }
		            invalidateItems = false;
		          } else if (!anchor) {
		            var _index = Math.round(indexFirst * (1 - scrollRatio) + indexLast * scrollRatio);
		            var _top = listTopCur + itemHeights.read(_index);
		            anchor = { index: _index, top: _top };
		          }
		
		          // Render top
		          if (targetFirst < indexFirst) {
		            $topFiller.after(items.slice(renderFirst, indexFirst).map(itemTemplate));
		            $topFiller.nextUntil($bottomFiller).slice(0, indexFirst - renderFirst).each(function (offset, el) {
		              itemHeights.writeSingle(renderFirst + offset, el.getBoundingClientRect().height);
		            });
		            indexFirst = renderFirst;
		            renderMore = renderTop = true;
		          } else if (renderBot && !renderTop && renderFirst > indexFirst) {
		            (function () {
		              var removal = [];
		              $topFiller.nextUntil($bottomFiller).slice(0, renderFirst - indexFirst).each(function (offset, el) {
		                return removal.push(el);
		              });
		              (0, _jquery2.default)(removal).remove();
		              indexFirst = renderFirst;
		              renderMore = true;
		            })();
		          }
		
		          // Render bottom
		          if (targetLast > indexLast) {
		            $bottomFiller.before(items.slice(indexLast, renderLast).map(itemTemplate));
		            $topFiller.nextUntil($bottomFiller).slice(indexLast - indexFirst).each(function (offset, el) {
		              itemHeights.writeSingle(indexLast + offset, el.getBoundingClientRect().height);
		            });
		            indexLast = renderLast;
		            renderMore = renderBot = true;
		          } else if (renderTop && !renderBot && renderLast < indexLast) {
		            (function () {
		              var removal = [];
		              $topFiller.nextUntil($bottomFiller).slice(renderLast - indexFirst).each(function (offset, el) {
		                return removal.push(el);
		              });
		              (0, _jquery2.default)(removal).remove();
		              indexLast = renderLast;
		              renderMore = true;
		            })();
		          }
		
		          return renderMore;
		        });
		
		        // Update the padding
		        if (indexFirst !== _this4.indexFirst || indexLast !== _this4.indexLast) {
		          _this4._applyPaddings({
		            paddingTop: itemHeights.read(indexFirst),
		            paddingBottom: itemHeights.read(items.length) - itemHeights.read(indexLast)
		          });
		        }
		
		        // Adjust the scroll if it's changed significantly
		        var listTop = anchor.top - itemHeights.read(anchor.index);
		        var innerTop = listTop - (listTopCur - metricsViewport.inner.top);
		        var scrollTop = Math.round(visibleTop - innerTop);
		        var anchorNew = null;
		
		        // Do a second scroll for a middle anchor after the item is rendered
		        if (anchor.isMiddle) {
		          var index = anchor.index;
		          var itemTop = listTopCur + _this4.itemHeights.read(index);
		          var itemBot = listTopCur + _this4.itemHeights.read(index + 1);
		
		          anchorNew = {
		            index: index,
		            top: (visibleTop + visibleBot + itemTop - itemBot) / 2
		          };
		          isCompleted = false;
		        }
		
		        if (Math.abs(scrollTop - viewport.getMetrics().scroll.y) >= 1) {
		          _this4.viewport.scrollTo({ y: scrollTop });
		          isCompleted = false;
		        }
		
		        anchor = anchorNew;
		
		        return !isCompleted;
		      });
		
		      // Write back the render state
		      _underscore2.default.extend(this._state, { indexFirst: indexFirst, indexLast: indexLast, anchor: null });
		
		      /**
		       * The event indicates the list view have completed redraw.
		       * @event ListView#didRedraw
		       */
		      this.trigger('didRedraw');
		    }
		
		    /**
		     * Get the item at certain index.
		     * @param {number} index The index of the item.
		     * @return {Object}
		     */
		
		  }, {
		    key: 'itemAt',
		    value: function itemAt(index) {
		      return _underscore2.default.first(this.options.items.slice(index, index + 1));
		    }
		
		    /**
		     * Get the rendered DOM element at certain index.
		     * @param {number} index The index of the item.
		     * @return {HTMLElement}
		     */
		
		  }, {
		    key: 'elementAt',
		    value: function elementAt(index) {
		      var _state2 = this._state;
		      var indexFirst = _state2.indexFirst;
		      var indexLast = _state2.indexLast;
		
		
		      if (index < indexFirst || index >= indexLast || !this.$topFiller || !this.$bottomFiller) {
		        return null;
		      }
		      return this.$topFiller.nextUntil(this.$bottomFiller).get(index - indexFirst);
		    }
		
		    /**
		     * The index of the first rendered item.
		     * @type {number}
		     */
		
		  }, {
		    key: 'set',
		
		
		    /**
		     * Set the list view options. The following options can be set
		     *
		     * __model__: The model object to render the skeleton of the list view.
		     *
		     * __listTemplate__: The template to render the skeleton of the list view.
		     *
		     *  * By default, it would render a single `UL`.
		     *  * __Note__: It must contain the following elements with specified class
		     *    names as the first and last siblings of the list items. All list items
		     *    will be rendered in between.
		     *    * `'top-filler'`: The filler block on top.
		     *    * `'bottom-filler'`: The filler block at bottom.
		     *
		     * __events__: The events hash in form of `{ "event selector": callback }`.
		     *
		     *  * Refer to {@link http://backbonejs.org/#View-events|Backbone.View~events}
		     *  * In addition to the DOM events, it can also handle the `'willRedraw'` and
		     *    `'didRedraw'` events of the list view.
		     *  * __Note__: The callback __MUST__ be a function. Member function names are
		     *    not supported.
		     *
		     * __items__: The model objects of the list items.
		     *
		     * __itemTemplate__: The template to render a list item.
		     *
		     *  * By default, it would render a single `LI` filled with `item.text`.
		     *  * __Note__: list items __MUST NOT__ have outer margins, otherwise the layout
		     *    calculation will be inaccurate.
		     *
		     * __defaultItemHeight__: The estimated height of a single item.
		     *
		     *  * It's not necessary to be accurate. But the accurater it is, the less the
		     *    scroll bar is adjusted overtime.
		     *
		     * Refer to {@link ListView} for detail.
		     *
		     * @param {Object} options The new options.
		     * @param {Object} options.model
		     * @param {ListView~cbListTemplate} [options.listTemplate]
		     * @param {Object} options.events
		     * @param {Object[]} [options.items=[]]
		     * @param {ListView~cbItemTemplate} [options.itemTemplate]
		     * @param {number} [options.defaultItemHeight=20]
		     * @param {function} [callback] The callback to notify completion.
		     * @return {ListView} The list view itself.
		     */
		    value: function set() {
		      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		      var callback = arguments.length <= 1 || arguments[1] === undefined ? _underscore2.default.noop : arguments[1];
		
		      var isSet = function isSet(key) {
		        return !_underscore2.default.isUndefined(options[key]);
		      };
		      var itemHeightsCur = this._itemHeights;
		      var invalidation = 0;
		
		      _underscore2.default.extend(this.options, options);
		
		      if (_underscore2.default.some(['model', 'listTemplate'], isSet)) {
		        invalidation |= INVALIDATION_ALL;
		      } else {
		        if (_underscore2.default.some(['items', 'itemTemplate', 'defaultItemHeight'], isSet)) {
		          if (isSet('defaultItemHeight') || this.itemHeights.maxVal !== this.length) {
		            this._itemHeights = null;
		          }
		          invalidation |= INVALIDATION_ITEMS;
		        }
		        if (isSet('events')) {
		          invalidation |= INVALIDATION_EVENTS;
		        }
		      }
		
		      if (invalidation) {
		        if (this.viewport && this.$topFiller && itemHeightsCur) {
		          var visibleTop = this.viewport.getMetrics().outer.top;
		          var listTopCur = this.$topFiller.get(0).getBoundingClientRect().top;
		          var visibleFirst = itemHeightsCur.lowerBound(visibleTop - listTopCur);
		
		          if (visibleFirst < this.length) {
		            var el = this.elementAt(visibleFirst);
		            if (el) {
		              var elTop = el.getBoundingClientRect().top;
		              this._state.anchor = {
		                index: visibleFirst,
		                top: elTop
		              };
		            }
		          }
		        }
		
		        this._invalidate(invalidation, callback);
		      } else {
		        callback();
		      }
		
		      return this;
		    }
		  }, {
		    key: '_invalidate',
		    value: function _invalidate(invalidation, callback) {
		      this._state.invalidation |= invalidation;
		      this._scheduleRedraw();
		      this.once('didRedraw', callback);
		    }
		
		    /**
		     * Invalidate the already rendered items and schedule another redraw.
		     * @param {function} [callback] The callback to notify completion.
		     */
		
		  }, {
		    key: 'invalidate',
		    value: function invalidate() {
		      var callback = arguments.length <= 0 || arguments[0] === undefined ? _underscore2.default.noop : arguments[0];
		
		      this._invalidate(INVALIDATION_ITEMS, callback);
		    }
		
		    /**
		     * Scroll to a certain item.
		     * @param {number} index The index of the item.
		     * @param {string|number} [position='default'] The position of the item.
		     *
		     * The valid positions are
		     *   * `'default'`, if the item is above the viewport top, scroll it to the
		     *     top, if the item is below the viewport bottom, scroll it to the bottom,
		     *     otherwise, keep the viewport unchanged.
		     *   * `'top'`, scroll the item to top of the viewport.
		     *   * `'middle'`, scroll the item to the vertical center of the viewport.
		     *   * `'bottom'`, scroll the item to the bottom of the viewport.
		     *   * `{number}`, scroll the item to the given offset from the viewport top.
		     *
		     * @param {function} [callback] The callback to notify completion.
		     *
		     */
		
		  }, {
		    key: 'scrollToItem',
		    value: function scrollToItem() {
		      if (!this.$topFiller || !this.$bottomFiller) {
		        throw new Error('Cannot scroll before the view is rendered');
		      }
		      var index = 0;
		      var position = 'default';
		      var callback = _underscore2.default.noop;
		
		      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		        args[_key] = arguments[_key];
		      }
		
		      if (args.length >= 3) {
		        index = args[0];
		        position = args[1];
		        callback = args[2];
		      } else if (args.length === 2) {
		        if (_underscore2.default.isFunction(args[1])) {
		          index = args[0];
		          callback = args[1];
		        } else {
		          index = args[0];
		          position = args[1];
		        }
		      } else if (args.length === 1) {
		        index = args[0];
		      }
		      this._scrollToItem(index, position, callback);
		    }
		  }, {
		    key: '_scrollToItem',
		    value: function _scrollToItem(index, position, callback) {
		      var metricsViewport = this.viewport.getMetrics();
		      var visibleTop = metricsViewport.outer.top;
		      var visibleBot = metricsViewport.outer.bottom;
		      var listTopCur = this.$topFiller.get(0).getBoundingClientRect().top;
		      var itemTop = listTopCur + this.itemHeights.read(index);
		      var itemBot = listTopCur + this.itemHeights.read(index + 1);
		      var pos = position;
		
		      if (pos === 'default') {
		        if (itemTop < visibleTop) {
		          pos = 'top';
		        } else if (itemBot > visibleBot) {
		          pos = 'bottom';
		        } else {
		          if (_underscore2.default.isFunction(callback)) {
		            callback();
		          }
		          return;
		        }
		      }
		
		      if (pos === 'top') {
		        this._state.anchor = {
		          index: index,
		          top: visibleTop
		        };
		      } else if (pos === 'bottom') {
		        this._state.anchor = {
		          index: index + 1,
		          top: visibleBot
		        };
		      } else if (pos === 'middle') {
		        this._state.anchor = {
		          index: index,
		          top: (visibleTop + visibleBot + itemTop - itemBot) / 2,
		          isMiddle: true
		        };
		      } else if (typeof pos === 'number') {
		        this._state.anchor = {
		          index: index,
		          top: visibleTop + pos
		        };
		      } else {
		        throw new Error('Invalid position');
		      }
		
		      this.once('didRedraw', callback);
		
		      this._scheduleRedraw();
		    }
		
		    /**
		     * Render the list view.
		     * @param {function} [callback] The callback to notify completion.
		     */
		
		  }, {
		    key: 'render',
		    value: function render() {
		      var _this5 = this;
		
		      var callback = arguments.length <= 0 || arguments[0] === undefined ? _underscore2.default.noop : arguments[0];
		
		      var requestId = null;
		
		      this._scheduleRedraw = function () {
		        if (!requestId) {
		          requestId = window.requestAnimationFrame(function () {
		            requestId = null;
		            if (!_this5._state.removed) {
		              _this5._redraw();
		            }
		          });
		        }
		      };
		      // this._hookUpViewport();
		      this._invalidate(INVALIDATION_ALL, callback);
		      return this;
		    }
		  }, {
		    key: 'virtualized',
		    get: function get() {
		      return this._props.virtualized;
		    }
		  }, {
		    key: 'indexFirst',
		    get: function get() {
		      return this._state.indexFirst;
		    }
		
		    /**
		     * The index after the last rendered item.
		     * @type {number}
		     */
		
		  }, {
		    key: 'indexLast',
		    get: function get() {
		      return this._state.indexLast;
		    }
		
		    /**
		     * The total count of the items.
		     * @type {number}
		     */
		
		  }, {
		    key: 'length',
		    get: function get() {
		      return this.options.items.length;
		    }
		
		    /**
		     * The model object to render the skeleton of the list view.
		     * @type {Object}
		     */
		
		  }, {
		    key: 'model',
		    get: function get() {
		      return this.options.model;
		    }
		
		    /**
		     * The template to render the skeleton of the list view.
		     * @callback ListView~cbListTemplate
		     * @param {Object} model The model object of the list view.
		     */
		
		    /**
		     * The template to render the skeleton of the list view.
		     * @type {ListView~cbListTemplate}
		     */
		
		  }, {
		    key: 'listTemplate',
		    get: function get() {
		      return this.options.listTemplate;
		    }
		
		    /**
		     * The template to render a list item.
		     * @callback ListView~cbItemTemplate
		     * @param {Object} item The model object of the item
		     */
		
		    /**
		     * The template to render a list item.
		     * @type {ListView~cbItemTemplate}
		     */
		
		  }, {
		    key: 'itemTemplate',
		    get: function get() {
		      return this.options.itemTemplate;
		    }
		
		    /**
		     * The default list item height.
		     * @type {number}
		     */
		
		  }, {
		    key: 'defaultItemHeight',
		    get: function get() {
		      return this.options.defaultItemHeight;
		    }
		
		    /**
		     * @external BinaryIndexedTree
		     * @see {@link https://microsoft.github.io/fast-binary-indexed-tree-js/BinaryIndexedTree.html}
		     */
		
		    /**
		     * The BinaryIndexedTree to get the heights and accumulated heights of items.
		     * @type {external:BinaryIndexedTree}
		     */
		
		  }, {
		    key: 'itemHeights',
		    get: function get() {
		      if (!this._itemHeights) {
		        var _options3 = this.options;
		        var defaultItemHeight = _options3.defaultItemHeight;
		        var items = _options3.items;
		
		        this._itemHeights = new _fastBinaryIndexedTree2.default({
		          defaultFrequency: Math.max(defaultItemHeight, 1),
		          maxVal: items.length
		        });
		      }
		      return this._itemHeights;
		    }
		  }]);
		
		  return ListView;
		}(_backbone2.default.View);
		
		exports.default = ListView;
	
	/***/ },
	/* 1 */
	/***/ function(module, exports) {
	
		module.exports = __WEBPACK_EXTERNAL_MODULE_1__;
	
	/***/ },
	/* 2 */
	/***/ function(module, exports) {
	
		module.exports = __WEBPACK_EXTERNAL_MODULE_2__;
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		module.exports = __WEBPACK_EXTERNAL_MODULE_3__;
	
	/***/ },
	/* 4 */
	/***/ function(module, exports) {
	
		module.exports = __WEBPACK_EXTERNAL_MODULE_4__;
	
	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		var jade = __webpack_require__(6);
		
		module.exports = function template(locals) {
		var buf = [];
		var jade_mixins = {};
		var jade_interp;
		
		buf.push("<ul class=\"list-container\"><div class=\"top-filler\"></div><div class=\"bottom-filler\"></div></ul>");;return buf.join("");
		}
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		/**
		 * Merge two attribute objects giving precedence
		 * to values in object `b`. Classes are special-cased
		 * allowing for arrays and merging/joining appropriately
		 * resulting in a string.
		 *
		 * @param {Object} a
		 * @param {Object} b
		 * @return {Object} a
		 * @api private
		 */
		
		exports.merge = function merge(a, b) {
		  if (arguments.length === 1) {
		    var attrs = a[0];
		    for (var i = 1; i < a.length; i++) {
		      attrs = merge(attrs, a[i]);
		    }
		    return attrs;
		  }
		  var ac = a['class'];
		  var bc = b['class'];
		
		  if (ac || bc) {
		    ac = ac || [];
		    bc = bc || [];
		    if (!Array.isArray(ac)) ac = [ac];
		    if (!Array.isArray(bc)) bc = [bc];
		    a['class'] = ac.concat(bc).filter(nulls);
		  }
		
		  for (var key in b) {
		    if (key != 'class') {
		      a[key] = b[key];
		    }
		  }
		
		  return a;
		};
		
		/**
		 * Filter null `val`s.
		 *
		 * @param {*} val
		 * @return {Boolean}
		 * @api private
		 */
		
		function nulls(val) {
		  return val != null && val !== '';
		}
		
		/**
		 * join array as classes.
		 *
		 * @param {*} val
		 * @return {String}
		 */
		exports.joinClasses = joinClasses;
		function joinClasses(val) {
		  return (Array.isArray(val) ? val.map(joinClasses) :
		    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
		    [val]).filter(nulls).join(' ');
		}
		
		/**
		 * Render the given classes.
		 *
		 * @param {Array} classes
		 * @param {Array.<Boolean>} escaped
		 * @return {String}
		 */
		exports.cls = function cls(classes, escaped) {
		  var buf = [];
		  for (var i = 0; i < classes.length; i++) {
		    if (escaped && escaped[i]) {
		      buf.push(exports.escape(joinClasses([classes[i]])));
		    } else {
		      buf.push(joinClasses(classes[i]));
		    }
		  }
		  var text = joinClasses(buf);
		  if (text.length) {
		    return ' class="' + text + '"';
		  } else {
		    return '';
		  }
		};
		
		
		exports.style = function (val) {
		  if (val && typeof val === 'object') {
		    return Object.keys(val).map(function (style) {
		      return style + ':' + val[style];
		    }).join(';');
		  } else {
		    return val;
		  }
		};
		/**
		 * Render the given attribute.
		 *
		 * @param {String} key
		 * @param {String} val
		 * @param {Boolean} escaped
		 * @param {Boolean} terse
		 * @return {String}
		 */
		exports.attr = function attr(key, val, escaped, terse) {
		  if (key === 'style') {
		    val = exports.style(val);
		  }
		  if ('boolean' == typeof val || null == val) {
		    if (val) {
		      return ' ' + (terse ? key : key + '="' + key + '"');
		    } else {
		      return '';
		    }
		  } else if (0 == key.indexOf('data') && 'string' != typeof val) {
		    if (JSON.stringify(val).indexOf('&') !== -1) {
		      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
		                   'will be escaped to `&amp;`');
		    };
		    if (val && typeof val.toISOString === 'function') {
		      console.warn('Jade will eliminate the double quotes around dates in ' +
		                   'ISO form after 2.0.0');
		    }
		    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
		  } else if (escaped) {
		    if (val && typeof val.toISOString === 'function') {
		      console.warn('Jade will stringify dates in ISO form after 2.0.0');
		    }
		    return ' ' + key + '="' + exports.escape(val) + '"';
		  } else {
		    if (val && typeof val.toISOString === 'function') {
		      console.warn('Jade will stringify dates in ISO form after 2.0.0');
		    }
		    return ' ' + key + '="' + val + '"';
		  }
		};
		
		/**
		 * Render the given attributes object.
		 *
		 * @param {Object} obj
		 * @param {Object} escaped
		 * @return {String}
		 */
		exports.attrs = function attrs(obj, terse){
		  var buf = [];
		
		  var keys = Object.keys(obj);
		
		  if (keys.length) {
		    for (var i = 0; i < keys.length; ++i) {
		      var key = keys[i]
		        , val = obj[key];
		
		      if ('class' == key) {
		        if (val = joinClasses(val)) {
		          buf.push(' ' + key + '="' + val + '"');
		        }
		      } else {
		        buf.push(exports.attr(key, val, false, terse));
		      }
		    }
		  }
		
		  return buf.join('');
		};
		
		/**
		 * Escape the given string of `html`.
		 *
		 * @param {String} html
		 * @return {String}
		 * @api private
		 */
		
		var jade_encode_html_rules = {
		  '&': '&amp;',
		  '<': '&lt;',
		  '>': '&gt;',
		  '"': '&quot;'
		};
		var jade_match_html = /[&<>"]/g;
		
		function jade_encode_char(c) {
		  return jade_encode_html_rules[c] || c;
		}
		
		exports.escape = jade_escape;
		function jade_escape(html){
		  var result = String(html).replace(jade_match_html, jade_encode_char);
		  if (result === '' + html) return html;
		  else return result;
		};
		
		/**
		 * Re-throw the given `err` in context to the
		 * the jade in `filename` at the given `lineno`.
		 *
		 * @param {Error} err
		 * @param {String} filename
		 * @param {String} lineno
		 * @api private
		 */
		
		exports.rethrow = function rethrow(err, filename, lineno, str){
		  if (!(err instanceof Error)) throw err;
		  if ((typeof window != 'undefined' || !filename) && !str) {
		    err.message += ' on line ' + lineno;
		    throw err;
		  }
		  try {
		    str = str || __webpack_require__(7).readFileSync(filename, 'utf8')
		  } catch (ex) {
		    rethrow(err, null, lineno)
		  }
		  var context = 3
		    , lines = str.split('\n')
		    , start = Math.max(lineno - context, 0)
		    , end = Math.min(lines.length, lineno + context);
		
		  // Error context
		  var context = lines.slice(start, end).map(function(line, i){
		    var curr = i + start + 1;
		    return (curr == lineno ? '  > ' : '    ')
		      + curr
		      + '| '
		      + line;
		  }).join('\n');
		
		  // Alter exception message
		  err.path = filename;
		  err.message = (filename || 'Jade') + ':' + lineno
		    + '\n' + context + '\n\n' + err.message;
		  throw err;
		};
		
		exports.DebugItem = function DebugItem(lineno, filename) {
		  this.lineno = lineno;
		  this.filename = filename;
		}
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		/* (ignored) */
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
		var jade = __webpack_require__(6);
		
		module.exports = function template(locals) {
		var buf = [];
		var jade_mixins = {};
		var jade_interp;
		;var locals_for_with = (locals || {});(function (text) {
		buf.push("<li>" + (jade.escape(null == (jade_interp = text) ? "" : jade_interp)) + "</li>");}.call(this,"text" in locals_for_with?locals_for_with.text:typeof text!=="undefined"?text:undefined));;return buf.join("");
		}
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.ElementViewport = exports.WindowViewport = exports.Viewport = undefined;
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _backbone = __webpack_require__(3);
		
		var _backbone2 = _interopRequireDefault(_backbone);
		
		var _jquery = __webpack_require__(2);
		
		var _jquery2 = _interopRequireDefault(_jquery);
		
		var _underscore = __webpack_require__(1);
		
		var _underscore2 = _interopRequireDefault(_underscore);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function getElementMetrics(el) {
		  return _underscore2.default.pick(el.getBoundingClientRect(), ['left', 'top', 'right', 'bottom', 'width', 'height']);
		}
		
		var Viewport = exports.Viewport = function () {
		  function Viewport($el) {
		    var _this = this;
		
		    _classCallCheck(this, Viewport);
		
		    _underscore2.default.extend(this, _backbone2.default.Events);
		
		    this.$el = $el;
		
		    this.onScroll = function () {
		      _this.trigger('scroll');
		      _this.trigger('change');
		    };
		
		    this.onResize = function () {
		      _this.trigger('resize');
		      _this.trigger('change');
		    };
		
		    var keyCode = null;
		    var timestamp = performance.now();
		    this.onKeydown = function (event) {
		      // Consolidate the keydown events for the same key in 0.2 seconds
		      if (keyCode !== event.keyCode || performance.now() > timestamp + 200) {
		        keyCode = event.keyCode;
		        timestamp = performance.now();
		        _this.trigger('keypress', keyCode);
		      }
		    };
		
		    this.onKeyup = function () {
		      keyCode = null;
		    };
		
		    this.$el.on('resize', this.onResize);
		    this.$el.on('scroll', this.onScroll);
		    (0, _jquery2.default)(document).on('keydown', this.onKeydown);
		    (0, _jquery2.default)(document).on('keyup', this.onKeyup);
		
		    this.scrollTo = function (scrollNew) {
		      if (_underscore2.default.isNumber(scrollNew.x)) {
		        _this.$el.scrollLeft(scrollNew.x);
		      }
		      if (_underscore2.default.isNumber(scrollNew.y)) {
		        _this.$el.scrollTop(scrollNew.y);
		      }
		    };
		  }
		
		  _createClass(Viewport, [{
		    key: 'remove',
		    value: function remove() {
		      this.$el.off('resize', this.onResize);
		      this.$el.off('scroll', this.onScroll);
		      (0, _jquery2.default)(document).off('keydown', this.onKeydown);
		      (0, _jquery2.default)(document).off('keyup', this.onKeyup);
		    }
		  }, {
		    key: 'getMetrics',
		    value: function getMetrics() {
		      throw new Error('Not implemented');
		    }
		  }]);
		
		  return Viewport;
		}();
		
		var WindowViewport = exports.WindowViewport = function (_Viewport) {
		  _inherits(WindowViewport, _Viewport);
		
		  function WindowViewport() {
		    _classCallCheck(this, WindowViewport);
		
		    return _possibleConstructorReturn(this, Object.getPrototypeOf(WindowViewport).call(this, (0, _jquery2.default)(window)));
		  }
		
		  _createClass(WindowViewport, [{
		    key: 'getMetrics',
		    value: function getMetrics() {
		      var inner = getElementMetrics(document.documentElement);
		
		      inner.width = document.documentElement.scrollWidth;
		      inner.height = document.documentElement.scrollHeight;
		      inner.right = inner.left + inner.width;
		      inner.bottom = inner.top + inner.height;
		
		      var outer = {
		        top: 0,
		        bottom: window.innerHeight,
		        left: 0,
		        right: window.innerWidth,
		        width: window.innerWidth,
		        height: window.innerHeight
		      };
		
		      var scroll = {
		        x: window.scrollX,
		        y: window.scrollY
		      };
		
		      scroll.ratioX = scroll.x > 0 ? scroll.x / (inner.width - outer.width) : 0;
		      scroll.ratioY = scroll.y > 0 ? scroll.y / (inner.height - outer.height) : 0;
		
		      return { inner: inner, outer: outer, scroll: scroll };
		    }
		  }]);
		
		  return WindowViewport;
		}(Viewport);
		
		var SCROLLABLE = ['auto', 'scroll'];
		
		var ElementViewport = exports.ElementViewport = function (_Viewport2) {
		  _inherits(ElementViewport, _Viewport2);
		
		  function ElementViewport(el) {
		    _classCallCheck(this, ElementViewport);
		
		    var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(ElementViewport).call(this, (0, _jquery2.default)(el)));
		
		    _this3.el = _this3.$el.get(0);
		    _this3.$el.css('overflowX', function (s) {
		      return _underscore2.default.contains(SCROLLABLE, s) ? s : 'auto';
		    });
		    _this3.$el.css('overflowY', function (s) {
		      return _underscore2.default.contains(SCROLLABLE, s) ? s : 'auto';
		    });
		    return _this3;
		  }
		
		  _createClass(ElementViewport, [{
		    key: 'getMetrics',
		    value: function getMetrics() {
		      var outer = getElementMetrics(this.el);
		      var scroll = {
		        x: this.el.scrollLeft,
		        y: this.el.scrollTop
		      };
		      var inner = {
		        left: outer.left - scroll.x,
		        top: outer.top - scroll.y,
		        width: this.el.scrollWidth,
		        height: this.el.scrollHeight
		      };
		      inner.right = inner.left + inner.width;
		      inner.bottom = inner.top + inner.height;
		
		      scroll.ratioX = scroll.x > 0 ? scroll.x / (inner.width - outer.width) : 0;
		      scroll.ratioY = scroll.y > 0 ? scroll.y / (inner.height - outer.height) : 0;
		
		      return { outer: outer, inner: inner, scroll: scroll };
		    }
		  }]);
		
		  return ElementViewport;
		}(Viewport);
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=backbone-virtualized-listview.js.map

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod.exports);
	    global.index = mod.exports;
	  }
	})(this, function (exports) {
	  'use strict';
	
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	
	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }
	
	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }
	
	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();
	
	  var isInteger = Number.isInteger || function (v) {
	    return typeof v === 'number' && isFinite(v) && Math.floor(v) === v;
	  };
	
	  function mostSignificantBit(value) {
	    var result = value;
	
	    result |= result >> 1;
	    result |= result >> 2;
	    result |= result >> 4;
	    result |= result >> 8;
	    result |= result >> 16;
	    result |= result >> 32;
	    result -= result >> 1;
	
	    return result;
	  }
	
	  /**
	   * Class BinaryIndexedTree
	   */
	
	  var BinaryIndexedTree = function () {
	
	    /**
	     * @param {Object} options
	     * @param {number} options.maxVal - The maximum value which will have non-zero frequency
	     * @param {number} [options.defaultFrequency=0] - The default initial frequency
	     */
	
	    function BinaryIndexedTree() {
	      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      var _ref$defaultFrequency = _ref.defaultFrequency;
	      var defaultFrequency = _ref$defaultFrequency === undefined ? 0 : _ref$defaultFrequency;
	      var maxVal = _ref.maxVal;
	
	      _classCallCheck(this, BinaryIndexedTree);
	
	      this._defaultFrequency = defaultFrequency;
	      this._maxVal = maxVal;
	      this._tree = { 0: 0 };
	      this._msb = mostSignificantBit(maxVal);
	      this._countNeg = defaultFrequency < 0 ? maxVal : 0;
	    }
	
	    /**
	     * The default initial frequency
	     * @type {number}
	     */
	
	
	    _createClass(BinaryIndexedTree, [{
	      key: '_getTree',
	      value: function _getTree(index) {
	        if (index in this._tree) {
	          return this._tree[index];
	        }
	
	        return this._defaultFrequency * (index & -index);
	      }
	    }, {
	      key: '_addTree',
	      value: function _addTree(index, delta) {
	        this._tree[index] = this._getTree(index) + delta;
	      }
	    }, {
	      key: '_checkIndex',
	      value: function _checkIndex(index) {
	        if (!isInteger(index)) {
	          throw new Error('Invalid index');
	        }
	        if (index < 0 || index >= this._maxVal) {
	          throw new Error('Index out of range');
	        }
	      }
	    }, {
	      key: '_readSingle',
	      value: function _readSingle(idx) {
	        var index = idx + 1;
	        var sum = this._getTree(index);
	        var z = index - (index & -index);
	
	        index--;
	
	        while (index !== z) {
	          sum -= this._getTree(index);
	          index -= index & -index;
	        }
	
	        return sum;
	      }
	    }, {
	      key: '_changed',
	      value: function _changed(freqCur, freqNew) {
	        if (freqCur < 0 && freqNew >= 0) {
	          this._countNeg--;
	        } else if (freqCur >= 0 && freqNew < 0) {
	          this._countNeg++;
	        }
	      }
	    }, {
	      key: '_update',
	      value: function _update(idx, delta) {
	        var index = idx + 1;
	
	        while (index <= this._maxVal) {
	          this._addTree(index, delta);
	          index += index & -index;
	        }
	      }
	    }, {
	      key: '_writeSingle',
	      value: function _writeSingle(idx, freq) {
	        var freqCur = this._readSingle(idx);
	
	        this._update(idx, freq - freqCur);
	        this._changed(freqCur, freq);
	      }
	    }, {
	      key: '_read',
	      value: function _read(count) {
	        var index = count;
	        var sum = 0;
	        while (index) {
	          sum += this._getTree(index);
	          index -= index & -index;
	        }
	
	        return sum;
	      }
	    }, {
	      key: '_find',
	      value: function _find(sum, before) {
	        var left = 0;
	        var right = this._msb << 1;
	        var sumT = sum;
	
	        while (right > left + 1) {
	          var middle = left + right >> 1;
	          var sumM = this._getTree(middle);
	
	          if (middle <= this._maxVal && before(sumM, sumT)) {
	            sumT -= sumM;
	            left = middle;
	          } else {
	            right = middle;
	          }
	        }
	        return left;
	      }
	    }, {
	      key: 'readSingle',
	      value: function readSingle(idx) {
	        this._checkIndex(idx);
	        return this._readSingle(idx);
	      }
	    }, {
	      key: 'update',
	      value: function update(idx, delta) {
	        this._checkIndex(idx);
	        var freqCur = this._readSingle(idx);
	
	        this._update(idx, delta);
	        this._changed(freqCur, freqCur + delta);
	      }
	    }, {
	      key: 'writeSingle',
	      value: function writeSingle(idx, freq) {
	        this._checkIndex(idx);
	        this._writeSingle(idx, freq);
	      }
	    }, {
	      key: 'read',
	      value: function read(count) {
	        if (!isInteger(count)) {
	          throw new Error('Invalid count');
	        }
	        return this._read(Math.max(Math.min(count, this._maxVal), 0));
	      }
	    }, {
	      key: 'lowerBound',
	      value: function lowerBound(sum) {
	        if (this._countNeg > 0) {
	          throw new Error('Sequence is not non-descending');
	        }
	        return this._find(sum, function (x, y) {
	          return x < y;
	        });
	      }
	    }, {
	      key: 'upperBound',
	      value: function upperBound(sum) {
	        if (this._countNeg > 0) {
	          throw new Error('Sequence is not non-descending');
	        }
	        return this._find(sum, function (x, y) {
	          return x <= y;
	        });
	      }
	    }, {
	      key: 'defaultFrequency',
	      get: function get() {
	        return this._defaultFrequency;
	      }
	    }, {
	      key: 'maxVal',
	      get: function get() {
	        return this._maxVal;
	      }
	    }]);
	
	    return BinaryIndexedTree;
	  }();
	
	  exports.default = BinaryIndexedTree;
	});

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.FooterView = exports.HeaderView = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _underscore = __webpack_require__(5);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	var _backbone = __webpack_require__(10);
	
	var _backbone2 = _interopRequireDefault(_backbone);
	
	var _headerFooter = __webpack_require__(101);
	
	var _headerFooter2 = _interopRequireDefault(_headerFooter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var subviewClass = function subviewClass(i) {
	  return 'header-subview-' + i;
	};
	var subviewSelector = function subviewSelector(i) {
	  return '.' + subviewClass(i);
	};
	
	var HeaderFooterView = function (_Backbone$View) {
	  _inherits(HeaderFooterView, _Backbone$View);
	
	  function HeaderFooterView() {
	    _classCallCheck(this, HeaderFooterView);
	
	    return _possibleConstructorReturn(this, (HeaderFooterView.__proto__ || Object.getPrototypeOf(HeaderFooterView)).apply(this, arguments));
	  }
	
	  _createClass(HeaderFooterView, [{
	    key: 'initialize',
	    value: function initialize(_ref) {
	      var tableView = _ref.tableView;
	      var group = _ref.group;
	
	      this.tableView = tableView;
	      this.group = group;
	      this.subviews = [];
	    }
	  }, {
	    key: 'redraw',
	    value: function redraw() {
	      var _this2 = this;
	
	      _underscore2.default.each(this.subviews, function (subview) {
	        return subview.$el.detach();
	      });
	      this.subviews = [];
	      this.$el.html(this.template({
	        rows: _underscore2.default.map(this.rows, function (row) {
	          var cells = _underscore2.default.map(row.cells, function (cell) {
	            if (cell.view) {
	              var classes = _underscore2.default.union(cell.classes, [subviewClass(_this2.subviews.length)]);
	              _this2.subviews.push(cell.view);
	              return _underscore2.default.defaults({ classes: classes }, cell);
	            }
	            return cell;
	          });
	
	          return _underscore2.default.defaults({ cells: cells }, row);
	        }),
	
	        group: this.group
	      }));
	
	      _underscore2.default.each(this.subviews, function (subview, i) {
	        subview.$el.appendTo(_this2.$(subviewSelector(i)));
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      this.redraw();
	      return this;
	    }
	  }]);
	
	  return HeaderFooterView;
	}(_backbone2.default.View);
	
	var HeaderView = exports.HeaderView = function (_HeaderFooterView) {
	  _inherits(HeaderView, _HeaderFooterView);
	
	  function HeaderView() {
	    _classCallCheck(this, HeaderView);
	
	    return _possibleConstructorReturn(this, (HeaderView.__proto__ || Object.getPrototypeOf(HeaderView)).apply(this, arguments));
	  }
	
	  _createClass(HeaderView, [{
	    key: 'template',
	    value: function template(model) {
	      return (0, _headerFooter2.default)(_underscore2.default.defaults({ group: 'head' }, model));
	    }
	  }, {
	    key: 'rows',
	    get: function get() {
	      return this.tableView._state.headRows;
	    }
	  }]);
	
	  return HeaderView;
	}(HeaderFooterView);
	
	var FooterView = exports.FooterView = function (_HeaderFooterView2) {
	  _inherits(FooterView, _HeaderFooterView2);
	
	  function FooterView() {
	    _classCallCheck(this, FooterView);
	
	    return _possibleConstructorReturn(this, (FooterView.__proto__ || Object.getPrototypeOf(FooterView)).apply(this, arguments));
	  }
	
	  _createClass(FooterView, [{
	    key: 'template',
	    value: function template(model) {
	      return (0, _headerFooter2.default)(_underscore2.default.defaults({ group: 'foot' }, model));
	    }
	  }, {
	    key: 'rows',
	    get: function get() {
	      return this.tableView._state.footRows;
	    }
	  }]);
	
	  return FooterView;
	}(HeaderFooterView);

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (group, rows) {
	jade_mixins["mixinHeadCell"] = jade_interp = function(cell){
	var block = (this && this.block), attributes = (this && this.attributes) || {};
	buf.push("<th" + (jade.attrs(jade.merge([{"class": (jade_interp = [true], jade.joinClasses([cell.classes].map(jade.joinClasses).map(function (cls, i) {   return jade_interp[i] ? jade.escape(cls) : cls })))},cell.attributes]), true)) + ">");
	if ( (cell.html))
	{
	buf.push(null == (jade_interp = cell.html) ? "" : jade_interp);
	}
	else
	{
	buf.push(jade.escape(null == (jade_interp = cell.value) ? "" : jade_interp));
	}
	buf.push("</th>");
	};
	jade_mixins["mixinCell"] = jade_interp = function(cell){
	var block = (this && this.block), attributes = (this && this.attributes) || {};
	buf.push("<td" + (jade.attrs(jade.merge([{"class": (jade_interp = [true], jade.joinClasses([cell.classes].map(jade.joinClasses).map(function (cls, i) {   return jade_interp[i] ? jade.escape(cls) : cls })))},cell.attributes]), true)) + ">");
	if ( (cell.html))
	{
	buf.push(null == (jade_interp = cell.html) ? "" : jade_interp);
	}
	else
	{
	buf.push(jade.escape(null == (jade_interp = cell.value) ? "" : jade_interp));
	}
	buf.push("</td>");
	};
	jade_mixins["mixinRow"] = jade_interp = function(row, group){
	var block = (this && this.block), attributes = (this && this.attributes) || {};
	buf.push("<tr" + (jade.attrs(jade.merge([{"class": (jade_interp = [true], jade.joinClasses([row.classes].map(jade.joinClasses).map(function (cls, i) {   return jade_interp[i] ? jade.escape(cls) : cls })))},row.attributes]), true)) + ">");
	// iterate row.cells || []
	;(function(){
	  var $$obj = row.cells || [];
	  if ('number' == typeof $$obj.length) {
	
	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var cell = $$obj[$index];
	
	switch (group){
	case 'head':
	jade_mixins["mixinHeadCell"](cell);
	  break;
	case 'body':
	case 'foot':
	jade_mixins["mixinCell"](cell);
	  break;
	}
	    }
	
	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var cell = $$obj[$index];
	
	switch (group){
	case 'head':
	jade_mixins["mixinHeadCell"](cell);
	  break;
	case 'body':
	case 'foot':
	jade_mixins["mixinCell"](cell);
	  break;
	}
	    }
	
	  }
	}).call(this);
	
	buf.push("</tr>");
	};
	jade_mixins["mixinRows"] = jade_interp = function(rows, group){
	var block = (this && this.block), attributes = (this && this.attributes) || {};
	// iterate rows || []
	;(function(){
	  var $$obj = rows || [];
	  if ('number' == typeof $$obj.length) {
	
	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var row = $$obj[$index];
	
	jade_mixins["mixinRow"](row, group);
	    }
	
	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var row = $$obj[$index];
	
	jade_mixins["mixinRow"](row, group);
	    }
	
	  }
	}).call(this);
	
	};
	jade_mixins["mixinRows"](rows, group);}.call(this,"group" in locals_for_with?locals_for_with.group:typeof group!=="undefined"?group:undefined,"rows" in locals_for_with?locals_for_with.rows:typeof rows!=="undefined"?rows:undefined));;return buf.join("");
	}

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (row) {
	jade_mixins["mixinHeadCell"] = jade_interp = function(cell){
	var block = (this && this.block), attributes = (this && this.attributes) || {};
	buf.push("<th" + (jade.attrs(jade.merge([{"class": (jade_interp = [true], jade.joinClasses([cell.classes].map(jade.joinClasses).map(function (cls, i) {   return jade_interp[i] ? jade.escape(cls) : cls })))},cell.attributes]), true)) + ">");
	if ( (cell.html))
	{
	buf.push(null == (jade_interp = cell.html) ? "" : jade_interp);
	}
	else
	{
	buf.push(jade.escape(null == (jade_interp = cell.value) ? "" : jade_interp));
	}
	buf.push("</th>");
	};
	jade_mixins["mixinCell"] = jade_interp = function(cell){
	var block = (this && this.block), attributes = (this && this.attributes) || {};
	buf.push("<td" + (jade.attrs(jade.merge([{"class": (jade_interp = [true], jade.joinClasses([cell.classes].map(jade.joinClasses).map(function (cls, i) {   return jade_interp[i] ? jade.escape(cls) : cls })))},cell.attributes]), true)) + ">");
	if ( (cell.html))
	{
	buf.push(null == (jade_interp = cell.html) ? "" : jade_interp);
	}
	else
	{
	buf.push(jade.escape(null == (jade_interp = cell.value) ? "" : jade_interp));
	}
	buf.push("</td>");
	};
	jade_mixins["mixinRow"] = jade_interp = function(row, group){
	var block = (this && this.block), attributes = (this && this.attributes) || {};
	buf.push("<tr" + (jade.attrs(jade.merge([{"class": (jade_interp = [true], jade.joinClasses([row.classes].map(jade.joinClasses).map(function (cls, i) {   return jade_interp[i] ? jade.escape(cls) : cls })))},row.attributes]), true)) + ">");
	// iterate row.cells || []
	;(function(){
	  var $$obj = row.cells || [];
	  if ('number' == typeof $$obj.length) {
	
	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var cell = $$obj[$index];
	
	switch (group){
	case 'head':
	jade_mixins["mixinHeadCell"](cell);
	  break;
	case 'body':
	case 'foot':
	jade_mixins["mixinCell"](cell);
	  break;
	}
	    }
	
	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var cell = $$obj[$index];
	
	switch (group){
	case 'head':
	jade_mixins["mixinHeadCell"](cell);
	  break;
	case 'body':
	case 'foot':
	jade_mixins["mixinCell"](cell);
	  break;
	}
	    }
	
	  }
	}).call(this);
	
	buf.push("</tr>");
	};
	
	
	
	
	
	
	
	
	
	
	
	jade_mixins["mixinRow"](row, 'body');}.call(this,"row" in locals_for_with?locals_for_with.row:typeof row!=="undefined"?row:undefined));;return buf.join("");
	}

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (classes) {
	var tableStyle = {
	  'border-collapse': 'collapse',
	  'margin': 0,
	  'table-layout': 'fixed',
	};
	
	buf.push("<div class=\"table-container\"><div class=\"fixed-header\"><table" + (jade.attr("style", tableStyle, true, true)) + (jade.cls([classes], [true])) + "><colgroup class=\"column-group\"></colgroup><thead class=\"header\"></thead></table></div><div class=\"viewport\"><table" + (jade.attr("style", tableStyle, true, true)) + (jade.cls([classes], [true])) + "><colgroup class=\"column-group\"></colgroup><tbody><tr class=\"top-filler\"></tr><tr class=\"bottom-filler\"></tr></tbody><tfoot class=\"footer\"></tfoot></table></div></div>");}.call(this,"classes" in locals_for_with?locals_for_with.classes:typeof classes!=="undefined"?classes:undefined));;return buf.join("");
	}

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (classes) {
	var tableStyle = {
	  'border-collapse': 'collapse',
	  'margin': 0,
	};
	
	buf.push("<div class=\"table-container\"><table" + (jade.attr("style", tableStyle, true, true)) + (jade.cls([classes], [true])) + "><colgroup class=\"column-group\"></colgroup><thead class=\"header\"></thead><tbody> <tr class=\"top-filler\"></tr><tr class=\"bottom-filler\"></tr></tbody><tfoot class=\"footer\"></tfoot></table></div>");}.call(this,"classes" in locals_for_with?locals_for_with.classes:typeof classes!=="undefined"?classes:undefined));;return buf.join("");
	}

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (classes) {
	var tableStyle = {
	  'border-collapse': 'collapse',
	  'margin': 0,
	  'table-layout': 'fixed',
	};
	
	buf.push("<div class=\"table-container\"><table" + (jade.attr("style", tableStyle, true, true)) + (jade.cls(['sticky-header',classes], [null,true])) + "><colgroup class=\"column-group\"></colgroup><thead class=\"header\"></thead></table><div class=\"sticky-header-filler\"></div><table" + (jade.attr("style", tableStyle, true, true)) + (jade.cls([classes], [true])) + "><colgroup class=\"column-group\"></colgroup><tbody><tr class=\"top-filler\"></tr><tr class=\"bottom-filler\"></tr></tbody><tfoot class=\"footer\"></tfoot></table></div>");}.call(this,"classes" in locals_for_with?locals_for_with.classes:typeof classes!=="undefined"?classes:undefined));;return buf.join("");
	}

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (cols, undefined) {
	// iterate cols || []
	;(function(){
	  var $$obj = cols || [];
	  if ('number' == typeof $$obj.length) {
	
	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var col = $$obj[$index];
	
	var columnStyle = col.width ? 'width: ' + col.width + ';' : null;
	buf.push("<col" + (jade.attr("style", columnStyle, true, true)) + (jade.cls([col.classes], [true])) + ">");
	    }
	
	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var col = $$obj[$index];
	
	var columnStyle = col.width ? 'width: ' + col.width + ';' : null;
	buf.push("<col" + (jade.attr("style", columnStyle, true, true)) + (jade.cls([col.classes], [true])) + ">");
	    }
	
	  }
	}).call(this);
	}.call(this,"cols" in locals_for_with?locals_for_with.cols:typeof cols!=="undefined"?cols:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = {
		"value": [
			{
				"UserName": "russellwhyte",
				"FirstName": "Russell",
				"LastName": "Whyte",
				"Emails": [
					"Russell@example.com",
					"Russell@contoso.com"
				],
				"AddressInfo": [
					{
						"Address": "187 Suffolk Ln.",
						"City": {
							"CountryRegion": "United States",
							"Name": "Boise",
							"Region": "ID"
						}
					}
				],
				"Gender": "Male",
				"Concurrency": 635997521113573200
			},
			{
				"UserName": "scottketchum",
				"FirstName": "Scott",
				"LastName": "Ketchum",
				"Emails": [
					"Scott@example.com"
				],
				"AddressInfo": [
					{
						"Address": "2817 Milton Dr.",
						"City": {
							"CountryRegion": "United States",
							"Name": "Albuquerque",
							"Region": "NM"
						}
					}
				],
				"Gender": "Male",
				"Concurrency": 635997521113573200
			},
			{
				"UserName": "ronaldmundy",
				"FirstName": "Ronald",
				"LastName": "Mundy",
				"Emails": [
					"Ronald@example.com",
					"Ronald@contoso.com"
				],
				"AddressInfo": [],
				"Gender": "Male",
				"Concurrency": 635997521113573200
			},
			{
				"UserName": "javieralfred",
				"FirstName": "Javier",
				"LastName": "Alfred",
				"Emails": [
					"Javier@example.com",
					"Javier@contoso.com"
				],
				"AddressInfo": [
					{
						"Address": "89 Jefferson Way Suite 2",
						"City": {
							"CountryRegion": "United States",
							"Name": "Portland",
							"Region": "WA"
						}
					}
				],
				"Gender": "Male",
				"Concurrency": 635997521113573200
			},
			{
				"UserName": "willieashmore",
				"FirstName": "Willie",
				"LastName": "Ashmore",
				"Emails": [
					"Willie@example.com",
					"Willie@contoso.com"
				],
				"AddressInfo": [],
				"Gender": "Male",
				"Concurrency": 635997521113573200
			},
			{
				"UserName": "vincentcalabrese",
				"FirstName": "Vincent",
				"LastName": "Calabrese",
				"Emails": [
					"Vincent@example.com",
					"Vincent@contoso.com"
				],
				"AddressInfo": [
					{
						"Address": "55 Grizzly Peak Rd.",
						"City": {
							"CountryRegion": "United States",
							"Name": "Butte",
							"Region": "MT"
						}
					}
				],
				"Gender": "Male",
				"Concurrency": 635997521113573200
			},
			{
				"UserName": "clydeguess",
				"FirstName": "Clyde",
				"LastName": "Guess",
				"Emails": [
					"Clyde@example.com"
				],
				"AddressInfo": [],
				"Gender": "Male",
				"Concurrency": 635997521113573200
			},
			{
				"UserName": "keithpinckney",
				"FirstName": "Keith",
				"LastName": "Pinckney",
				"Emails": [
					"Keith@example.com",
					"Keith@contoso.com"
				],
				"AddressInfo": [],
				"Gender": "Male",
				"Concurrency": 635997521113573200
			},
			{
				"UserName": "marshallgaray",
				"FirstName": "Marshall",
				"LastName": "Garay",
				"Emails": [
					"Marshall@example.com",
					"Marshall@contoso.com"
				],
				"AddressInfo": [],
				"Gender": "Male",
				"Concurrency": 635997660015061500
			},
			{
				"UserName": "ryantheriault",
				"FirstName": "Ryan",
				"LastName": "Theriault",
				"Emails": [
					"Ryan@example.com",
					"Ryan@contoso.com"
				],
				"AddressInfo": [],
				"Gender": "Male",
				"Concurrency": 635997660015061500
			},
			{
				"UserName": "elainestewart",
				"FirstName": "Elaine",
				"LastName": "Stewart",
				"Emails": [
					"Elaine@example.com",
					"Elaine@contoso.com"
				],
				"AddressInfo": [],
				"Gender": "Female",
				"Concurrency": 635997660015061500
			},
			{
				"UserName": "salliesampson",
				"FirstName": "Sallie",
				"LastName": "Sampson",
				"Emails": [
					"Sallie@example.com",
					"Sallie@contoso.com"
				],
				"AddressInfo": [
					{
						"Address": "87 Polk St. Suite 5",
						"City": {
							"CountryRegion": "United States",
							"Name": "San Francisco",
							"Region": "CA"
						}
					},
					{
						"Address": "89 Chiaroscuro Rd.",
						"City": {
							"CountryRegion": "United States",
							"Name": "Portland",
							"Region": "OR"
						}
					}
				],
				"Gender": "Female",
				"Concurrency": 635997660015061500
			},
			{
				"UserName": "jonirosales",
				"FirstName": "Joni",
				"LastName": "Rosales",
				"Emails": [
					"Joni@example.com",
					"Joni@contoso.com"
				],
				"AddressInfo": [],
				"Gender": "Female",
				"Concurrency": 635997660015061500
			},
			{
				"UserName": "georginabarlow",
				"FirstName": "Georgina",
				"LastName": "Barlow",
				"Emails": [
					"Georgina@example.com",
					"Georgina@contoso.com"
				],
				"AddressInfo": [],
				"Gender": "Female",
				"Concurrency": 635997660015061500
			},
			{
				"UserName": "angelhuffman",
				"FirstName": "Angel",
				"LastName": "Huffman",
				"Emails": [
					"Angel@example.com"
				],
				"AddressInfo": [],
				"Gender": "Female",
				"Concurrency": 635997660015061500
			},
			{
				"UserName": "laurelosborn",
				"FirstName": "Laurel",
				"LastName": "Osborn",
				"Emails": [
					"Laurel@example.com",
					"Laurel@contoso.com"
				],
				"AddressInfo": [],
				"Gender": "Female",
				"Concurrency": 635997660015061500
			}
		]
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(12);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (value) {
	buf.push("<div class=\"testTmpl\">" + (jade.escape((jade_interp = value) == null ? '' : jade_interp)) + "</div>");}.call(this,"value" in locals_for_with?locals_for_with.value:typeof value!=="undefined"?value:undefined));;return buf.join("");
	}

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgN2Q5MjZhZmE0NmM4YTE4NjhmYTEiLCJ3ZWJwYWNrOi8vLy4vZW50cnkuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvZmFjdG9yeS9ncmlkLWZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwid2VicGFjazovLy8uLy4uL2pzL2ZhY3RvcnkvcmVuZGVyZXJzLXBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy9sYXlvdXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvbGF5b3V0L3RhYmxlLmpzIiwid2VicGFjazovLy8uLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9iYWNrYm9uZS9iYWNrYm9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vanMvbGF5b3V0L3RlbXBsYXRlL3RhYmxlLmphZGUiLCJ3ZWJwYWNrOi8vLy4uL34vamFkZS9saWIvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vZnMgKGlnbm9yZWQpIiwid2VicGFjazovLy8uLy4uL2pzL2xheW91dC9yZW5kZXJlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy9sYXlvdXQvcmVuZGVyZXIvZml4ZWQtaGVhZGVyLmpzIiwid2VicGFjazovLy8uLy4uL2pzL2xheW91dC9tZWFzdXJlLmpzIiwid2VicGFjazovLy8uLy4uL2pzL2xheW91dC9weC5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy9sYXlvdXQvcmVuZGVyZXIvdmlydHVhbGl6YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvZmFjdG9yeS9wcm9qZWN0aW9uLXBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy9wcm9qZWN0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uLy4uL2pzL3Byb2plY3Rpb24vYTExeS5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy9wcm9qZWN0aW9uL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvbW9kZWwvcmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9hZ2dyZWdhdGUtcm93LmpzIiwid2VicGFjazovLy8uLy4uL2pzL3Byb2plY3Rpb24vY29sdW1uLWkxOG4uanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvc2NoZW1hL3Byb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9jb2x1bW4tcXVlcnlhYmxlLmpzIiwid2VicGFjazovLy8uLy4uL2pzL3Byb2plY3Rpb24vY29sdW1uLXNoaWZ0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9jb2x1bW4tdGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9lZGl0YWJsZS1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL2pzL2xheW91dC90ZW1wbGF0ZS9yb3cuZWRpdGFibGUuc3RyaW5nLmphZGUiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9lZGl0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vanMvbGF5b3V0L3RlbXBsYXRlL2VkaXRhYmxlLmphZGUiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcG9wdXAtZWRpdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2JsdWViaXJkL2pzL2Jyb3dzZXIvYmx1ZWJpcmQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi4vanMvcG9wdXAtZWRpdG9yL2luZGV4LmphZGUiLCJ3ZWJwYWNrOi8vLy4uL2xlc3MvZWRpdGFibGUubGVzcz85MTVmIiwid2VicGFjazovLy8uLi9sZXNzL2VkaXRhYmxlLmxlc3MiLCJ3ZWJwYWNrOi8vLy4uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy9wcm9qZWN0aW9uL2pzZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy9wcm9qZWN0aW9uL21hcC5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy9wcm9qZWN0aW9uL21lbW9yeS1xdWVyeWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9tZW1vcnkuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9tb2NrLmpzIiwid2VicGFjazovLy8uLy4uL2pzL3Byb2plY3Rpb24vb2RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9wYWdlLmpzIiwid2VicGFjazovLy8uLy4uL2pzL3Byb2plY3Rpb24vcHJvcGVydHktdGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9yb3ctY2hlY2tib3guanMiLCJ3ZWJwYWNrOi8vLy4uL2pzL2xheW91dC90ZW1wbGF0ZS9zZWxlY3RhYmxlLmphZGUiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9yb3cuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9yb3ctdHJpLXN0YXRlLWNoZWNrYm94LmpzIiwid2VicGFjazovLy8uLi9qcy9sYXlvdXQvdGVtcGxhdGUvcm93LnRyaS1zdGF0ZS1jaGVja2VkLmphZGUiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9yb3ctaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvcHJvamVjdGlvbi9zaW5rLmpzIiwid2VicGFjazovLy8uLy4uL2pzL3Byb2plY3Rpb24vY29sdW1uLWdyb3VwLmpzIiwid2VicGFjazovLy8uLy4uL2pzL3Byb2plY3Rpb24vY29sdW1uLWhvdmVydGV4dC5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy9wcm9qZWN0aW9uL2NvbHVtbnMuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvZmFjdG9yeS91dGlsaXR5LmpzIiwid2VicGFjazovLy8uLy4uL2pzL2ZhY3RvcnkvZ3JpZC12aWV3LXBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy9ncmlkLXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvbW9kZWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvd2luZG93Q29udGFpbmVyLmpzIiwid2VicGFjazovLy8uLy4uL2pzL2NvbnRhaW5lckJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvZWxlbWVudENvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy92bmV4dC9mYWN0b3J5L2RhdGEtc291cmNlLXBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy92bmV4dC9kYXRhLXNvdXJjZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy92bmV4dC9kYXRhLXNvdXJjZS9iYXNlLmpzIiwid2VicGFjazovLy8uLy4uL2pzL3ZuZXh0L2RhdGEtc291cmNlL29kYXRhLmpzIiwid2VicGFjazovLy8uLy4uL2pzL3ZuZXh0L2RhdGEtc291cmNlL2pzLWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvdm5leHQvZGF0YS1zb3VyY2UvbWVtb3J5LmpzIiwid2VicGFjazovLy8uLy4uL2pzL3ZuZXh0L2ZhY3RvcnkvZ3JpZC12aWV3LXBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy92bmV4dC9ncmlkLXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvdm5leHQvcHJvamVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy92bmV4dC9wcm9qZWN0aW9uL3F1ZXJ5LmpzIiwid2VicGFjazovLy8uLy4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vYnVmZmVyLmpzIiwid2VicGFjazovLy8uLy4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vc2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uLy4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vc2luZ2xlLXNlbGVjdGlvbi1yZXNvbHZlci5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy92bmV4dC9wcm9qZWN0aW9uL3NlbGVjdGlvbi1yZXNvbHZlci5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy92bmV4dC9wcm9qZWN0aW9uL211bHRpcGxlLXNlbGVjdGlvbi1yZXNvbHZlci5qcyIsIndlYnBhY2s6Ly8vLi4vanMvdm5leHQvcHJvamVjdGlvbi9zZWxlY3Rpb24taGVhZC5qYWRlIiwid2VicGFjazovLy8uLi9qcy92bmV4dC9wcm9qZWN0aW9uL3NlbGVjdGlvbi1ib2R5LmphZGUiLCJ3ZWJwYWNrOi8vLy4vLi4vanMvdm5leHQvcHJvamVjdGlvbi9jb2x1bW5zLmpzIiwid2VicGFjazovLy8uLy4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vcm93cy5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy92bmV4dC9wcm9qZWN0aW9uL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy92bmV4dC9wcm9qZWN0aW9uL2NvbHVtbi1ncm91cC5qcyIsIndlYnBhY2s6Ly8vLi4vanMvdm5leHQvcHJvamVjdGlvbi9kZWZhdWx0LWNlbGwuamFkZSIsIndlYnBhY2s6Ly8vLi8uLi9qcy92bmV4dC9wcm9qZWN0aW9uL2NlbGxzLmpzIiwid2VicGFjazovLy8uLy4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vc29ydGFibGUtaGVhZGVyLmpzIiwid2VicGFjazovLy8uLi9qcy92bmV4dC9wcm9qZWN0aW9uL3NvcnRhYmxlLWhlYWRlci5qYWRlIiwid2VicGFjazovLy8uLy4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vZWRpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2pzL3ZuZXh0L2xheW91dC9lZGl0YWJsZS5qYWRlIiwid2VicGFjazovLy8uLy4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vZXZlbnRzLmpzIiwid2VicGFjazovLy8uLy4uL2pzL3ZuZXh0L2xheW91dC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi8uLi9qcy92bmV4dC9sYXlvdXQvdGFibGUtdmlldy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9iYWNrYm9uZS12aXJ0dWFsaXplZC1saXN0dmlldy9kaXN0L2JhY2tib25lLXZpcnR1YWxpemVkLWxpc3R2aWV3LmpzIiwid2VicGFjazovLy8uLi9+L2Zhc3QtYmluYXJ5LWluZGV4ZWQtdHJlZS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uLy4uL2pzL3ZuZXh0L2xheW91dC9oZWFkZXItZm9vdGVyLXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4uL2pzL3ZuZXh0L2xheW91dC9oZWFkZXItZm9vdGVyLmphZGUiLCJ3ZWJwYWNrOi8vLy4uL2pzL3ZuZXh0L2xheW91dC9yb3cuamFkZSIsIndlYnBhY2s6Ly8vLi4vanMvdm5leHQvbGF5b3V0L3RhYmxlLWZpeGVkLmphZGUiLCJ3ZWJwYWNrOi8vLy4uL2pzL3ZuZXh0L2xheW91dC90YWJsZS1zdGF0aWMuamFkZSIsIndlYnBhY2s6Ly8vLi4vanMvdm5leHQvbGF5b3V0L3RhYmxlLXN0aWNreS5qYWRlIiwid2VicGFjazovLy8uLi9qcy92bmV4dC9sYXlvdXQvY29sdW1uLWdyb3VwLmphZGUiLCJ3ZWJwYWNrOi8vLy4vcGVvcGxlLmpzb24iLCJ3ZWJwYWNrOi8vLy4vdGVzdFRtcGwuamFkZSJdLCJuYW1lcyI6WyJwR3JpZCIsInJlcXVpcmUiLCJtZW1vcnlEYXRhIiwidmFsdWUiLCJ0bXBsIiwiZ3JpZENvbmZpZyIsImVsIiwiZGF0YVNvdXJjZSIsInR5cGUiLCJkYXRhIiwicHJpbWFyeUtleSIsImNvbHVtbnMiLCJuYW1lIiwidGl0bGUiLCJzb3J0YWJsZSIsImxvY2tlZCIsImVkaXRhYmxlIiwiY29sQ2xhc3NlcyIsImhlYWRlckNsYXNzZXMiLCJwcm9wZXJ0eSIsInRlbXBsYXRlIiwiaHRtbCIsImhpZGRlbiIsInBncmlkIiwiZmFjdG9yeSIsInZuZXh0IiwiY3JlYXRlIiwiZ3JpZFZpZXciLCJyZW5kZXIiLCJtb2R1bGUiLCJleHBvcnRzIiwidmVyc2lvbiIsIkdyaWRWaWV3IiwicHJvamVjdGlvbnMiLCJsYXlvdXQiLCJwb3B1cEVkaXRvclByb21wdCIsIkJhc2UiLCJNZW1vcnkiLCJPRGF0YSIsIkpTRGF0YSIsIm9wdGlvbnMiLCJHcmlkRmFjdG9yeSIsImNvbmZpZ1BsdWdpbiIsImRlZmluZVBsdWdpbiIsImNvbmZpZyIsInBsdWdpbkluZGV4IiwicGx1Z2lucyIsInVzZSIsImRlcHMiLCJjYWxsYmFjayIsInBsdWdpbiIsInB1c2giLCJlYWNoIiwiaGFzIiwiZGVwIiwiRXJyb3IiLCJiaW5kIiwicmVkdWNlIiwicmVzdWx0IiwiZXh0ZW5kIiwiYXBwbHkiLCJtYXAiLCJyZW5kZXJlcnMiLCJzY3JvbGxhYmxlIiwidmlydHVhbCIsIlZpcnR1YWxpemF0aW9uIiwiZml4ZWRIZWFkZXIiLCJGaXhlZEhlYWRlciIsIlRhYmxlTGF5b3V0IiwidGVtcGxhdGVzIiwidGFibGUiLCJfIiwiJCIsIkJhY2tib25lIiwiVmlldyIsImV2ZW50cyIsImluaXRpYWxpemUiLCJiaW5kQWxsIiwidW5kZWZpbmVkIiwiY29udGFpbmVyIiwiZ3JpZCIsIlJlbmRlcmVyIiwic3Vidmlld3MiLCJvblZpZXdQb3J0Q2hhbmdlIiwiaXNFbXB0eSIsImxpc3RlblRvIiwic2NoZWR1bGVEcmF3IiwicmVtb3ZlU3Vidmlld3MiLCJzdWJ2aWV3IiwicmVtb3ZlIiwic3RvcExpc3RlbmluZyIsInJlbmRlcmVyIiwicHJvdG90eXBlIiwiYXJndW1lbnRzIiwidGhDbGljayIsImUiLCJhcmciLCJkYXRhRm9yIiwiY3VycmVudFRhcmdldCIsImNvbHVtbiIsInRyaWdnZXIiLCJ0ZENsaWNrIiwiZWRpdGFibGVTdHJpbmdDaGFuZ2UiLCJjb2xFZGl0YWJsZVN0ciIsInByb2plY3Rpb24iLCJnZXQiLCJpc09iamVjdCIsImlzVW5kZWZpbmVkIiwiY29udGFpbnMiLCIkZWwiLCIkdHIiLCJjbG9zZXN0IiwiJGNsb3Nlc3RURCIsIiRjbG9zZXN0VEgiLCIkdGQiLCJzaXplIiwidmlydHVhbGl6ZXIiLCJnZXRSZW5kZXJlciIsImkiLCJpbmRleCIsImoiLCJpc0hlYWRlciIsImxlbmd0aCIsInJldCIsImhlYWRlciIsInNlbGVjdCIsInN1YlNlbGVjdCIsInNlbGVjdEV4cGFuZCIsImZpcnN0IiwibW9kZWwiLCJjaGVja2JveCIsImZpbmQiLCJjaGVja2VkIiwidG9IVE1MIiwiZGVmYXVsdHMiLCJjb2wiLCIkbWV0YWRhdGEiLCJpc0FycmF5IiwiY2xhc3MiLCJqb2luIiwidXBkYXRlIiwiY29sdW1uc0RlbHRhIiwiY29sT3B0aW9ucyIsIm9yZGVyYnkiLCJlbGVtZW50Iiwia2V5Iiwia2V5cyIsImRpciIsImRlbHRhIiwiY29sT3B0aW9uIiwib3JkZXJOYW1lIiwiaXNTdHJpbmciLCIkb3JkZXJieSIsImluZGV4QnkiLCJoaWRlSGVhZGVycyIsInRvSlNPTiIsImRyYXciLCJjYW5Ta2lwRHJhdyIsInNjaGVkdWxlZERyYXciLCJ3aW5kb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkcmF3YWJsZSIsInIiLCJtaWRkbGV3YXJlIiwiY2IiLCJjbG9uZSIsImNzcyIsIm9uY2UiLCJlcnIiLCJyZXMiLCJyb3dzIiwiaW5uZXJIVE1MIiwiaXNGdW5jdGlvbiIsImNlbGxWaWV3IiwiSGVhZGVyVmlldyIsImhlYWRlclZpZXciLCJvbiIsInBhcnRpYWwiLCJtZWFzdXJlIiwicHgiLCJzdGF0ZSIsImFkanVzdENvbHVtbldpZHRoIiwiZnJlZXplQ29sdW1uV2lkdGgiLCJuZXdTdGF0ZSIsInZwTWVhc3VyZXMiLCJ2aWV3cG9ydCIsImNhbGwiLCJ2aWV3cG9ydFRvcCIsInRvcCIsImJvdW5kc1RvcCIsImRpc3BsYWNlbWVudCIsIm91dGVySGVpZ2h0IiwicGl4ZWxpZnkiLCJwYXJzZSIsIiR0aGVhZCIsIiRoZWFkVFIiLCIkaGVhZFREIiwiY2hpbGRyZW4iLCIkc2Vjb25kSGVhZFREIiwiZXEiLCIkYm9keVREIiwiJHJlZiIsIiR0YXJnZXQiLCJjb2xXaWR0aCIsInRkIiwid2lkdGgiLCJjb2xJbmRleCIsInNlY29uZEhlYWRUREluZGV4IiwiY29sc3BhbiIsInBhcnNlSW50IiwiYXR0ciIsInJvd3NwYW4iLCJzY3JvbGxUb3AiLCJvZmZzZXRMZWZ0Iiwib2ZmIiwibyIsIiR2aWV3cG9ydCIsInZpZXdwb3J0Qm90dG9tIiwiaGVpZ2h0Iiwidmlld3BvcnRMZWZ0Iiwic2Nyb2xsTGVmdCIsIm9mZnNldCIsImJvdW5kc0JvdHRvbSIsImlubmVySGVpZ2h0IiwidmlzaWJsZVRvcCIsIk1hdGgiLCJtYXgiLCJ2aXNpYmxlQm90dG9tIiwibWluIiwiYm90dG9tIiwiZGltZW5zaW9ucyIsInRoZWFkIiwiYXZnIiwibWVtbyIsIm51bSIsImF2Z1Jvd0hlaWdodCIsImVzdGltYXRlSGVpZ2h0Iiwic2FtcGxlIiwiJHRtcEVsIiwiYXBwZW5kIiwiYSIsImFicyIsInBhcnNlRmxvYXQiLCJpc0Zpbml0ZSIsInJvd0hlaWdodCIsInJvdyIsImlzTnVtYmVyIiwiX19oZWlnaHQiLCJfX21lYXN1cmVzIiwibGFzdCIsInJvd0F0T2Zmc2V0IiwicmVtIiwiY291bnQiLCJzbXBsIiwicGljayIsImVyck1hcmdpblJvd0NvdW50IiwicFRvcCIsInBCb3R0b20iLCJzbGljZSIsInRibE1lYXN1cmUiLCJoZWlnaHRzIiwiY2hhaW4iLCJjb21wYWN0Iiwibm9vcCIsInByb2plY3Rpb25Db25maWdzIiwiQTExeSIsImFjY0NvbmZpZyIsImExMXkiLCJzZWxlY3Rpb24iLCJzZWxlY3RBbGxMYWJlbCIsIkFnZ3JlZ2F0ZVJvdyIsImNvbmZpZ0FnZyIsImFnZ3JlZ2F0ZSIsInJlc291cmNlIiwicXVlcnkiLCJNYXAiLCJwcm9wZXJ0aWVzIiwiZmllbGQiLCJzcGxpdCIsInByb3AiLCJpdGVtIiwiQ29sdW1ucyIsImF0dHJpYnV0ZXMiLCJoZWFkZXJBdHRyaWJ1dGVzIiwiaGVhZGVyQnVpbGRlciIsInNlbGVjdGFibGUiLCJjb2x1bW5TaGlmdGVyIiwiQ29sdW1uSTE4biIsImNvbHVtbkkxOG4iLCJzdWJDb2xUaXRsZSIsIkNvbHVtblF1ZXJ5YWJsZSIsImNvbHVtbkluIiwicmVqZWN0IiwiY29sdW1uTG9jayIsImZpbHRlciIsImNvbHFDb25maWciLCJ1bnNoaWZ0IiwidG90YWxDb2x1bW5zIiwiQ29sdW1uR3JvdXAiLCJjb2x1bW5Hcm91cCIsIkNvbHVtblNoaWZ0ZXIiLCJDb2x1bW5UZW1wbGF0ZSIsImNvbHVtblRtcGwiLCJoZWFkZXJUZW1wbGF0ZSIsIkNvbHVtbkhvdmVyVGV4dCIsIkVkaXRhYmxlIiwiZWRpdGFibGVPcHRpb25zIiwiY29uZGl0aW9uIiwiZWRpdG9yIiwidG9vbHRpcFRleHQiLCJpY29uQ2xhc3NlcyIsIk1lbW9yeVF1ZXJ5YWJsZSIsImNvbHVtblNvcnRhYmxlIiwiT2RhdGEiLCJQcm9wZXJ0eVRlbXBsYXRlIiwicHJvcFRtcGwiLCJSb3dJbmRleCIsIlJvdyIsIlJvd0NoZWNrYm94IiwiUGFnZSIsInBhZ2VhYmxlIiwicGFnZVNpemUiLCJTaW5rIiwic2VlZCIsIkNvbGxlY3Rpb24iLCJwaXBlUHJvamVjdGlvbiIsIlByb2plY3Rpb24iLCJjb25maWdQcm9qIiwicHJvamVjdGlvbkRlc3QiLCJwaXBlIiwiZGF0YVNvdXJjZVR5cGUiLCJ1cGRhdGluZyIsInNjaGVkdWxlVXBkYXRlIiwic2V0VGltZW91dCIsInNldCIsImRhdGFTb3VyY2VQcm9qZWN0aW9uIiwiZW5hYmxlUG9QIiwiZnJvbSIsInRvIiwiRWRpdGFibGVTdHJpbmciLCJNb2NrIiwiUm93VHJpU3RhdGVDaGVja2JveFByb2plY3Rpb24iLCJkZWZhdWx0IiwiQmFzZVByb2plY3Rpb24iLCJkZWZhdWx0c2VsZWN0QWxsTGFiZWwiLCJNb2RlbCIsIl9fc3VwZXJfXyIsInBhdGNoIiwidW5pcXVlSWQiLCJjb25jYXQiLCJSZXNwb25zZSIsInNyYyIsImNvbnN0cnVjdG9yIiwibG9jYWxLZXlzIiwic2V0U3JjIiwib25TcmNVcGRhdGUiLCJidWJibGUiLCJiZWZvcmVTZXQiLCJhZnRlclNldCIsImZjdCIsInJlc3QiLCJ0b0FycmF5IiwiZGVlcCIsIm9iaiIsImxvY2FsIiwib3RoZXIiLCJvbWl0Iiwia2V5UmVnZXgiLCJtYXRjaCIsImV4ZWMiLCJwIiwiY3JlYXRlUm93cyIsImZuIiwidG9wRm4iLCJyb3dUb3AiLCJib3R0b21GbiIsInJvd0JvdHRvbSIsImZsYXR0ZW4iLCJzdWJDb2xPcHRpb25zIiwiJGRlZmF1bHQiLCJpMThuQ29sdW1ucyIsIm9wdCIsIiR0ZXh0IiwiYXJyIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwidGFrZSIsInNraXAiLCJsb2NrIiwiJGluIiwidW5sb2NrZWQiLCJsb29rdXAiLCJkaWZmZXJlbmNlIiwic2tpcHBlZCIsInJlbWFpbmluZyIsInVuaW9uIiwiJGxvY2siLCJjb2xTa2lwcGVkIiwiY29sUmVtYWluaW5nIiwidW5sb2NrZWRBdCIsImZpbmRJbmRleCIsImhhc0xlc3MiLCJoYXNNb3JlIiwiY29sTGVzcyIsIiRodG1sIiwiY29sTW9yZSIsInNwbGljZSIsImVuYWJsZWQiLCJjb2xUZW1wbGF0ZSIsInRlbXBsYXRlVmFsdWUiLCJqcXVlcnkiLCJlZGl0YWJsZVRlbXBsYXRlIiwiY29sdW1uRWRpdGFibGUiLCJPYmplY3QiLCIkdW5kZWZpbmVkIiwiaXNOdWxsIiwiJG51bGwiLCJkZWZhdWx0VmFsdWUiLCJkZWZhdWx0RWRpdGFibGVUZW1wbGF0ZSIsInByb21wdCIsImlzUmVhZG9ubHlSb3ciLCJ2aWV3Q29uZmlnIiwiY29uZGl0aW9ucyIsImVkaXRhYmxlQ29sdW1uIiwiY29sdW1uTmFtZSIsImlzRWRpdGFibGUiLCJ2aWV3IiwiYXR0ckJvZHkiLCJjbGFzc05hbWUiLCJtYXBPYmplY3QiLCJ0ZXh0IiwiY2xhc3NlcyIsInNjaGVtYSIsIm1ldGFkYXRhIiwidGFyZ2V0IiwidGFnTmFtZSIsInBvc2l0aW9uIiwicmlnaHQiLCJsZWZ0Iiwib3V0ZXJXaWR0aCIsIm9uU3VibWl0IiwiUHJvbWlzZSIsIlBvcHVwRWRpdG9yIiwic2V0VmFsdWUiLCJzdG9wUHJvcGFnYXRpb24iLCJzYXZlQnV0dG9uVGV4dCIsImNhbmNlbEJ1dHRvblRleHQiLCJnZXRWYWx1ZSIsInZhbCIsImRpc21pc3MiLCJmb2N1cyIsImlucHV0IiwiZG9jdW1lbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJvbkNhbmNlbCIsInNjaGVtYVByb3BlcnRpZXMiLCJlbnRpdHkiLCJhbGwiLCJvcCIsInAkZmV0Y2hEYXRhIiwibGltaXQiLCJ3aGVyZSIsIm9yZGVyQnkiLCJmaW5kQWxsIiwidGhlbiIsInRvdGFsQ291bnQiLCJlcnJvciIsInJhd1ZhbHVlIiwicmF3IiwiY2F0Y2giLCJmaW5hbGx5IiwiaWRlbnRpdHkiLCJ3aXRob3V0Iiwib3JkZXIiLCJwYWlycyIsIm9yZGVyS2V5Iiwib3JkZXJEaXIiLCJzb3J0RnVuYyIsInNvcnRCeSIsInJldmVyc2UiLCJ3cmRzIiwiaWR4IiwicmFuZG9tUm93Iiwid3JkMSIsInJhbmRvbSIsIndyZDIiLCJhZ2UiLCJuIiwidGltZXMiLCJ2ZXJiIiwidXJsIiwiJGZvcm1hdCIsIiRjb3VudCIsIiR0b3AiLCIkc2tpcCIsInJlc29sdmUiLCJnZXRKU09OIiwic3VjY2VzcyIsImZhaWwiLCJqcVhIUiIsInRleHRTdGF0dXMiLCJlcnJvclRocm93biIsIm51bWJlciIsInBhZ2VDb3VudCIsImNlaWwiLCJwYWdlTnVtYmVyIiwic2lsZW50Iiwic2VsZWN0YWJsZVRlbXBsYXRlIiwicmVzZXQiLCJjaGVja0lkIiwiaWRzIiwicGx1Y2siLCJpbnRlcnNlY3Rpb24iLCJjaGVja2VkTG9va3VwIiwib2JqZWN0IiwiY2hlY2tlZEFsbCIsImhhc0NoZWNrYm94YWJsZSIsImNoZWNrYm94QWxsb3ciLCJjaGVja2JveENvbHVtbiIsImlzU2luZ2xlIiwiZGlzYWJsZWQiLCJpc0FsbG93ZWQiLCJsYWJlbGxlZElkIiwiQm9vbGVhbiIsImxhYmVsU3RyaW5nIiwiY2hlY2tib3hQcm9wZXJ0eSIsImxpc3QiLCJpZCIsImNsYXNzQXJyIiwib3JpZ2luQ2xhc3MiLCJjbGFzc2VzUnVsZSIsImZ1bmMiLCJvcmlnaW5JZCIsImExMXlJZCIsInJvbGUiLCJkZWZhdWx0Um93Q2hlY2tUZW1wIiwiQ2hlY2tUcmFuc2l0aW9uUnVsZSIsImluZGV0ZXJtaW5hdGVUb0NoZWNrZWQiLCJuZXh0U3RhdGUiLCJ1bmNoZWNrZWQiLCJzaG9ydEN5Y2xlIiwiY29uc3RhbnQiLCJpbmRldGVybWluYXRlIiwiY3VycmVudFN0YXRlIiwiaW5kZXRlcm1pbmF0ZVRvVW5jaGVja2VkIiwiaW5kZXRlcm1pbmF0ZVRvQ2hlY2tlZEZ1bGxDeWNsZSIsImluZGV0ZXJtaW5hdGVUb1VuY2hlY2tlZEZ1bGxDeWNsZSIsImluZGV0ZXJtaW5hdGVUb0NoZWNrZWRTaG9ydEN5Y2xlIiwiaW5kZXRlcm1pbmF0ZVRvVW5jaGVja2VkU2hvcnRDeWNsZSIsImdldEFsbENoZWNrU3RhdGUiLCJjaGVja1N0YXRlQ291bnRlcnMiLCJmaW5kS2V5IiwiYyIsImNoZWNrTWFwIiwicm93Q2hlY2tUZW1wIiwiY2hlY2siLCJjaGVja1N0YXRlIiwiZGlzYWJsZWRBbGxDaGVjayIsImNsaWNrQW55d2hlcmUiLCJkZWZhdWx0VHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJhbGxDaGVjayIsImFsbENoZWNrVHJhbnNpdGlvblJ1bGUiLCJDaGVja0RpZmYiLCJhZGRlZCIsImNoYW5nZWQiLCJyZW1vdmVkIiwidW5jaGFuZ2VkIiwiaGFzQ2hhbmdlcyIsImRpZmZDaGVja01hcCIsImJlZm9yZSIsImFmdGVyIiwiZGVmYXVsdFN0YXRlIiwiY2hlY2tEaWZmIiwiZm9yRWFjaCIsImJlZm9yZVN0YXRlIiwiYWZ0ZXJTdGF0ZSIsInN0YXRDaGVja01hcCIsImZ1bGxTdGF0Q2hlY2tNYXAiLCJyb3dJbmRleCIsImdyb3VwRXhwYW5zaW9uIiwiZGF0ZSIsImlzQXBwbHlHcm91cCIsInN0YXJ0RGF0ZTIiLCJlbmREYXRlMiIsImdyb3VwIiwic3ViQ29sdW1ucyIsIm5hbWVJbmRleCIsImluZGV4T2YiLCJvbkNsaWNrSGVhZGVyIiwiY2xhc3NMaXN0IiwiQ29sdW1uc1Byb2plY3Rpb24iLCJkZWxlZ2F0ZUV2ZW50cyIsImV2ZW50IiwiYXJncyIsIkxheW91dCIsImxheW91dE9wdGlvbnMiLCJPcHRpb25zIiwiV2luZG93Q29udGFpbmVyIiwiRWxlbWVudENvbnRhaW5lciIsInNlbGVjdENvbnRhaW5lciIsInNjb3BlIiwib3JkZXJJdGVtIiwiZmV0Y2giLCJnZXRTZWxlY3Rpb24iLCJ1c2VyQ29udGFpbmVyIiwiaXNWYWxpZENvbnRhaW5lciIsIkNvbnRhaW5lckJhc2UiLCJzY3JvbGwiLCJyZXNpemUiLCJvblNjcm9sbCIsIm9uUmVzaXplIiwiRGF0YVNvdXJjZSIsIk9EYXRhRGF0YVNvdXJjZSIsIkpTRGF0YURhdGFTb3VyY2UiLCJNZW1vcnlEYXRhU291cmNlIiwiZGVmYXVsdFByaW1hcnlLZXkiLCJfcHJpbWFyeUtleSIsInBhcmFtcyIsIml0ZW1zIiwiZGlyZWN0aW9uIiwiZGlyU3RyaW5nIiwibm9ybWFsaXplT3JkZXJCeSIsInRyYW5zbGF0ZU9yZGVyQnkiLCJvcmRlckJ5UGFyYW1zIiwidHJhbnNsYXRlUGFyYW1zIiwiJGZpbHRlciIsIl91cmwiLCJpZEF0dHJpYnV0ZSIsIl9yZXNvdXJjZSIsIl9vcHRpb25zIiwic29ydEl0ZXJhdGVlIiwic2VncyIsInNlZyIsIkNPTlNUUlVDVE9SX09QVElPTlMiLCJOT05FX1BST0pFQ1RJT05fT1BUSU9OUyIsImRlZmF1bHRzRGVlcCIsImRlc3QiLCJuZXh0VGljayIsIlByb2plY3Rpb25DaGFpbiIsImZvcmNlIiwidXBkYXRlZCIsInByb2oiLCJwJHN0YXRlIiwiaGFuZGxlciIsInAkb3V0cHV0IiwidGFwIiwicHJvanMiLCJub3JtYWxpemUiLCJzY3JvbGxpbmciLCJ0YWJsZUNsYXNzZXMiLCJfdGFibGVWaWV3IiwiX2RhdGFTb3VyY2UiLCJfcHJvamVjdGlvbnMiLCJfcmVnaXN0ZXJQcm9qZWN0aW9uIiwiX2NoYWluRGF0YSIsIl9jaGFpblN0cnVjdHVyZSIsIl9jaGFpbkNvbnRlbnQiLCJwaXBlRGF0YVByb2plY3Rpb25zIiwicGlwZVN0cnVjdHVyZVByb2plY3Rpb25zIiwicGlwZUNvbnRlbnRQcm9qZWN0aW9ucyIsInBhdGNoRXZlbnRzIiwicmVmcmVzaFN0YXRlIiwiY2hhbmdlcyIsInByb21pc2UiLCJfaXNSZW5kZXJlZCIsInJlZnJlc2giLCJjaGFuZ2VkQXR0cmlidXRlcyIsInZhbHVlQ3VyIiwidG90YWxDb3VudFJvd3MiLCJpbmRleE9mRWxlbWVudCIsIml0ZW1JbmRleCIsInNlbGVjdGVkS2V5cyIsImNvbHVtbldpdGhOYW1lIiwiaGVhZFJvd3MiLCJnZXRIZWFkUm93cyIsInNldEhlYWRSb3dzIiwiYm9keVJvd3MiLCJnZXRCb2R5Um93cyIsInNldEJvZHlSb3dzIiwiZm9vdFJvd3MiLCJnZXRGb290Um93cyIsInNldEZvb3RSb3dzIiwiYnVmZmVyIiwic2V0U2VsZWN0QWxsIiwic2V0U2VsZWN0Um93IiwiY2VsbHMiLCJzb3J0YWJsZUhlYWRlciIsInF1ZXJ5UHJvamVjdGlvbkhhbmRsZXIiLCJjb25zb2xlIiwid2FybiIsInVwZGF0ZUl0ZW1TdGF0ZSIsImJlZ2luIiwiZW5kIiwib25Db21taXQiLCJvbkVkaXQiLCJkaWRFZGl0IiwidXBkYXRlU2VsZWN0aW9uIiwic2VsZWN0ZWQiLCJyZXNvbHZlciIsInNlbGVjdEFsbCIsImRlc2VsZWN0QWxsIiwiY2hhbmdlU2VsZWN0QWxsIiwicHJldmVudERlZmF1bHQiLCJzZWxlY3RSb3ciLCJkZXNlbGVjdFJvdyIsImNoYW5nZVNlbGVjdFJvdyIsImtleU9mRWxlbWVudCIsInNlbGVjdGlvblByb2plY3Rpb25IYW5kbGVyIiwidXBkYXRlSXRlbXMiLCJzaW5nbGUiLCJoZWFkQ2xhc3NlcyIsImJvZHlDbGFzc2VzIiwiZm9vdENsYXNzZXMiLCJzZWxlY3RlZEluZGV4Iiwic2VsZWN0ZWRBbGwiLCJzZWxlY3RhYmxlQ291bnQiLCJzZWxlY3RlZENvdW50IiwiaXRlbVdpdGhLZXkiLCJub3JtYWxpemVTZWxlY3Rpb25Db25maWciLCJSZXNvbHZlciIsIlNpbmdsZVNlbGVjdGlvblJlc29sdmVyIiwidG9TdHJpbmciLCJTZWxlY3Rpb25SZXNvbHZlciIsInNlbGVjdGlvbkN1ciIsIk11bHRpcGxlU2VsZWN0aW9uUmVzb2x2ZXIiLCJTdHJpbmciLCJjb2x1bW5zUHJvamVjdGlvbkhhbmRsZXIiLCJidWZmZXJTdGF0ZUNsYXNzZXMiLCJyb3dzUHJvamVjdGlvbkhhbmRsZXIiLCJidWZmZXJTdGF0ZSIsImRlZmFsdXRzIiwibm9ybWFsaXplQ2xhc3NlcyIsImNvbnRleHQiLCJpc0Z1bmMiLCJzdHJpbmdQcm9wZXJ0eSIsIm5vcm1hbGl6ZVByb3BlcnR5Iiwibm9ybWFsaXplU29ydGFibGUiLCJjb2x1bW5LZXkiLCJoZWFkZXJSb3dzIiwibGVhZkNvbHVtbnMiLCJjb2x1bW5JbmRleCIsImJ1aWxkQ29sdW1uIiwicGFyZW50IiwidHJlZUhlaWdodCIsInRyZWVXaWR0aCIsImIiLCJidWlsZENvbHVtbkhlYWRlciIsInJvb3QiLCJjZWxsIiwidHJhbnNsYXRlQ29sdW1uR3JvdXAiLCJjb2x1bW5Hcm91cFByb2plY3Rpb25IYW5kbGVyIiwiY29scyIsInRyYW5zbGF0ZVJvdyIsInJvd1R5cGUiLCJjZWxsQ2xhc3NlcyIsImNlbGxzUHJvamVjdGlvbkhhbmRsZXIiLCJyZWdleEtleSIsInJlb3JkZXIiLCJzb3J0YWJsZUhlYWRlckN1ciIsInNvcnRhYmxlSGVhZGVyUHJvamVjdGlvbkhhbmRsZXIiLCJsZWFmQ29sdW1uSW5kZXgiLCJwYXRjaENlbGwiLCJkZWNvcmF0aW9uVGVtcGxhdGUiLCJkZWVwQ2xvbmUiLCJlZGl0SW5Db2x1bW4iLCJoYXNDbGFzcyIsInByb21wdFBvcyIsImlubmVyV2lkdGgiLCJjbGllbnRXaWR0aCIsImlzRXF1YWwiLCJzZXF1ZW5jZSIsImNhbGxiYWNrcyIsImFyZ3NJbm5lciIsImV2ZW50c1Byb2plY3Rpb25IYW5kbGVyIiwiZXZlbnRzT3B0aW9ucyIsIlRhYmxlVmlldyIsIlNUQVRFX09QVElPTlMiLCJIRUFERVJfVFlQRVMiLCJfcHJvcHMiLCJfbm9ybWFsaXplU2Nyb2xsaW5nQ29uZmlnIiwiX3N0YXRlIiwiX2xpc3RWaWV3IiwidmlydHVhbGl6ZWQiLCJfaGVhZGVyVmlldyIsInRhYmxlVmlldyIsIl9mb290ZXJWaWV3IiwiX25vcm1hbGl6ZUhlYWRlckNvbmZpZyIsImlzU2V0IiwibGlzdFN0YXRlIiwic3RhcnQiLCJzdG9wIiwiX3JlbmRlckNvbHVtbkdyb3VwIiwicmVkcmF3IiwiJGNvbGdyb3VwIiwic2V0RWxlbWVudCIsImxpc3RWaWV3IiwiaXNXaW5kb3ciLCIkdGFibGVDb250YWluZXIiLCIkc3RpY2t5SGVhZGVyIiwiJHN0aWNreUhlYWRlckZpbGxlciIsIiR0YWJsZSIsInZpZXdwb3J0U2l6ZSIsImFkanVzdFN0aWNreUhlYWRlciIsImlzIiwibWV0cmljc1ZQIiwiZ2V0TWV0cmljcyIsInRvcFZQIiwib3V0ZXIiLCJyZWN0Q29udGFpbmVyIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wQ3VyIiwic3RpY2t5IiwiZGlzcGxheSIsInN0eWxlIiwiZGVsdGFXaWR0aCIsImRlbHRhSGVpZ2h0IiwibGlzdFRlbXBsYXRlIiwiaXRlbVRlbXBsYXRlIiwiX3JlbmRlckhlYWRlciIsIl9yZW5kZXJGb290ZXIiLCJ3aWR0aFZpZXdwb3J0Iiwid2lkdGhDb250YWluZXIiLCJ3aWR0aFNjcm9sbGJhciIsIndpZHRoVGFibGUiLCJvZmZzZXRXaWR0aCIsIl9ob29rVXBTdGlja3lIZWFkZXIiLCJfcmVuZGVyU3RhdGljIiwiX3JlbmRlckZpeGVkIiwiX3JlbmRlclN0aWNreSIsInNjcm9sbFRvSXRlbSIsIiRlbFRyIiwiJGNvbnRhaW5lciIsImluZGV4Rmlyc3QiLCJzdWJ2aWV3Q2xhc3MiLCJzdWJ2aWV3U2VsZWN0b3IiLCJIZWFkZXJGb290ZXJWaWV3IiwiZGV0YWNoIiwiYXBwZW5kVG8iLCJGb290ZXJWaWV3Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdENBLEtBQUlBLFFBQVEsbUJBQUFDLENBQVEsQ0FBUixDQUFaO0FBQ0EsS0FBSUMsYUFBYSxtQkFBQUQsQ0FBUSxHQUFSLEVBQXlCRSxLQUExQztBQUNBLEtBQUlDLE9BQU8sbUJBQUFILENBQVEsR0FBUixDQUFYOztBQUVBLEtBQUlJLGFBQWE7QUFDZkMsT0FBSSxZQURXO0FBRWZDLGVBQVk7QUFDVkMsV0FBTSxRQURJO0FBRVZDLFdBQU1QLFVBRkk7QUFHVlEsaUJBQVk7QUFIRixJQUZHO0FBT2ZDLFlBQVMsQ0FBQztBQUNSQyxXQUFNLFVBREU7QUFFUkMsWUFBTyxXQUZDO0FBR1JDLGVBQVUsSUFIRjtBQUlSQyxhQUFRO0FBSkEsSUFBRCxFQUtOO0FBQ0RILFdBQU0sV0FETDtBQUVEQyxZQUFPLFlBRk47QUFHREcsZUFBVSxJQUhUO0FBSURDLGlCQUFZLENBQUMsWUFBRCxFQUFlLFlBQWYsQ0FKWDtBQUtEQyxvQkFBZSxDQUFDLGtCQUFELEVBQXFCLGtCQUFyQjtBQUxkLElBTE0sRUFXTjtBQUNETixXQUFNLFVBREw7QUFFREMsWUFBTyxXQUZOO0FBR0RHLGVBQVUsSUFIVDtBQUlEQyxpQkFBWSxDQUFDLFlBQUQsRUFBZSxZQUFmLENBSlg7QUFLREMsb0JBQWUsQ0FBQyxrQkFBRCxFQUFxQixrQkFBckI7QUFMZCxJQVhNLEVBaUJOO0FBQ0ROLFdBQU0sU0FETDtBQUVETyxlQUFVLHVCQUZUO0FBR0RDLGVBQVVoQjtBQUhULElBakJNLEVBcUJOO0FBQ0RRLFdBQU0sUUFETDtBQUVEUyxXQUFNO0FBRkwsSUFyQk0sRUF3Qk47QUFDRFQsV0FBTSxhQURMO0FBRURVLGFBQVE7QUFGUCxJQXhCTTtBQVBNLEVBQWpCOztBQXFDQSxLQUFJQyxRQUFRdkIsTUFDVHdCLE9BRFMsQ0FDRCxFQUFDQyxPQUFPLElBQVIsRUFEQyxFQUVUQyxNQUZTLENBRUZyQixVQUZFLENBQVo7QUFHQSxLQUFJc0IsV0FBV0osTUFBTUksUUFBTixDQUFlQyxNQUFmLEVBQWYsQzs7Ozs7Ozs7QUM1Q0E7Ozs7QUFDQTs7OztBQU9BQyxRQUFPQyxPQUFQLEdBQWlCO0FBQ2ZDLFlBQVMsVUFETTtBQUVmQyxhQUFVLG1CQUFBL0IsQ0FBUSxFQUFSLENBRks7QUFHZmdDLGdCQUFhLG1CQUFBaEMsQ0FBUSxFQUFSLENBSEU7QUFJZmlDLFdBQVEsbUJBQUFqQyxDQUFRLENBQVIsQ0FKTztBQUtmdUIsaUNBTGU7QUFNZlcsc0JBQW1CLG1CQUFBbEMsQ0FBUSxFQUFSLENBTko7QUFPZk0sZUFBWTtBQUNWNkIsaUNBRFU7QUFFVkMseUNBRlU7QUFHVkMsdUNBSFU7QUFJVkM7QUFKVTtBQVBHLEVBQWpCLEM7Ozs7Ozs7Ozs7Ozs7O21CQ3NEZSxVQUFVQyxPQUFWLEVBQW1CO0FBQ2hDLFVBQU8sSUFBSUMsV0FBSixDQUFnQkQsT0FBaEIsQ0FBUDtBQUNELEU7O0FBaEVEOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7OztBQUVBLEtBQU1FLGVBQWUsU0FBZkEsWUFBZTtBQUFBLFVBQWdCQyxhQUFhLFFBQWIsRUFBdUIsRUFBdkIsRUFBMkIsWUFBWTtBQUMxRSxZQUFPLEtBQUtDLE1BQVo7QUFDRCxJQUZvQyxDQUFoQjtBQUFBLEVBQXJCOztLQUlNSCxXO0FBQ0osMEJBRVE7QUFBQSxvRkFBSixFQUFJOztBQUFBLDJCQUROaEIsS0FDTTtBQUFBLFNBRE5BLEtBQ00sOEJBREUsS0FDRjs7QUFBQTs7QUFDTixVQUFLb0IsV0FBTCxHQUFtQixFQUFuQjtBQUNBLFVBQUtDLE9BQUwsR0FBZSxFQUFmO0FBQ0EsU0FBSXJCLEtBQUosRUFBVztBQUNULFlBQ0dzQixHQURILENBQ09MLFlBRFAsRUFFR0ssR0FGSCw2QkFHR0EsR0FISDtBQUlELE1BTEQsTUFLTztBQUNMLFlBQ0dBLEdBREgsQ0FDT0wsWUFEUCxFQUVHSyxHQUZILDZCQUdHQSxHQUhILDRCQUlHQSxHQUpIO0FBS0Q7QUFDRjs7OztrQ0FFWW5DLEksRUFBTW9DLEksRUFBTUMsUSxFQUFVO0FBQUE7O0FBQ2pDLFdBQU1DLFNBQVMsRUFBRXRDLFVBQUYsRUFBUW9DLFVBQVIsRUFBY0Msa0JBQWQsRUFBZjs7QUFFQSxZQUFLSixXQUFMLENBQWlCakMsSUFBakIsSUFBeUJzQyxNQUF6QjtBQUNBLFlBQUtKLE9BQUwsQ0FBYUssSUFBYixDQUFrQkQsTUFBbEI7QUFDQSw0QkFBRUUsSUFBRixDQUFPSixJQUFQLEVBQWEsZUFBTztBQUNsQixhQUFJLENBQUMscUJBQUVLLEdBQUYsQ0FBTSxNQUFLUixXQUFYLEVBQXdCUyxHQUF4QixDQUFMLEVBQW1DO0FBQ2pDLGlCQUFNLElBQUlDLEtBQUosbUNBQTBDM0MsSUFBMUMsWUFBcUQwQyxHQUFyRCxDQUFOO0FBQ0Q7QUFDRixRQUpEO0FBS0Q7Ozt5QkFFR0wsUSxFQUFVO0FBQ1pBLGdCQUFTLEtBQUtOLFlBQUwsQ0FBa0JhLElBQWxCLENBQXVCLElBQXZCLENBQVQ7QUFDQSxjQUFPLElBQVA7QUFDRDs7OzRCQUVNWixNLEVBQVE7QUFDYixjQUFPLHFCQUFFYSxNQUFGLENBQ0wsS0FBS1gsT0FEQSxFQUVMLFVBQUNZLE1BQUQ7QUFBQSxhQUFXOUMsSUFBWCxTQUFXQSxJQUFYO0FBQUEsYUFBaUJvQyxJQUFqQixTQUFpQkEsSUFBakI7QUFBQSxhQUF1QkMsUUFBdkIsU0FBdUJBLFFBQXZCO0FBQUEsZ0JBQ0UscUJBQUVVLE1BQUYsQ0FBU0QsTUFBVCxzQkFDRzlDLElBREgsRUFDVXFDLFNBQVNXLEtBQVQsQ0FBZUYsTUFBZixFQUF1QixxQkFBRUcsR0FBRixDQUFNYixJQUFOLEVBQVk7QUFBQSxrQkFBT1UsT0FBT0osR0FBUCxDQUFQO0FBQUEsVUFBWixDQUF2QixDQURWLEVBREY7QUFBQSxRQUZLLEVBTUwsRUFBRVYsY0FBRixFQU5LLENBQVA7QUFRRDs7Ozs7Ozs7OztBQzFESDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLHdDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQW9EO0FBQ3BELElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDO0FBQzFDLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0Esc0JBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQywwQkFBMEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXFCLGNBQWM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU8sZUFBZTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQSwwQkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLDZDQUE0QyxtQkFBbUI7QUFDL0Q7QUFDQTtBQUNBLDBDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsWUFBWTs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGLHFCQUFvQjs7QUFFcEI7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRixpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUEsaUJBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNELFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFD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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBOztBQUVBLEVBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxTQUFRLEdBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQSxlQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTLE9BQU87QUFDaEIsMEJBQXlCLHdCQUF3Qjs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBLDJDQUEwQztBQUMxQyxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUixRQUFPO0FBQ1A7QUFDQSxPQUFNO0FBQ04sTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBOEM7QUFDOUMsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjs7QUFFQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsYUFBYTtBQUNwQyxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsb0JBQW9CLEVBQUU7QUFDckMsZ0JBQWUscUNBQXFDLEVBQUU7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsd0RBQXdEO0FBQy9FOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVSxPQUFPO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FB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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxTQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBOztBQUVBLFdBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsU0FBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FB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QUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQSxrQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7O0FBRUEsS0FBSTtBQUNKO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUscUNBQXFDOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjs7QUFFaEIsaURBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUI7QUFDakIsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQWtDOztBQUVsQztBQUNBLHVCQUFzQjtBQUN0Qiw0QkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBYyxvQ0FBb0M7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZCxPQUFNO0FBQ04sT0FBTTtBQUNOLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsdUJBQXVCO0FBQ2xDLFlBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsNkJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsVUFBUyw2QkFBNkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF1QztBQUN2QztBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLG1CQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsbUJBQW1CO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVCwwQ0FBeUMsY0FBYztBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQyxFQUFFLFlBQVk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXVCLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUMsRUFBRSxZQUFZO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxzQkFBc0I7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGdDQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUMsRUFBRSx1QkFBdUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLHFFQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEIsTUFBSztBQUNMO0FBQ0EsaUJBQWdCO0FBQ2hCLE1BQUs7QUFDTDtBQUNBLGlCQUFnQjtBQUNoQixNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQTZCLGNBQWM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXFELEVBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FB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QTtBQUNBO0FBQ0EsZ0NBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUyxtQkFBbUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLG1CQUFtQjtBQUNwQyx1QkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDLEVBQUUsMEJBQTBCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsYUFBYTtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsZUFBZTtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsZUFBZTtBQUMzRCxNQUFLO0FBQ0w7QUFDQSxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLGFBQWE7QUFDMUQsTUFBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsRUFBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQSx3QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQyxFQUFFLHVCQUF1QjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRCxpQkFBZ0I7QUFDaEIsaUJBQWdCO0FBQ2hCLG1CQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFDLEVBQUUsWUFBWTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLEVBQUMsRUFBRSxZQUFZO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRUFBRSxZQUFZO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUMsRUFBRSxxQ0FBcUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQyxFQUFFLFlBQVk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRUFBRSx1QkFBdUI7QUFDMUI7QUFDQTtBQUNBLG9CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxTQUFTO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUMsRUFBRSxZQUFZO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDLEVBQUUsWUFBWTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MscUNBQXFDO0FBQ3JFLGlDQUFnQyxtQ0FBbUM7QUFDbkUsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQSxFQUFDLEVBQUUsWUFBWTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDLEVBQUUsWUFBWTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLHlCQUF5QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUMsRUFBRSwwQkFBMEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQSxNQUFLLGtCQUFrQixFQUFFLFlBQVk7QUFDckM7O0FBRUEsRUFBQyxFQUFFLFdBQVcsRUFBRSxHQUFHO0FBQ25CLEVBQUMsRUFBRSxxQkFBcUIsdURBQXVELHlEQUF5RCxzREFBc0QseURBQXlELG1EQUFtRCwwRDs7Ozs7OztBQzc5SzFTO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ3JQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsbUNBQW1DLEVBQUU7QUFDdEMsb0hBQW1ILDBHQUEwRztBQUM3TixFIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgN2Q5MjZhZmE0NmM4YTE4NjhmYTFcbiAqKi8iLCJ2YXIgcEdyaWQgPSByZXF1aXJlKCcuLi9qcycpO1xyXG52YXIgbWVtb3J5RGF0YSA9IHJlcXVpcmUoJy4vcGVvcGxlLmpzb24nKS52YWx1ZTtcclxudmFyIHRtcGwgPSByZXF1aXJlKCcuL3Rlc3RUbXBsLmphZGUnKTtcclxuXHJcbnZhciBncmlkQ29uZmlnID0ge1xyXG4gIGVsOiAnI2NvbnRhaW5lcicsXHJcbiAgZGF0YVNvdXJjZToge1xyXG4gICAgdHlwZTogJ21lbW9yeScsXHJcbiAgICBkYXRhOiBtZW1vcnlEYXRhLFxyXG4gICAgcHJpbWFyeUtleTogJ1VzZXJOYW1lJyxcclxuICB9LFxyXG4gIGNvbHVtbnM6IFt7XHJcbiAgICBuYW1lOiAnVXNlck5hbWUnLFxyXG4gICAgdGl0bGU6ICdVc2VyIE5hbWUnLFxyXG4gICAgc29ydGFibGU6IHRydWUsXHJcbiAgICBsb2NrZWQ6IHRydWUsXHJcbiAgfSwge1xyXG4gICAgbmFtZTogJ0ZpcnN0TmFtZScsXHJcbiAgICB0aXRsZTogJ0ZpcnN0IE5hbWUnLFxyXG4gICAgZWRpdGFibGU6IHRydWUsXHJcbiAgICBjb2xDbGFzc2VzOiBbJ25hbWVDbGFzczEnLCAnbmFtZUNsYXNzMiddLFxyXG4gICAgaGVhZGVyQ2xhc3NlczogWyduYW1lSGVhZGVyQ2xhc3MxJywgJ25hbWVIZWFkZXJDbGFzczInXSxcclxuICB9LCB7XHJcbiAgICBuYW1lOiAnTGFzdE5hbWUnLFxyXG4gICAgdGl0bGU6ICdMYXN0IE5hbWUnLFxyXG4gICAgZWRpdGFibGU6IHRydWUsXHJcbiAgICBjb2xDbGFzc2VzOiBbJ25hbWVDbGFzczEnLCAnbmFtZUNsYXNzMiddLFxyXG4gICAgaGVhZGVyQ2xhc3NlczogWyduYW1lSGVhZGVyQ2xhc3MxJywgJ25hbWVIZWFkZXJDbGFzczInXSxcclxuICB9LCB7XHJcbiAgICBuYW1lOiAnQWRkcmVzcycsXHJcbiAgICBwcm9wZXJ0eTogJ0FkZHJlc3NJbmZvLzAvQWRkcmVzcycsXHJcbiAgICB0ZW1wbGF0ZTogdG1wbCxcclxuICB9LCB7XHJcbiAgICBuYW1lOiAnR2VuZGVyJyxcclxuICAgIGh0bWw6ICc8aT5HZW5kZXI8L2k+JyxcclxuICB9LCB7XHJcbiAgICBuYW1lOiAnQ29uY3VycmVuY3knLFxyXG4gICAgaGlkZGVuOiB0cnVlLFxyXG4gIH1dXHJcbn07XHJcblxyXG52YXIgcGdyaWQgPSBwR3JpZFxyXG4gIC5mYWN0b3J5KHt2bmV4dDogdHJ1ZX0pXHJcbiAgLmNyZWF0ZShncmlkQ29uZmlnKTtcclxudmFyIGdyaWRWaWV3ID0gcGdyaWQuZ3JpZFZpZXcucmVuZGVyKCk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZW50cnkuanNcbiAqKi8iLCJpbXBvcnQgZmFjdG9yeSBmcm9tICcuL2ZhY3RvcnkvZ3JpZC1mYWN0b3J5JztcclxuaW1wb3J0IHtcclxuICBEYXRhU291cmNlLFxyXG4gIE1lbW9yeURhdGFTb3VyY2UsXHJcbiAgT0RhdGFEYXRhU291cmNlLFxyXG4gIEpTRGF0YURhdGFTb3VyY2UsXHJcbn0gZnJvbSAnLi92bmV4dC9kYXRhLXNvdXJjZSc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICB2ZXJzaW9uOiAnMC4xLjAtNDEnLFxyXG4gIEdyaWRWaWV3OiByZXF1aXJlKCcuL2dyaWQtdmlldycpLFxyXG4gIHByb2plY3Rpb25zOiByZXF1aXJlKCcuL3Byb2plY3Rpb24vaW5kZXgnKSxcclxuICBsYXlvdXQ6IHJlcXVpcmUoJy4vbGF5b3V0L2luZGV4JyksXHJcbiAgZmFjdG9yeSxcclxuICBwb3B1cEVkaXRvclByb21wdDogcmVxdWlyZSgnLi9wb3B1cC1lZGl0b3IvaW5kZXgnKSxcclxuICBkYXRhU291cmNlOiB7XHJcbiAgICBCYXNlOiBEYXRhU291cmNlLFxyXG4gICAgTWVtb3J5OiBNZW1vcnlEYXRhU291cmNlLFxyXG4gICAgT0RhdGE6IE9EYXRhRGF0YVNvdXJjZSxcclxuICAgIEpTRGF0YTogSlNEYXRhRGF0YVNvdXJjZSxcclxuICB9LFxyXG59O1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL2luZGV4LmpzXG4gKiovIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XHJcbmltcG9ydCByZW5kZXJlcnNQbHVnaW4gZnJvbSAnLi9yZW5kZXJlcnMtcGx1Z2luJztcclxuaW1wb3J0IHByb2plY3Rpb25QbHVnaW4gZnJvbSAnLi9wcm9qZWN0aW9uLXBsdWdpbic7XHJcbmltcG9ydCBncmlkVmlld1BsdWdpbiBmcm9tICcuL2dyaWQtdmlldy1wbHVnaW4nO1xyXG5cclxuaW1wb3J0IGRhdGFTb3VyY2VWTmV4dFBsdWdpbiBmcm9tICcuLi92bmV4dC9mYWN0b3J5L2RhdGEtc291cmNlLXBsdWdpbi5qcyc7XHJcbmltcG9ydCBncmlkVmlld1ZOZXh0UGx1Z2luIGZyb20gJy4uL3ZuZXh0L2ZhY3RvcnkvZ3JpZC12aWV3LXBsdWdpbi5qcyc7XHJcblxyXG5jb25zdCBjb25maWdQbHVnaW4gPSBkZWZpbmVQbHVnaW4gPT4gZGVmaW5lUGx1Z2luKCdjb25maWcnLCBbXSwgZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLmNvbmZpZztcclxufSk7XHJcblxyXG5jbGFzcyBHcmlkRmFjdG9yeSB7XHJcbiAgY29uc3RydWN0b3Ioe1xyXG4gICAgdm5leHQgPSBmYWxzZSxcclxuICB9ID0ge30pIHtcclxuICAgIHRoaXMucGx1Z2luSW5kZXggPSB7fTtcclxuICAgIHRoaXMucGx1Z2lucyA9IFtdO1xyXG4gICAgaWYgKHZuZXh0KSB7XHJcbiAgICAgIHRoaXNcclxuICAgICAgICAudXNlKGNvbmZpZ1BsdWdpbilcclxuICAgICAgICAudXNlKGRhdGFTb3VyY2VWTmV4dFBsdWdpbilcclxuICAgICAgICAudXNlKGdyaWRWaWV3Vk5leHRQbHVnaW4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpc1xyXG4gICAgICAgIC51c2UoY29uZmlnUGx1Z2luKVxyXG4gICAgICAgIC51c2UocHJvamVjdGlvblBsdWdpbilcclxuICAgICAgICAudXNlKHJlbmRlcmVyc1BsdWdpbilcclxuICAgICAgICAudXNlKGdyaWRWaWV3UGx1Z2luKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlZmluZVBsdWdpbihuYW1lLCBkZXBzLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3QgcGx1Z2luID0geyBuYW1lLCBkZXBzLCBjYWxsYmFjayB9O1xyXG5cclxuICAgIHRoaXMucGx1Z2luSW5kZXhbbmFtZV0gPSBwbHVnaW47XHJcbiAgICB0aGlzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xyXG4gICAgXy5lYWNoKGRlcHMsIGRlcCA9PiB7XHJcbiAgICAgIGlmICghXy5oYXModGhpcy5wbHVnaW5JbmRleCwgZGVwKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZXNvbHZlZCBwbHVnaW4gZGVwZW5kZW5jeSAke25hbWV9IC0+ICR7ZGVwfWApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHVzZShjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2sodGhpcy5kZWZpbmVQbHVnaW4uYmluZCh0aGlzKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGNyZWF0ZShjb25maWcpIHtcclxuICAgIHJldHVybiBfLnJlZHVjZShcclxuICAgICAgdGhpcy5wbHVnaW5zLFxyXG4gICAgICAocmVzdWx0LCB7IG5hbWUsIGRlcHMsIGNhbGxiYWNrIH0pID0+XHJcbiAgICAgICAgXy5leHRlbmQocmVzdWx0LCB7XHJcbiAgICAgICAgICBbbmFtZV06IGNhbGxiYWNrLmFwcGx5KHJlc3VsdCwgXy5tYXAoZGVwcywgZGVwID0+IHJlc3VsdFtkZXBdKSksXHJcbiAgICAgICAgfSksXHJcbiAgICAgIHsgY29uZmlnIH1cclxuICAgICk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IEdyaWRGYWN0b3J5KG9wdGlvbnMpO1xyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvZmFjdG9yeS9ncmlkLWZhY3RvcnkuanNcbiAqKi8iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguM1xuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kLFxuICAgIG5hdGl2ZUNyZWF0ZSAgICAgICA9IE9iamVjdC5jcmVhdGU7XG5cbiAgLy8gTmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuOC4zJztcblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXG4gIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXG4gIC8vIGZ1bmN0aW9ucy5cbiAgdmFyIG9wdGltaXplQ2IgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuICAgIHN3aXRjaCAoYXJnQ291bnQgPT0gbnVsbCA/IDMgOiBhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBIG1vc3RseS1pbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZFxuICAvLyB0byBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXJcbiAgLy8gaWRlbnRpdHksIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSByZXR1cm4gXy5tYXRjaGVyKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gIH07XG4gIF8uaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBjYih2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVBc3NpZ25lciA9IGZ1bmN0aW9uKGtleXNGdW5jLCB1bmRlZmluZWRPbmx5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0sXG4gICAgICAgICAgICBrZXlzID0ga2V5c0Z1bmMoc291cmNlKSxcbiAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoIXVuZGVmaW5lZE9ubHkgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXG4gIHZhciBiYXNlQ3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiB7fTtcbiAgICBpZiAobmF0aXZlQ3JlYXRlKSByZXR1cm4gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yO1xuICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBwcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gSGVscGVyIGZvciBjb2xsZWN0aW9uIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb2xsZWN0aW9uXG4gIC8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3RcbiAgLy8gUmVsYXRlZDogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgLy8gQXZvaWRzIGEgdmVyeSBuYXN0eSBpT1MgOCBKSVQgYnVnIG9uIEFSTS02NC4gIzIwOTRcbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIHZhciBnZXRMZW5ndGggPSBwcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gIHZhciBpc0FycmF5TGlrZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8PSBNQVhfQVJSQVlfSU5ERVg7XG4gIH07XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyByYXcgb2JqZWN0cyBpbiBhZGRpdGlvbiB0byBhcnJheS1saWtlcy4gVHJlYXRzIGFsbFxuICAvLyBzcGFyc2UgYXJyYXktbGlrZXMgYXMgaWYgdGhleSB3ZXJlIGRlbnNlLlxuICBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgaSwgbGVuZ3RoO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgcmVzdWx0c1tpbmRleF0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIHJlZHVjaW5nIGZ1bmN0aW9uIGl0ZXJhdGluZyBsZWZ0IG9yIHJpZ2h0LlxuICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoZGlyKSB7XG4gICAgLy8gT3B0aW1pemVkIGl0ZXJhdG9yIGZ1bmN0aW9uIGFzIHVzaW5nIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAvLyBpbiB0aGUgbWFpbiBmdW5jdGlvbiB3aWxsIGRlb3B0aW1pemUgdGhlLCBzZWUgIzE5OTEuXG4gICAgZnVuY3Rpb24gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgNCk7XG4gICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBpbml0aWFsIHZhbHVlIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgbWVtbyA9IG9ialtrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGRpcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGNyZWF0ZVJlZHVjZSgxKTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBjcmVhdGVSZWR1Y2UoLTEpO1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBrZXk7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGtleSA9IF8uZmluZEluZGV4KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gXy5maW5kS2V5KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubmVnYXRlKGNiKHByZWRpY2F0ZSkpLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIGl0ZW0gKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZXNgIGFuZCBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGVzID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCBpdGVtLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ICE9ICdudW1iZXInIHx8IGd1YXJkKSBmcm9tSW5kZXggPSAwO1xuICAgIHJldHVybiBfLmluZGV4T2Yob2JqLCBpdGVtLCBmcm9tSW5kZXgpID49IDA7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyBmdW5jIDogZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSBJbmZpbml0eSAmJiByZXN1bHQgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLCB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4gIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHNldCA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBzZXQubGVuZ3RoO1xuICAgIHZhciBzaHVmZmxlZCA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCByYW5kOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKDAsIGluZGV4KTtcbiAgICAgIGlmIChyYW5kICE9PSBpbmRleCkgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHNldFtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfTtcblxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgbWFwYC5cbiAgXy5zYW1wbGUgPSBmdW5jdGlvbihvYmosIG4sIGd1YXJkKSB7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgICAgcmV0dXJuIG9ialtfLnJhbmRvbShvYmoubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgICByZXR1cm4gXy5zaHVmZmxlKG9iaikuc2xpY2UoMCwgTWF0aC5tYXgoMCwgbikpO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCB2YWx1ZSwga2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldLnB1c2godmFsdWUpOyBlbHNlIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gU3BsaXQgYSBjb2xsZWN0aW9uIGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqKSA/IHBhc3MgOiBmYWlsKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Bhc3MsIGZhaWxdO1xuICB9O1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgcmV0dXJuIF8uaW5pdGlhbChhcnJheSwgYXJyYXkubGVuZ3RoIC0gbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAobiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIF8ucmVzdChhcnJheSwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gbikpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgbiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pO1xuICB9O1xuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIF8uaWRlbnRpdHkpO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgc3RyaWN0LCBzdGFydEluZGV4KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdLCBpZHggPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDAsIGxlbmd0aCA9IGdldExlbmd0aChpbnB1dCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAvL2ZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0XG4gICAgICAgIGlmICghc2hhbGxvdykgdmFsdWUgPSBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBzdHJpY3QpO1xuICAgICAgICB2YXIgaiA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgb3V0cHV0Lmxlbmd0aCArPSBsZW47XG4gICAgICAgIHdoaWxlIChqIDwgbGVuKSB7XG4gICAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlW2orK107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCkge1xuICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIGp1c3Qgb25lIGxldmVsLlxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xuICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBmYWxzZSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgICAgaWYgKCFpIHx8IHNlZW4gIT09IGNvbXB1dGVkKSByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKHNlZW4sIGNvbXB1dGVkKSkge1xuICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFfLmNvbnRhaW5zKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bmlxKGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuemlwKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ29tcGxlbWVudCBvZiBfLnppcC4gVW56aXAgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIGdyb3Vwc1xuICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXNcbiAgXy51bnppcCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIF8ubWF4KGFycmF5LCBnZXRMZW5ndGgpLmxlbmd0aCB8fCAwO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IF8ucGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgobGlzdCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpbmRJbmRleCBhbmQgZmluZExhc3RJbmRleCBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb24gYW4gYXJyYXktbGlrZSB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoMSk7XG4gIF8uZmluZExhc3RJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKC0xKTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBpbmRleE9mIGFuZCBsYXN0SW5kZXhPZiBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlSW5kZXhGaW5kZXIoZGlyLCBwcmVkaWNhdGVGaW5kLCBzb3J0ZWRJbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgaXRlbSwgaWR4KSB7XG4gICAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgaSA9IGlkeCA+PSAwID8gaWR4IDogTWF0aC5tYXgoaWR4ICsgbGVuZ3RoLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGlkeCA+PSAwID8gTWF0aC5taW4oaWR4ICsgMSwgbGVuZ3RoKSA6IGlkeCArIGxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc29ydGVkSW5kZXggJiYgaWR4ICYmIGxlbmd0aCkge1xuICAgICAgICBpZHggPSBzb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpZHhdID09PSBpdGVtID8gaWR4IDogLTE7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICBpZHggPSBwcmVkaWNhdGVGaW5kKHNsaWNlLmNhbGwoYXJyYXksIGksIGxlbmd0aCksIF8uaXNOYU4pO1xuICAgICAgICByZXR1cm4gaWR4ID49IDAgPyBpZHggKyBpIDogLTE7XG4gICAgICB9XG4gICAgICBmb3IgKGlkeCA9IGRpciA+IDAgPyBpIDogbGVuZ3RoIC0gMTsgaWR4ID49IDAgJiYgaWR4IDwgbGVuZ3RoOyBpZHggKz0gZGlyKSB7XG4gICAgICAgIGlmIChhcnJheVtpZHhdID09PSBpdGVtKSByZXR1cm4gaWR4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigxLCBfLmZpbmRJbmRleCwgXy5zb3J0ZWRJbmRleCk7XG4gIF8ubGFzdEluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigtMSwgXy5maW5kTGFzdEluZGV4KTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChzdG9wID09IG51bGwpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCB8fCAxO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvclxuICAvLyBvciBhIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHNcbiAgdmFyIGV4ZWN1dGVCb3VuZCA9IGZ1bmN0aW9uKHNvdXJjZUZ1bmMsIGJvdW5kRnVuYywgY29udGV4dCwgY2FsbGluZ0NvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIShjYWxsaW5nQ29udGV4dCBpbnN0YW5jZW9mIGJvdW5kRnVuYykpIHJldHVybiBzb3VyY2VGdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIHZhciBzZWxmID0gYmFzZUNyZWF0ZShzb3VyY2VGdW5jLnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IHNvdXJjZUZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgaWYgKF8uaXNPYmplY3QocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXG4gIC8vIGFzIGEgcGxhY2Vob2xkZXIsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmUgcHJlLWZpbGxlZC5cbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBib3VuZEFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYm91bmRBcmdzW2ldID09PSBfID8gYXJndW1lbnRzW3Bvc2l0aW9uKytdIDogYm91bmRBcmdzW2ldO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aCkgYXJncy5wdXNoKGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCB0aGlzLCB0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbiAgLy8gYXJlIHRoZSBtZXRob2QgbmFtZXMgdG8gYmUgYm91bmQuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBhbGwgY2FsbGJhY2tzXG4gIC8vIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGksIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGtleTtcbiAgICBpZiAobGVuZ3RoIDw9IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gYXJndW1lbnRzW2ldO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9ICcnICsgKGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5KTtcbiAgICAgIGlmICghXy5oYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBfLnBhcnRpYWwoXy5kZWxheSwgXywgMSk7XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogXy5ub3coKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsYXN0ID0gXy5ub3coKSAtIHRpbWVzdGFtcDtcblxuICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB0aW1lc3RhbXAgPSBfLm5vdygpO1xuICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIHBhc3NlZC1pbiBwcmVkaWNhdGUuXG4gIF8ubmVnYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHN0YXJ0O1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb24gYW5kIGFmdGVyIHRoZSBOdGggY2FsbC5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgTnRoIGNhbGwuXG4gIF8uYmVmb3JlID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICB2YXIgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA+IDApIHtcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcyA8PSAxKSBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gIF8ub25jZSA9IF8ucGFydGlhbChfLmJlZm9yZSwgMik7XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gS2V5cyBpbiBJRSA8IDkgdGhhdCB3b24ndCBiZSBpdGVyYXRlZCBieSBgZm9yIGtleSBpbiAuLi5gIGFuZCB0aHVzIG1pc3NlZC5cbiAgdmFyIGhhc0VudW1CdWcgPSAhe3RvU3RyaW5nOiBudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbiAgdmFyIG5vbkVudW1lcmFibGVQcm9wcyA9IFsndmFsdWVPZicsICdpc1Byb3RvdHlwZU9mJywgJ3RvU3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnaGFzT3duUHJvcGVydHknLCAndG9Mb2NhbGVTdHJpbmcnXTtcblxuICBmdW5jdGlvbiBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cykge1xuICAgIHZhciBub25FbnVtSWR4ID0gbm9uRW51bWVyYWJsZVByb3BzLmxlbmd0aDtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG4gICAgdmFyIHByb3RvID0gKF8uaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlKSB8fCBPYmpQcm90bztcblxuICAgIC8vIENvbnN0cnVjdG9yIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgIHZhciBwcm9wID0gJ2NvbnN0cnVjdG9yJztcbiAgICBpZiAoXy5oYXMob2JqLCBwcm9wKSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkga2V5cy5wdXNoKHByb3ApO1xuXG4gICAgd2hpbGUgKG5vbkVudW1JZHgtLSkge1xuICAgICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tub25FbnVtSWR4XTtcbiAgICAgIGlmIChwcm9wIGluIG9iaiAmJiBvYmpbcHJvcF0gIT09IHByb3RvW3Byb3BdICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSB7XG4gICAgICAgIGtleXMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICBfLmFsbEtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG9iamVjdFxuICAvLyBJbiBjb250cmFzdCB0byBfLm1hcCBpdCByZXR1cm5zIGFuIG9iamVjdFxuICBfLm1hcE9iamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHRzID0ge30sXG4gICAgICAgICAgY3VycmVudEtleTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY3VycmVudEtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICByZXN1bHRzW2N1cnJlbnRLZXldID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMpO1xuXG4gIC8vIEFzc2lnbnMgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIG93biBwcm9wZXJ0aWVzIGluIHRoZSBwYXNzZWQtaW4gb2JqZWN0KHMpXG4gIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduKVxuICBfLmV4dGVuZE93biA9IF8uYXNzaWduID0gY3JlYXRlQXNzaWduZXIoXy5rZXlzKTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBrZXkgb24gYW4gb2JqZWN0IHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kS2V5ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksIGtleTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2tleV0sIGtleSwgb2JqKSkgcmV0dXJuIGtleTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqZWN0LCBvaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIG9iaiA9IG9iamVjdCwgaXRlcmF0ZWUsIGtleXM7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24ob2l0ZXJhdGVlKSkge1xuICAgICAga2V5cyA9IF8uYWxsS2V5cyhvYmopO1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKG9pdGVyYXRlZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7IHJldHVybiBrZXkgaW4gb2JqOyB9O1xuICAgICAgb2JqID0gT2JqZWN0KG9iaik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgaWYgKGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iaikpIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLm9taXQgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gXy5uZWdhdGUoaXRlcmF0ZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ubWFwKGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzLCB0cnVlKTtcblxuICAvLyBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIHByb3RvdHlwZSBvYmplY3QuXG4gIC8vIElmIGFkZGl0aW9uYWwgcHJvcGVydGllcyBhcmUgcHJvdmlkZWQgdGhlbiB0aGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4gIC8vIGNyZWF0ZWQgb2JqZWN0LlxuICBfLmNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIGlmIChwcm9wcykgXy5leHRlbmRPd24ocmVzdWx0LCBwcm9wcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uaXNNYXRjaCA9IGZ1bmN0aW9uKG9iamVjdCwgYXR0cnMpIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhhdHRycyksIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuICFsZW5ndGg7XG4gICAgdmFyIG9iaiA9IE9iamVjdChvYmplY3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldIHx8ICEoa2V5IGluIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gJycgKyBhID09PSAnJyArIGI7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTlxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICB9XG5cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuXG4gICAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gICAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgdmFyIGtleXMgPSBfLmtleXMoYSksIGtleTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgaWYgKF8ua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICAgIGlmICghKF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSAmJiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBfLmtleXMob2JqKS5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAsIGlzRXJyb3IuXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJywgJ0Vycm9yJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSA8IDkpLCB3aGVyZVxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmhhcyhvYmosICdjYWxsZWUnKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBzb21lIHR5cGVvZiBidWdzIGluIG9sZCB2OCxcbiAgLy8gSUUgMTEgKCMxNjIxKSwgYW5kIGluIFNhZmFyaSA4ICgjMTkyOSkuXG4gIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0Jykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT09ICtvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdGVlcy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9ucy4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG4gIF8ucHJvcGVydHkgPSBwcm9wZXJ0eTtcblxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBvYmplY3QgdGhhdCByZXR1cm5zIGEgZ2l2ZW4gcHJvcGVydHkuXG4gIF8ucHJvcGVydHlPZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT0gbnVsbCA/IGZ1bmN0aW9uKCl7fSA6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLm1hdGNoZXIgPSBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xuICAgIGF0dHJzID0gXy5leHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5pc01hdGNoKG9iaiwgYXR0cnMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdGVlKGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuICB2YXIgdW5lc2NhcGVNYXAgPSBfLmludmVydChlc2NhcGVNYXApO1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcbiAgICB9O1xuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZFxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBfLmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIGZhbGxiYWNrKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBvYmplY3RbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IGZhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgZXZhbHVhdGUgICAgOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlICAgICAgOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgIFwiJ1wiOiAgICAgIFwiJ1wiLFxuICAgICdcXFxcJzogICAgICdcXFxcJyxcbiAgICAnXFxyJzogICAgICdyJyxcbiAgICAnXFxuJzogICAgICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XG5cbiAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbiAgfTtcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcbiAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLiBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfKG9iaik7XG4gICAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2NoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIF8ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gUHJvdmlkZSB1bndyYXBwaW5nIHByb3h5IGZvciBzb21lIG1ldGhvZHMgdXNlZCBpbiBlbmdpbmUgb3BlcmF0aW9uc1xuICAvLyBzdWNoIGFzIGFyaXRobWV0aWMgYW5kIEpTT04gc3RyaW5naWZpY2F0aW9uLlxuICBfLnByb3RvdHlwZS52YWx1ZU9mID0gXy5wcm90b3R5cGUudG9KU09OID0gXy5wcm90b3R5cGUudmFsdWU7XG5cbiAgXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcbiAgLy8gdGhhdCBtYXkgbm90IGVuZm9yY2UgbmV4dC10dXJuIHNlbWFudGljcyBvbiBtb2R1bGVzLiBFdmVuIHRob3VnaCBnZW5lcmFsXG4gIC8vIHByYWN0aWNlIGZvciBBTUQgcmVnaXN0cmF0aW9uIGlzIHRvIGJlIGFub255bW91cywgdW5kZXJzY29yZSByZWdpc3RlcnNcbiAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcbiAgLy8gcG9wdWxhciBlbm91Z2ggdG8gYmUgYnVuZGxlZCBpbiBhIHRoaXJkIHBhcnR5IGxpYiwgYnV0IG5vdCBiZSBwYXJ0IG9mXG4gIC8vIGFuIEFNRCBsb2FkIHJlcXVlc3QuIFRob3NlIGNhc2VzIGNvdWxkIGdlbmVyYXRlIGFuIGVycm9yIHdoZW4gYW5cbiAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxufS5jYWxsKHRoaXMpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dC9pbmRleCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVQbHVnaW4gPT4gZGVmaW5lUGx1Z2luKCdyZW5kZXJlcnMnLCBbXHJcbiAgJ2NvbmZpZycsXHJcbiAgXSwgZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgY29uc3QgcmVuZGVyZXJzID0gW107XHJcblxyXG4gICAgaWYgKGNvbmZpZy5zY3JvbGxhYmxlKSB7XHJcbiAgICAgIGlmIChjb25maWcuc2Nyb2xsYWJsZS52aXJ0dWFsKSB7XHJcbiAgICAgICAgcmVuZGVyZXJzLnB1c2gobGF5b3V0LnJlbmRlcmVycy5WaXJ0dWFsaXphdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbmZpZy5zY3JvbGxhYmxlLmZpeGVkSGVhZGVyKSB7XHJcbiAgICAgICAgcmVuZGVyZXJzLnB1c2gobGF5b3V0LnJlbmRlcmVycy5GaXhlZEhlYWRlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVuZGVyZXJzO1xyXG4gIH0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL2ZhY3RvcnkvcmVuZGVyZXJzLXBsdWdpbi5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIFRhYmxlTGF5b3V0OiByZXF1aXJlKCcuL3RhYmxlJyksXHJcbiAgdGVtcGxhdGVzOiB7XHJcbiAgICB0YWJsZTogcmVxdWlyZSgnLi90ZW1wbGF0ZS90YWJsZS5qYWRlJyksXHJcbiAgfSxcclxuICByZW5kZXJlcnM6IHJlcXVpcmUoJy4vcmVuZGVyZXIvaW5kZXgnKSxcclxufTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy9sYXlvdXQvaW5kZXguanNcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2xpYi9qcXVlcnknLFxyXG4gICdsaWIvYmFja2JvbmUnLFxyXG5dLCBmdW5jdGlvbiAoXywgJCwgQmFja2JvbmUpIHtcclxuICB2YXIgVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICAgIGV2ZW50czoge1xyXG4gICAgICAnY2xpY2sgdGgnOiAndGhDbGljaycsXHJcbiAgICAgICdjbGljayB0ZCc6ICd0ZENsaWNrJyxcclxuICAgICAgJ2NoYW5nZSB0ZD5pbnB1dC5ncmlkLXRleHQtaW5wdXQnOiAnZWRpdGFibGVTdHJpbmdDaGFuZ2UnLFxyXG4gICAgfSxcclxuXHJcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICBfLmJpbmRBbGwodGhpcywgJ3VwZGF0ZScsICd0aENsaWNrJywgJ3RkQ2xpY2snLCAnZGF0YUZvcicpO1xyXG5cclxuICAgICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcclxuXHJcbiAgICAgIC8vIFRPRE8gW2FrYW1lbF0gcmVuYW1lPyB0aGlzIGlzbid0IGEgYmFja2JvbmUgZGF0YSBvYmo/XHJcbiAgICAgIHRoaXMuZGF0YSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XHJcbiAgICAgIHRoaXMuZ3JpZCA9IG9wdGlvbnMuZ3JpZDtcclxuXHJcbiAgICAgIHRoaXMucmVuZGVyZXJzID0gXy5tYXAodGhpcy5vcHRpb25zLnJlbmRlcmVycywgZnVuY3Rpb24gKFJlbmRlcmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJlcih7IGxheW91dDogdGhpcyB9KTtcclxuICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgIHRoaXMuc3Vidmlld3MgPSBbXTtcclxuXHJcbiAgICAgIHRoaXMub25WaWV3UG9ydENoYW5nZSA9IHRoaXMub25WaWV3UG9ydENoYW5nZS5iaW5kKHRoaXMpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFfLmlzRW1wdHkodGhpcy5yZW5kZXJlcnMpKSB7XHJcbiAgICAgIFx0dGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgJ3Njcm9sbDpjb250YWluZXInLCB0aGlzLm9uVmlld1BvcnRDaGFuZ2UpO1xyXG4gICAgICBcdHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsICdyZXNpemU6Y29udGFpbmVyJywgdGhpcy5vblZpZXdQb3J0Q2hhbmdlKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvblZpZXdQb3J0Q2hhbmdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuc2NoZWR1bGVEcmF3KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZVN1YnZpZXdzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIF8uZWFjaCh0aGlzLnN1YnZpZXdzLCBmdW5jdGlvbiAoc3Vidmlldykge1xyXG4gICAgICAgIHN1YnZpZXcucmVtb3ZlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnN1YnZpZXdzID0gW107XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLnJlbW92ZVN1YnZpZXdzKCk7XHJcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0b3BMaXN0ZW5pbmcodGhpcy5jb250YWluZXIpO1xyXG4gICAgICBfLmVhY2godGhpcy5yZW5kZXJlcnMsIHJlbmRlcmVyID0+IHJlbmRlcmVyLnJlbW92ZSgpKTtcclxuICAgICAgQmFja2JvbmUuVmlldy5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRoQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIHZhciBhcmcgPSB0aGlzLmRhdGFGb3IoZS5jdXJyZW50VGFyZ2V0KTtcclxuXHJcbiAgICAgIGlmIChhcmcuY29sdW1uKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjbGljazpoZWFkZXInLCBlLCBhcmcpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHRkQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIHZhciBhcmcgPSB0aGlzLmRhdGFGb3IoZS5jdXJyZW50VGFyZ2V0KTtcclxuXHJcbiAgICAgIGlmIChhcmcuY29sdW1uKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjbGljazpjZWxsJywgZSwgYXJnKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBlZGl0YWJsZVN0cmluZ0NoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgdmFyIGFyZyA9IHRoaXMuZGF0YUZvcihlLmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICB2YXIgY29sRWRpdGFibGVTdHIgPSB0aGlzLmdyaWQucHJvamVjdGlvbi5nZXQoJ2NvbHVtbi5lZGl0YWJsZS5zdHJpbmcnKTtcclxuXHJcbiAgICAgIGlmIChhcmcuY29sdW1uKSB7XHJcbiAgICAgICAgaWYgKF8uaXNPYmplY3QoY29sRWRpdGFibGVTdHIpICYmICFfLmlzVW5kZWZpbmVkKGNvbEVkaXRhYmxlU3RyW2FyZy5wcm9wZXJ0eV0pKSB7XHJcbiAgICAgICAgICB0aGlzLmdyaWQucHJvamVjdGlvbi5nZXQoJ3Byb2plY3Rpb246Y29sdW1uLWVkaXRhYmxlLXN0cmluZycpLnRyaWdnZXIoJ2NoYW5nZTpzdHJpbmcnLCBlLCBhcmcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTplZGl0YWJsZS5zdHJpbmcnLCBlLCBhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkYXRhRm9yOiBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgaWYgKCEkLmNvbnRhaW5zKHRoaXMuZWwsIGVsKSkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciAkZWwgPSAkKGVsKTtcclxuICAgICAgLy8gVE9ETyBbYWthbWVsXSBjYW4gd2UgdXNlIHRhcmdldCBpbnN0ZWFkP1xyXG4gICAgICB2YXIgJHRyID0gJGVsLmNsb3Nlc3QoJ3RyJywgdGhpcy5lbCk7XHJcbiAgICAgIHZhciAkY2xvc2VzdFREID0gJGVsLmNsb3Nlc3QoJ3RkJywgdGhpcy5lbCk7XHJcbiAgICAgIHZhciAkY2xvc2VzdFRIID0gJGVsLmNsb3Nlc3QoJ3RoJywgdGhpcy5lbCk7XHJcbiAgICAgIHZhciAkdGQgPSBfLnNpemUoJGNsb3Nlc3RURCkgPyAkY2xvc2VzdFREIDogJGNsb3Nlc3RUSDtcclxuICAgICAgdmFyIHZpcnR1YWxpemVyID0gdGhpcy5nZXRSZW5kZXJlcigndmlydHVhbGl6YXRpb24nKTtcclxuICAgICAgdmFyIGkgPSAkdHIuaW5kZXgoKTtcclxuICAgICAgdmFyIGogPSAkdGQuaW5kZXgoKTtcclxuICAgICAgLy8gVE9ETyBbYWthbWVsXSAxLSBjaGVjayBpZiAkdGQgaXMgdGg7IDItIHRocm93IGlmIGVsIGlzIG5laXRoZXIgdGggb3IgdGQgYXMgaXQgaXMgYXNzdW1lZCBpbiB0aGlzIGZ1bmN0aW9uXHJcbiAgICAgIHZhciBpc0hlYWRlciA9ICR0ZC5jbG9zZXN0KCd0aGVhZCcsIHRoaXMuZWwpLmxlbmd0aDtcclxuICAgICAgdmFyIHJldCA9IHsgaGVhZGVyOiBpc0hlYWRlciB9O1xyXG5cclxuICAgICAgLy8gd2UgYXJlIG5vdCBpbiBoZWFkZXJcclxuICAgICAgaWYgKGlzSGVhZGVyKSB7XHJcbiAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgIHJldC5wcm9wZXJ0eSA9IHRoaXMuZGF0YS5zZWxlY3Rbal07XHJcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSAxKSB7XHJcbiAgICAgICAgICByZXQucHJvcGVydHkgPSB0aGlzLmRhdGEuc3ViU2VsZWN0W2pdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXQucHJvcGVydHkgPSB0aGlzLmRhdGEuc2VsZWN0RXhwYW5kW2pdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpICs9ICh2aXJ0dWFsaXplciA/IHZpcnR1YWxpemVyLmZpcnN0IDogMCk7XHJcbiAgICAgICAgcmV0Lm1vZGVsID0gdGhpcy5kYXRhLnZhbHVlW2ldO1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEuc2VsZWN0RXhwYW5kKSB7XHJcbiAgICAgICAgICByZXQucHJvcGVydHkgPSB0aGlzLmRhdGEuc2VsZWN0RXhwYW5kW2pdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXQucHJvcGVydHkgPSB0aGlzLmRhdGEuc2VsZWN0W2pdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0LmNvbHVtbiA9IHRoaXMuZGF0YS5jb2x1bW5zW3JldC5wcm9wZXJ0eV07XHJcbiAgICAgIGlmIChyZXQucHJvcGVydHkgPT09IHRoaXMuZ3JpZC5wcm9qZWN0aW9uLmdldCgnY29sdW1uLmNoZWNrZWQnKSkge1xyXG4gICAgICAgIC8vIFRPRE8gW2FrYW1lbF0gdGhpcyBzaG91bGRuJ3QgYmUgaGVyZVxyXG4gICAgICAgIHZhciBjaGVja2JveCA9ICRlbC5maW5kKCcuY29sdW1uLXNlbGVjdGlvbicpO1xyXG4gICAgICAgIGlmIChjaGVja2JveC5sZW5ndGgpIHtcclxuICAgICAgICAgIHJldC5jaGVja2VkID0gY2hlY2tib3hbMF0uY2hlY2tlZDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0LmdyaWQgPSB0aGlzLmdyaWQ7XHJcblxyXG4gICAgICByZXR1cm4gcmV0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBUT0RPIFtha2FtZWxdIFtwZXJmXSA4LjUlXHJcbiAgICB0b0hUTUw6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICB2YXIgZGF0YSA9IF8uZGVmYXVsdHMoeyB2YWx1ZTogdmFsdWUgfSwgdGhpcy5kYXRhKTtcclxuXHJcbiAgICAgIF8uZWFjaChkYXRhLmNvbHVtbnMsIGZ1bmN0aW9uIChjb2wpIHtcclxuICAgICAgICBpZiAoXy5pc09iamVjdChjb2wuJG1ldGFkYXRhKSkge1xyXG4gICAgICAgICAgaWYgKF8uaGFzKGNvbC4kbWV0YWRhdGFbJ2F0dHIuaGVhZCddLCAnY2xhc3MnKSAmJiBfLmlzQXJyYXkoY29sLiRtZXRhZGF0YVsnYXR0ci5oZWFkJ10uY2xhc3MpKSB7XHJcbiAgICAgICAgICAgIGNvbC4kbWV0YWRhdGFbJ2F0dHIuaGVhZCddLmNsYXNzID0gY29sLiRtZXRhZGF0YVsnYXR0ci5oZWFkJ10uY2xhc3Muam9pbignICcpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChfLmhhcyhjb2wuJG1ldGFkYXRhWydhdHRyLmJvZHknXSwgJ2NsYXNzJykgJiYgXy5pc0FycmF5KGNvbC4kbWV0YWRhdGFbJ2F0dHIuYm9keSddLmNsYXNzKSkge1xyXG4gICAgICAgICAgICBjb2wuJG1ldGFkYXRhWydhdHRyLmJvZHknXS5jbGFzcyA9IGNvbC4kbWV0YWRhdGFbJ2F0dHIuYm9keSddLmNsYXNzLmpvaW4oJyAnKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIFRPRE8gW2FrYW1lbF0gbWVyZ2UgYXR0ciB0aGF0IGFyZSBvbiAkbWV0YWRhdGFbJ2F0dHInXVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRlbXBsYXRlKGRhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICBfLmVhY2godGhpcy5yZW5kZXJlcnMsIGZ1bmN0aW9uIChyZW5kZXJlcikge1xyXG4gICAgICAgIHJlbmRlcmVyLnVwZGF0ZSAmJiByZW5kZXJlci51cGRhdGUoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB2YXIgdmFsdWUgPSBtb2RlbC5nZXQoJ3ZhbHVlJyk7XHJcbiAgICAgIHZhciBjb2x1bW5zID0gbW9kZWwuZ2V0KCdjb2x1bW5zJyk7XHJcbiAgICAgIHZhciBjb2x1bW5zRGVsdGEgPSB7fTtcclxuICAgICAgdmFyIGNvbE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuY29sdW1ucyB8fCB7fTtcclxuICAgICAgdmFyIG9yZGVyYnkgPSB7fTtcclxuXHJcbiAgICAgIF8uZWFjaCh0aGlzLmdyaWQucHJvamVjdGlvbi5nZXQoJ29yZGVyYnknKSwgZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGtleSA9IF8uZmlyc3QoXy5rZXlzKGVsZW1lbnQpKTtcclxuICAgICAgICBvcmRlcmJ5W2tleV0gPSB7XHJcbiAgICAgICAgICBkaXI6IGVsZW1lbnRba2V5XSxcclxuICAgICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIF8uZWFjaChjb2x1bW5zLCBmdW5jdGlvbiAoY29sLCBwcm9wZXJ0eSkge1xyXG4gICAgICAvLyBUT0RPIFtha2FtZWxdIGNvbnNpZGVyIGZpbHRlcmluZyB3aGljaCBwcm9wcyB0byBjb3B5L292ZXJyaWRlXHJcbiAgICAgICAgdmFyIGRlbHRhID0ge307XHJcbiAgICAgICAgdmFyIGNvbE9wdGlvbiA9IGNvbE9wdGlvbnNbcHJvcGVydHldO1xyXG4gICAgICAgIHZhciBvcmRlck5hbWUgPSBwcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgaWYgKGNvbE9wdGlvbiAmJiBfLmlzU3RyaW5nKGNvbE9wdGlvbi5zb3J0YWJsZSkpIHtcclxuICAgICAgICAgIG9yZGVyTmFtZSA9IGNvbE9wdGlvbi5zb3J0YWJsZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvbCAmJiBfLmlzU3RyaW5nKGNvbC5zb3J0YWJsZSkpIHtcclxuICAgICAgICAgIG9yZGVyTmFtZSA9IGNvbC5zb3J0YWJsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcmRlcmJ5W29yZGVyTmFtZV0pIHtcclxuICAgICAgICAgIGRlbHRhLiRvcmRlcmJ5ID0gb3JkZXJieVtvcmRlck5hbWVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29sdW1uc0RlbHRhW3Byb3BlcnR5XSA9IF8uZGVmYXVsdHMoZGVsdGEsIGNvbE9wdGlvbiwgY29sKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoXy5oYXModGhpcy5vcHRpb25zLiRtZXRhZGF0YSwgJ2NsYXNzJykgJiYgXy5pc0FycmF5KHRoaXMub3B0aW9ucy4kbWV0YWRhdGEuY2xhc3MpKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLiRtZXRhZGF0YS5jbGFzcyA9IHRoaXMub3B0aW9ucy4kbWV0YWRhdGEuY2xhc3Muam9pbignICcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZGVsdGEgPSB7XHJcbiAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXHJcbiAgICAgICAgJ2NvbHVtbnMnOiBjb2x1bW5zRGVsdGEsXHJcbiAgICAgICAgJ2NvbHVtbnMubG9va3VwJzogXy5pbmRleEJ5KGNvbHVtbnMsIGZ1bmN0aW9uIChjb2wpIHtcclxuICAgICAgICAgIHJldHVybiBjb2wucHJvcGVydHk7XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgJyRtZXRhZGF0YSc6IHRoaXMub3B0aW9ucy4kbWV0YWRhdGEsXHJcbiAgICAgICAgJ2hpZGVIZWFkZXJzJzogdGhpcy5vcHRpb25zLmhpZGVIZWFkZXJzLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5kYXRhID0gXy5kZWZhdWx0cyhkZWx0YSwgbW9kZWwudG9KU09OKCkpO1xyXG5cclxuICAgICAgdGhpcy5kcmF3KHsgY2FuU2tpcERyYXc6IGZhbHNlIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzY2hlZHVsZURyYXc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKCF0aGlzLnNjaGVkdWxlZERyYXcpIHtcclxuICAgICAgICB0aGlzLnNjaGVkdWxlZERyYXcgPSB0cnVlO1xyXG5cclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHRoaXMuc2NoZWR1bGVkRHJhdyA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhpcy5kcmF3KCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkcmF3YWJsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgcmV0dXJuIF8uZmluZCh0aGlzLnJlbmRlcmVycywgZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICByZXR1cm4gci5uYW1lID09PSBuYW1lO1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgZHJhdzogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgaWYgKCF0aGlzLmRyYXdhYmxlKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcigncmVuZGVyOmJlZ2lubmluZycpO1xyXG5cclxuICAgICAgdmFyIHJlbmRlcmVycyA9IHRoaXMucmVuZGVyZXJzO1xyXG4gICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICB2YXIgbWlkZGxld2FyZSA9IGZ1bmN0aW9uIChkYXRhLCBjYikge1xyXG4gICAgICAgIHZhciByID0gcmVuZGVyZXJzW2krK107XHJcbiAgICAgICAgaWYgKHIpIHtcclxuICAgICAgICAgIHZhciBjbG9uZSA9IF8uZGVmYXVsdHMoe30sIGRhdGEsIHsgY3NzOiB7fSB9KTtcclxuICAgICAgICAgIGRlbGV0ZSBjbG9uZS5jYW5Ta2lwRHJhdztcclxuXHJcbiAgICAgICAgICByLmRyYXcoY2xvbmUsIF8ub25jZShmdW5jdGlvbiAoZXJyLCByZXMpIHtcclxuICAgICAgICAgICAgcmVzLmNhblNraXBEcmF3ID0gZGF0YS5jYW5Ta2lwRHJhdyA9PT0gdHJ1ZSAmJiByZXMuY2FuU2tpcERyYXcgPT09IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICBjYihlcnIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG1pZGRsZXdhcmUocmVzIHx8IGNsb25lLCBjYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2IodW5kZWZpbmVkLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgY2FuU2tpcERyYXcgPSBfLmhhcyhvcHRpb25zLCAnY2FuU2tpcERyYXcnKSA/IG9wdGlvbnMuY2FuU2tpcERyYXcgOiB0cnVlO1xyXG5cclxuICAgICAgLy8gdGhpcyBpcyBfbm90XyBhbmQgX2Nhbm5vdF8gYmUgYXN5bmNcclxuICAgICAgbWlkZGxld2FyZSh7IHJvd3M6IHRoaXMuZGF0YS52YWx1ZSwgY2FuU2tpcERyYXc6IGNhblNraXBEcmF3IH0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xyXG4gICAgICAgIHJlcy5jc3MgJiYgdGhpcy4kZWwuY3NzKHJlcy5jc3MpO1xyXG5cclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlbW92ZVN1YnZpZXdzKCk7XHJcblxyXG4gICAgICAgIGlmIChyZXMuY2FuU2tpcERyYXcgIT09IHRydWUpIHtcclxuICAgICAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gdGhpcy50b0hUTUwocmVzLnJvd3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXy5lYWNoKHRoaXMuZGF0YS5jb2x1bW5zLCBmdW5jdGlvbiAoY29sdW1uKSB7XHJcbiAgICAgICAgICBpZiAoY29sdW1uLmNvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNvbHVtbi5jb25maWcuVmlldykpIHtcclxuICAgICAgICAgICAgICB0aGlzLiQoJ3RkLmNvbC0nICsgY29sdW1uLmNvbmZpZy5uYW1lKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjZWxsVmlldyA9IG5ldyBjb2x1bW4uY29uZmlnLlZpZXcoeyBtb2RlbDogdGhpcy5kYXRhRm9yKGVsKS5tb2RlbCB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuJChlbCkuaHRtbChjZWxsVmlldy5yZW5kZXIoKS5lbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnZpZXdzLnB1c2goY2VsbFZpZXcpO1xyXG4gICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb2x1bW4uY29uZmlnLkhlYWRlclZpZXcpKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy4kKCd0aC5jb2wtJyArIGNvbHVtbi5jb25maWcubmFtZSkuZWFjaChmdW5jdGlvbiAoaW5kZXgsIGVsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyVmlldyA9IG5ldyBjb2x1bW4uY29uZmlnLkhlYWRlclZpZXcoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuJChlbCkuaHRtbChoZWFkZXJWaWV3LnJlbmRlcigpLmVsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3Vidmlld3MucHVzaChoZWFkZXJWaWV3KTtcclxuICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICB0aGlzLnRyaWdnZXIoJ3JlbmRlcjpmaW5pc2hlZCcpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5ncmlkLm9uKCdjaGFuZ2U6ZGF0YScsIHRoaXMudXBkYXRlKTtcclxuXHJcbiAgICAgIC8vIHRoaXMuZ3JpZC5wcm9qZWN0aW9uLmRhdGEub24oJ2NoYW5nZScsIHRoaXMudXBkYXRlKTtcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIFZpZXcucGFydGlhbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gVmlldy5leHRlbmQoeyBvcHRpb25zOiBvcHRpb25zIH0pO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBWaWV3O1xyXG59KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy9sYXlvdXQvdGFibGUuanNcbiAqKi8iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMi40XG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDUtMjBUMTc6MjNaXG4gKi9cblxuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gU3VwcG9ydDogRmlyZWZveCAxOCtcbi8vIENhbid0IGJlIGluIHN0cmljdCBtb2RlLCBzZXZlcmFsIGxpYnMgaW5jbHVkaW5nIEFTUC5ORVQgdHJhY2Vcbi8vIHRoZSBzdGFjayB2aWEgYXJndW1lbnRzLmNhbGxlci5jYWxsZWUgYW5kIEZpcmVmb3ggZGllcyBpZlxuLy8geW91IHRyeSB0byB0cmFjZSB0aHJvdWdoIFwidXNlIHN0cmljdFwiIGNhbGwgY2hhaW5zLiAoIzEzMzM1KVxuLy9cInVzZSBzdHJpY3RcIjtcbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIyLjIuNFwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbXFxkYS16XSkvZ2ksXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0Ly8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG5cdFx0dmFyIHJlYWxTdHJpbmdPYmogPSBvYmogJiYgb2JqLnRvU3RyaW5nKCk7XG5cdFx0cmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgKCByZWFsU3RyaW5nT2JqIC0gcGFyc2VGbG9hdCggcmVhbFN0cmluZ09iaiApICsgMSApID49IDA7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Ly8gTm90IHBsYWluIG9iamVjdHM6XG5cdFx0Ly8gLSBBbnkgb2JqZWN0IG9yIHZhbHVlIHdob3NlIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSBpcyBub3QgXCJbb2JqZWN0IE9iamVjdF1cIlxuXHRcdC8vIC0gRE9NIG5vZGVzXG5cdFx0Ly8gLSB3aW5kb3dcblx0XHRpZiAoIGpRdWVyeS50eXBlKCBvYmogKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG5cdFx0aWYgKCBvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmosIFwiY29uc3RydWN0b3JcIiApICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbCggb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSB8fCB7fSwgXCJpc1Byb3RvdHlwZU9mXCIgKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0XHQvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93blxuXHRcdGZvciAoIGtleSBpbiBvYmogKSB7fVxuXG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGhhc093bi5jYWxsKCBvYmosIGtleSApO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wLCBpT1M8NiAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHR2YXIgc2NyaXB0LFxuXHRcdFx0aW5kaXJlY3QgPSBldmFsO1xuXG5cdFx0Y29kZSA9IGpRdWVyeS50cmltKCBjb2RlICk7XG5cblx0XHRpZiAoIGNvZGUgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBjb2RlIGluY2x1ZGVzIGEgdmFsaWQsIHByb2xvZ3VlIHBvc2l0aW9uXG5cdFx0XHQvLyBzdHJpY3QgbW9kZSBwcmFnbWEsIGV4ZWN1dGUgY29kZSBieSBpbmplY3RpbmcgYVxuXHRcdFx0Ly8gc2NyaXB0IHRhZyBpbnRvIHRoZSBkb2N1bWVudC5cblx0XHRcdGlmICggY29kZS5pbmRleE9mKCBcInVzZSBzdHJpY3RcIiApID09PSAxICkge1xuXHRcdFx0XHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cdFx0XHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgYXZvaWQgdGhlIERPTSBub2RlIGNyZWF0aW9uLCBpbnNlcnRpb25cblx0XHRcdFx0Ly8gYW5kIHJlbW92YWwgYnkgdXNpbmcgYW4gaW5kaXJlY3QgZ2xvYmFsIGV2YWxcblxuXHRcdFx0XHRpbmRpcmVjdCggY29kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjFcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuLy8gSlNIaW50IHdvdWxkIGVycm9yIG9uIHRoaXMgY29kZSBkdWUgdG8gdGhlIFN5bWJvbCBub3QgYmVpbmcgZGVmaW5lZCBpbiBFUzUuXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuanNoaW50cmMgd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBqdXN0IGRpc2FibGUgSlNIaW50IGZvciB0aGVzZVxuLy8gdGhyZWUgbGluZXMuXG4vKiBqc2hpbnQgaWdub3JlOiBzdGFydCAqL1xuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuLyoganNoaW50IGlnbm9yZTogZW5kICovXG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiBpT1MgOC4yIChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjIuMVxuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNS0xMC0xN1xuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gR2VuZXJhbC1wdXJwb3NlIGNvbnN0YW50c1xuXHRNQVhfTkVHQVRJVkUgPSAxIDw8IDMxLFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXFxceDAwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cdHJlc2NhcGUgPSAvJ3xcXFxcL2csXG5cblx0Ly8gQ1NTIGVzY2FwZXMgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9O1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG5pZHNlbGVjdCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJlc2NhcGUsIFwiXFxcXCQmXCIgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0bmlkc2VsZWN0ID0gcmlkZW50aWZpZXIudGVzdCggbmlkICkgPyBcIiNcIiArIG5pZCA6IFwiW2lkPSdcIiArIG5pZCArIFwiJ11cIjtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IG5pZHNlbGVjdCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZGl2IGFuZCBleHBlY3RzIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZGl2ICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBkaXYucGFyZW50Tm9kZSApIHtcblx0XHRcdGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBkaXYgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRkaXYgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0KCB+Yi5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKSAtXG5cdFx0XHQoIH5hLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApO1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBwYXJlbnQsXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIChwYXJlbnQgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgcGFyZW50LnRvcCAhPT0gcGFyZW50ICkge1xuXHRcdC8vIFN1cHBvcnQ6IElFIDExXG5cdFx0aWYgKCBwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHBhcmVudC5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBwYXJlbnQuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRwYXJlbnQuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFkaXYuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBtID8gWyBtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdXBwb3J0OiBJRTYvN1xuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRkZWxldGUgRXhwci5maW5kW1wiSURcIl07XG5cblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCBcImRpdlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZGl2LCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdFwiZGlzYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBkaXIgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsgZGlyIF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBkaXIgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRzdXBwb3J0LmdldEJ5SWQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdFx0XHRFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdjEgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZGl2MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdGRpdi5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGRpdi5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdHJldHVybiBkaXYuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW1xcdy1dKylcXHMqXFwvPz4oPzo8XFwvXFwxPnwpJC8gKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cblx0fVxuXG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cblx0fVxuXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0XHR9XG5cblx0XHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHR9ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdC8vIE5lZWRlZCBiZWNhdXNlICQoIHNlbGVjdG9yLCBjb250ZXh0ICkgYmVjb21lcyAkKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKVxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQgKTtcblx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFwiIFwiICsgc2VsZWN0b3IgOiBzZWxlY3Rvcjtcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0qKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBCbGFja2JlcnJ5IDQuNlxuXHRcdFx0XHRcdC8vIGdFQklEIHJldHVybnMgbm9kZXMgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAoIzY5NjMpXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gdGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0cG9zID0gcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSB8fCB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvcnMsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0ICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHBvcyA/XG5cdFx0XHRcdFx0cG9zLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdHdoaXRlID0gKCAvXFxTKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIGpRdWVyeS50eXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIFwicmVqZWN0ZWRcIiBdLFxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyBpIF0gKSAmJiBmbnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZFsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdIGZvciBmb3J3YXJkaW5nIGFjdGlvbnMgdG8gbmV3RGVmZXJcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMgPT09IHByb21pc2UgPyBuZXdEZWZlci5wcm9taXNlKCkgOiB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdHByb21pc2UucGlwZSA9IHByb21pc2UudGhlbjtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDMgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdC8vIHN0YXRlID0gWyByZXNvbHZlZCB8IHJlamVjdGVkIF1cblx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXG5cdFx0XHRcdC8vIFsgcmVqZWN0X2xpc3QgfCByZXNvbHZlX2xpc3QgXS5kaXNhYmxlOyBwcm9ncmVzc19saXN0LmxvY2tcblx0XHRcdFx0fSwgdHVwbGVzWyBpIF4gMSBdWyAyIF0uZGlzYWJsZSwgdHVwbGVzWyAyIF1bIDIgXS5sb2NrICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRlZmVycmVkWyByZXNvbHZlIHwgcmVqZWN0IHwgbm90aWZ5IF1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHByb21pc2UgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzdWJvcmRpbmF0ZSAvKiAsIC4uLiwgc3Vib3JkaW5hdGVOICovICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGxlbmd0aCA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoLFxuXG5cdFx0XHQvLyB0aGUgY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBsZW5ndGggIT09IDEgfHxcblx0XHRcdFx0KCBzdWJvcmRpbmF0ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggc3Vib3JkaW5hdGUucHJvbWlzZSApICkgPyBsZW5ndGggOiAwLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkLlxuXHRcdFx0Ly8gSWYgcmVzb2x2ZVZhbHVlcyBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgRGVmZXJyZWQsIGp1c3QgdXNlIHRoYXQuXG5cdFx0XHRkZWZlcnJlZCA9IHJlbWFpbmluZyA9PT0gMSA/IHN1Ym9yZGluYXRlIDogalF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIFVwZGF0ZSBmdW5jdGlvbiBmb3IgYm90aCByZXNvbHZlIGFuZCBwcm9ncmVzcyB2YWx1ZXNcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRjb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHR2YWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlcyA9PT0gcHJvZ3Jlc3NWYWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMsIHByb2dyZXNzQ29udGV4dHMsIHJlc29sdmVDb250ZXh0cztcblxuXHRcdC8vIEFkZCBsaXN0ZW5lcnMgdG8gRGVmZXJyZWQgc3Vib3JkaW5hdGVzOyB0cmVhdCBvdGhlcnMgYXMgcmVzb2x2ZWRcblx0XHRpZiAoIGxlbmd0aCA+IDEgKSB7XG5cdFx0XHRwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRwcm9ncmVzc0NvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0LnByb2dyZXNzKCB1cGRhdGVGdW5jKCBpLCBwcm9ncmVzc0NvbnRleHRzLCBwcm9ncmVzc1ZhbHVlcyApIClcblx0XHRcdFx0XHRcdC5kb25lKCB1cGRhdGVGdW5jKCBpLCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZmFpbCggZGVmZXJyZWQucmVqZWN0ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LS1yZW1haW5pbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBvbiBhbnl0aGluZywgcmVzb2x2ZSB0aGUgbWFzdGVyXG5cdFx0aWYgKCAhcmVtYWluaW5nICkge1xuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3Q7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHQvLyBBZGQgdGhlIGNhbGxiYWNrXG5cdGpRdWVyeS5yZWFkeS5wcm9taXNlKCkuZG9uZSggZm4gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cblx0XHQvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcblx0XHRpZiAoIGpRdWVyeS5mbi50cmlnZ2VySGFuZGxlciApIHtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS50cmlnZ2VySGFuZGxlciggXCJyZWFkeVwiICk7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkub2ZmKCBcInJlYWR5XCIgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuLyoqXG4gKiBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuICovXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbmpRdWVyeS5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24oIG9iaiApIHtcblx0aWYgKCAhcmVhZHlMaXN0ICkge1xuXG5cdFx0cmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cblx0XHQvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuXHRcdC8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuXHRcdC8vIFN1cHBvcnQ6IElFOS0xMCBvbmx5XG5cdFx0Ly8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5cdFx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0XHRcdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdFx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWFkeUxpc3QucHJvbWlzZSggb2JqICk7XG59O1xuXG4vLyBLaWNrIG9mZiB0aGUgRE9NIHJlYWR5IGNoZWNrIGV2ZW4gaWYgdGhlIHVzZXIgZG9lcyBub3RcbmpRdWVyeS5yZWFkeS5wcm9taXNlKCk7XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjaGFpbmFibGUgP1xuXHRcdGVsZW1zIDpcblxuXHRcdC8vIEdldHNcblx0XHRidWxrID9cblx0XHRcdGZuLmNhbGwoIGVsZW1zICkgOlxuXHRcdFx0bGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdC8qIGpzaGludCAtVzAxOCAqL1xuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0cmVnaXN0ZXI6IGZ1bmN0aW9uKCBvd25lciwgaW5pdGlhbCApIHtcblx0XHR2YXIgdmFsdWUgPSBpbml0aWFsIHx8IHt9O1xuXG5cdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUgcHJvcGVydHlcblx0XHQvLyBjb25maWd1cmFiaWxpdHkgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdC8vIGRlbGV0ZWQgd2l0aCB0aGUgZGVsZXRlIG9wZXJhdG9yXG5cdFx0fSBlbHNlIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0fSxcblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0aWYgKCAhYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBkYXRhIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIHByb3AgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGtleSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgc3RvcmVkO1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRzdG9yZWQgPSB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXG5cdFx0XHRyZXR1cm4gc3RvcmVkICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRzdG9yZWQgOiB0aGlzLmdldCggb3duZXIsIGpRdWVyeS5jYW1lbENhc2UoIGtleSApICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLCBuYW1lLCBjYW1lbCxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnJlZ2lzdGVyKCBvd25lciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIFwibmFtZVwiIGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2hlbiBkYXRhIGlzIGluaXRpYWxseSBjcmVhdGVkLCB2aWEgKFwia2V5XCIsIFwidmFsXCIpIHNpZ25hdHVyZSxcblx0XHRcdFx0Ly8ga2V5cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2UuXG5cdFx0XHRcdC8vIFNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byB0ZWxsIF9ob3dfIGEga2V5IHdhcyBhZGRlZCwgcmVtb3ZlXG5cdFx0XHRcdC8vIGJvdGggcGxhaW4ga2V5IGFuZCBjYW1lbENhc2Uga2V5LiAjMTI3ODZcblx0XHRcdFx0Ly8gVGhpcyB3aWxsIG9ubHkgcGVuYWxpemUgdGhlIGFycmF5IGFyZ3VtZW50IHBhdGguXG5cdFx0XHRcdG5hbWUgPSBrZXkuY29uY2F0KCBrZXkubWFwKCBqUXVlcnkuY2FtZWxDYXNlICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbWVsID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gVHJ5IHRoZSBzdHJpbmcgYXMgYSBrZXkgYmVmb3JlIGFueSBtYW5pcHVsYXRpb25cblx0XHRcdFx0aWYgKCBrZXkgaW4gY2FjaGUgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IFsga2V5LCBjYW1lbCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0bmFtZSA9IGNhbWVsO1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lIGluIGNhY2hlID9cblx0XHRcdFx0XHRcdFsgbmFtZSBdIDogKCBuYW1lLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsgbmFtZVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDdcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuXG5cdFx0XHRcdFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0XHRcdFx0XHQrZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTExK1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGEsIGNhbWVsS2V5O1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgYXMtaXNcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICkgfHxcblxuXHRcdFx0XHRcdC8vIFRyeSB0byBmaW5kIGRhc2hlZCBrZXkgaWYgaXQgZXhpc3RzIChnaC0yNzc5KVxuXHRcdFx0XHRcdC8vIFRoaXMgaXMgZm9yIDIuMi54IG9ubHlcblx0XHRcdFx0XHRkYXRhVXNlci5nZXQoIGVsZW0sIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKSApO1xuXG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FtZWxLZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBjYW1lbGl6ZWRcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwgY2FtZWxLZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwgY2FtZWxLZXksIHVuZGVmaW5lZCApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIEZpcnN0LCBhdHRlbXB0IHRvIHN0b3JlIGEgY29weSBvciByZWZlcmVuY2Ugb2YgYW55XG5cdFx0XHRcdC8vIGRhdGEgdGhhdCBtaWdodCd2ZSBiZWVuIHN0b3JlIHdpdGggYSBjYW1lbENhc2VkIGtleS5cblx0XHRcdFx0dmFyIGRhdGEgPSBkYXRhVXNlci5nZXQoIHRoaXMsIGNhbWVsS2V5ICk7XG5cblx0XHRcdFx0Ly8gRm9yIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGUgaW50ZXJvcCwgd2UgaGF2ZSB0b1xuXHRcdFx0XHQvLyBzdG9yZSBwcm9wZXJ0eSBuYW1lcyB3aXRoIGRhc2hlcyBpbiBhIGNhbWVsQ2FzZSBmb3JtLlxuXHRcdFx0XHQvLyBUaGlzIG1pZ2h0IG5vdCBhcHBseSB0byBhbGwgcHJvcGVydGllcy4uLipcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBjYW1lbEtleSwgdmFsdWUgKTtcblxuXHRcdFx0XHQvLyAqLi4uIEluIHRoZSBjYXNlIG9mIHByb3BlcnRpZXMgdGhhdCBtaWdodCBfYWN0dWFsbHlfXG5cdFx0XHRcdC8vIGhhdmUgZGFzaGVzLCB3ZSBuZWVkIHRvIGFsc28gc3RvcmUgYSBjb3B5IG9mIHRoYXRcblx0XHRcdFx0Ly8gdW5jaGFuZ2VkIHByb3BlcnR5LlxuXHRcdFx0XHRpZiAoIGtleS5pbmRleE9mKCBcIi1cIiApID4gLTEgJiYgZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW4gbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCIgfHxcblx0XHRcdCFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLFxuXHRcdHNjYWxlID0gMSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0d2Vlbi5jdXIoKTsgfSA6XG5cdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTsgfSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cblx0XHR9IHdoaWxlIChcblx0XHRcdHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG5cdFx0KTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW1xcdzotXSspLyApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRTlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0ID0gdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0dHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRcdGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0W107XG5cblx0cmV0dXJuIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBqUXVlcnkubm9kZU5hbWUoIGNvbnRleHQsIHRhZyApID9cblx0XHRqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKSA6XG5cdFx0cmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjEsIFBoYW50b21KUzwyXG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wLTQuMywgU2FmYXJpPD01LjFcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaTw9NS4xLCBBbmRyb2lkPDQuMlxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRTlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBtYXRjaGVzLCBzZWwsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBTdXBwb3J0IChhdCBsZWFzdCk6IENocm9tZSwgSUU5XG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXG5cdFx0Ly9cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PD00Mitcblx0XHQvLyBBdm9pZCBub24tbGVmdC1jbGljayBpbiBGRiBidXQgZG9uJ3QgYmxvY2sgSUUgcmFkaW8gZXZlbnRzICgjMzg2MSwgZ2gtMjM0Mylcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiYgY3VyLm5vZGVUeXBlICYmXG5cdFx0XHQoIGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiB8fCBpc05hTiggZXZlbnQuYnV0dG9uICkgfHwgZXZlbnQuYnV0dG9uIDwgMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICggY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiApICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlcyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdC8vIEluY2x1ZGVzIHNvbWUgZXZlbnQgcHJvcHMgc2hhcmVkIGJ5IEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50XG5cdHByb3BzOiAoIFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZGV0YWlsIGV2ZW50UGhhc2UgXCIgK1xuXHRcdFwibWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiICkuc3BsaXQoIFwiIFwiICksXG5cblx0Zml4SG9va3M6IHt9LFxuXG5cdGtleUhvb2tzOiB7XG5cdFx0cHJvcHM6IFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KCBcIiBcIiApLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gb3JpZ2luYWwuY2hhckNvZGUgIT0gbnVsbCA/IG9yaWdpbmFsLmNoYXJDb2RlIDogb3JpZ2luYWwua2V5Q29kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRtb3VzZUhvb2tzOiB7XG5cdFx0cHJvcHM6ICggXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIFwiICtcblx0XHRcdFwic2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFwiICkuc3BsaXQoIFwiIFwiICksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXHRcdFx0dmFyIGV2ZW50RG9jLCBkb2MsIGJvZHksXG5cdFx0XHRcdGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbjtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0ZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHRib2R5ID0gZXZlbnREb2MuYm9keTtcblxuXHRcdFx0XHRldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggK1xuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDAgKSAtXG5cdFx0XHRcdFx0KCBkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCApO1xuXHRcdFx0XHRldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgK1xuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtXG5cdFx0XHRcdFx0KCBkb2MgJiYgZG9jLmNsaWVudFRvcCAgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCAgfHwgMCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0XHQvLyBOb3RlOiBidXR0b24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIGRvbid0IHVzZSBpdFxuXHRcdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gKCBidXR0b24gJiAxID8gMSA6ICggYnV0dG9uICYgMiA/IDMgOiAoIGJ1dHRvbiAmIDQgPyAyIDogMCApICkgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSBhIHdyaXRhYmxlIGNvcHkgb2YgdGhlIGV2ZW50IG9iamVjdCBhbmQgbm9ybWFsaXplIHNvbWUgcHJvcGVydGllc1xuXHRcdHZhciBpLCBwcm9wLCBjb3B5LFxuXHRcdFx0dHlwZSA9IGV2ZW50LnR5cGUsXG5cdFx0XHRvcmlnaW5hbEV2ZW50ID0gZXZlbnQsXG5cdFx0XHRmaXhIb29rID0gdGhpcy5maXhIb29rc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCAhZml4SG9vayApIHtcblx0XHRcdHRoaXMuZml4SG9va3NbIHR5cGUgXSA9IGZpeEhvb2sgPVxuXHRcdFx0XHRybW91c2VFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLm1vdXNlSG9va3MgOlxuXHRcdFx0XHRya2V5RXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5rZXlIb29rcyA6XG5cdFx0XHRcdHt9O1xuXHRcdH1cblx0XHRjb3B5ID0gZml4SG9vay5wcm9wcyA/IHRoaXMucHJvcHMuY29uY2F0KCBmaXhIb29rLnByb3BzICkgOiB0aGlzLnByb3BzO1xuXG5cdFx0ZXZlbnQgPSBuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cblx0XHRpID0gY29weS5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRwcm9wID0gY29weVsgaSBdO1xuXHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdpbmFsRXZlbnRbIHByb3AgXTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBDb3Jkb3ZhIDIuNSAoV2ViS2l0KSAoIzEzMjU1KVxuXHRcdC8vIEFsbCBldmVudHMgc2hvdWxkIGhhdmUgYSB0YXJnZXQ7IENvcmRvdmEgZGV2aWNlcmVhZHkgZG9lc24ndFxuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGRvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjArLCBDaHJvbWU8Mjhcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdGlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZpeEhvb2suZmlsdGVyID8gZml4SG9vay5maWx0ZXIoIGV2ZW50LCBvcmlnaW5hbEV2ZW50ICkgOiBldmVudDtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Oi1dKylbXj5dKilcXC8+L2dpLFxuXG5cdC8vIFN1cHBvcnQ6IElFIDEwLTExLCBFZGdlIDEwMjQwK1xuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIE1hbmlwdWxhdGluZyB0YWJsZXMgcmVxdWlyZXMgYSB0Ym9keVxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdGpRdWVyeS5ub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSA/XG5cblx0XHRlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInRib2R5XCIgKVsgMCBdIHx8XG5cdFx0XHRlbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0Ym9keVwiICkgKSA6XG5cdFx0ZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjEsIFBoYW50b21KUzwyXG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHA6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PSAzNS00NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0gMzUtNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBLZWVwIGRvbU1hbmlwIGV4cG9zZWQgdW50aWwgMy4wIChnaC0yMjI1KVxuXHRkb21NYW5pcDogZG9tTWFuaXAsXG5cblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Ncblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xuXG5cbnZhciBpZnJhbWUsXG5cdGVsZW1kaXNwbGF5ID0ge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveFxuXHRcdC8vIFdlIGhhdmUgdG8gcHJlLWRlZmluZSB0aGVzZSB2YWx1ZXMgZm9yIEZGICgjMTAyMjcpXG5cdFx0SFRNTDogXCJibG9ja1wiLFxuXHRcdEJPRFk6IFwiYmxvY2tcIlxuXHR9O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhY3R1YWwgZGlzcGxheSBvZiBhIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIERvY3VtZW50IG9iamVjdFxuICovXG5cbi8vIENhbGxlZCBvbmx5IGZyb20gd2l0aGluIGRlZmF1bHREaXNwbGF5XG5mdW5jdGlvbiBhY3R1YWxEaXNwbGF5KCBuYW1lLCBkb2MgKSB7XG5cdHZhciBlbGVtID0galF1ZXJ5KCBkb2MuY3JlYXRlRWxlbWVudCggbmFtZSApICkuYXBwZW5kVG8oIGRvYy5ib2R5ICksXG5cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbVsgMCBdLCBcImRpc3BsYXlcIiApO1xuXG5cdC8vIFdlIGRvbid0IGhhdmUgYW55IGRhdGEgc3RvcmVkIG9uIHRoZSBlbGVtZW50LFxuXHQvLyBzbyB1c2UgXCJkZXRhY2hcIiBtZXRob2QgYXMgZmFzdCB3YXkgdG8gZ2V0IHJpZCBvZiB0aGUgZWxlbWVudFxuXHRlbGVtLmRldGFjaCgpO1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG4vKipcbiAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkoIG5vZGVOYW1lICkge1xuXHR2YXIgZG9jID0gZG9jdW1lbnQsXG5cdFx0ZGlzcGxheSA9IGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdO1xuXG5cdGlmICggIWRpc3BsYXkgKSB7XG5cdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblxuXHRcdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZVxuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIWRpc3BsYXkgKSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgYWxyZWFkeS1jcmVhdGVkIGlmcmFtZSBpZiBwb3NzaWJsZVxuXHRcdFx0aWZyYW1lID0gKCBpZnJhbWUgfHwgalF1ZXJ5KCBcIjxpZnJhbWUgZnJhbWVib3JkZXI9JzAnIHdpZHRoPScwJyBoZWlnaHQ9JzAnLz5cIiApIClcblx0XHRcdFx0LmFwcGVuZFRvKCBkb2MuZG9jdW1lbnRFbGVtZW50ICk7XG5cblx0XHRcdC8vIEFsd2F5cyB3cml0ZSBhIG5ldyBIVE1MIHNrZWxldG9uIHNvIFdlYmtpdCBhbmQgRmlyZWZveCBkb24ndCBjaG9rZSBvbiByZXVzZVxuXHRcdFx0ZG9jID0gaWZyYW1lWyAwIF0uY29udGVudERvY3VtZW50O1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0ZG9jLndyaXRlKCk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblxuXHRcdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblx0XHRcdGlmcmFtZS5kZXRhY2goKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcblx0XHRlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cdH1cblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cbnZhciBybWFyZ2luID0gKCAvXm1hcmdpbi8gKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw9MTErLCBGaXJlZm94PD0zMCsgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBwaXhlbE1hcmdpblJpZ2h0VmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtcIiArXG5cdFx0XCJwYWRkaW5nOjA7bWFyZ2luLXRvcDoxcHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcIi13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwidG9wOjElO3dpZHRoOjUwJVwiO1xuXHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IGRpdlN0eWxlLm1hcmdpbkxlZnQgPT09IFwiMnB4XCI7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSBkaXZTdHlsZS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjUwJVwiO1xuXHRcdHBpeGVsTWFyZ2luUmlnaHRWYWwgPSBkaXZTdHlsZS5tYXJnaW5SaWdodCA9PT0gXCI0cHhcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdH1cblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFRoaXMgdGVzdCBpcyBleGVjdXRlZCBvbmx5IG9uY2UgYnV0IHdlIHN0aWxsIGRvIG1lbW9pemluZ1xuXHRcdFx0Ly8gc2luY2Ugd2UgY2FuIHVzZSB0aGUgYm94U2l6aW5nUmVsaWFibGUgcHJlLWNvbXB1dGluZy5cblx0XHRcdC8vIE5vIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHRlc3Qgd2FzIGFscmVhZHkgcGVyZm9ybWVkLCB0aG91Z2guXG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbE1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAtNC4zXG5cdFx0XHQvLyBXZSdyZSBjaGVja2luZyBmb3IgYm94U2l6aW5nUmVsaWFibGVWYWwgaGVyZSBpbnN0ZWFkIG9mIHBpeGVsTWFyZ2luUmlnaHRWYWxcblx0XHRcdC8vIHNpbmNlIHRoYXQgY29tcHJlc3NlcyBiZXR0ZXIgYW5kIHRoZXkncmUgY29tcHV0ZWQgdG9nZXRoZXIgYW55d2F5LlxuXHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBpeGVsTWFyZ2luUmlnaHRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggb25seSwgQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSAzN1xuXHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0Ly8gQ2hlY2sgaWYgZGl2IHdpdGggZXhwbGljaXQgd2lkdGggYW5kIG5vIG1hcmdpbi1yaWdodCBpbmNvcnJlY3RseVxuXHRcdFx0Ly8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiAoIzMzMzMpXG5cdFx0XHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdC8vIFRoaXMgc3VwcG9ydCBmdW5jdGlvbiBpcyBvbmx5IGV4ZWN1dGVkIG9uY2Ugc28gbm8gbWVtb2l6aW5nIGlzIG5lZWRlZC5cblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdG1hcmdpbkRpdiA9IGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdC8vIFJlc2V0IENTUzogYm94LXNpemluZzsgZGlzcGxheTsgbWFyZ2luOyBib3JkZXI7IHBhZGRpbmdcblx0XHRcdG1hcmdpbkRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2LnN0eWxlLmNzc1RleHQgPVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XHRcIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcblx0XHRcdFx0XCJkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MFwiO1xuXHRcdFx0bWFyZ2luRGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXCIwXCI7XG5cdFx0XHRkaXYuc3R5bGUud2lkdGggPSBcIjFweFwiO1xuXHRcdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdFx0cmV0ID0gIXBhcnNlRmxvYXQoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBtYXJnaW5EaXYgKS5tYXJnaW5SaWdodCApO1xuXG5cdFx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHRcdFx0ZGl2LnJlbW92ZUNoaWxkKCBtYXJnaW5EaXYgKTtcblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cdHJldCA9IGNvbXB1dGVkID8gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF0gOiB1bmRlZmluZWQ7XG5cblx0Ly8gU3VwcG9ydDogT3BlcmEgMTIuMXggb25seVxuXHQvLyBGYWxsIGJhY2sgdG8gc3R5bGUgZXZlbiB3aXRob3V0IGNvbXB1dGVkXG5cdC8vIGNvbXB1dGVkIGlzIHVuZGVmaW5lZCBmb3IgZWxlbXMgb24gZG9jdW1lbnQgZnJhZ21lbnRzXG5cdGlmICggKCByZXQgPT09IFwiXCIgfHwgcmV0ID09PSB1bmRlZmluZWQgKSAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiT1wiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSA9IGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgP1xuXG5cdFx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdFx0NCA6XG5cblx0XHQvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG5cdFx0bmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cblx0XHR2YWwgPSAwO1xuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuXHR2YXIgdmFsdWVJc0JvcmRlckJveCA9IHRydWUsXG5cdFx0dmFsID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0LFxuXHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHQvLyBTb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcblx0Ly8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG5cdC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuXHRpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkge1xuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLCBoaWRkZW4sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApO1xuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBSZXNldCB0aGUgaW5saW5lIGRpc3BsYXkgb2YgdGhpcyBlbGVtZW50IHRvIGxlYXJuIGlmIGl0IGlzXG5cdFx0XHQvLyBiZWluZyBoaWRkZW4gYnkgY2FzY2FkZWQgcnVsZXMgb3Igbm90XG5cdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gJiYgZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gb3ZlcnJpZGRlbiB3aXRoIGRpc3BsYXk6IG5vbmVcblx0XHRcdC8vIGluIGEgc3R5bGVzaGVldCB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCBicm93c2VyIHN0eWxlIGlzXG5cdFx0XHQvLyBmb3Igc3VjaCBhbiBlbGVtZW50XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbiggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5hY2Nlc3MoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcIm9sZGRpc3BsYXlcIixcblx0XHRcdFx0XHRkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhpZGRlbiA9IGlzSGlkZGVuKCBlbGVtICk7XG5cblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgfHwgIWhpZGRlbiApIHtcblx0XHRcdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XCJvbGRkaXNwbGF5XCIsXG5cdFx0XHRcdFx0aGlkZGVuID8gZGlzcGxheSA6IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHQvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCAhc2hvdyB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZXNbIGluZGV4IF0gfHwgXCJcIiA6IFwibm9uZVwiO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cdFx0XHRcdFx0ZWxlbS5vZmZzZXRXaWR0aCA9PT0gMCA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xualF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuIHN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSxcblx0XHRcdFx0Y3VyQ1NTLCBbIGVsZW0sIFwibWFyZ2luUmlnaHRcIiBdICk7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW4oIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRTlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIENvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCB0aW1lcklkLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNCA7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHQvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCB0d2VlbiwgaG9va3MsIG9sZGZpcmUsIGRpc3BsYXksIGNoZWNrRGlzcGxheSxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIEhhbmRsZSBxdWV1ZTogZmFsc2UgcHJvbWlzZXNcblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSGVpZ2h0L3dpZHRoIG92ZXJmbG93IHBhc3Ncblx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCJoZWlnaHRcIiBpbiBwcm9wcyB8fCBcIndpZHRoXCIgaW4gcHJvcHMgKSApIHtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUU5LTEwIGRvIG5vdFxuXHRcdC8vIGNoYW5nZSB0aGUgb3ZlcmZsb3cgYXR0cmlidXRlIHdoZW4gb3ZlcmZsb3dYIGFuZFxuXHRcdC8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBTZXQgZGlzcGxheSBwcm9wZXJ0eSB0byBpbmxpbmUtYmxvY2sgZm9yIGhlaWdodC93aWR0aFxuXHRcdC8vIGFuaW1hdGlvbnMgb24gaW5saW5lIGVsZW1lbnRzIHRoYXQgYXJlIGhhdmluZyB3aWR0aC9oZWlnaHQgYW5pbWF0ZWRcblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblxuXHRcdC8vIFRlc3QgZGVmYXVsdCBkaXNwbGF5IGlmIGRpc3BsYXkgaXMgY3VycmVudGx5IFwibm9uZVwiXG5cdFx0Y2hlY2tEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgP1xuXHRcdFx0ZGF0YVByaXYuZ2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApIHx8IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5O1xuXG5cdFx0aWYgKCBjaGVja0Rpc3BsYXkgPT09IFwiaW5saW5lXCIgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBzaG93L2hpZGUgcGFzc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLmV4ZWMoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGRhdGFTaG93IGxlZnQgb3ZlciBmcm9tIGEgc3RvcHBlZCBoaWRlIG9yIHNob3dcblx0XHRcdFx0Ly8gYW5kIHdlIGFyZSBnb2luZyB0byBwcm9jZWVkIHdpdGggc2hvdywgd2Ugc2hvdWxkIHByZXRlbmQgdG8gYmUgaGlkZGVuXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXG5cdFx0Ly8gQW55IG5vbi1meCB2YWx1ZSBzdG9wcyB1cyBmcm9tIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXNwbGF5ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwge30gKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSBzdGF0ZSBpZiBpdHMgdG9nZ2xlIC0gZW5hYmxlcyAuc3RvcCgpLnRvZ2dsZSgpIHRvIFwicmV2ZXJzZVwiXG5cdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdH1cblx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdGpRdWVyeSggZWxlbSApLnNob3coKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5KCBlbGVtICkuaGlkZSgpO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHByb3A7XG5cblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHR0d2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXG5cdFx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0XHR0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0XHR0d2Vlbi5zdGFydCA9IHByb3AgPT09IFwid2lkdGhcIiB8fCBwcm9wID09PSBcImhlaWdodFwiID8gMSA6IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0Ly8gSWYgdGhpcyBpcyBhIG5vb3AgbGlrZSAuaGlkZSgpLmhpZGUoKSwgcmVzdG9yZSBhbiBvdmVyd3JpdHRlbiBkaXNwbGF5IHZhbHVlXG5cdH0gZWxzZSBpZiAoICggZGlzcGxheSA9PT0gXCJub25lXCIgPyBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheSApID09PSBcImlubGluZVwiICkge1xuXHRcdHN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRqUXVlcnkucHJveHkoIHJlc3VsdC5zdG9wLCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHQvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRyZXR1cm4gYW5pbWF0aW9uLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90d2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID9cblx0XHRvcHQuZHVyYXRpb24gOiBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/XG5cdFx0XHRqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW4gKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gd2luZG93LnNldEludGVydmFsKCBqUXVlcnkuZngudGljaywgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdHdpbmRvdy5jbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cblx0dGltZXJJZCA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cDovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IGlPUzw9NS4xLCBBbmRyb2lkPD00LjIrXG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw9Mi4zXG5cdC8vIE9wdGlvbnMgaW5zaWRlIGRpc2FibGVkIHNlbGVjdHMgYXJlIGluY29ycmVjdGx5IG1hcmtlZCBhcyBkaXNhYmxlZFxuXHRzZWxlY3QuZGlzYWJsZWQgPSB0cnVlO1xuXHRzdXBwb3J0Lm9wdERpc2FibGVkID0gIW9wdC5kaXNhYmxlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSwgcHJvcE5hbWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cblx0XHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGdldCBzcGVjaWFsIHRyZWF0bWVudCAoIzEwODcwKVxuXHRcdFx0XHRpZiAoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHRcdFx0Ly8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2Vcblx0XHRcdFx0XHRlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZTtcblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdHJldHVybiB0YWJpbmRleCA/XG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRhYmluZGV4LCAxMCApIDpcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgZWxlbS5ocmVmID9cblx0XHRcdFx0XHRcdFx0MCA6XG5cdFx0XHRcdFx0XHRcdC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIGdldENsYXNzKCBlbGVtICkgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nLFxuXHRyc3BhY2VzID0gL1tcXHgyMFxcdFxcclxcblxcZl0rL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICkgOlxuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTAtMTErXG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRqUXVlcnkudHJpbSggalF1ZXJ5LnRleHQoIGVsZW0gKSApLnJlcGxhY2UoIHJzcGFjZXMsIFwiIFwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIiB8fCBpbmRleCA8IDAsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0KCBzdXBwb3J0Lm9wdERpc2FibGVkID9cblx0XHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT09IG51bGwgKSAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3hcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lLCBTYWZhcmlcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbi8vIFdvcmthcm91bmQgZmFpbHVyZSB0byBzdHJpbmctY2FzdCBudWxsIGlucHV0XG5qUXVlcnkucGFyc2VKU09OID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICsgXCJcIiApO1xufTtcblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyaGFzaCA9IC8jLiokLyxcblx0cnRzID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogalF1ZXJ5LnBhcnNlSlNPTixcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gVGhlIGpxWEhSIHN0YXRlXG5cdFx0XHRzdGF0ZSA9IDAsXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGUgPT09IDIgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHR2YXIgbG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2sgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApLmNvbXBsZXRlID0gY29tcGxldGVEZWZlcnJlZC5hZGQ7XG5cdFx0anFYSFIuc3VjY2VzcyA9IGpxWEhSLmRvbmU7XG5cdFx0anFYSFIuZXJyb3IgPSBqcVhIUi5mYWlsO1xuXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggY2hhcmFjdGVyICgjNzUzMTogYW5kIHN0cmluZyBwcm9tb3Rpb24pXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApLnJlcGxhY2UoIHJoYXNoLCBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0galF1ZXJ5LnRyaW0oIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LTExK1xuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBpZiB1cmwgaXMgbWFsZm9ybWVkLCBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFOC0xMStcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHRjYWNoZVVSTCA9IHMudXJsO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9ICggcy51cmwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YSApO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGFudGktY2FjaGUgaW4gdXJsIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0cy51cmwgPSBydHMudGVzdCggY2FjaGVVUkwgKSA/XG5cblx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ18nIHBhcmFtZXRlciwgc2V0IGl0cyB2YWx1ZVxuXHRcdFx0XHRcdGNhY2hlVVJMLnJlcGxhY2UoIHJ0cywgXCIkMV89XCIgKyBub25jZSsrICkgOlxuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFkZCBvbmUgdG8gdGhlIGVuZFxuXHRcdFx0XHRcdGNhY2hlVVJMICsgKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArIG5vbmNlKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IHN0YXRlID09PSAyICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRmb3IgKCBpIGluIHsgc3VjY2VzczogMSwgZXJyb3I6IDEsIGNvbXBsZXRlOiAxIH0gKSB7XG5cdFx0XHRqcVhIUlsgaSBdKCBzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c3RhdGUgPSAxO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBleGNlcHRpb24gYXMgZXJyb3IgaWYgbm90IGRvbmVcblx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblxuXHRcdFx0XHQvLyBTaW1wbHkgcmV0aHJvdyBvdGhlcndpc2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gQ2FsbGVkIG9uY2Vcblx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdGUgaXMgXCJkb25lXCIgbm93XG5cdFx0XHRzdGF0ZSA9IDI7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiYm9keVwiICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHRcdH1cblx0XHR9ICkuZW5kKCk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDw9IDEyLjEyXG5cdC8vIE9wZXJhIHJlcG9ydHMgb2Zmc2V0V2lkdGhzIGFuZCBvZmZzZXRIZWlnaHRzIGxlc3MgdGhhbiB6ZXJvIG9uIHNvbWUgZWxlbWVudHNcblx0Ly8gVXNlIE9SIGluc3RlYWQgb2YgQU5EIGFzIHRoZSBlbGVtZW50IGlzIG5vdCB2aXNpYmxlIGlmIGVpdGhlciBpcyB0cnVlXG5cdC8vIFNlZSB0aWNrZXRzICMxMDQwNiBhbmQgIzEzMTMyXG5cdHJldHVybiBlbGVtLm9mZnNldFdpZHRoID4gMCB8fCBlbGVtLm9mZnNldEhlaWdodCA+IDAgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA+IDA7XG59O1xuXG5cblxuXG52YXIgcjIwID0gLyUyMC9nLFxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG5cdFx0XHR2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApID8gdmFsdWUoKSA6ICggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIFNldCB0cmFkaXRpb25hbCB0byB0cnVlIGZvciBqUXVlcnkgPD0gMS4zLjIgYmVoYXZpb3IuXG5cdGlmICggdHJhZGl0aW9uYWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHR0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0cmV0dXJuIHZhbCA9PSBudWxsID9cblx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdGpRdWVyeS5pc0FycmF5KCB2YWwgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcblx0XHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vLyBLZWVwIGEgY29weSBvZiB0aGUgb2xkIGxvYWQgbWV0aG9kXG52YXIgX2xvYWQgPSBqUXVlcnkuZm4ubG9hZDtcblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0aWYgKCB0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiICYmIF9sb2FkICkge1xuXHRcdHJldHVybiBfbG9hZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH1cblxuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBqUXVlcnkudHJpbSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbi8qKlxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgZG9jRWxlbSwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGJveCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH0sXG5cdFx0XHRkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDtcblxuXHRcdGlmICggIWRvYyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuXHRcdGlmICggIWpRdWVyeS5jb250YWlucyggZG9jRWxlbSwgZWxlbSApICkge1xuXHRcdFx0cmV0dXJuIGJveDtcblx0XHR9XG5cblx0XHRib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogYm94LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0bGVmdDogYm94LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHR9O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LFxuXHRcdC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB0aGVyZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmk8Ny04KywgQ2hyb21lPDM3LTQ0K1xuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MjgwXG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlLCBudWxsICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cdHNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cbnJldHVybiBqUXVlcnk7XG59KSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gICAgIEJhY2tib25lLmpzIDEuMy4zXG5cbi8vICAgICAoYykgMjAxMC0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgQmFja2JvbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyAgICAgRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuLy8gICAgIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZ1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIChgc2VsZmApIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyLlxuICAvLyBXZSB1c2UgYHNlbGZgIGluc3RlYWQgb2YgYHdpbmRvd2AgZm9yIGBXZWJXb3JrZXJgIHN1cHBvcnQuXG4gIHZhciByb290ID0gKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCk7XG5cbiAgLy8gU2V0IHVwIEJhY2tib25lIGFwcHJvcHJpYXRlbHkgZm9yIHRoZSBlbnZpcm9ubWVudC4gU3RhcnQgd2l0aCBBTUQuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWyd1bmRlcnNjb3JlJywgJ2pxdWVyeScsICdleHBvcnRzJ10sIGZ1bmN0aW9uKF8sICQsIGV4cG9ydHMpIHtcbiAgICAgIC8vIEV4cG9ydCBnbG9iYWwgZXZlbiBpbiBBTUQgY2FzZSBpbiBjYXNlIHRoaXMgc2NyaXB0IGlzIGxvYWRlZCB3aXRoXG4gICAgICAvLyBvdGhlcnMgdGhhdCBtYXkgc3RpbGwgZXhwZWN0IGEgZ2xvYmFsIEJhY2tib25lLlxuICAgICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwgZXhwb3J0cywgXywgJCk7XG4gICAgfSk7XG5cbiAgLy8gTmV4dCBmb3IgTm9kZS5qcyBvciBDb21tb25KUy4galF1ZXJ5IG1heSBub3QgYmUgbmVlZGVkIGFzIGEgbW9kdWxlLlxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpLCAkO1xuICAgIHRyeSB7ICQgPSByZXF1aXJlKCdqcXVlcnknKTsgfSBjYXRjaCAoZSkge31cbiAgICBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIF8sICQpO1xuXG4gIC8vIEZpbmFsbHksIGFzIGEgYnJvd3NlciBnbG9iYWwuXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwge30sIHJvb3QuXywgKHJvb3QualF1ZXJ5IHx8IHJvb3QuWmVwdG8gfHwgcm9vdC5lbmRlciB8fCByb290LiQpKTtcbiAgfVxuXG59KShmdW5jdGlvbihyb290LCBCYWNrYm9uZSwgXywgJCkge1xuXG4gIC8vIEluaXRpYWwgU2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyByZXN0b3JlZCBsYXRlciBvbiwgaWYgYG5vQ29uZmxpY3RgIGlzIHVzZWQuXG4gIHZhciBwcmV2aW91c0JhY2tib25lID0gcm9vdC5CYWNrYm9uZTtcblxuICAvLyBDcmVhdGUgYSBsb2NhbCByZWZlcmVuY2UgdG8gYSBjb21tb24gYXJyYXkgbWV0aG9kIHdlJ2xsIHdhbnQgdG8gdXNlIGxhdGVyLlxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5LiBLZWVwIGluIHN5bmMgd2l0aCBgcGFja2FnZS5qc29uYC5cbiAgQmFja2JvbmUuVkVSU0lPTiA9ICcxLjMuMyc7XG5cbiAgLy8gRm9yIEJhY2tib25lJ3MgcHVycG9zZXMsIGpRdWVyeSwgWmVwdG8sIEVuZGVyLCBvciBNeSBMaWJyYXJ5IChraWRkaW5nKSBvd25zXG4gIC8vIHRoZSBgJGAgdmFyaWFibGUuXG4gIEJhY2tib25lLiQgPSAkO1xuXG4gIC8vIFJ1bnMgQmFja2JvbmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYEJhY2tib25lYCB2YXJpYWJsZVxuICAvLyB0byBpdHMgcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhpcyBCYWNrYm9uZSBvYmplY3QuXG4gIEJhY2tib25lLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290LkJhY2tib25lID0gcHJldmlvdXNCYWNrYm9uZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUdXJuIG9uIGBlbXVsYXRlSFRUUGAgdG8gc3VwcG9ydCBsZWdhY3kgSFRUUCBzZXJ2ZXJzLiBTZXR0aW5nIHRoaXMgb3B0aW9uXG4gIC8vIHdpbGwgZmFrZSBgXCJQQVRDSFwiYCwgYFwiUFVUXCJgIGFuZCBgXCJERUxFVEVcImAgcmVxdWVzdHMgdmlhIHRoZSBgX21ldGhvZGAgcGFyYW1ldGVyIGFuZFxuICAvLyBzZXQgYSBgWC1IdHRwLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxuICBCYWNrYm9uZS5lbXVsYXRlSFRUUCA9IGZhbHNlO1xuXG4gIC8vIFR1cm4gb24gYGVtdWxhdGVKU09OYCB0byBzdXBwb3J0IGxlZ2FjeSBzZXJ2ZXJzIHRoYXQgY2FuJ3QgZGVhbCB3aXRoIGRpcmVjdFxuICAvLyBgYXBwbGljYXRpb24vanNvbmAgcmVxdWVzdHMgLi4uIHRoaXMgd2lsbCBlbmNvZGUgdGhlIGJvZHkgYXNcbiAgLy8gYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGAgaW5zdGVhZCBhbmQgd2lsbCBzZW5kIHRoZSBtb2RlbCBpbiBhXG4gIC8vIGZvcm0gcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgQmFja2JvbmUuZW11bGF0ZUpTT04gPSBmYWxzZTtcblxuICAvLyBQcm94eSBCYWNrYm9uZSBjbGFzcyBtZXRob2RzIHRvIFVuZGVyc2NvcmUgZnVuY3Rpb25zLCB3cmFwcGluZyB0aGUgbW9kZWwnc1xuICAvLyBgYXR0cmlidXRlc2Agb2JqZWN0IG9yIGNvbGxlY3Rpb24ncyBgbW9kZWxzYCBhcnJheSBiZWhpbmQgdGhlIHNjZW5lcy5cbiAgLy9cbiAgLy8gY29sbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLmdldCgnYWdlJykgPiAxMCB9KTtcbiAgLy8gY29sbGVjdGlvbi5lYWNoKHRoaXMuYWRkVmlldyk7XG4gIC8vXG4gIC8vIGBGdW5jdGlvbiNhcHBseWAgY2FuIGJlIHNsb3cgc28gd2UgdXNlIHRoZSBtZXRob2QncyBhcmcgY291bnQsIGlmIHdlIGtub3cgaXQuXG4gIHZhciBhZGRNZXRob2QgPSBmdW5jdGlvbihsZW5ndGgsIG1ldGhvZCwgYXR0cmlidXRlKSB7XG4gICAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0sIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSwgY2IoaXRlcmF0ZWUsIHRoaXMpLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihpdGVyYXRlZSwgZGVmYXVsdFZhbCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSwgY2IoaXRlcmF0ZWUsIHRoaXMpLCBkZWZhdWx0VmFsLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBkZWZhdWx0OiByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBhcmdzLnVuc2hpZnQodGhpc1thdHRyaWJ1dGVdKTtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXS5hcHBseShfLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICB2YXIgYWRkVW5kZXJzY29yZU1ldGhvZHMgPSBmdW5jdGlvbihDbGFzcywgbWV0aG9kcywgYXR0cmlidXRlKSB7XG4gICAgXy5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKGxlbmd0aCwgbWV0aG9kKSB7XG4gICAgICBpZiAoX1ttZXRob2RdKSBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGFkZE1ldGhvZChsZW5ndGgsIG1ldGhvZCwgYXR0cmlidXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBTdXBwb3J0IGBjb2xsZWN0aW9uLnNvcnRCeSgnYXR0cicpYCBhbmQgYGNvbGxlY3Rpb24uZmluZFdoZXJlKHtpZDogMX0pYC5cbiAgdmFyIGNiID0gZnVuY3Rpb24oaXRlcmF0ZWUsIGluc3RhbmNlKSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHJldHVybiBpdGVyYXRlZTtcbiAgICBpZiAoXy5pc09iamVjdChpdGVyYXRlZSkgJiYgIWluc3RhbmNlLl9pc01vZGVsKGl0ZXJhdGVlKSkgcmV0dXJuIG1vZGVsTWF0Y2hlcihpdGVyYXRlZSk7XG4gICAgaWYgKF8uaXNTdHJpbmcoaXRlcmF0ZWUpKSByZXR1cm4gZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLmdldChpdGVyYXRlZSk7IH07XG4gICAgcmV0dXJuIGl0ZXJhdGVlO1xuICB9O1xuICB2YXIgbW9kZWxNYXRjaGVyID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICB2YXIgbWF0Y2hlciA9IF8ubWF0Y2hlcyhhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcihtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEJhY2tib25lLkV2ZW50c1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIG1vZHVsZSB0aGF0IGNhbiBiZSBtaXhlZCBpbiB0byAqYW55IG9iamVjdCogaW4gb3JkZXIgdG8gcHJvdmlkZSBpdCB3aXRoXG4gIC8vIGEgY3VzdG9tIGV2ZW50IGNoYW5uZWwuIFlvdSBtYXkgYmluZCBhIGNhbGxiYWNrIHRvIGFuIGV2ZW50IHdpdGggYG9uYCBvclxuICAvLyByZW1vdmUgd2l0aCBgb2ZmYDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgdmFyIEV2ZW50cyA9IEJhY2tib25lLkV2ZW50cyA9IHt9O1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuXG4gIC8vIEl0ZXJhdGVzIG92ZXIgdGhlIHN0YW5kYXJkIGBldmVudCwgY2FsbGJhY2tgIChhcyB3ZWxsIGFzIHRoZSBmYW5jeSBtdWx0aXBsZVxuICAvLyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGBcImNoYW5nZSBibHVyXCIsIGNhbGxiYWNrYCBhbmQgalF1ZXJ5LXN0eWxlIGV2ZW50XG4gIC8vIG1hcHMgYHtldmVudDogY2FsbGJhY2t9YCkuXG4gIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbihpdGVyYXRlZSwgZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0cykge1xuICAgIHZhciBpID0gMCwgbmFtZXM7XG4gICAgaWYgKG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBIYW5kbGUgZXZlbnQgbWFwcy5cbiAgICAgIGlmIChjYWxsYmFjayAhPT0gdm9pZCAwICYmICdjb250ZXh0JyBpbiBvcHRzICYmIG9wdHMuY29udGV4dCA9PT0gdm9pZCAwKSBvcHRzLmNvbnRleHQgPSBjYWxsYmFjaztcbiAgICAgIGZvciAobmFtZXMgPSBfLmtleXMobmFtZSk7IGkgPCBuYW1lcy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzQXBpKGl0ZXJhdGVlLCBldmVudHMsIG5hbWVzW2ldLCBuYW1lW25hbWVzW2ldXSwgb3B0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lICYmIGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgLy8gSGFuZGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lcyBieSBkZWxlZ2F0aW5nIHRoZW0gaW5kaXZpZHVhbGx5LlxuICAgICAgZm9yIChuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcik7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBldmVudHMgPSBpdGVyYXRlZShldmVudHMsIG5hbWVzW2ldLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmFsbHksIHN0YW5kYXJkIGV2ZW50cy5cbiAgICAgIGV2ZW50cyA9IGl0ZXJhdGVlKGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIEJpbmQgYW4gZXZlbnQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLiBQYXNzaW5nIGBcImFsbFwiYCB3aWxsIGJpbmRcbiAgLy8gdGhlIGNhbGxiYWNrIHRvIGFsbCBldmVudHMgZmlyZWQuXG4gIEV2ZW50cy5vbiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGludGVybmFsT24odGhpcywgbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEd1YXJkIHRoZSBgbGlzdGVuaW5nYCBhcmd1bWVudCBmcm9tIHRoZSBwdWJsaWMgQVBJLlxuICB2YXIgaW50ZXJuYWxPbiA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQsIGxpc3RlbmluZykge1xuICAgIG9iai5fZXZlbnRzID0gZXZlbnRzQXBpKG9uQXBpLCBvYmouX2V2ZW50cyB8fCB7fSwgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBjdHg6IG9iaixcbiAgICAgIGxpc3RlbmluZzogbGlzdGVuaW5nXG4gICAgfSk7XG5cbiAgICBpZiAobGlzdGVuaW5nKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gb2JqLl9saXN0ZW5lcnMgfHwgKG9iai5fbGlzdGVuZXJzID0ge30pO1xuICAgICAgbGlzdGVuZXJzW2xpc3RlbmluZy5pZF0gPSBsaXN0ZW5pbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gLiBUZWxsICp0aGlzKiBvYmplY3QgdG8gbGlzdGVuIHRvXG4gIC8vIGFuIGV2ZW50IGluIGFub3RoZXIgb2JqZWN0Li4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzIGxpc3RlbmluZyB0b1xuICAvLyBmb3IgZWFzaWVyIHVuYmluZGluZyBsYXRlci5cbiAgRXZlbnRzLmxpc3RlblRvID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGlmICghb2JqKSByZXR1cm4gdGhpcztcbiAgICB2YXIgaWQgPSBvYmouX2xpc3RlbklkIHx8IChvYmouX2xpc3RlbklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbyB8fCAodGhpcy5fbGlzdGVuaW5nVG8gPSB7fSk7XG4gICAgdmFyIGxpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkXTtcblxuICAgIC8vIFRoaXMgb2JqZWN0IGlzIG5vdCBsaXN0ZW5pbmcgdG8gYW55IG90aGVyIGV2ZW50cyBvbiBgb2JqYCB5ZXQuXG4gICAgLy8gU2V0dXAgdGhlIG5lY2Vzc2FyeSByZWZlcmVuY2VzIHRvIHRyYWNrIHRoZSBsaXN0ZW5pbmcgY2FsbGJhY2tzLlxuICAgIGlmICghbGlzdGVuaW5nKSB7XG4gICAgICB2YXIgdGhpc0lkID0gdGhpcy5fbGlzdGVuSWQgfHwgKHRoaXMuX2xpc3RlbklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICAgIGxpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkXSA9IHtvYmo6IG9iaiwgb2JqSWQ6IGlkLCBpZDogdGhpc0lkLCBsaXN0ZW5pbmdUbzogbGlzdGVuaW5nVG8sIGNvdW50OiAwfTtcbiAgICB9XG5cbiAgICAvLyBCaW5kIGNhbGxiYWNrcyBvbiBvYmosIGFuZCBrZWVwIHRyYWNrIG9mIHRoZW0gb24gbGlzdGVuaW5nLlxuICAgIGludGVybmFsT24ob2JqLCBuYW1lLCBjYWxsYmFjaywgdGhpcywgbGlzdGVuaW5nKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUaGUgcmVkdWNpbmcgQVBJIHRoYXQgYWRkcyBhIGNhbGxiYWNrIHRvIHRoZSBgZXZlbnRzYCBvYmplY3QuXG4gIHZhciBvbkFwaSA9IGZ1bmN0aW9uKGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXSB8fCAoZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgdmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQsIGN0eCA9IG9wdGlvbnMuY3R4LCBsaXN0ZW5pbmcgPSBvcHRpb25zLmxpc3RlbmluZztcbiAgICAgIGlmIChsaXN0ZW5pbmcpIGxpc3RlbmluZy5jb3VudCsrO1xuXG4gICAgICBoYW5kbGVycy5wdXNoKHtjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGN0eDogY29udGV4dCB8fCBjdHgsIGxpc3RlbmluZzogbGlzdGVuaW5nfSk7XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIG9uZSBvciBtYW55IGNhbGxiYWNrcy4gSWYgYGNvbnRleHRgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxuICAvLyBjYWxsYmFja3MgZm9yIGFsbCBldmVudHMuXG4gIEV2ZW50cy5vZmYgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLl9ldmVudHMgPSBldmVudHNBcGkob2ZmQXBpLCB0aGlzLl9ldmVudHMsIG5hbWUsIGNhbGxiYWNrLCB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgbGlzdGVuZXJzOiB0aGlzLl9saXN0ZW5lcnNcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gIC8vIHRvIGV2ZXJ5IG9iamVjdCBpdCdzIGN1cnJlbnRseSBsaXN0ZW5pbmcgdG8uXG4gIEV2ZW50cy5zdG9wTGlzdGVuaW5nID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvO1xuICAgIGlmICghbGlzdGVuaW5nVG8pIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGlkcyA9IG9iaiA/IFtvYmouX2xpc3RlbklkXSA6IF8ua2V5cyhsaXN0ZW5pbmdUbyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkc1tpXV07XG5cbiAgICAgIC8vIElmIGxpc3RlbmluZyBkb2Vzbid0IGV4aXN0LCB0aGlzIG9iamVjdCBpcyBub3QgY3VycmVudGx5XG4gICAgICAvLyBsaXN0ZW5pbmcgdG8gb2JqLiBCcmVhayBvdXQgZWFybHkuXG4gICAgICBpZiAoIWxpc3RlbmluZykgYnJlYWs7XG5cbiAgICAgIGxpc3RlbmluZy5vYmoub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUaGUgcmVkdWNpbmcgQVBJIHRoYXQgcmVtb3ZlcyBhIGNhbGxiYWNrIGZyb20gdGhlIGBldmVudHNgIG9iamVjdC5cbiAgdmFyIG9mZkFwaSA9IGZ1bmN0aW9uKGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWV2ZW50cykgcmV0dXJuO1xuXG4gICAgdmFyIGkgPSAwLCBsaXN0ZW5pbmc7XG4gICAgdmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQsIGxpc3RlbmVycyA9IG9wdGlvbnMubGlzdGVuZXJzO1xuXG4gICAgLy8gRGVsZXRlIGFsbCBldmVudHMgbGlzdGVuZXJzIGFuZCBcImRyb3BcIiBldmVudHMuXG4gICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgdmFyIGlkcyA9IF8ua2V5cyhsaXN0ZW5lcnMpO1xuICAgICAgZm9yICg7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGlzdGVuaW5nID0gbGlzdGVuZXJzW2lkc1tpXV07XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbbGlzdGVuaW5nLmlkXTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmluZy5saXN0ZW5pbmdUb1tsaXN0ZW5pbmcub2JqSWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBfLmtleXMoZXZlbnRzKTtcbiAgICBmb3IgKDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG5cbiAgICAgIC8vIEJhaWwgb3V0IGlmIHRoZXJlIGFyZSBubyBldmVudHMgc3RvcmVkLlxuICAgICAgaWYgKCFoYW5kbGVycykgYnJlYWs7XG5cbiAgICAgIC8vIFJlcGxhY2UgZXZlbnRzIGlmIHRoZXJlIGFyZSBhbnkgcmVtYWluaW5nLiAgT3RoZXJ3aXNlLCBjbGVhbiB1cC5cbiAgICAgIHZhciByZW1haW5pbmcgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tqXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBoYW5kbGVyLmNhbGxiYWNrICYmXG4gICAgICAgICAgICBjYWxsYmFjayAhPT0gaGFuZGxlci5jYWxsYmFjay5fY2FsbGJhY2sgfHxcbiAgICAgICAgICAgICAgY29udGV4dCAmJiBjb250ZXh0ICE9PSBoYW5kbGVyLmNvbnRleHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVtYWluaW5nLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdGVuaW5nID0gaGFuZGxlci5saXN0ZW5pbmc7XG4gICAgICAgICAgaWYgKGxpc3RlbmluZyAmJiAtLWxpc3RlbmluZy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tsaXN0ZW5pbmcuaWRdO1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmluZy5saXN0ZW5pbmdUb1tsaXN0ZW5pbmcub2JqSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGFpbCBldmVudCBpZiB0aGUgbGlzdCBoYXMgYW55IGV2ZW50cy4gIE90aGVyd2lzZSwgY2xlYW4gdXAuXG4gICAgICBpZiAocmVtYWluaW5nLmxlbmd0aCkge1xuICAgICAgICBldmVudHNbbmFtZV0gPSByZW1haW5pbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgZXZlbnRzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIEJpbmQgYW4gZXZlbnQgdG8gb25seSBiZSB0cmlnZ2VyZWQgYSBzaW5nbGUgdGltZS4gQWZ0ZXIgdGhlIGZpcnN0IHRpbWVcbiAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0cyBsaXN0ZW5lciB3aWxsIGJlIHJlbW92ZWQuIElmIG11bHRpcGxlIGV2ZW50c1xuICAvLyBhcmUgcGFzc2VkIGluIHVzaW5nIHRoZSBzcGFjZS1zZXBhcmF0ZWQgc3ludGF4LCB0aGUgaGFuZGxlciB3aWxsIGZpcmVcbiAgLy8gb25jZSBmb3IgZWFjaCBldmVudCwgbm90IG9uY2UgZm9yIGEgY29tYmluYXRpb24gb2YgYWxsIGV2ZW50cy5cbiAgRXZlbnRzLm9uY2UgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIC8vIE1hcCB0aGUgZXZlbnQgaW50byBhIGB7ZXZlbnQ6IG9uY2V9YCBvYmplY3QuXG4gICAgdmFyIGV2ZW50cyA9IGV2ZW50c0FwaShvbmNlTWFwLCB7fSwgbmFtZSwgY2FsbGJhY2ssIF8uYmluZCh0aGlzLm9mZiwgdGhpcykpO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgY29udGV4dCA9PSBudWxsKSBjYWxsYmFjayA9IHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudHMsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25jZWAuXG4gIEV2ZW50cy5saXN0ZW5Ub09uY2UgPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgLy8gTWFwIHRoZSBldmVudCBpbnRvIGEgYHtldmVudDogb25jZX1gIG9iamVjdC5cbiAgICB2YXIgZXZlbnRzID0gZXZlbnRzQXBpKG9uY2VNYXAsIHt9LCBuYW1lLCBjYWxsYmFjaywgXy5iaW5kKHRoaXMuc3RvcExpc3RlbmluZywgdGhpcywgb2JqKSk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuVG8ob2JqLCBldmVudHMpO1xuICB9O1xuXG4gIC8vIFJlZHVjZXMgdGhlIGV2ZW50IGNhbGxiYWNrcyBpbnRvIGEgbWFwIG9mIGB7ZXZlbnQ6IG9uY2VXcmFwcGVyfWAuXG4gIC8vIGBvZmZlcmAgdW5iaW5kcyB0aGUgYG9uY2VXcmFwcGVyYCBhZnRlciBpdCBoYXMgYmVlbiBjYWxsZWQuXG4gIHZhciBvbmNlTWFwID0gZnVuY3Rpb24obWFwLCBuYW1lLCBjYWxsYmFjaywgb2ZmZXIpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBvbmNlID0gbWFwW25hbWVdID0gXy5vbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICBvZmZlcihuYW1lLCBvbmNlKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgb25jZS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuICAvLyBUcmlnZ2VyIG9uZSBvciBtYW55IGV2ZW50cywgZmlyaW5nIGFsbCBib3VuZCBjYWxsYmFja3MuIENhbGxiYWNrcyBhcmVcbiAgLy8gcGFzc2VkIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBgdHJpZ2dlcmAgaXMsIGFwYXJ0IGZyb20gdGhlIGV2ZW50IG5hbWVcbiAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gIC8vIHJlY2VpdmUgdGhlIHRydWUgbmFtZSBvZiB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50KS5cbiAgRXZlbnRzLnRyaWdnZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG5cbiAgICBldmVudHNBcGkodHJpZ2dlckFwaSwgdGhpcy5fZXZlbnRzLCBuYW1lLCB2b2lkIDAsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEhhbmRsZXMgdHJpZ2dlcmluZyB0aGUgYXBwcm9wcmlhdGUgZXZlbnQgY2FsbGJhY2tzLlxuICB2YXIgdHJpZ2dlckFwaSA9IGZ1bmN0aW9uKG9iakV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICBpZiAob2JqRXZlbnRzKSB7XG4gICAgICB2YXIgZXZlbnRzID0gb2JqRXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IG9iakV2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzICYmIGFsbEV2ZW50cykgYWxsRXZlbnRzID0gYWxsRXZlbnRzLnNsaWNlKCk7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgW25hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmpFdmVudHM7XG4gIH07XG5cbiAgLy8gQSBkaWZmaWN1bHQtdG8tYmVsaWV2ZSwgYnV0IG9wdGltaXplZCBpbnRlcm5hbCBkaXNwYXRjaCBmdW5jdGlvbiBmb3JcbiAgLy8gdHJpZ2dlcmluZyBldmVudHMuIFRyaWVzIHRvIGtlZXAgdGhlIHVzdWFsIGNhc2VzIHNwZWVkeSAobW9zdCBpbnRlcm5hbFxuICAvLyBCYWNrYm9uZSBldmVudHMgaGF2ZSAzIGFyZ3VtZW50cykuXG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24oZXZlbnRzLCBhcmdzKSB7XG4gICAgdmFyIGV2LCBpID0gLTEsIGwgPSBldmVudHMubGVuZ3RoLCBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgpOyByZXR1cm47XG4gICAgICBjYXNlIDE6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSk7IHJldHVybjtcbiAgICAgIGNhc2UgMjogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMik7IHJldHVybjtcbiAgICAgIGNhc2UgMzogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMiwgYTMpOyByZXR1cm47XG4gICAgICBkZWZhdWx0OiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5hcHBseShldi5jdHgsIGFyZ3MpOyByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBFdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAvLyBBbGxvdyB0aGUgYEJhY2tib25lYCBvYmplY3QgdG8gc2VydmUgYXMgYSBnbG9iYWwgZXZlbnQgYnVzLCBmb3IgZm9sa3Mgd2hvXG4gIC8vIHdhbnQgZ2xvYmFsIFwicHVic3ViXCIgaW4gYSBjb252ZW5pZW50IHBsYWNlLlxuICBfLmV4dGVuZChCYWNrYm9uZSwgRXZlbnRzKTtcblxuICAvLyBCYWNrYm9uZS5Nb2RlbFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEJhY2tib25lICoqTW9kZWxzKiogYXJlIHRoZSBiYXNpYyBkYXRhIG9iamVjdCBpbiB0aGUgZnJhbWV3b3JrIC0tXG4gIC8vIGZyZXF1ZW50bHkgcmVwcmVzZW50aW5nIGEgcm93IGluIGEgdGFibGUgaW4gYSBkYXRhYmFzZSBvbiB5b3VyIHNlcnZlci5cbiAgLy8gQSBkaXNjcmV0ZSBjaHVuayBvZiBkYXRhIGFuZCBhIGJ1bmNoIG9mIHVzZWZ1bCwgcmVsYXRlZCBtZXRob2RzIGZvclxuICAvLyBwZXJmb3JtaW5nIGNvbXB1dGF0aW9ucyBhbmQgdHJhbnNmb3JtYXRpb25zIG9uIHRoYXQgZGF0YS5cblxuICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZXMuIEEgY2xpZW50IGlkIChgY2lkYClcbiAgLy8gaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkIGZvciB5b3UuXG4gIHZhciBNb2RlbCA9IEJhY2tib25lLk1vZGVsID0gZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIHZhciBhdHRycyA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB0aGlzLmNpZCA9IF8udW5pcXVlSWQodGhpcy5jaWRQcmVmaXgpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSB0aGlzLnBhcnNlKGF0dHJzLCBvcHRpb25zKSB8fCB7fTtcbiAgICB2YXIgZGVmYXVsdHMgPSBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKTtcbiAgICBhdHRycyA9IF8uZGVmYXVsdHMoXy5leHRlbmQoe30sIGRlZmF1bHRzLCBhdHRycyksIGRlZmF1bHRzKTtcbiAgICB0aGlzLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQXR0YWNoIGFsbCBpbmhlcml0YWJsZSBtZXRob2RzIHRvIHRoZSBNb2RlbCBwcm90b3R5cGUuXG4gIF8uZXh0ZW5kKE1vZGVsLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBBIGhhc2ggb2YgYXR0cmlidXRlcyB3aG9zZSBjdXJyZW50IGFuZCBwcmV2aW91cyB2YWx1ZSBkaWZmZXIuXG4gICAgY2hhbmdlZDogbnVsbCxcblxuICAgIC8vIFRoZSB2YWx1ZSByZXR1cm5lZCBkdXJpbmcgdGhlIGxhc3QgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAgdmFsaWRhdGlvbkVycm9yOiBudWxsLFxuXG4gICAgLy8gVGhlIGRlZmF1bHQgbmFtZSBmb3IgdGhlIEpTT04gYGlkYCBhdHRyaWJ1dGUgaXMgYFwiaWRcImAuIE1vbmdvREIgYW5kXG4gICAgLy8gQ291Y2hEQiB1c2VycyBtYXkgd2FudCB0byBzZXQgdGhpcyB0byBgXCJfaWRcImAuXG4gICAgaWRBdHRyaWJ1dGU6ICdpZCcsXG5cbiAgICAvLyBUaGUgcHJlZml4IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBjbGllbnQgaWQgd2hpY2ggaXMgdXNlZCB0byBpZGVudGlmeSBtb2RlbHMgbG9jYWxseS5cbiAgICAvLyBZb3UgbWF5IHdhbnQgdG8gb3ZlcnJpZGUgdGhpcyBpZiB5b3UncmUgZXhwZXJpZW5jaW5nIG5hbWUgY2xhc2hlcyB3aXRoIG1vZGVsIGlkcy5cbiAgICBjaWRQcmVmaXg6ICdjJyxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG1vZGVsJ3MgYGF0dHJpYnV0ZXNgIG9iamVjdC5cbiAgICB0b0pTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIFByb3h5IGBCYWNrYm9uZS5zeW5jYCBieSBkZWZhdWx0IC0tIGJ1dCBvdmVycmlkZSB0aGlzIGlmIHlvdSBuZWVkXG4gICAgLy8gY3VzdG9tIHN5bmNpbmcgc2VtYW50aWNzIGZvciAqdGhpcyogcGFydGljdWxhciBtb2RlbC5cbiAgICBzeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBCYWNrYm9uZS5zeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlLlxuICAgIGdldDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1thdHRyXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBIVE1MLWVzY2FwZWQgdmFsdWUgb2YgYW4gYXR0cmlidXRlLlxuICAgIGVzY2FwZTogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIF8uZXNjYXBlKHRoaXMuZ2V0KGF0dHIpKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGF0dHJpYnV0ZSBjb250YWlucyBhIHZhbHVlIHRoYXQgaXMgbm90IG51bGxcbiAgICAvLyBvciB1bmRlZmluZWQuXG4gICAgaGFzOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoYXR0cikgIT0gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gU3BlY2lhbC1jYXNlZCBwcm94eSB0byB1bmRlcnNjb3JlJ3MgYF8ubWF0Y2hlc2AgbWV0aG9kLlxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICByZXR1cm4gISFfLml0ZXJhdGVlKGF0dHJzLCB0aGlzKSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gVGhpcyBpc1xuICAgIC8vIHRoZSBjb3JlIHByaW1pdGl2ZSBvcGVyYXRpb24gb2YgYSBtb2RlbCwgdXBkYXRpbmcgdGhlIGRhdGEgYW5kIG5vdGlmeWluZ1xuICAgIC8vIGFueW9uZSB3aG8gbmVlZHMgdG8ga25vdyBhYm91dCB0aGUgY2hhbmdlIGluIHN0YXRlLiBUaGUgaGVhcnQgb2YgdGhlIGJlYXN0LlxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICB2YXIgYXR0cnM7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgLy8gUnVuIHZhbGlkYXRpb24uXG4gICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBFeHRyYWN0IGF0dHJpYnV0ZXMgYW5kIG9wdGlvbnMuXG4gICAgICB2YXIgdW5zZXQgICAgICA9IG9wdGlvbnMudW5zZXQ7XG4gICAgICB2YXIgc2lsZW50ICAgICA9IG9wdGlvbnMuc2lsZW50O1xuICAgICAgdmFyIGNoYW5nZXMgICAgPSBbXTtcbiAgICAgIHZhciBjaGFuZ2luZyAgID0gdGhpcy5fY2hhbmdpbmc7XG4gICAgICB0aGlzLl9jaGFuZ2luZyA9IHRydWU7XG5cbiAgICAgIGlmICghY2hhbmdpbmcpIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzID0gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICB2YXIgY2hhbmdlZCA9IHRoaXMuY2hhbmdlZDtcbiAgICAgIHZhciBwcmV2ICAgID0gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzO1xuXG4gICAgICAvLyBGb3IgZWFjaCBgc2V0YCBhdHRyaWJ1dGUsIHVwZGF0ZSBvciBkZWxldGUgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgIHZhbCA9IGF0dHJzW2F0dHJdO1xuICAgICAgICBpZiAoIV8uaXNFcXVhbChjdXJyZW50W2F0dHJdLCB2YWwpKSBjaGFuZ2VzLnB1c2goYXR0cik7XG4gICAgICAgIGlmICghXy5pc0VxdWFsKHByZXZbYXR0cl0sIHZhbCkpIHtcbiAgICAgICAgICBjaGFuZ2VkW2F0dHJdID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBjaGFuZ2VkW2F0dHJdO1xuICAgICAgICB9XG4gICAgICAgIHVuc2V0ID8gZGVsZXRlIGN1cnJlbnRbYXR0cl0gOiBjdXJyZW50W2F0dHJdID0gdmFsO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIGBpZGAuXG4gICAgICBpZiAodGhpcy5pZEF0dHJpYnV0ZSBpbiBhdHRycykgdGhpcy5pZCA9IHRoaXMuZ2V0KHRoaXMuaWRBdHRyaWJ1dGUpO1xuXG4gICAgICAvLyBUcmlnZ2VyIGFsbCByZWxldmFudCBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkgdGhpcy5fcGVuZGluZyA9IG9wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBjaGFuZ2VzW2ldLCB0aGlzLCBjdXJyZW50W2NoYW5nZXNbaV1dLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBZb3UgbWlnaHQgYmUgd29uZGVyaW5nIHdoeSB0aGVyZSdzIGEgYHdoaWxlYCBsb29wIGhlcmUuIENoYW5nZXMgY2FuXG4gICAgICAvLyBiZSByZWN1cnNpdmVseSBuZXN0ZWQgd2l0aGluIGBcImNoYW5nZVwiYCBldmVudHMuXG4gICAgICBpZiAoY2hhbmdpbmcpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5fcGVuZGluZztcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBgdW5zZXRgIGlzIGEgbm9vcFxuICAgIC8vIGlmIHRoZSBhdHRyaWJ1dGUgZG9lc24ndCBleGlzdC5cbiAgICB1bnNldDogZnVuY3Rpb24oYXR0ciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIHZvaWQgMCwgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXIgYWxsIGF0dHJpYnV0ZXMgb24gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLlxuICAgIGNsZWFyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIGF0dHJzW2tleV0gPSB2b2lkIDA7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cnMsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgbW9kZWwgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIC8vIElmIHlvdSBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBuYW1lLCBkZXRlcm1pbmUgaWYgdGhhdCBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQuXG4gICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCkgcmV0dXJuICFfLmlzRW1wdHkodGhpcy5jaGFuZ2VkKTtcbiAgICAgIHJldHVybiBfLmhhcyh0aGlzLmNoYW5nZWQsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBjaGFuZ2VkLCBvclxuICAgIC8vIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VkIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hhdFxuICAgIC8vIHBhcnRzIG9mIGEgdmlldyBuZWVkIHRvIGJlIHVwZGF0ZWQgYW5kL29yIHdoYXQgYXR0cmlidXRlcyBuZWVkIHRvIGJlXG4gICAgLy8gcGVyc2lzdGVkIHRvIHRoZSBzZXJ2ZXIuIFVuc2V0IGF0dHJpYnV0ZXMgd2lsbCBiZSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRvIGRpZmYgYWdhaW5zdCB0aGUgbW9kZWwsXG4gICAgLy8gZGV0ZXJtaW5pbmcgaWYgdGhlcmUgKndvdWxkIGJlKiBhIGNoYW5nZS5cbiAgICBjaGFuZ2VkQXR0cmlidXRlczogZnVuY3Rpb24oZGlmZikge1xuICAgICAgaWYgKCFkaWZmKSByZXR1cm4gdGhpcy5oYXNDaGFuZ2VkKCkgPyBfLmNsb25lKHRoaXMuY2hhbmdlZCkgOiBmYWxzZTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLl9jaGFuZ2luZyA/IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA6IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIHZhciBjaGFuZ2VkID0ge307XG4gICAgICBmb3IgKHZhciBhdHRyIGluIGRpZmYpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRpZmZbYXR0cl07XG4gICAgICAgIGlmIChfLmlzRXF1YWwob2xkW2F0dHJdLCB2YWwpKSBjb250aW51ZTtcbiAgICAgICAgY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfLnNpemUoY2hhbmdlZCkgPyBjaGFuZ2VkIDogZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgcHJldmlvdXMgdmFsdWUgb2YgYW4gYXR0cmlidXRlLCByZWNvcmRlZCBhdCB0aGUgdGltZSB0aGUgbGFzdFxuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudCB3YXMgZmlyZWQuXG4gICAgcHJldmlvdXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChhdHRyID09IG51bGwgfHwgIXRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYWxsIG9mIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtb2RlbCBhdCB0aGUgdGltZSBvZiB0aGUgcHJldmlvdXNcbiAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgcHJldmlvdXNBdHRyaWJ1dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIEZldGNoIHRoZSBtb2RlbCBmcm9tIHRoZSBzZXJ2ZXIsIG1lcmdpbmcgdGhlIHJlc3BvbnNlIHdpdGggdGhlIG1vZGVsJ3NcbiAgICAvLyBsb2NhbCBhdHRyaWJ1dGVzLiBBbnkgY2hhbmdlZCBhdHRyaWJ1dGVzIHdpbGwgdHJpZ2dlciBhIFwiY2hhbmdlXCIgZXZlbnQuXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7cGFyc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gb3B0aW9ucy5wYXJzZSA/IG1vZGVsLnBhcnNlKHJlc3AsIG9wdGlvbnMpIDogcmVzcDtcbiAgICAgICAgaWYgKCFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMsIGFuZCBzeW5jIHRoZSBtb2RlbCB0byB0aGUgc2VydmVyLlxuICAgIC8vIElmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhbiBhdHRyaWJ1dGVzIGhhc2ggdGhhdCBkaWZmZXJzLCB0aGUgbW9kZWwnc1xuICAgIC8vIHN0YXRlIHdpbGwgYmUgYHNldGAgYWdhaW4uXG4gICAgc2F2ZTogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICB2YXIgYXR0cnM7XG4gICAgICBpZiAoa2V5ID09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt2YWxpZGF0ZTogdHJ1ZSwgcGFyc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgICAgIHZhciB3YWl0ID0gb3B0aW9ucy53YWl0O1xuXG4gICAgICAvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBhbmQgYXR0cmlidXRlcyBleGlzdCwgc2F2ZSBhY3RzIGFzXG4gICAgICAvLyBgc2V0KGF0dHIpLnNhdmUobnVsbCwgb3B0cylgIHdpdGggdmFsaWRhdGlvbi4gT3RoZXJ3aXNlLCBjaGVjayBpZlxuICAgICAgLy8gdGhlIG1vZGVsIHdpbGwgYmUgdmFsaWQgd2hlbiB0aGUgYXR0cmlidXRlcywgaWYgYW55LCBhcmUgc2V0LlxuICAgICAgaWYgKGF0dHJzICYmICF3YWl0KSB7XG4gICAgICAgIGlmICghdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBBZnRlciBhIHN1Y2Nlc3NmdWwgc2VydmVyLXNpZGUgc2F2ZSwgdGhlIGNsaWVudCBpcyAob3B0aW9uYWxseSlcbiAgICAgIC8vIHVwZGF0ZWQgd2l0aCB0aGUgc2VydmVyLXNpZGUgc3RhdGUuXG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgLy8gRW5zdXJlIGF0dHJpYnV0ZXMgYXJlIHJlc3RvcmVkIGR1cmluZyBzeW5jaHJvbm91cyBzYXZlcy5cbiAgICAgICAgbW9kZWwuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBzZXJ2ZXJBdHRycyA9IG9wdGlvbnMucGFyc2UgPyBtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKSA6IHJlc3A7XG4gICAgICAgIGlmICh3YWl0KSBzZXJ2ZXJBdHRycyA9IF8uZXh0ZW5kKHt9LCBhdHRycywgc2VydmVyQXR0cnMpO1xuICAgICAgICBpZiAoc2VydmVyQXR0cnMgJiYgIW1vZGVsLnNldChzZXJ2ZXJBdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFNldCB0ZW1wb3JhcnkgYXR0cmlidXRlcyBpZiBge3dhaXQ6IHRydWV9YCB0byBwcm9wZXJseSBmaW5kIG5ldyBpZHMuXG4gICAgICBpZiAoYXR0cnMgJiYgd2FpdCkgdGhpcy5hdHRyaWJ1dGVzID0gXy5leHRlbmQoe30sIGF0dHJpYnV0ZXMsIGF0dHJzKTtcblxuICAgICAgdmFyIG1ldGhvZCA9IHRoaXMuaXNOZXcoKSA/ICdjcmVhdGUnIDogKG9wdGlvbnMucGF0Y2ggPyAncGF0Y2gnIDogJ3VwZGF0ZScpO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJyAmJiAhb3B0aW9ucy5hdHRycykgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xuICAgICAgdmFyIHhociA9IHRoaXMuc3luYyhtZXRob2QsIHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBSZXN0b3JlIGF0dHJpYnV0ZXMuXG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gICAgICByZXR1cm4geGhyO1xuICAgIH0sXG5cbiAgICAvLyBEZXN0cm95IHRoaXMgbW9kZWwgb24gdGhlIHNlcnZlciBpZiBpdCB3YXMgYWxyZWFkeSBwZXJzaXN0ZWQuXG4gICAgLy8gT3B0aW1pc3RpY2FsbHkgcmVtb3ZlcyB0aGUgbW9kZWwgZnJvbSBpdHMgY29sbGVjdGlvbiwgaWYgaXQgaGFzIG9uZS5cbiAgICAvLyBJZiBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCB3YWl0cyBmb3IgdGhlIHNlcnZlciB0byByZXNwb25kIGJlZm9yZSByZW1vdmFsLlxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG5cbiAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGVsLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignZGVzdHJveScsIG1vZGVsLCBtb2RlbC5jb2xsZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgaWYgKHdhaXQpIGRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFtb2RlbC5pc05ldygpKSBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHhociA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkge1xuICAgICAgICBfLmRlZmVyKG9wdGlvbnMuc3VjY2Vzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHhociA9IHRoaXMuc3luYygnZGVsZXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIXdhaXQpIGRlc3Ryb3koKTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlZmF1bHQgVVJMIGZvciB0aGUgbW9kZWwncyByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2VydmVyIC0tIGlmIHlvdSdyZVxuICAgIC8vIHVzaW5nIEJhY2tib25lJ3MgcmVzdGZ1bCBtZXRob2RzLCBvdmVycmlkZSB0aGlzIHRvIGNoYW5nZSB0aGUgZW5kcG9pbnRcbiAgICAvLyB0aGF0IHdpbGwgYmUgY2FsbGVkLlxuICAgIHVybDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmFzZSA9XG4gICAgICAgIF8ucmVzdWx0KHRoaXMsICd1cmxSb290JykgfHxcbiAgICAgICAgXy5yZXN1bHQodGhpcy5jb2xsZWN0aW9uLCAndXJsJykgfHxcbiAgICAgICAgdXJsRXJyb3IoKTtcbiAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHJldHVybiBiYXNlO1xuICAgICAgdmFyIGlkID0gdGhpcy5nZXQodGhpcy5pZEF0dHJpYnV0ZSk7XG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKTtcbiAgICB9LFxuXG4gICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byB0aGUgaGFzaCBvZiBhdHRyaWJ1dGVzIHRvIGJlIGBzZXRgIG9uXG4gICAgLy8gdGhlIG1vZGVsLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgdGhlIHJlc3BvbnNlIGFsb25nLlxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1vZGVsIHdpdGggaWRlbnRpY2FsIGF0dHJpYnV0ZXMgdG8gdGhpcyBvbmUuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIEEgbW9kZWwgaXMgbmV3IGlmIGl0IGhhcyBuZXZlciBiZWVuIHNhdmVkIHRvIHRoZSBzZXJ2ZXIsIGFuZCBsYWNrcyBhbiBpZC5cbiAgICBpc05ldzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaGFzKHRoaXMuaWRBdHRyaWJ1dGUpO1xuICAgIH0sXG5cbiAgICAvLyBDaGVjayBpZiB0aGUgbW9kZWwgaXMgY3VycmVudGx5IGluIGEgdmFsaWQgc3RhdGUuXG4gICAgaXNWYWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlKHt9LCBfLmV4dGVuZCh7fSwgb3B0aW9ucywge3ZhbGlkYXRlOiB0cnVlfSkpO1xuICAgIH0sXG5cbiAgICAvLyBSdW4gdmFsaWRhdGlvbiBhZ2FpbnN0IHRoZSBuZXh0IGNvbXBsZXRlIHNldCBvZiBtb2RlbCBhdHRyaWJ1dGVzLFxuICAgIC8vIHJldHVybmluZyBgdHJ1ZWAgaWYgYWxsIGlzIHdlbGwuIE90aGVyd2lzZSwgZmlyZSBhbiBgXCJpbnZhbGlkXCJgIGV2ZW50LlxuICAgIF92YWxpZGF0ZTogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucy52YWxpZGF0ZSB8fCAhdGhpcy52YWxpZGF0ZSkgcmV0dXJuIHRydWU7XG4gICAgICBhdHRycyA9IF8uZXh0ZW5kKHt9LCB0aGlzLmF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICAgIHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGlvbkVycm9yID0gdGhpcy52YWxpZGF0ZShhdHRycywgb3B0aW9ucykgfHwgbnVsbDtcbiAgICAgIGlmICghZXJyb3IpIHJldHVybiB0cnVlO1xuICAgICAgdGhpcy50cmlnZ2VyKCdpbnZhbGlkJywgdGhpcywgZXJyb3IsIF8uZXh0ZW5kKG9wdGlvbnMsIHt2YWxpZGF0aW9uRXJyb3I6IGVycm9yfSkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB3ZSB3YW50IHRvIGltcGxlbWVudCBvbiB0aGUgTW9kZWwsIG1hcHBlZCB0byB0aGVcbiAgLy8gbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGV5IHRha2UuXG4gIHZhciBtb2RlbE1ldGhvZHMgPSB7a2V5czogMSwgdmFsdWVzOiAxLCBwYWlyczogMSwgaW52ZXJ0OiAxLCBwaWNrOiAwLFxuICAgICAgb21pdDogMCwgY2hhaW46IDEsIGlzRW1wdHk6IDF9O1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYE1vZGVsI2F0dHJpYnV0ZXNgLlxuICBhZGRVbmRlcnNjb3JlTWV0aG9kcyhNb2RlbCwgbW9kZWxNZXRob2RzLCAnYXR0cmlidXRlcycpO1xuXG4gIC8vIEJhY2tib25lLkNvbGxlY3Rpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIElmIG1vZGVscyB0ZW5kIHRvIHJlcHJlc2VudCBhIHNpbmdsZSByb3cgb2YgZGF0YSwgYSBCYWNrYm9uZSBDb2xsZWN0aW9uIGlzXG4gIC8vIG1vcmUgYW5hbG9nb3VzIHRvIGEgdGFibGUgZnVsbCBvZiBkYXRhIC4uLiBvciBhIHNtYWxsIHNsaWNlIG9yIHBhZ2Ugb2YgdGhhdFxuICAvLyB0YWJsZSwgb3IgYSBjb2xsZWN0aW9uIG9mIHJvd3MgdGhhdCBiZWxvbmcgdG9nZXRoZXIgZm9yIGEgcGFydGljdWxhciByZWFzb25cbiAgLy8gLS0gYWxsIG9mIHRoZSBtZXNzYWdlcyBpbiB0aGlzIHBhcnRpY3VsYXIgZm9sZGVyLCBhbGwgb2YgdGhlIGRvY3VtZW50c1xuICAvLyBiZWxvbmdpbmcgdG8gdGhpcyBwYXJ0aWN1bGFyIGF1dGhvciwgYW5kIHNvIG9uLiBDb2xsZWN0aW9ucyBtYWludGFpblxuICAvLyBpbmRleGVzIG9mIHRoZWlyIG1vZGVscywgYm90aCBpbiBvcmRlciwgYW5kIGZvciBsb29rdXAgYnkgYGlkYC5cblxuICAvLyBDcmVhdGUgYSBuZXcgKipDb2xsZWN0aW9uKiosIHBlcmhhcHMgdG8gY29udGFpbiBhIHNwZWNpZmljIHR5cGUgb2YgYG1vZGVsYC5cbiAgLy8gSWYgYSBgY29tcGFyYXRvcmAgaXMgc3BlY2lmaWVkLCB0aGUgQ29sbGVjdGlvbiB3aWxsIG1haW50YWluXG4gIC8vIGl0cyBtb2RlbHMgaW4gc29ydCBvcmRlciwgYXMgdGhleSdyZSBhZGRlZCBhbmQgcmVtb3ZlZC5cbiAgdmFyIENvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uID0gZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICBpZiAob3B0aW9ucy5tb2RlbCkgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyYXRvciAhPT0gdm9pZCAwKSB0aGlzLmNvbXBhcmF0b3IgPSBvcHRpb25zLmNvbXBhcmF0b3I7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAobW9kZWxzKSB0aGlzLnJlc2V0KG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgfTtcblxuICAvLyBEZWZhdWx0IG9wdGlvbnMgZm9yIGBDb2xsZWN0aW9uI3NldGAuXG4gIHZhciBzZXRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiB0cnVlLCBtZXJnZTogdHJ1ZX07XG4gIHZhciBhZGRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiBmYWxzZX07XG5cbiAgLy8gU3BsaWNlcyBgaW5zZXJ0YCBpbnRvIGBhcnJheWAgYXQgaW5kZXggYGF0YC5cbiAgdmFyIHNwbGljZSA9IGZ1bmN0aW9uKGFycmF5LCBpbnNlcnQsIGF0KSB7XG4gICAgYXQgPSBNYXRoLm1pbihNYXRoLm1heChhdCwgMCksIGFycmF5Lmxlbmd0aCk7XG4gICAgdmFyIHRhaWwgPSBBcnJheShhcnJheS5sZW5ndGggLSBhdCk7XG4gICAgdmFyIGxlbmd0aCA9IGluc2VydC5sZW5ndGg7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRhaWwubGVuZ3RoOyBpKyspIHRhaWxbaV0gPSBhcnJheVtpICsgYXRdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJyYXlbaSArIGF0XSA9IGluc2VydFtpXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFpbC5sZW5ndGg7IGkrKykgYXJyYXlbaSArIGxlbmd0aCArIGF0XSA9IHRhaWxbaV07XG4gIH07XG5cbiAgLy8gRGVmaW5lIHRoZSBDb2xsZWN0aW9uJ3MgaW5oZXJpdGFibGUgbWV0aG9kcy5cbiAgXy5leHRlbmQoQ29sbGVjdGlvbi5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gVGhlIGRlZmF1bHQgbW9kZWwgZm9yIGEgY29sbGVjdGlvbiBpcyBqdXN0IGEgKipCYWNrYm9uZS5Nb2RlbCoqLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIG92ZXJyaWRkZW4gaW4gbW9zdCBjYXNlcy5cbiAgICBtb2RlbDogTW9kZWwsXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIENvbGxlY3Rpb24gaXMgYW4gYXJyYXkgb2YgdGhlXG4gICAgLy8gbW9kZWxzJyBhdHRyaWJ1dGVzLlxuICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKG1vZGVsKSB7IHJldHVybiBtb2RlbC50b0pTT04ob3B0aW9ucyk7IH0pO1xuICAgIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdC5cbiAgICBzeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBCYWNrYm9uZS5zeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsLCBvciBsaXN0IG9mIG1vZGVscyB0byB0aGUgc2V0LiBgbW9kZWxzYCBtYXkgYmUgQmFja2JvbmVcbiAgICAvLyBNb2RlbHMgb3IgcmF3IEphdmFTY3JpcHQgb2JqZWN0cyB0byBiZSBjb252ZXJ0ZWQgdG8gTW9kZWxzLCBvciBhbnlcbiAgICAvLyBjb21iaW5hdGlvbiBvZiB0aGUgdHdvLlxuICAgIGFkZDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQobW9kZWxzLCBfLmV4dGVuZCh7bWVyZ2U6IGZhbHNlfSwgb3B0aW9ucywgYWRkT3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCwgb3IgYSBsaXN0IG9mIG1vZGVscyBmcm9tIHRoZSBzZXQuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IFttb2RlbHNdIDogbW9kZWxzLnNsaWNlKCk7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuX3JlbW92ZU1vZGVscyhtb2RlbHMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCAmJiByZW1vdmVkLmxlbmd0aCkge1xuICAgICAgICBvcHRpb25zLmNoYW5nZXMgPSB7YWRkZWQ6IFtdLCBtZXJnZWQ6IFtdLCByZW1vdmVkOiByZW1vdmVkfTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaW5ndWxhciA/IHJlbW92ZWRbMF0gOiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgYSBjb2xsZWN0aW9uIGJ5IGBzZXRgLWluZyBhIG5ldyBsaXN0IG9mIG1vZGVscywgYWRkaW5nIG5ldyBvbmVzLFxuICAgIC8vIHJlbW92aW5nIG1vZGVscyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudCwgYW5kIG1lcmdpbmcgbW9kZWxzIHRoYXRcbiAgICAvLyBhbHJlYWR5IGV4aXN0IGluIHRoZSBjb2xsZWN0aW9uLCBhcyBuZWNlc3NhcnkuIFNpbWlsYXIgdG8gKipNb2RlbCNzZXQqKixcbiAgICAvLyB0aGUgY29yZSBvcGVyYXRpb24gZm9yIHVwZGF0aW5nIHRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgY29sbGVjdGlvbi5cbiAgICBzZXQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgaWYgKG1vZGVscyA9PSBudWxsKSByZXR1cm47XG5cbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgc2V0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5wYXJzZSAmJiAhdGhpcy5faXNNb2RlbChtb2RlbHMpKSB7XG4gICAgICAgIG1vZGVscyA9IHRoaXMucGFyc2UobW9kZWxzLCBvcHRpb25zKSB8fCBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpbmd1bGFyID0gIV8uaXNBcnJheShtb2RlbHMpO1xuICAgICAgbW9kZWxzID0gc2luZ3VsYXIgPyBbbW9kZWxzXSA6IG1vZGVscy5zbGljZSgpO1xuXG4gICAgICB2YXIgYXQgPSBvcHRpb25zLmF0O1xuICAgICAgaWYgKGF0ICE9IG51bGwpIGF0ID0gK2F0O1xuICAgICAgaWYgKGF0ID4gdGhpcy5sZW5ndGgpIGF0ID0gdGhpcy5sZW5ndGg7XG4gICAgICBpZiAoYXQgPCAwKSBhdCArPSB0aGlzLmxlbmd0aCArIDE7XG5cbiAgICAgIHZhciBzZXQgPSBbXTtcbiAgICAgIHZhciB0b0FkZCA9IFtdO1xuICAgICAgdmFyIHRvTWVyZ2UgPSBbXTtcbiAgICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuICAgICAgdmFyIG1vZGVsTWFwID0ge307XG5cbiAgICAgIHZhciBhZGQgPSBvcHRpb25zLmFkZDtcbiAgICAgIHZhciBtZXJnZSA9IG9wdGlvbnMubWVyZ2U7XG4gICAgICB2YXIgcmVtb3ZlID0gb3B0aW9ucy5yZW1vdmU7XG5cbiAgICAgIHZhciBzb3J0ID0gZmFsc2U7XG4gICAgICB2YXIgc29ydGFibGUgPSB0aGlzLmNvbXBhcmF0b3IgJiYgYXQgPT0gbnVsbCAmJiBvcHRpb25zLnNvcnQgIT09IGZhbHNlO1xuICAgICAgdmFyIHNvcnRBdHRyID0gXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpID8gdGhpcy5jb21wYXJhdG9yIDogbnVsbDtcblxuICAgICAgLy8gVHVybiBiYXJlIG9iamVjdHMgaW50byBtb2RlbCByZWZlcmVuY2VzLCBhbmQgcHJldmVudCBpbnZhbGlkIG1vZGVsc1xuICAgICAgLy8gZnJvbSBiZWluZyBhZGRlZC5cbiAgICAgIHZhciBtb2RlbCwgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW9kZWwgPSBtb2RlbHNbaV07XG5cbiAgICAgICAgLy8gSWYgYSBkdXBsaWNhdGUgaXMgZm91bmQsIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZGRlZCBhbmRcbiAgICAgICAgLy8gb3B0aW9uYWxseSBtZXJnZSBpdCBpbnRvIHRoZSBleGlzdGluZyBtb2RlbC5cbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQobW9kZWwpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICBpZiAobWVyZ2UgJiYgbW9kZWwgIT09IGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB0aGlzLl9pc01vZGVsKG1vZGVsKSA/IG1vZGVsLmF0dHJpYnV0ZXMgOiBtb2RlbDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlKSBhdHRycyA9IGV4aXN0aW5nLnBhcnNlKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGV4aXN0aW5nLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0b01lcmdlLnB1c2goZXhpc3RpbmcpO1xuICAgICAgICAgICAgaWYgKHNvcnRhYmxlICYmICFzb3J0KSBzb3J0ID0gZXhpc3RpbmcuaGFzQ2hhbmdlZChzb3J0QXR0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSkge1xuICAgICAgICAgICAgbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSA9IHRydWU7XG4gICAgICAgICAgICBzZXQucHVzaChleGlzdGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGVsc1tpXSA9IGV4aXN0aW5nO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBuZXcsIHZhbGlkIG1vZGVsLCBwdXNoIGl0IHRvIHRoZSBgdG9BZGRgIGxpc3QuXG4gICAgICAgIH0gZWxzZSBpZiAoYWRkKSB7XG4gICAgICAgICAgbW9kZWwgPSBtb2RlbHNbaV0gPSB0aGlzLl9wcmVwYXJlTW9kZWwobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgdG9BZGQucHVzaChtb2RlbCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgbW9kZWxNYXBbbW9kZWwuY2lkXSA9IHRydWU7XG4gICAgICAgICAgICBzZXQucHVzaChtb2RlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBzdGFsZSBtb2RlbHMuXG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsc1tpXTtcbiAgICAgICAgICBpZiAoIW1vZGVsTWFwW21vZGVsLmNpZF0pIHRvUmVtb3ZlLnB1c2gobW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JlbW92ZS5sZW5ndGgpIHRoaXMuX3JlbW92ZU1vZGVscyh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cbiAgICAgIHZhciBvcmRlckNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciByZXBsYWNlID0gIXNvcnRhYmxlICYmIGFkZCAmJiByZW1vdmU7XG4gICAgICBpZiAoc2V0Lmxlbmd0aCAmJiByZXBsYWNlKSB7XG4gICAgICAgIG9yZGVyQ2hhbmdlZCA9IHRoaXMubGVuZ3RoICE9PSBzZXQubGVuZ3RoIHx8IF8uc29tZSh0aGlzLm1vZGVscywgZnVuY3Rpb24obSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbSAhPT0gc2V0W2luZGV4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWxzLmxlbmd0aCA9IDA7XG4gICAgICAgIHNwbGljZSh0aGlzLm1vZGVscywgc2V0LCAwKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLm1vZGVscy5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKHRvQWRkLmxlbmd0aCkge1xuICAgICAgICBpZiAoc29ydGFibGUpIHNvcnQgPSB0cnVlO1xuICAgICAgICBzcGxpY2UodGhpcy5tb2RlbHMsIHRvQWRkLCBhdCA9PSBudWxsID8gdGhpcy5sZW5ndGggOiBhdCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5tb2RlbHMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBTaWxlbnRseSBzb3J0IHRoZSBjb2xsZWN0aW9uIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgaWYgKHNvcnQpIHRoaXMuc29ydCh7c2lsZW50OiB0cnVlfSk7XG5cbiAgICAgIC8vIFVubGVzcyBzaWxlbmNlZCwgaXQncyB0aW1lIHRvIGZpcmUgYWxsIGFwcHJvcHJpYXRlIGFkZC9zb3J0L3VwZGF0ZSBldmVudHMuXG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhdCAhPSBudWxsKSBvcHRpb25zLmluZGV4ID0gYXQgKyBpO1xuICAgICAgICAgIG1vZGVsID0gdG9BZGRbaV07XG4gICAgICAgICAgbW9kZWwudHJpZ2dlcignYWRkJywgbW9kZWwsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3J0IHx8IG9yZGVyQ2hhbmdlZCkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0b0FkZC5sZW5ndGggfHwgdG9SZW1vdmUubGVuZ3RoIHx8IHRvTWVyZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFuZ2VzID0ge1xuICAgICAgICAgICAgYWRkZWQ6IHRvQWRkLFxuICAgICAgICAgICAgcmVtb3ZlZDogdG9SZW1vdmUsXG4gICAgICAgICAgICBtZXJnZWQ6IHRvTWVyZ2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMudHJpZ2dlcigndXBkYXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHRoZSBhZGRlZCAob3IgbWVyZ2VkKSBtb2RlbCAob3IgbW9kZWxzKS5cbiAgICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gV2hlbiB5b3UgaGF2ZSBtb3JlIGl0ZW1zIHRoYW4geW91IHdhbnQgdG8gYWRkIG9yIHJlbW92ZSBpbmRpdmlkdWFsbHksXG4gICAgLy8geW91IGNhbiByZXNldCB0aGUgZW50aXJlIHNldCB3aXRoIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCB3aXRob3V0IGZpcmluZ1xuICAgIC8vIGFueSBncmFudWxhciBgYWRkYCBvciBgcmVtb3ZlYCBldmVudHMuIEZpcmVzIGByZXNldGAgd2hlbiBmaW5pc2hlZC5cbiAgICAvLyBVc2VmdWwgZm9yIGJ1bGsgb3BlcmF0aW9ucyBhbmQgb3B0aW1pemF0aW9ucy5cbiAgICByZXNldDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKHRoaXMubW9kZWxzW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMucHJldmlvdXNNb2RlbHMgPSB0aGlzLm1vZGVscztcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICBtb2RlbHMgPSB0aGlzLmFkZChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3Jlc2V0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHB1c2g6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogdGhpcy5sZW5ndGh9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBwb3A6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQodGhpcy5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgdW5zaGlmdDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiAwfSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQoMCk7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBTbGljZSBvdXQgYSBzdWItYXJyYXkgb2YgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmFwcGx5KHRoaXMubW9kZWxzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQsIGNpZCwgbW9kZWwgb2JqZWN0IHdpdGggaWQgb3IgY2lkXG4gICAgLy8gcHJvcGVydGllcywgb3IgYW4gYXR0cmlidXRlcyBvYmplY3QgdGhhdCBpcyB0cmFuc2Zvcm1lZCB0aHJvdWdoIG1vZGVsSWQuXG4gICAgZ2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHJldHVybiB0aGlzLl9ieUlkW29ial0gfHxcbiAgICAgICAgdGhpcy5fYnlJZFt0aGlzLm1vZGVsSWQob2JqLmF0dHJpYnV0ZXMgfHwgb2JqKV0gfHxcbiAgICAgICAgb2JqLmNpZCAmJiB0aGlzLl9ieUlkW29iai5jaWRdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgbW9kZWwgaXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgaGFzOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChvYmopICE9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgbW9kZWwgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggKz0gdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbHNbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gbW9kZWxzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXMgb2ZcbiAgICAvLyBgZmlsdGVyYC5cbiAgICB3aGVyZTogZnVuY3Rpb24oYXR0cnMsIGZpcnN0KSB7XG4gICAgICByZXR1cm4gdGhpc1tmaXJzdCA/ICdmaW5kJyA6ICdmaWx0ZXInXShhdHRycyk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0aGUgZmlyc3QgbW9kZWwgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIHNpbXBsZSBjYXNlc1xuICAgIC8vIG9mIGBmaW5kYC5cbiAgICBmaW5kV2hlcmU6IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICByZXR1cm4gdGhpcy53aGVyZShhdHRycywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8vIEZvcmNlIHRoZSBjb2xsZWN0aW9uIHRvIHJlLXNvcnQgaXRzZWxmLiBZb3UgZG9uJ3QgbmVlZCB0byBjYWxsIHRoaXMgdW5kZXJcbiAgICAvLyBub3JtYWwgY2lyY3Vtc3RhbmNlcywgYXMgdGhlIHNldCB3aWxsIG1haW50YWluIHNvcnQgb3JkZXIgYXMgZWFjaCBpdGVtXG4gICAgLy8gaXMgYWRkZWQuXG4gICAgc29ydDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLmNvbXBhcmF0b3I7XG4gICAgICBpZiAoIWNvbXBhcmF0b3IpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNvcnQgYSBzZXQgd2l0aG91dCBhIGNvbXBhcmF0b3InKTtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb21wYXJhdG9yLmxlbmd0aDtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oY29tcGFyYXRvcikpIGNvbXBhcmF0b3IgPSBfLmJpbmQoY29tcGFyYXRvciwgdGhpcyk7XG5cbiAgICAgIC8vIFJ1biBzb3J0IGJhc2VkIG9uIHR5cGUgb2YgYGNvbXBhcmF0b3JgLlxuICAgICAgaWYgKGxlbmd0aCA9PT0gMSB8fCBfLmlzU3RyaW5nKGNvbXBhcmF0b3IpKSB7XG4gICAgICAgIHRoaXMubW9kZWxzID0gdGhpcy5zb3J0QnkoY29tcGFyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vZGVscy5zb3J0KGNvbXBhcmF0b3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUGx1Y2sgYW4gYXR0cmlidXRlIGZyb20gZWFjaCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBwbHVjazogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGF0dHIgKyAnJyk7XG4gICAgfSxcblxuICAgIC8vIEZldGNoIHRoZSBkZWZhdWx0IHNldCBvZiBtb2RlbHMgZm9yIHRoaXMgY29sbGVjdGlvbiwgcmVzZXR0aW5nIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gd2hlbiB0aGV5IGFycml2ZS4gSWYgYHJlc2V0OiB0cnVlYCBpcyBwYXNzZWQsIHRoZSByZXNwb25zZVxuICAgIC8vIGRhdGEgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgYHJlc2V0YCBtZXRob2QgaW5zdGVhZCBvZiBgc2V0YC5cbiAgICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtwYXJzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvcHRpb25zLnJlc2V0ID8gJ3Jlc2V0JyA6ICdzZXQnO1xuICAgICAgICBjb2xsZWN0aW9uW21ldGhvZF0ocmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0LCBjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgY29sbGVjdGlvbi50cmlnZ2VyKCdzeW5jJywgY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBtb2RlbCBpbiB0aGlzIGNvbGxlY3Rpb24uIEFkZCB0aGUgbW9kZWwgdG8gdGhlXG4gICAgLy8gY29sbGVjdGlvbiBpbW1lZGlhdGVseSwgdW5sZXNzIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAvLyB3YWl0IGZvciB0aGUgc2VydmVyIHRvIGFncmVlLlxuICAgIGNyZWF0ZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG4gICAgICBtb2RlbCA9IHRoaXMuX3ByZXBhcmVNb2RlbChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoIW1vZGVsKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIXdhaXQpIHRoaXMuYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24obSwgcmVzcCwgY2FsbGJhY2tPcHRzKSB7XG4gICAgICAgIGlmICh3YWl0KSBjb2xsZWN0aW9uLmFkZChtLCBjYWxsYmFja09wdHMpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcy5jYWxsKGNhbGxiYWNrT3B0cy5jb250ZXh0LCBtLCByZXNwLCBjYWxsYmFja09wdHMpO1xuICAgICAgfTtcbiAgICAgIG1vZGVsLnNhdmUobnVsbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gYSBsaXN0IG9mIG1vZGVscyB0byBiZSBhZGRlZCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgaXQgdGhyb3VnaC5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHdpdGggYW4gaWRlbnRpY2FsIGxpc3Qgb2YgbW9kZWxzIGFzIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm1vZGVscywge1xuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgY29tcGFyYXRvcjogdGhpcy5jb21wYXJhdG9yXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gRGVmaW5lIGhvdyB0byB1bmlxdWVseSBpZGVudGlmeSBtb2RlbHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgbW9kZWxJZDogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRyc1t0aGlzLm1vZGVsLnByb3RvdHlwZS5pZEF0dHJpYnV0ZSB8fCAnaWQnXTtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2QgdG8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlLiBDYWxsZWQgd2hlbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGlzIGZpcnN0IGluaXRpYWxpemVkIG9yIHJlc2V0LlxuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLm1vZGVscyA9IFtdO1xuICAgICAgdGhpcy5fYnlJZCAgPSB7fTtcbiAgICB9LFxuXG4gICAgLy8gUHJlcGFyZSBhIGhhc2ggb2YgYXR0cmlidXRlcyAob3Igb3RoZXIgbW9kZWwpIHRvIGJlIGFkZGVkIHRvIHRoaXNcbiAgICAvLyBjb2xsZWN0aW9uLlxuICAgIF9wcmVwYXJlTW9kZWw6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5faXNNb2RlbChhdHRycykpIHtcbiAgICAgICAgaWYgKCFhdHRycy5jb2xsZWN0aW9uKSBhdHRycy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICBvcHRpb25zLmNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgdmFyIG1vZGVsID0gbmV3IHRoaXMubW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFtb2RlbC52YWxpZGF0aW9uRXJyb3IpIHJldHVybiBtb2RlbDtcbiAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIG1vZGVsLnZhbGlkYXRpb25FcnJvciwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgYnkgYm90aCByZW1vdmUgYW5kIHNldC5cbiAgICBfcmVtb3ZlTW9kZWxzOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLmdldChtb2RlbHNbaV0pO1xuICAgICAgICBpZiAoIW1vZGVsKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YobW9kZWwpO1xuICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuXG4gICAgICAgIC8vIFJlbW92ZSByZWZlcmVuY2VzIGJlZm9yZSB0cmlnZ2VyaW5nICdyZW1vdmUnIGV2ZW50IHRvIHByZXZlbnQgYW5cbiAgICAgICAgLy8gaW5maW5pdGUgbG9vcC4gIzM2OTNcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwuY2lkXTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkgZGVsZXRlIHRoaXMuX2J5SWRbaWRdO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICBvcHRpb25zLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgbW9kZWwudHJpZ2dlcigncmVtb3ZlJywgbW9kZWwsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvLyBNZXRob2QgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgbW9kZWwgZm9yXG4gICAgLy8gdGhlIHB1cnBvc2VzIG9mIGFkZGluZyB0byB0aGUgY29sbGVjdGlvbi5cbiAgICBfaXNNb2RlbDogZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgIHJldHVybiBtb2RlbCBpbnN0YW5jZW9mIE1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfYWRkUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5fYnlJZFttb2RlbC5jaWRdID0gbW9kZWw7XG4gICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICBpZiAoaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFtpZF0gPSBtb2RlbDtcbiAgICAgIG1vZGVsLm9uKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gc2V2ZXIgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgIF9yZW1vdmVSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5jaWRdO1xuICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKGlkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW2lkXTtcbiAgICAgIGlmICh0aGlzID09PSBtb2RlbC5jb2xsZWN0aW9uKSBkZWxldGUgbW9kZWwuY29sbGVjdGlvbjtcbiAgICAgIG1vZGVsLm9mZignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIGNhbGxlZCBldmVyeSB0aW1lIGEgbW9kZWwgaW4gdGhlIHNldCBmaXJlcyBhbiBldmVudC5cbiAgICAvLyBTZXRzIG5lZWQgdG8gdXBkYXRlIHRoZWlyIGluZGV4ZXMgd2hlbiBtb2RlbHMgY2hhbmdlIGlkcy4gQWxsIG90aGVyXG4gICAgLy8gZXZlbnRzIHNpbXBseSBwcm94eSB0aHJvdWdoLiBcImFkZFwiIGFuZCBcInJlbW92ZVwiIGV2ZW50cyB0aGF0IG9yaWdpbmF0ZVxuICAgIC8vIGluIG90aGVyIGNvbGxlY3Rpb25zIGFyZSBpZ25vcmVkLlxuICAgIF9vbk1vZGVsRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBtb2RlbCwgY29sbGVjdGlvbiwgb3B0aW9ucykge1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIGlmICgoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAncmVtb3ZlJykgJiYgY29sbGVjdGlvbiAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgICBpZiAoZXZlbnQgPT09ICdkZXN0cm95JykgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZXZlbnQgPT09ICdjaGFuZ2UnKSB7XG4gICAgICAgICAgdmFyIHByZXZJZCA9IHRoaXMubW9kZWxJZChtb2RlbC5wcmV2aW91c0F0dHJpYnV0ZXMoKSk7XG4gICAgICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgIGlmIChwcmV2SWQgIT09IGlkKSB7XG4gICAgICAgICAgICBpZiAocHJldklkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW3ByZXZJZF07XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFtpZF0gPSBtb2RlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB3ZSB3YW50IHRvIGltcGxlbWVudCBvbiB0aGUgQ29sbGVjdGlvbi5cbiAgLy8gOTAlIG9mIHRoZSBjb3JlIHVzZWZ1bG5lc3Mgb2YgQmFja2JvbmUgQ29sbGVjdGlvbnMgaXMgYWN0dWFsbHkgaW1wbGVtZW50ZWRcbiAgLy8gcmlnaHQgaGVyZTpcbiAgdmFyIGNvbGxlY3Rpb25NZXRob2RzID0ge2ZvckVhY2g6IDMsIGVhY2g6IDMsIG1hcDogMywgY29sbGVjdDogMywgcmVkdWNlOiAwLFxuICAgICAgZm9sZGw6IDAsIGluamVjdDogMCwgcmVkdWNlUmlnaHQ6IDAsIGZvbGRyOiAwLCBmaW5kOiAzLCBkZXRlY3Q6IDMsIGZpbHRlcjogMyxcbiAgICAgIHNlbGVjdDogMywgcmVqZWN0OiAzLCBldmVyeTogMywgYWxsOiAzLCBzb21lOiAzLCBhbnk6IDMsIGluY2x1ZGU6IDMsIGluY2x1ZGVzOiAzLFxuICAgICAgY29udGFpbnM6IDMsIGludm9rZTogMCwgbWF4OiAzLCBtaW46IDMsIHRvQXJyYXk6IDEsIHNpemU6IDEsIGZpcnN0OiAzLFxuICAgICAgaGVhZDogMywgdGFrZTogMywgaW5pdGlhbDogMywgcmVzdDogMywgdGFpbDogMywgZHJvcDogMywgbGFzdDogMyxcbiAgICAgIHdpdGhvdXQ6IDAsIGRpZmZlcmVuY2U6IDAsIGluZGV4T2Y6IDMsIHNodWZmbGU6IDEsIGxhc3RJbmRleE9mOiAzLFxuICAgICAgaXNFbXB0eTogMSwgY2hhaW46IDEsIHNhbXBsZTogMywgcGFydGl0aW9uOiAzLCBncm91cEJ5OiAzLCBjb3VudEJ5OiAzLFxuICAgICAgc29ydEJ5OiAzLCBpbmRleEJ5OiAzLCBmaW5kSW5kZXg6IDMsIGZpbmRMYXN0SW5kZXg6IDN9O1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYENvbGxlY3Rpb24jbW9kZWxzYC5cbiAgYWRkVW5kZXJzY29yZU1ldGhvZHMoQ29sbGVjdGlvbiwgY29sbGVjdGlvbk1ldGhvZHMsICdtb2RlbHMnKTtcblxuICAvLyBCYWNrYm9uZS5WaWV3XG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSBWaWV3cyBhcmUgYWxtb3N0IG1vcmUgY29udmVudGlvbiB0aGFuIHRoZXkgYXJlIGFjdHVhbCBjb2RlLiBBIFZpZXdcbiAgLy8gaXMgc2ltcGx5IGEgSmF2YVNjcmlwdCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbG9naWNhbCBjaHVuayBvZiBVSSBpbiB0aGVcbiAgLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXG4gIC8vIGV2ZW4gdGhlIHN1cnJvdW5kaW5nIGZyYW1lIHdoaWNoIHdyYXBzIHlvdXIgd2hvbGUgYXBwLiBEZWZpbmluZyBhIGNodW5rIG9mXG4gIC8vIFVJIGFzIGEgKipWaWV3KiogYWxsb3dzIHlvdSB0byBkZWZpbmUgeW91ciBET00gZXZlbnRzIGRlY2xhcmF0aXZlbHksIHdpdGhvdXRcbiAgLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXG4gIC8vIHJlYWN0IHRvIHNwZWNpZmljIGNoYW5nZXMgaW4gdGhlIHN0YXRlIG9mIHlvdXIgbW9kZWxzLlxuXG4gIC8vIENyZWF0aW5nIGEgQmFja2JvbmUuVmlldyBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxuICAvLyBpZiBhbiBleGlzdGluZyBlbGVtZW50IGlzIG5vdCBwcm92aWRlZC4uLlxuICB2YXIgVmlldyA9IEJhY2tib25lLlZpZXcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCd2aWV3Jyk7XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCB0byBzcGxpdCBrZXlzIGZvciBgZGVsZWdhdGVgLlxuICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4gIC8vIExpc3Qgb2YgdmlldyBvcHRpb25zIHRvIGJlIHNldCBhcyBwcm9wZXJ0aWVzLlxuICB2YXIgdmlld09wdGlvbnMgPSBbJ21vZGVsJywgJ2NvbGxlY3Rpb24nLCAnZWwnLCAnaWQnLCAnYXR0cmlidXRlcycsICdjbGFzc05hbWUnLCAndGFnTmFtZScsICdldmVudHMnXTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGB0YWdOYW1lYCBvZiBhIFZpZXcncyBlbGVtZW50IGlzIGBcImRpdlwiYC5cbiAgICB0YWdOYW1lOiAnZGl2JyxcblxuICAgIC8vIGpRdWVyeSBkZWxlZ2F0ZSBmb3IgZWxlbWVudCBsb29rdXAsIHNjb3BlZCB0byBET00gZWxlbWVudHMgd2l0aGluIHRoZVxuICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxuICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZWwuZmluZChzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxuICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLiBUaGVcbiAgICAvLyBjb252ZW50aW9uIGlzIGZvciAqKnJlbmRlcioqIHRvIGFsd2F5cyByZXR1cm4gYHRoaXNgLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldyBieSB0YWtpbmcgdGhlIGVsZW1lbnQgb3V0IG9mIHRoZSBET00sIGFuZCByZW1vdmluZyBhbnlcbiAgICAvLyBhcHBsaWNhYmxlIEJhY2tib25lLkV2ZW50cyBsaXN0ZW5lcnMuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQoKTtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcncyBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50IGFuZCBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gYXR0YWNoZWQgdG8gaXQuIEV4cG9zZWQgZm9yIHN1YmNsYXNzZXMgdXNpbmcgYW4gYWx0ZXJuYXRpdmUgRE9NXG4gICAgLy8gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hhbmdlIHRoZSB2aWV3J3MgZWxlbWVudCAoYHRoaXMuZWxgIHByb3BlcnR5KSBhbmQgcmUtZGVsZWdhdGUgdGhlXG4gICAgLy8gdmlldydzIGV2ZW50cyBvbiB0aGUgbmV3IGVsZW1lbnQuXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICB0aGlzLl9zZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZXMgdGhlIGB0aGlzLmVsYCBhbmQgYHRoaXMuJGVsYCByZWZlcmVuY2VzIGZvciB0aGlzIHZpZXcgdXNpbmcgdGhlXG4gICAgLy8gZ2l2ZW4gYGVsYC4gYGVsYCBjYW4gYmUgYSBDU1Mgc2VsZWN0b3Igb3IgYW4gSFRNTCBzdHJpbmcsIGEgalF1ZXJ5XG4gICAgLy8gY29udGV4dCBvciBhbiBlbGVtZW50LiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIHV0aWxpemUgYW5cbiAgICAvLyBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSSBhbmQgYXJlIG9ubHkgcmVxdWlyZWQgdG8gc2V0IHRoZVxuICAgIC8vIGB0aGlzLmVsYCBwcm9wZXJ0eS5cbiAgICBfc2V0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHRoaXMuJGVsID0gZWwgaW5zdGFuY2VvZiBCYWNrYm9uZS4kID8gZWwgOiBCYWNrYm9uZS4kKGVsKTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgIGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKTtcbiAgICAgIGlmICghZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50cykge1xuICAgICAgICB2YXIgbWV0aG9kID0gZXZlbnRzW2tleV07XG4gICAgICAgIGlmICghXy5pc0Z1bmN0aW9uKG1ldGhvZCkpIG1ldGhvZCA9IHRoaXNbbWV0aG9kXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZShtYXRjaFsxXSwgbWF0Y2hbMl0sIF8uYmluZChtZXRob2QsIHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHZpZXcncyBlbGVtZW50IChvciBhIGNoaWxkIGVsZW1lbnRcbiAgICAvLyB1c2luZyBgc2VsZWN0b3JgKS4gVGhpcyBvbmx5IHdvcmtzIGZvciBkZWxlZ2F0ZS1hYmxlIGV2ZW50czogbm90IGBmb2N1c2AsXG4gICAgLy8gYGJsdXJgLCBhbmQgbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAgZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUgKyAnLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENsZWFycyBhbGwgY2FsbGJhY2tzIHByZXZpb3VzbHkgYm91bmQgdG8gdGhlIHZpZXcgYnkgYGRlbGVnYXRlRXZlbnRzYC5cbiAgICAvLyBZb3UgdXN1YWxseSBkb24ndCBuZWVkIHRvIHVzZSB0aGlzLCBidXQgbWF5IHdpc2ggdG8gaWYgeW91IGhhdmUgbXVsdGlwbGVcbiAgICAvLyBCYWNrYm9uZSB2aWV3cyBhdHRhY2hlZCB0byB0aGUgc2FtZSBET00gZWxlbWVudC5cbiAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLiRlbCkgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEEgZmluZXItZ3JhaW5lZCBgdW5kZWxlZ2F0ZUV2ZW50c2AgZm9yIHJlbW92aW5nIGEgc2luZ2xlIGRlbGVnYXRlZCBldmVudC5cbiAgICAvLyBgc2VsZWN0b3JgIGFuZCBgbGlzdGVuZXJgIGFyZSBib3RoIG9wdGlvbmFsLlxuICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vZmYoZXZlbnROYW1lICsgJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCwgc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBQcm9kdWNlcyBhIERPTSBlbGVtZW50IHRvIGJlIGFzc2lnbmVkIHRvIHlvdXIgdmlldy4gRXhwb3NlZCBmb3JcbiAgICAvLyBzdWJjbGFzc2VzIHVzaW5nIGFuIGFsdGVybmF0aXZlIERPTSBtYW5pcHVsYXRpb24gQVBJLlxuICAgIF9jcmVhdGVFbGVtZW50OiBmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAgLy8gSWYgYHRoaXMuZWxgIGlzIGEgc3RyaW5nLCBwYXNzIGl0IHRocm91Z2ggYCQoKWAsIHRha2UgdGhlIGZpcnN0XG4gICAgLy8gbWF0Y2hpbmcgZWxlbWVudCwgYW5kIHJlLWFzc2lnbiBpdCB0byBgZWxgLiBPdGhlcndpc2UsIGNyZWF0ZVxuICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBfLmV4dGVuZCh7fSwgXy5yZXN1bHQodGhpcywgJ2F0dHJpYnV0ZXMnKSk7XG4gICAgICAgIGlmICh0aGlzLmlkKSBhdHRycy5pZCA9IF8ucmVzdWx0KHRoaXMsICdpZCcpO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIGF0dHJzWydjbGFzcyddID0gXy5yZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQodGhpcy5fY3JlYXRlRWxlbWVudChfLnJlc3VsdCh0aGlzLCAndGFnTmFtZScpKSk7XG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KF8ucmVzdWx0KHRoaXMsICdlbCcpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXMgZnJvbSBhIGhhc2ggb24gdGhpcyB2aWV3J3MgZWxlbWVudC4gIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfc2V0QXR0cmlidXRlczogZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgdGhpcy4kZWwuYXR0cihhdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuc3luY1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gT3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBjaGFuZ2UgdGhlIG1hbm5lciBpbiB3aGljaCBCYWNrYm9uZSBwZXJzaXN0c1xuICAvLyBtb2RlbHMgdG8gdGhlIHNlcnZlci4gWW91IHdpbGwgYmUgcGFzc2VkIHRoZSB0eXBlIG9mIHJlcXVlc3QsIGFuZCB0aGVcbiAgLy8gbW9kZWwgaW4gcXVlc3Rpb24uIEJ5IGRlZmF1bHQsIG1ha2VzIGEgUkVTVGZ1bCBBamF4IHJlcXVlc3RcbiAgLy8gdG8gdGhlIG1vZGVsJ3MgYHVybCgpYC4gU29tZSBwb3NzaWJsZSBjdXN0b21pemF0aW9ucyBjb3VsZCBiZTpcbiAgLy9cbiAgLy8gKiBVc2UgYHNldFRpbWVvdXRgIHRvIGJhdGNoIHJhcGlkLWZpcmUgdXBkYXRlcyBpbnRvIGEgc2luZ2xlIHJlcXVlc3QuXG4gIC8vICogU2VuZCB1cCB0aGUgbW9kZWxzIGFzIFhNTCBpbnN0ZWFkIG9mIEpTT04uXG4gIC8vICogUGVyc2lzdCBtb2RlbHMgdmlhIFdlYlNvY2tldHMgaW5zdGVhZCBvZiBBamF4LlxuICAvL1xuICAvLyBUdXJuIG9uIGBCYWNrYm9uZS5lbXVsYXRlSFRUUGAgaW4gb3JkZXIgdG8gc2VuZCBgUFVUYCBhbmQgYERFTEVURWAgcmVxdWVzdHNcbiAgLy8gYXMgYFBPU1RgLCB3aXRoIGEgYF9tZXRob2RgIHBhcmFtZXRlciBjb250YWluaW5nIHRoZSB0cnVlIEhUVFAgbWV0aG9kLFxuICAvLyBhcyB3ZWxsIGFzIGFsbCByZXF1ZXN0cyB3aXRoIHRoZSBib2R5IGFzIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgXG4gIC8vIGluc3RlYWQgb2YgYGFwcGxpY2F0aW9uL2pzb25gIHdpdGggdGhlIG1vZGVsIGluIGEgcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgLy8gVXNlZnVsIHdoZW4gaW50ZXJmYWNpbmcgd2l0aCBzZXJ2ZXItc2lkZSBsYW5ndWFnZXMgbGlrZSAqKlBIUCoqIHRoYXQgbWFrZVxuICAvLyBpdCBkaWZmaWN1bHQgdG8gcmVhZCB0aGUgYm9keSBvZiBgUFVUYCByZXF1ZXN0cy5cbiAgQmFja2JvbmUuc3luYyA9IGZ1bmN0aW9uKG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHlwZSA9IG1ldGhvZE1hcFttZXRob2RdO1xuXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zLCB1bmxlc3Mgc3BlY2lmaWVkLlxuICAgIF8uZGVmYXVsdHMob3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KSwge1xuICAgICAgZW11bGF0ZUhUVFA6IEJhY2tib25lLmVtdWxhdGVIVFRQLFxuICAgICAgZW11bGF0ZUpTT046IEJhY2tib25lLmVtdWxhdGVKU09OXG4gICAgfSk7XG5cbiAgICAvLyBEZWZhdWx0IEpTT04tcmVxdWVzdCBvcHRpb25zLlxuICAgIHZhciBwYXJhbXMgPSB7dHlwZTogdHlwZSwgZGF0YVR5cGU6ICdqc29uJ307XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIGEgVVJMLlxuICAgIGlmICghb3B0aW9ucy51cmwpIHtcbiAgICAgIHBhcmFtcy51cmwgPSBfLnJlc3VsdChtb2RlbCwgJ3VybCcpIHx8IHVybEVycm9yKCk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgcmVxdWVzdCBkYXRhLlxuICAgIGlmIChvcHRpb25zLmRhdGEgPT0gbnVsbCAmJiBtb2RlbCAmJiAobWV0aG9kID09PSAnY3JlYXRlJyB8fCBtZXRob2QgPT09ICd1cGRhdGUnIHx8IG1ldGhvZCA9PT0gJ3BhdGNoJykpIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgIHBhcmFtcy5kYXRhID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5hdHRycyB8fCBtb2RlbC50b0pTT04ob3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8vIEZvciBvbGRlciBzZXJ2ZXJzLCBlbXVsYXRlIEpTT04gYnkgZW5jb2RpbmcgdGhlIHJlcXVlc3QgaW50byBhbiBIVE1MLWZvcm0uXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgcGFyYW1zLmRhdGEgPSBwYXJhbXMuZGF0YSA/IHttb2RlbDogcGFyYW1zLmRhdGF9IDoge307XG4gICAgfVxuXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSFRUUCBieSBtaW1pY2tpbmcgdGhlIEhUVFAgbWV0aG9kIHdpdGggYF9tZXRob2RgXG4gICAgLy8gQW5kIGFuIGBYLUhUVFAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUhUVFAgJiYgKHR5cGUgPT09ICdQVVQnIHx8IHR5cGUgPT09ICdERUxFVEUnIHx8IHR5cGUgPT09ICdQQVRDSCcpKSB7XG4gICAgICBwYXJhbXMudHlwZSA9ICdQT1NUJztcbiAgICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSBwYXJhbXMuZGF0YS5fbWV0aG9kID0gdHlwZTtcbiAgICAgIHZhciBiZWZvcmVTZW5kID0gb3B0aW9ucy5iZWZvcmVTZW5kO1xuICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJywgdHlwZSk7XG4gICAgICAgIGlmIChiZWZvcmVTZW5kKSByZXR1cm4gYmVmb3JlU2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBwcm9jZXNzIGRhdGEgb24gYSBub24tR0VUIHJlcXVlc3QuXG4gICAgaWYgKHBhcmFtcy50eXBlICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgcGFyYW1zLnByb2Nlc3NEYXRhID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUGFzcyBhbG9uZyBgdGV4dFN0YXR1c2AgYW5kIGBlcnJvclRocm93bmAgZnJvbSBqUXVlcnkuXG4gICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24oeGhyLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgb3B0aW9ucy50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcbiAgICAgIG9wdGlvbnMuZXJyb3JUaHJvd24gPSBlcnJvclRocm93bjtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IuY2FsbChvcHRpb25zLmNvbnRleHQsIHhociwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSByZXF1ZXN0LCBhbGxvd2luZyB0aGUgdXNlciB0byBvdmVycmlkZSBhbnkgQWpheCBvcHRpb25zLlxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociA9IEJhY2tib25lLmFqYXgoXy5leHRlbmQocGFyYW1zLCBvcHRpb25zKSk7XG4gICAgbW9kZWwudHJpZ2dlcigncmVxdWVzdCcsIG1vZGVsLCB4aHIsIG9wdGlvbnMpO1xuICAgIHJldHVybiB4aHI7XG4gIH07XG5cbiAgLy8gTWFwIGZyb20gQ1JVRCB0byBIVFRQIGZvciBvdXIgZGVmYXVsdCBgQmFja2JvbmUuc3luY2AgaW1wbGVtZW50YXRpb24uXG4gIHZhciBtZXRob2RNYXAgPSB7XG4gICAgJ2NyZWF0ZSc6ICdQT1NUJyxcbiAgICAndXBkYXRlJzogJ1BVVCcsXG4gICAgJ3BhdGNoJzogJ1BBVENIJyxcbiAgICAnZGVsZXRlJzogJ0RFTEVURScsXG4gICAgJ3JlYWQnOiAnR0VUJ1xuICB9O1xuXG4gIC8vIFNldCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgQmFja2JvbmUuYWpheGAgdG8gcHJveHkgdGhyb3VnaCB0byBgJGAuXG4gIC8vIE92ZXJyaWRlIHRoaXMgaWYgeW91J2QgbGlrZSB0byB1c2UgYSBkaWZmZXJlbnQgbGlicmFyeS5cbiAgQmFja2JvbmUuYWpheCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCYWNrYm9uZS4kLmFqYXguYXBwbHkoQmFja2JvbmUuJCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBCYWNrYm9uZS5Sb3V0ZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUm91dGVycyBtYXAgZmF1eC1VUkxzIHRvIGFjdGlvbnMsIGFuZCBmaXJlIGV2ZW50cyB3aGVuIHJvdXRlcyBhcmVcbiAgLy8gbWF0Y2hlZC4gQ3JlYXRpbmcgYSBuZXcgb25lIHNldHMgaXRzIGByb3V0ZXNgIGhhc2gsIGlmIG5vdCBzZXQgc3RhdGljYWxseS5cbiAgdmFyIFJvdXRlciA9IEJhY2tib25lLlJvdXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLnJvdXRlcykgdGhpcy5yb3V0ZXMgPSBvcHRpb25zLnJvdXRlcztcbiAgICB0aGlzLl9iaW5kUm91dGVzKCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIG1hdGNoaW5nIG5hbWVkIHBhcmFtIHBhcnRzIGFuZCBzcGxhdHRlZFxuICAvLyBwYXJ0cyBvZiByb3V0ZSBzdHJpbmdzLlxuICB2YXIgb3B0aW9uYWxQYXJhbSA9IC9cXCgoLio/KVxcKS9nO1xuICB2YXIgbmFtZWRQYXJhbSAgICA9IC8oXFwoXFw/KT86XFx3Ky9nO1xuICB2YXIgc3BsYXRQYXJhbSAgICA9IC9cXCpcXHcrL2c7XG4gIHZhciBlc2NhcGVSZWdFeHAgID0gL1tcXC17fVxcW1xcXSs/LixcXFxcXFxeJHwjXFxzXS9nO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5Sb3V0ZXIqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChSb3V0ZXIucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIE1hbnVhbGx5IGJpbmQgYSBzaW5nbGUgbmFtZWQgcm91dGUgdG8gYSBjYWxsYmFjay4gRm9yIGV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyAgICAgdGhpcy5yb3V0ZSgnc2VhcmNoLzpxdWVyeS9wOm51bScsICdzZWFyY2gnLCBmdW5jdGlvbihxdWVyeSwgbnVtKSB7XG4gICAgLy8gICAgICAgLi4uXG4gICAgLy8gICAgIH0pO1xuICAgIC8vXG4gICAgcm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFfLmlzUmVnRXhwKHJvdXRlKSkgcm91dGUgPSB0aGlzLl9yb3V0ZVRvUmVnRXhwKHJvdXRlKTtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24obmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgICBuYW1lID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IHRoaXNbbmFtZV07XG4gICAgICB2YXIgcm91dGVyID0gdGhpcztcbiAgICAgIEJhY2tib25lLmhpc3Rvcnkucm91dGUocm91dGUsIGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICAgIHZhciBhcmdzID0gcm91dGVyLl9leHRyYWN0UGFyYW1ldGVycyhyb3V0ZSwgZnJhZ21lbnQpO1xuICAgICAgICBpZiAocm91dGVyLmV4ZWN1dGUoY2FsbGJhY2ssIGFyZ3MsIG5hbWUpICE9PSBmYWxzZSkge1xuICAgICAgICAgIHJvdXRlci50cmlnZ2VyLmFwcGx5KHJvdXRlciwgWydyb3V0ZTonICsgbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICByb3V0ZXIudHJpZ2dlcigncm91dGUnLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICBCYWNrYm9uZS5oaXN0b3J5LnRyaWdnZXIoJ3JvdXRlJywgcm91dGVyLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRXhlY3V0ZSBhIHJvdXRlIGhhbmRsZXIgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy4gIFRoaXMgaXMgYW5cbiAgICAvLyBleGNlbGxlbnQgcGxhY2UgdG8gZG8gcHJlLXJvdXRlIHNldHVwIG9yIHBvc3Qtcm91dGUgY2xlYW51cC5cbiAgICBleGVjdXRlOiBmdW5jdGlvbihjYWxsYmFjaywgYXJncywgbmFtZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLy8gU2ltcGxlIHByb3h5IHRvIGBCYWNrYm9uZS5oaXN0b3J5YCB0byBzYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoZnJhZ21lbnQsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEJpbmQgYWxsIGRlZmluZWQgcm91dGVzIHRvIGBCYWNrYm9uZS5oaXN0b3J5YC4gV2UgaGF2ZSB0byByZXZlcnNlIHRoZVxuICAgIC8vIG9yZGVyIG9mIHRoZSByb3V0ZXMgaGVyZSB0byBzdXBwb3J0IGJlaGF2aW9yIHdoZXJlIHRoZSBtb3N0IGdlbmVyYWxcbiAgICAvLyByb3V0ZXMgY2FuIGJlIGRlZmluZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcm91dGUgbWFwLlxuICAgIF9iaW5kUm91dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5yb3V0ZXMpIHJldHVybjtcbiAgICAgIHRoaXMucm91dGVzID0gXy5yZXN1bHQodGhpcywgJ3JvdXRlcycpO1xuICAgICAgdmFyIHJvdXRlLCByb3V0ZXMgPSBfLmtleXModGhpcy5yb3V0ZXMpO1xuICAgICAgd2hpbGUgKChyb3V0ZSA9IHJvdXRlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJvdXRlKHJvdXRlLCB0aGlzLnJvdXRlc1tyb3V0ZV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgcm91dGUgc3RyaW5nIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24sIHN1aXRhYmxlIGZvciBtYXRjaGluZ1xuICAgIC8vIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24gaGFzaC5cbiAgICBfcm91dGVUb1JlZ0V4cDogZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgIHJvdXRlID0gcm91dGUucmVwbGFjZShlc2NhcGVSZWdFeHAsICdcXFxcJCYnKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG9wdGlvbmFsUGFyYW0sICcoPzokMSk/JylcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZShuYW1lZFBhcmFtLCBmdW5jdGlvbihtYXRjaCwgb3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25hbCA/IG1hdGNoIDogJyhbXi8/XSspJztcbiAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHNwbGF0UGFyYW0sICcoW14/XSo/KScpO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcm91dGUgKyAnKD86XFxcXD8oW1xcXFxzXFxcXFNdKikpPyQnKTtcbiAgICB9LFxuXG4gICAgLy8gR2l2ZW4gYSByb3V0ZSwgYW5kIGEgVVJMIGZyYWdtZW50IHRoYXQgaXQgbWF0Y2hlcywgcmV0dXJuIHRoZSBhcnJheSBvZlxuICAgIC8vIGV4dHJhY3RlZCBkZWNvZGVkIHBhcmFtZXRlcnMuIEVtcHR5IG9yIHVubWF0Y2hlZCBwYXJhbWV0ZXJzIHdpbGwgYmVcbiAgICAvLyB0cmVhdGVkIGFzIGBudWxsYCB0byBub3JtYWxpemUgY3Jvc3MtYnJvd3NlciBiZWhhdmlvci5cbiAgICBfZXh0cmFjdFBhcmFtZXRlcnM6IGZ1bmN0aW9uKHJvdXRlLCBmcmFnbWVudCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHJvdXRlLmV4ZWMoZnJhZ21lbnQpLnNsaWNlKDEpO1xuICAgICAgcmV0dXJuIF8ubWFwKHBhcmFtcywgZnVuY3Rpb24ocGFyYW0sIGkpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVjb2RlIHRoZSBzZWFyY2ggcGFyYW1zLlxuICAgICAgICBpZiAoaSA9PT0gcGFyYW1zLmxlbmd0aCAtIDEpIHJldHVybiBwYXJhbSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gcGFyYW0gPyBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pIDogbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5IaXN0b3J5XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBIYW5kbGVzIGNyb3NzLWJyb3dzZXIgaGlzdG9yeSBtYW5hZ2VtZW50LCBiYXNlZCBvbiBlaXRoZXJcbiAgLy8gW3B1c2hTdGF0ZV0oaHR0cDovL2RpdmVpbnRvaHRtbDUuaW5mby9oaXN0b3J5Lmh0bWwpIGFuZCByZWFsIFVSTHMsIG9yXG4gIC8vIFtvbmhhc2hjaGFuZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL3dpbmRvdy5vbmhhc2hjaGFuZ2UpXG4gIC8vIGFuZCBVUkwgZnJhZ21lbnRzLiBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBuZWl0aGVyIChvbGQgSUUsIG5hdGNoKSxcbiAgLy8gZmFsbHMgYmFjayB0byBwb2xsaW5nLlxuICB2YXIgSGlzdG9yeSA9IEJhY2tib25lLkhpc3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgdGhpcy5jaGVja1VybCA9IF8uYmluZCh0aGlzLmNoZWNrVXJsLCB0aGlzKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IGBIaXN0b3J5YCBjYW4gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBicm93c2VyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5sb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgIHRoaXMuaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICAgIH1cbiAgfTtcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBhIGxlYWRpbmcgaGFzaC9zbGFzaCBhbmQgdHJhaWxpbmcgc3BhY2UuXG4gIHZhciByb3V0ZVN0cmlwcGVyID0gL15bI1xcL118XFxzKyQvZztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzLlxuICB2YXIgcm9vdFN0cmlwcGVyID0gL15cXC8rfFxcLyskL2c7XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgdXJscyBvZiBoYXNoLlxuICB2YXIgcGF0aFN0cmlwcGVyID0gLyMuKiQvO1xuXG4gIC8vIEhhcyB0aGUgaGlzdG9yeSBoYW5kbGluZyBhbHJlYWR5IGJlZW4gc3RhcnRlZD9cbiAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLkhpc3RvcnkqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChIaXN0b3J5LnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBpbnRlcnZhbCB0byBwb2xsIGZvciBoYXNoIGNoYW5nZXMsIGlmIG5lY2Vzc2FyeSwgaXNcbiAgICAvLyB0d2VudHkgdGltZXMgYSBzZWNvbmQuXG4gICAgaW50ZXJ2YWw6IDUwLFxuXG4gICAgLy8gQXJlIHdlIGF0IHRoZSBhcHAgcm9vdD9cbiAgICBhdFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1teXFwvXSQvLCAnJCYvJyk7XG4gICAgICByZXR1cm4gcGF0aCA9PT0gdGhpcy5yb290ICYmICF0aGlzLmdldFNlYXJjaCgpO1xuICAgIH0sXG5cbiAgICAvLyBEb2VzIHRoZSBwYXRobmFtZSBtYXRjaCB0aGUgcm9vdD9cbiAgICBtYXRjaFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmRlY29kZUZyYWdtZW50KHRoaXMubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgdmFyIHJvb3RQYXRoID0gcGF0aC5zbGljZSgwLCB0aGlzLnJvb3QubGVuZ3RoIC0gMSkgKyAnLyc7XG4gICAgICByZXR1cm4gcm9vdFBhdGggPT09IHRoaXMucm9vdDtcbiAgICB9LFxuXG4gICAgLy8gVW5pY29kZSBjaGFyYWN0ZXJzIGluIGBsb2NhdGlvbi5wYXRobmFtZWAgYXJlIHBlcmNlbnQgZW5jb2RlZCBzbyB0aGV5J3JlXG4gICAgLy8gZGVjb2RlZCBmb3IgY29tcGFyaXNvbi4gYCUyNWAgc2hvdWxkIG5vdCBiZSBkZWNvZGVkIHNpbmNlIGl0IG1heSBiZSBwYXJ0XG4gICAgLy8gb2YgYW4gZW5jb2RlZCBwYXJhbWV0ZXIuXG4gICAgZGVjb2RlRnJhZ21lbnQ6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJKGZyYWdtZW50LnJlcGxhY2UoLyUyNS9nLCAnJTI1MjUnKSk7XG4gICAgfSxcblxuICAgIC8vIEluIElFNiwgdGhlIGhhc2ggZnJhZ21lbnQgYW5kIHNlYXJjaCBwYXJhbXMgYXJlIGluY29ycmVjdCBpZiB0aGVcbiAgICAvLyBmcmFnbWVudCBjb250YWlucyBgP2AuXG4gICAgZ2V0U2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXRjaCA9IHRoaXMubG9jYXRpb24uaHJlZi5yZXBsYWNlKC8jLiovLCAnJykubWF0Y2goL1xcPy4rLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXRzIHRoZSB0cnVlIGhhc2ggdmFsdWUuIENhbm5vdCB1c2UgbG9jYXRpb24uaGFzaCBkaXJlY3RseSBkdWUgdG8gYnVnXG4gICAgLy8gaW4gRmlyZWZveCB3aGVyZSBsb2NhdGlvbi5oYXNoIHdpbGwgYWx3YXlzIGJlIGRlY29kZWQuXG4gICAgZ2V0SGFzaDogZnVuY3Rpb24od2luZG93KSB7XG4gICAgICB2YXIgbWF0Y2ggPSAod2luZG93IHx8IHRoaXMpLmxvY2F0aW9uLmhyZWYubWF0Y2goLyMoLiopJC8pO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwYXRobmFtZSBhbmQgc2VhcmNoIHBhcmFtcywgd2l0aG91dCB0aGUgcm9vdC5cbiAgICBnZXRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5kZWNvZGVGcmFnbWVudChcbiAgICAgICAgdGhpcy5sb2NhdGlvbi5wYXRobmFtZSArIHRoaXMuZ2V0U2VhcmNoKClcbiAgICAgICkuc2xpY2UodGhpcy5yb290Lmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnNsaWNlKDEpIDogcGF0aDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBjcm9zcy1icm93c2VyIG5vcm1hbGl6ZWQgVVJMIGZyYWdtZW50IGZyb20gdGhlIHBhdGggb3IgaGFzaC5cbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgIGlmIChmcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUgfHwgIXRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRQYXRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgIH0sXG5cbiAgICAvLyBTdGFydCB0aGUgaGFzaCBjaGFuZ2UgaGFuZGxpbmcsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgVVJMIG1hdGNoZXNcbiAgICAvLyBhbiBleGlzdGluZyByb3V0ZSwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIHN0YXJ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoSGlzdG9yeS5zdGFydGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0JhY2tib25lLmhpc3RvcnkgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkJyk7XG4gICAgICBIaXN0b3J5LnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAvLyBGaWd1cmUgb3V0IHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24uIERvIHdlIG5lZWQgYW4gaWZyYW1lP1xuICAgICAgLy8gSXMgcHVzaFN0YXRlIGRlc2lyZWQgLi4uIGlzIGl0IGF2YWlsYWJsZT9cbiAgICAgIHRoaXMub3B0aW9ucyAgICAgICAgICA9IF8uZXh0ZW5kKHtyb290OiAnLyd9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5yb290ICAgICAgICAgICAgID0gdGhpcy5vcHRpb25zLnJvb3Q7XG4gICAgICB0aGlzLl93YW50c0hhc2hDaGFuZ2UgPSB0aGlzLm9wdGlvbnMuaGFzaENoYW5nZSAhPT0gZmFsc2U7XG4gICAgICB0aGlzLl9oYXNIYXNoQ2hhbmdlICAgPSAnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3cgJiYgKGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PT0gdm9pZCAwIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDcpO1xuICAgICAgdGhpcy5fdXNlSGFzaENoYW5nZSAgID0gdGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmIHRoaXMuX2hhc0hhc2hDaGFuZ2U7XG4gICAgICB0aGlzLl93YW50c1B1c2hTdGF0ZSAgPSAhIXRoaXMub3B0aW9ucy5wdXNoU3RhdGU7XG4gICAgICB0aGlzLl9oYXNQdXNoU3RhdGUgICAgPSAhISh0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LnB1c2hTdGF0ZSk7XG4gICAgICB0aGlzLl91c2VQdXNoU3RhdGUgICAgPSB0aGlzLl93YW50c1B1c2hTdGF0ZSAmJiB0aGlzLl9oYXNQdXNoU3RhdGU7XG4gICAgICB0aGlzLmZyYWdtZW50ICAgICAgICAgPSB0aGlzLmdldEZyYWdtZW50KCk7XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSByb290IHRvIGFsd2F5cyBpbmNsdWRlIGEgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXG4gICAgICB0aGlzLnJvb3QgPSAoJy8nICsgdGhpcy5yb290ICsgJy8nKS5yZXBsYWNlKHJvb3RTdHJpcHBlciwgJy8nKTtcblxuICAgICAgLy8gVHJhbnNpdGlvbiBmcm9tIGhhc2hDaGFuZ2UgdG8gcHVzaFN0YXRlIG9yIHZpY2UgdmVyc2EgaWYgYm90aCBhcmVcbiAgICAgIC8vIHJlcXVlc3RlZC5cbiAgICAgIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgdGhpcy5fd2FudHNQdXNoU3RhdGUpIHtcblxuICAgICAgICAvLyBJZiB3ZSd2ZSBzdGFydGVkIG9mZiB3aXRoIGEgcm91dGUgZnJvbSBhIGBwdXNoU3RhdGVgLWVuYWJsZWRcbiAgICAgICAgLy8gYnJvd3NlciwgYnV0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIGJyb3dzZXIgdGhhdCBkb2Vzbid0IHN1cHBvcnQgaXQuLi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNQdXNoU3RhdGUgJiYgIXRoaXMuYXRSb290KCkpIHtcbiAgICAgICAgICB2YXIgcm9vdFBhdGggPSB0aGlzLnJvb3Quc2xpY2UoMCwgLTEpIHx8ICcvJztcbiAgICAgICAgICB0aGlzLmxvY2F0aW9uLnJlcGxhY2Uocm9vdFBhdGggKyAnIycgKyB0aGlzLmdldFBhdGgoKSk7XG4gICAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IGFzIGJyb3dzZXIgd2lsbCBkbyByZWRpcmVjdCB0byBuZXcgdXJsXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gT3IgaWYgd2UndmUgc3RhcnRlZCBvdXQgd2l0aCBhIGhhc2gtYmFzZWQgcm91dGUsIGJ1dCB3ZSdyZSBjdXJyZW50bHlcbiAgICAgICAgLy8gaW4gYSBicm93c2VyIHdoZXJlIGl0IGNvdWxkIGJlIGBwdXNoU3RhdGVgLWJhc2VkIGluc3RlYWQuLi5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUgJiYgdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHRoaXMubmF2aWdhdGUodGhpcy5nZXRIYXNoKCksIHtyZXBsYWNlOiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyBQcm94eSBhbiBpZnJhbWUgdG8gaGFuZGxlIGxvY2F0aW9uIGV2ZW50cyBpZiB0aGUgYnJvd3NlciBkb2Vzbid0XG4gICAgICAvLyBzdXBwb3J0IHRoZSBgaGFzaGNoYW5nZWAgZXZlbnQsIEhUTUw1IGhpc3RvcnksIG9yIHRoZSB1c2VyIHdhbnRzXG4gICAgICAvLyBgaGFzaENoYW5nZWAgYnV0IG5vdCBgcHVzaFN0YXRlYC5cbiAgICAgIGlmICghdGhpcy5faGFzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgIXRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICB0aGlzLmlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICB0aGlzLmlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICAgICAgdGhpcy5pZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5pZnJhbWUudGFiSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAvLyBVc2luZyBgYXBwZW5kQ2hpbGRgIHdpbGwgdGhyb3cgb24gSUUgPCA5IGlmIHRoZSBkb2N1bWVudCBpcyBub3QgcmVhZHkuXG4gICAgICAgIHZhciBpV2luZG93ID0gYm9keS5pbnNlcnRCZWZvcmUodGhpcy5pZnJhbWUsIGJvZHkuZmlyc3RDaGlsZCkuY29udGVudFdpbmRvdztcbiAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5vcGVuKCk7XG4gICAgICAgIGlXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgaVdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyMnICsgdGhpcy5mcmFnbWVudDtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGEgY3Jvc3MtcGxhdGZvcm0gYGFkZEV2ZW50TGlzdGVuZXJgIHNoaW0gZm9yIG9sZGVyIGJyb3dzZXJzLlxuICAgICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCBmdW5jdGlvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSB1c2luZyBwdXNoU3RhdGUgb3IgaGFzaGVzLCBhbmQgd2hldGhlclxuICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXG4gICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl91c2VIYXNoQ2hhbmdlICYmICF0aGlzLmlmcmFtZSkge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tVcmxJbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMuY2hlY2tVcmwsIHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWxlbnQpIHJldHVybiB0aGlzLmxvYWRVcmwoKTtcbiAgICB9LFxuXG4gICAgLy8gRGlzYWJsZSBCYWNrYm9uZS5oaXN0b3J5LCBwZXJoYXBzIHRlbXBvcmFyaWx5LiBOb3QgdXNlZnVsIGluIGEgcmVhbCBhcHAsXG4gICAgLy8gYnV0IHBvc3NpYmx5IHVzZWZ1bCBmb3IgdW5pdCB0ZXN0aW5nIFJvdXRlcnMuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBBZGQgYSBjcm9zcy1wbGF0Zm9ybSBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgc2hpbSBmb3Igb2xkZXIgYnJvd3NlcnMuXG4gICAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyIHx8IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGRldGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFJlbW92ZSB3aW5kb3cgbGlzdGVuZXJzLlxuICAgICAgaWYgKHRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuY2hlY2tVcmwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdXNlSGFzaENoYW5nZSAmJiAhdGhpcy5pZnJhbWUpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuY2hlY2tVcmwsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYW4gdXAgdGhlIGlmcmFtZSBpZiBuZWNlc3NhcnkuXG4gICAgICBpZiAodGhpcy5pZnJhbWUpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmlmcmFtZSk7XG4gICAgICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgd2lsbCB0aHJvdyB3aGVuIGNsZWFyaW5nIGFuIHVuZGVmaW5lZCBpbnRlcnZhbC5cbiAgICAgIGlmICh0aGlzLl9jaGVja1VybEludGVydmFsKSBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwpO1xuICAgICAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIHJvdXRlIHRvIGJlIHRlc3RlZCB3aGVuIHRoZSBmcmFnbWVudCBjaGFuZ2VzLiBSb3V0ZXMgYWRkZWQgbGF0ZXJcbiAgICAvLyBtYXkgb3ZlcnJpZGUgcHJldmlvdXMgcm91dGVzLlxuICAgIHJvdXRlOiBmdW5jdGlvbihyb3V0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuaGFuZGxlcnMudW5zaGlmdCh7cm91dGU6IHJvdXRlLCBjYWxsYmFjazogY2FsbGJhY2t9KTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIHRoZSBjdXJyZW50IFVSTCB0byBzZWUgaWYgaXQgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsXG4gICAgLy8gY2FsbHMgYGxvYWRVcmxgLCBub3JtYWxpemluZyBhY3Jvc3MgdGhlIGhpZGRlbiBpZnJhbWUuXG4gICAgY2hlY2tVcmw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuXG4gICAgICAvLyBJZiB0aGUgdXNlciBwcmVzc2VkIHRoZSBiYWNrIGJ1dHRvbiwgdGhlIGlmcmFtZSdzIGhhc2ggd2lsbCBoYXZlXG4gICAgICAvLyBjaGFuZ2VkIGFuZCB3ZSBzaG91bGQgdXNlIHRoYXQgZm9yIGNvbXBhcmlzb24uXG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mcmFnbWVudCAmJiB0aGlzLmlmcmFtZSkge1xuICAgICAgICBjdXJyZW50ID0gdGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mcmFnbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaWZyYW1lKSB0aGlzLm5hdmlnYXRlKGN1cnJlbnQpO1xuICAgICAgdGhpcy5sb2FkVXJsKCk7XG4gICAgfSxcblxuICAgIC8vIEF0dGVtcHQgdG8gbG9hZCB0aGUgY3VycmVudCBVUkwgZnJhZ21lbnQuIElmIGEgcm91dGUgc3VjY2VlZHMgd2l0aCBhXG4gICAgLy8gbWF0Y2gsIHJldHVybnMgYHRydWVgLiBJZiBubyBkZWZpbmVkIHJvdXRlcyBtYXRjaGVzIHRoZSBmcmFnbWVudCxcbiAgICAvLyByZXR1cm5zIGBmYWxzZWAuXG4gICAgbG9hZFVybDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIHRoZSByb290IGRvZXNuJ3QgbWF0Y2gsIG5vIHJvdXRlcyBjYW4gbWF0Y2ggZWl0aGVyLlxuICAgICAgaWYgKCF0aGlzLm1hdGNoUm9vdCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgIHJldHVybiBfLnNvbWUodGhpcy5oYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICBpZiAoaGFuZGxlci5yb3V0ZS50ZXN0KGZyYWdtZW50KSkge1xuICAgICAgICAgIGhhbmRsZXIuY2FsbGJhY2soZnJhZ21lbnQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gU2F2ZSBhIGZyYWdtZW50IGludG8gdGhlIGhhc2ggaGlzdG9yeSwgb3IgcmVwbGFjZSB0aGUgVVJMIHN0YXRlIGlmIHRoZVxuICAgIC8vICdyZXBsYWNlJyBvcHRpb24gaXMgcGFzc2VkLiBZb3UgYXJlIHJlc3BvbnNpYmxlIGZvciBwcm9wZXJseSBVUkwtZW5jb2RpbmdcbiAgICAvLyB0aGUgZnJhZ21lbnQgaW4gYWR2YW5jZS5cbiAgICAvL1xuICAgIC8vIFRoZSBvcHRpb25zIG9iamVjdCBjYW4gY29udGFpbiBgdHJpZ2dlcjogdHJ1ZWAgaWYgeW91IHdpc2ggdG8gaGF2ZSB0aGVcbiAgICAvLyByb3V0ZSBjYWxsYmFjayBiZSBmaXJlZCAobm90IHVzdWFsbHkgZGVzaXJhYmxlKSwgb3IgYHJlcGxhY2U6IHRydWVgLCBpZlxuICAgIC8vIHlvdSB3aXNoIHRvIG1vZGlmeSB0aGUgY3VycmVudCBVUkwgd2l0aG91dCBhZGRpbmcgYW4gZW50cnkgdG8gdGhlIGhpc3RvcnkuXG4gICAgbmF2aWdhdGU6IGZ1bmN0aW9uKGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgICBpZiAoIUhpc3Rvcnkuc3RhcnRlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMgPT09IHRydWUpIG9wdGlvbnMgPSB7dHJpZ2dlcjogISFvcHRpb25zfTtcblxuICAgICAgLy8gTm9ybWFsaXplIHRoZSBmcmFnbWVudC5cbiAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudCB8fCAnJyk7XG5cbiAgICAgIC8vIERvbid0IGluY2x1ZGUgYSB0cmFpbGluZyBzbGFzaCBvbiB0aGUgcm9vdC5cbiAgICAgIHZhciByb290UGF0aCA9IHRoaXMucm9vdDtcbiAgICAgIGlmIChmcmFnbWVudCA9PT0gJycgfHwgZnJhZ21lbnQuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgICAgcm9vdFBhdGggPSByb290UGF0aC5zbGljZSgwLCAtMSkgfHwgJy8nO1xuICAgICAgfVxuICAgICAgdmFyIHVybCA9IHJvb3RQYXRoICsgZnJhZ21lbnQ7XG5cbiAgICAgIC8vIFN0cmlwIHRoZSBoYXNoIGFuZCBkZWNvZGUgZm9yIG1hdGNoaW5nLlxuICAgICAgZnJhZ21lbnQgPSB0aGlzLmRlY29kZUZyYWdtZW50KGZyYWdtZW50LnJlcGxhY2UocGF0aFN0cmlwcGVyLCAnJykpO1xuXG4gICAgICBpZiAodGhpcy5mcmFnbWVudCA9PT0gZnJhZ21lbnQpIHJldHVybjtcbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcblxuICAgICAgLy8gSWYgcHVzaFN0YXRlIGlzIGF2YWlsYWJsZSwgd2UgdXNlIGl0IHRvIHNldCB0aGUgZnJhZ21lbnQgYXMgYSByZWFsIFVSTC5cbiAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5W29wdGlvbnMucmVwbGFjZSA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKHt9LCBkb2N1bWVudC50aXRsZSwgdXJsKTtcblxuICAgICAgLy8gSWYgaGFzaCBjaGFuZ2VzIGhhdmVuJ3QgYmVlbiBleHBsaWNpdGx5IGRpc2FibGVkLCB1cGRhdGUgdGhlIGhhc2hcbiAgICAgIC8vIGZyYWdtZW50IHRvIHN0b3JlIGhpc3RvcnkuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHRoaXMubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICBpZiAodGhpcy5pZnJhbWUgJiYgZnJhZ21lbnQgIT09IHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZS5jb250ZW50V2luZG93KSkge1xuICAgICAgICAgIHZhciBpV2luZG93ID0gdGhpcy5pZnJhbWUuY29udGVudFdpbmRvdztcblxuICAgICAgICAgIC8vIE9wZW5pbmcgYW5kIGNsb3NpbmcgdGhlIGlmcmFtZSB0cmlja3MgSUU3IGFuZCBlYXJsaWVyIHRvIHB1c2ggYVxuICAgICAgICAgIC8vIGhpc3RvcnkgZW50cnkgb24gaGFzaC10YWcgY2hhbmdlLiAgV2hlbiByZXBsYWNlIGlzIHRydWUsIHdlIGRvbid0XG4gICAgICAgICAgLy8gd2FudCB0aGlzLlxuICAgICAgICAgIGlmICghb3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAgICAgICBpV2luZG93LmRvY3VtZW50Lm9wZW4oKTtcbiAgICAgICAgICAgIGlXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl91cGRhdGVIYXNoKGlXaW5kb3cubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICB9XG5cbiAgICAgIC8vIElmIHlvdSd2ZSB0b2xkIHVzIHRoYXQgeW91IGV4cGxpY2l0bHkgZG9uJ3Qgd2FudCBmYWxsYmFjayBoYXNoY2hhbmdlLVxuICAgICAgLy8gYmFzZWQgaGlzdG9yeSwgdGhlbiBgbmF2aWdhdGVgIGJlY29tZXMgYSBwYWdlIHJlZnJlc2guXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRyaWdnZXIpIHJldHVybiB0aGlzLmxvYWRVcmwoZnJhZ21lbnQpO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgdGhlIGhhc2ggbG9jYXRpb24sIGVpdGhlciByZXBsYWNpbmcgdGhlIGN1cnJlbnQgZW50cnksIG9yIGFkZGluZ1xuICAgIC8vIGEgbmV3IG9uZSB0byB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgIF91cGRhdGVIYXNoOiBmdW5jdGlvbihsb2NhdGlvbiwgZnJhZ21lbnQsIHJlcGxhY2UpIHtcbiAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgIHZhciBocmVmID0gbG9jYXRpb24uaHJlZi5yZXBsYWNlKC8oamF2YXNjcmlwdDp8IykuKiQvLCAnJyk7XG4gICAgICAgIGxvY2F0aW9uLnJlcGxhY2UoaHJlZiArICcjJyArIGZyYWdtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgcmVxdWlyZSB0aGF0IGBoYXNoYCBjb250YWlucyBhIGxlYWRpbmcgIy5cbiAgICAgICAgbG9jYXRpb24uaGFzaCA9ICcjJyArIGZyYWdtZW50O1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxuICAvLyBDcmVhdGUgdGhlIGRlZmF1bHQgQmFja2JvbmUuaGlzdG9yeS5cbiAgQmFja2JvbmUuaGlzdG9yeSA9IG5ldyBIaXN0b3J5O1xuXG4gIC8vIEhlbHBlcnNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb3JyZWN0bHkgc2V0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gZm9yIHN1YmNsYXNzZXMuXG4gIC8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4gIC8vIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZXh0ZW5kZWQuXG4gIHZhciBleHRlbmQgPSBmdW5jdGlvbihwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIHZhciBjaGlsZDtcblxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yLlxuICAgIGlmIChwcm90b1Byb3BzICYmIF8uaGFzKHByb3RvUHJvcHMsICdjb25zdHJ1Y3RvcicpKSB7XG4gICAgICBjaGlsZCA9IHByb3RvUHJvcHMuY29uc3RydWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkID0gZnVuY3Rpb24oKXsgcmV0dXJuIHBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIH1cblxuICAgIC8vIEFkZCBzdGF0aWMgcHJvcGVydGllcyB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24sIGlmIHN1cHBsaWVkLlxuICAgIF8uZXh0ZW5kKGNoaWxkLCBwYXJlbnQsIHN0YXRpY1Byb3BzKTtcblxuICAgIC8vIFNldCB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGluaGVyaXQgZnJvbSBgcGFyZW50YCwgd2l0aG91dCBjYWxsaW5nXG4gICAgLy8gYHBhcmVudGAncyBjb25zdHJ1Y3RvciBmdW5jdGlvbiBhbmQgYWRkIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAgICBjaGlsZC5wcm90b3R5cGUgPSBfLmNyZWF0ZShwYXJlbnQucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBjaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZDtcblxuICAgIC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWRcbiAgICAvLyBsYXRlci5cbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuXG4gIC8vIFNldCB1cCBpbmhlcml0YW5jZSBmb3IgdGhlIG1vZGVsLCBjb2xsZWN0aW9uLCByb3V0ZXIsIHZpZXcgYW5kIGhpc3RvcnkuXG4gIE1vZGVsLmV4dGVuZCA9IENvbGxlY3Rpb24uZXh0ZW5kID0gUm91dGVyLmV4dGVuZCA9IFZpZXcuZXh0ZW5kID0gSGlzdG9yeS5leHRlbmQgPSBleHRlbmQ7XG5cbiAgLy8gVGhyb3cgYW4gZXJyb3Igd2hlbiBhIFVSTCBpcyBuZWVkZWQsIGFuZCBub25lIGlzIHN1cHBsaWVkLlxuICB2YXIgdXJsRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgXCJ1cmxcIiBwcm9wZXJ0eSBvciBmdW5jdGlvbiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuICB9O1xuXG4gIC8vIFdyYXAgYW4gb3B0aW9uYWwgZXJyb3IgY2FsbGJhY2sgd2l0aCBhIGZhbGxiYWNrIGVycm9yIGV2ZW50LlxuICB2YXIgd3JhcEVycm9yID0gZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICBpZiAoZXJyb3IpIGVycm9yLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICBtb2RlbC50cmlnZ2VyKCdlcnJvcicsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBCYWNrYm9uZTtcbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2JhY2tib25lL2JhY2tib25lLmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBqYWRlID0gcmVxdWlyZShcIkQ6XFxcXHdvcmtzcGFjZVxcXFxmb3JrXFxcXHByb2plY3Rpb24tZ3JpZFxcXFxub2RlX21vZHVsZXNcXFxcamFkZVxcXFxsaWJcXFxccnVudGltZS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZW1wbGF0ZShsb2NhbHMpIHtcbnZhciBidWYgPSBbXTtcbnZhciBqYWRlX21peGlucyA9IHt9O1xudmFyIGphZGVfaW50ZXJwO1xuO3ZhciBsb2NhbHNfZm9yX3dpdGggPSAobG9jYWxzIHx8IHt9KTsoZnVuY3Rpb24gKCRtZXRhZGF0YSwgY29sdW1ucywgaGlkZUhlYWRlcnMsIGlzQXBwbHlHcm91cCwgc3ViU2VsZWN0LCB1bmRlZmluZWQsIHZhbHVlKSB7XG5qYWRlX21peGluc1tcImNvbHVtbkhlYWRlclwiXSA9IGphZGVfaW50ZXJwID0gZnVuY3Rpb24oY29sdW1uLCBpc1N1YkhlYWRlcil7XG52YXIgYmxvY2sgPSAodGhpcyAmJiB0aGlzLmJsb2NrKSwgYXR0cmlidXRlcyA9ICh0aGlzICYmIHRoaXMuYXR0cmlidXRlcykgfHwge307XG5pZiAoIGNvbHVtbi5oZWFkZXJCdWlsZGVyKVxue1xuYnVmLnB1c2gobnVsbCA9PSAoamFkZV9pbnRlcnAgPSBjb2x1bW4uaGVhZGVyQnVpbGRlcihjb2x1bW4sIGlzU3ViSGVhZGVyKSkgPyBcIlwiIDogamFkZV9pbnRlcnApO1xufVxuZWxzZVxue1xuaWYgKCBjb2x1bW4uJG9yZGVyYnkpXG57XG5pZiAoIGNvbHVtbi4kb3JkZXJieS5kaXIgPiAwKVxue1xuYnVmLnB1c2goXCI8c3BhbiBjbGFzcz1cXFwiZ3JpZC1hc2NcXFwiPjwvc3Bhbj5cIik7XG59XG5lbHNlXG57XG5idWYucHVzaChcIjxzcGFuIGNsYXNzPVxcXCJncmlkLWRlc1xcXCI+PC9zcGFuPlwiKTtcbn1cbn1cbmlmICggKGNvbHVtbiAmJiBjb2x1bW4uJGh0bWwpKVxue1xuYnVmLnB1c2gobnVsbCA9PSAoamFkZV9pbnRlcnAgPSBjb2x1bW4uJGh0bWwpID8gXCJcIiA6IGphZGVfaW50ZXJwKTtcbn1cbmVsc2VcbntcbmlmICggaXNTdWJIZWFkZXIgJiYgY29sdW1uLmNvbmZpZy5zdWJDb2xUaXRsZSlcbntcbmJ1Zi5wdXNoKGphZGUuZXNjYXBlKG51bGwgPT0gKGphZGVfaW50ZXJwID0gY29sdW1uLmNvbmZpZy5zdWJDb2xUaXRsZSkgPyBcIlwiIDogamFkZV9pbnRlcnApKTtcbn1cbmVsc2VcbntcbmJ1Zi5wdXNoKGphZGUuZXNjYXBlKG51bGwgPT0gKGphZGVfaW50ZXJwID0gKHR5cGVvZiBjb2x1bW4uJHRleHQgIT0gJ3VuZGVmaW5lZCcpPyBjb2x1bW4uJHRleHQgOiAoY29sdW1uLnByb3BlcnR5IHx8IGNvbHVtbikpID8gXCJcIiA6IGphZGVfaW50ZXJwKSk7XG59XG59XG59XG59O1xuamFkZV9taXhpbnNbXCJ0aFwiXSA9IGphZGVfaW50ZXJwID0gZnVuY3Rpb24oY29sdW1uLCBoYXNHcm91cCwgaXNTdWJDb2x1bW4pe1xudmFyIGJsb2NrID0gKHRoaXMgJiYgdGhpcy5ibG9jayksIGF0dHJpYnV0ZXMgPSAodGhpcyAmJiB0aGlzLmF0dHJpYnV0ZXMpIHx8IHt9O1xudmFyIGF0dHIgPSAoY29sdW1uLiRtZXRhZGF0YSB8fCB7fSlbJ2F0dHIuaGVhZCddIHx8IHt9XG52YXIgY29sTmFtZSA9IGNvbHVtbi5jb25maWcgJiYgY29sdW1uLmNvbmZpZy5uYW1lIHx8ICcnO1xudmFyIGNscyA9IFtdO1xuaWYgKCAoY29sTmFtZSkpXG57XG5jbHMucHVzaCgnY29sLScgKyBjb2xOYW1lKTtcbn1cbmlmICggY29sdW1uLnNvcnRhYmxlKVxue1xuY2xzLnB1c2goJ3NvcnRhYmxlJyk7XG59XG5pZiAoIGNvbHVtbi4kb3JkZXJieSlcbntcbmNscy5wdXNoKCdvcmRlcmJ5Jyk7XG59XG5jbHMgPSBjbHMuam9pbignICcpO1xuaWYgKCBpc1N1YkNvbHVtbiApXG57XG52YXIgY29sc3BhbiA9IDEsIHJvd3NwYW4gPSAxO1xuYnVmLnB1c2goXCI8dGhcIiArIChqYWRlLmF0dHJzKGphZGUubWVyZ2UoW3tcImNvbHNwYW5cIjogamFkZS5lc2NhcGUoY29sc3BhbiksXCJyb3dzcGFuXCI6IGphZGUuZXNjYXBlKHJvd3NwYW4pLFwiY2xhc3NcIjogKGphZGVfaW50ZXJwID0gW3RydWVdLCBqYWRlLmpvaW5DbGFzc2VzKFtjbHNdLm1hcChqYWRlLmpvaW5DbGFzc2VzKS5tYXAoZnVuY3Rpb24gKGNscywgaSkgeyAgIHJldHVybiBqYWRlX2ludGVycFtpXSA/IGphZGUuZXNjYXBlKGNscykgOiBjbHMgfSkpKX0sYXR0cmlidXRlcyxhdHRyXSksIHRydWUpKSArIFwiPlwiKTtcbmphZGVfbWl4aW5zW1wiY29sdW1uSGVhZGVyXCJdKGNvbHVtbiwgdHJ1ZSk7XG5idWYucHVzaChcIjwvdGg+XCIpO1xufVxuZWxzZSBpZiAoIGhhc0dyb3VwICYmIGNvbHVtbi5ncm91cEV4cGFuc2lvbilcbntcbnZhciBjb2xzcGFuID0gY29sdW1uLmdyb3VwLmxlbmd0aCwgcm93c3BhbiA9IDE7XG5idWYucHVzaChcIjx0aFwiICsgKGphZGUuYXR0cnMoamFkZS5tZXJnZShbe1wiY29sc3BhblwiOiBqYWRlLmVzY2FwZShjb2xzcGFuKSxcInJvd3NwYW5cIjogamFkZS5lc2NhcGUocm93c3BhbiksXCJjbGFzc1wiOiAoamFkZV9pbnRlcnAgPSBbdHJ1ZV0sIGphZGUuam9pbkNsYXNzZXMoW2Nsc10ubWFwKGphZGUuam9pbkNsYXNzZXMpLm1hcChmdW5jdGlvbiAoY2xzLCBpKSB7ICAgcmV0dXJuIGphZGVfaW50ZXJwW2ldID8gamFkZS5lc2NhcGUoY2xzKSA6IGNscyB9KSkpfSxhdHRyaWJ1dGVzLGF0dHJdKSwgdHJ1ZSkpICsgXCI+PHNwYW4gY2xhc3M9XFxcInBvcC1jb2xsYXBzZSBnbHlwaGljb24gZ2x5cGhpY29uLW1pbnVzXFxcIj48L3NwYW4+PGRpdj5cIik7XG5qYWRlX21peGluc1tcImNvbHVtbkhlYWRlclwiXShjb2x1bW4pO1xuYnVmLnB1c2goXCI8L2Rpdj48L3RoPlwiKTtcbn1cbmVsc2UgaWYgKCBoYXNHcm91cCAmJiBjb2x1bW4uZ3JvdXApXG57XG52YXIgY29sc3BhbiA9IDEsIHJvd3NwYW4gPSAyO1xuYnVmLnB1c2goXCI8dGhcIiArIChqYWRlLmF0dHJzKGphZGUubWVyZ2UoW3tcImNvbHNwYW5cIjogamFkZS5lc2NhcGUoY29sc3BhbiksXCJyb3dzcGFuXCI6IGphZGUuZXNjYXBlKHJvd3NwYW4pLFwiY2xhc3NcIjogKGphZGVfaW50ZXJwID0gW3RydWVdLCBqYWRlLmpvaW5DbGFzc2VzKFtjbHNdLm1hcChqYWRlLmpvaW5DbGFzc2VzKS5tYXAoZnVuY3Rpb24gKGNscywgaSkgeyAgIHJldHVybiBqYWRlX2ludGVycFtpXSA/IGphZGUuZXNjYXBlKGNscykgOiBjbHMgfSkpKX0sYXR0cmlidXRlcyxhdHRyXSksIHRydWUpKSArIFwiPjxzcGFuIGNsYXNzPVxcXCJwb3AtZXhwYW5kIGdseXBoaWNvbiBnbHlwaGljb24tcGx1c1xcXCI+PC9zcGFuPjxkaXY+XCIpO1xuamFkZV9taXhpbnNbXCJjb2x1bW5IZWFkZXJcIl0oY29sdW1uKTtcbmJ1Zi5wdXNoKFwiPC9kaXY+PC90aD5cIik7XG59XG5lbHNlXG57XG52YXIgY29sc3BhbiA9IDEsIHJvd3NwYW4gPSAyO1xuYnVmLnB1c2goXCI8dGhcIiArIChqYWRlLmF0dHJzKGphZGUubWVyZ2UoW3tcImNvbHNwYW5cIjogamFkZS5lc2NhcGUoY29sc3BhbiksXCJyb3dzcGFuXCI6IGphZGUuZXNjYXBlKHJvd3NwYW4pLFwiY2xhc3NcIjogKGphZGVfaW50ZXJwID0gW3RydWVdLCBqYWRlLmpvaW5DbGFzc2VzKFtjbHNdLm1hcChqYWRlLmpvaW5DbGFzc2VzKS5tYXAoZnVuY3Rpb24gKGNscywgaSkgeyAgIHJldHVybiBqYWRlX2ludGVycFtpXSA/IGphZGUuZXNjYXBlKGNscykgOiBjbHMgfSkpKX0sYXR0cmlidXRlcyxhdHRyXSksIHRydWUpKSArIFwiPlwiKTtcbmphZGVfbWl4aW5zW1wiY29sdW1uSGVhZGVyXCJdKGNvbHVtbik7XG5idWYucHVzaChcIjwvdGg+XCIpO1xufVxufTtcbmphZGVfbWl4aW5zW1widGRcIl0gPSBqYWRlX2ludGVycCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKXtcbnZhciBibG9jayA9ICh0aGlzICYmIHRoaXMuYmxvY2spLCBhdHRyaWJ1dGVzID0gKHRoaXMgJiYgdGhpcy5hdHRyaWJ1dGVzKSB8fCB7fTtcbnZhciBhdHRyID0gKGNvbHVtbi4kbWV0YWRhdGEgfHwge30pWydhdHRyLmJvZHknXSB8fCB7fVxudmFyIGNvbE5hbWUgPSBjb2x1bW4uY29uZmlnICYmIGNvbHVtbi5jb25maWcubmFtZSB8fCAnJztcbnZhciBjbHMgPSBjb2xOYW1lID8gJ2NvbC0nICsgY29sTmFtZSA6ICcnO1xuYnVmLnB1c2goXCI8dGRcIiArIChqYWRlLmF0dHJzKGphZGUubWVyZ2UoW3tcImNsYXNzXCI6IChqYWRlX2ludGVycCA9IFt0cnVlXSwgamFkZS5qb2luQ2xhc3NlcyhbY2xzXS5tYXAoamFkZS5qb2luQ2xhc3NlcykubWFwKGZ1bmN0aW9uIChjbHMsIGkpIHsgICByZXR1cm4gamFkZV9pbnRlcnBbaV0gPyBqYWRlLmVzY2FwZShjbHMpIDogY2xzIH0pKSl9LGF0dHJpYnV0ZXMsYXR0cl0pLCB0cnVlKSkgKyBcIj5cIik7XG52YXIgcmVzID0gcm93W2NvbHVtbi5wcm9wZXJ0eV1cbmlmICggKHJlcyAmJiByZXMuJGh0bWwpKVxue1xuYnVmLnB1c2gobnVsbCA9PSAoamFkZV9pbnRlcnAgPSByZXMuJGh0bWwpID8gXCJcIiA6IGphZGVfaW50ZXJwKTtcbn1cbmVsc2VcbntcbmJ1Zi5wdXNoKGphZGUuZXNjYXBlKG51bGwgPT0gKGphZGVfaW50ZXJwID0gcmVzKSA/IFwiXCIgOiBqYWRlX2ludGVycCkpO1xufVxuYnVmLnB1c2goXCI8L3RkPlwiKTtcbn07XG5idWYucHVzaChcIjx0YWJsZVwiICsgKGphZGUuYXR0cnMoamFkZS5tZXJnZShbe1wicm9sZVwiOiBcImdyaWRcIixcImNsYXNzXCI6IFwidGFibGUgdGFibGUtaG92ZXIgZ3JpZFwifSwkbWV0YWRhdGEgfHwge31dKSwgdHJ1ZSkpICsgXCI+XCIpO1xuaWYgKCAhaGlkZUhlYWRlcnMpXG57XG5idWYucHVzaChcIjx0aGVhZD5cIik7XG5pZiAoIGlzQXBwbHlHcm91cCAmJiBzdWJTZWxlY3QubGVuZ3RoID09PSAwKVxue1xuYnVmLnB1c2goXCI8dHIgY2xhc3M9XFxcInRhYmxlX19yb3ctLWhlYWRlclxcXCI+XCIpO1xuLy8gaXRlcmF0ZSBsb2NhbHNbJ3NlbGVjdCddIHx8IFtdXG47KGZ1bmN0aW9uKCl7XG4gIHZhciAkJG9iaiA9IGxvY2Fsc1snc2VsZWN0J10gfHwgW107XG4gIGlmICgnbnVtYmVyJyA9PSB0eXBlb2YgJCRvYmoubGVuZ3RoKSB7XG5cbiAgICBmb3IgKHZhciAkaW5kZXggPSAwLCAkJGwgPSAkJG9iai5sZW5ndGg7ICRpbmRleCA8ICQkbDsgJGluZGV4KyspIHtcbiAgICAgIHZhciBjb2x1bW5OYW1lID0gJCRvYmpbJGluZGV4XTtcblxuamFkZV9taXhpbnNbXCJ0aFwiXShjb2x1bW5zW2NvbHVtbk5hbWVdLCB0cnVlKTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB2YXIgJCRsID0gMDtcbiAgICBmb3IgKHZhciAkaW5kZXggaW4gJCRvYmopIHtcbiAgICAgICQkbCsrOyAgICAgIHZhciBjb2x1bW5OYW1lID0gJCRvYmpbJGluZGV4XTtcblxuamFkZV9taXhpbnNbXCJ0aFwiXShjb2x1bW5zW2NvbHVtbk5hbWVdLCB0cnVlKTtcbiAgICB9XG5cbiAgfVxufSkuY2FsbCh0aGlzKTtcblxuYnVmLnB1c2goXCI8L3RyPlwiKTtcbn1cbmVsc2UgaWYgKCBpc0FwcGx5R3JvdXApXG57XG5idWYucHVzaChcIjx0ciBjbGFzcz1cXFwidGFibGVfX3Jvdy0taGVhZGVyXFxcIj5cIik7XG4vLyBpdGVyYXRlIGxvY2Fsc1snc2VsZWN0J10gfHwgW11cbjsoZnVuY3Rpb24oKXtcbiAgdmFyICQkb2JqID0gbG9jYWxzWydzZWxlY3QnXSB8fCBbXTtcbiAgaWYgKCdudW1iZXInID09IHR5cGVvZiAkJG9iai5sZW5ndGgpIHtcblxuICAgIGZvciAodmFyICRpbmRleCA9IDAsICQkbCA9ICQkb2JqLmxlbmd0aDsgJGluZGV4IDwgJCRsOyAkaW5kZXgrKykge1xuICAgICAgdmFyIGNvbHVtbk5hbWUgPSAkJG9ialskaW5kZXhdO1xuXG5qYWRlX21peGluc1tcInRoXCJdKGNvbHVtbnNbY29sdW1uTmFtZV0sIHRydWUpO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHZhciAkJGwgPSAwO1xuICAgIGZvciAodmFyICRpbmRleCBpbiAkJG9iaikge1xuICAgICAgJCRsKys7ICAgICAgdmFyIGNvbHVtbk5hbWUgPSAkJG9ialskaW5kZXhdO1xuXG5qYWRlX21peGluc1tcInRoXCJdKGNvbHVtbnNbY29sdW1uTmFtZV0sIHRydWUpO1xuICAgIH1cblxuICB9XG59KS5jYWxsKHRoaXMpO1xuXG5idWYucHVzaChcIjwvdHI+PHRyIGNsYXNzPVxcXCJ0YWJsZV9fcm93LS1oZWFkZXIgdGFibGVfX3Jvdy0tc3ViLWhlYWRlclxcXCI+XCIpO1xuLy8gaXRlcmF0ZSBsb2NhbHNbJ3N1YlNlbGVjdCddXG47KGZ1bmN0aW9uKCl7XG4gIHZhciAkJG9iaiA9IGxvY2Fsc1snc3ViU2VsZWN0J107XG4gIGlmICgnbnVtYmVyJyA9PSB0eXBlb2YgJCRvYmoubGVuZ3RoKSB7XG5cbiAgICBmb3IgKHZhciAkaW5kZXggPSAwLCAkJGwgPSAkJG9iai5sZW5ndGg7ICRpbmRleCA8ICQkbDsgJGluZGV4KyspIHtcbiAgICAgIHZhciBjb2x1bW5OYW1lID0gJCRvYmpbJGluZGV4XTtcblxuamFkZV9taXhpbnNbXCJ0aFwiXShjb2x1bW5zW2NvbHVtbk5hbWVdLCB0cnVlLCB0cnVlKTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB2YXIgJCRsID0gMDtcbiAgICBmb3IgKHZhciAkaW5kZXggaW4gJCRvYmopIHtcbiAgICAgICQkbCsrOyAgICAgIHZhciBjb2x1bW5OYW1lID0gJCRvYmpbJGluZGV4XTtcblxuamFkZV9taXhpbnNbXCJ0aFwiXShjb2x1bW5zW2NvbHVtbk5hbWVdLCB0cnVlLCB0cnVlKTtcbiAgICB9XG5cbiAgfVxufSkuY2FsbCh0aGlzKTtcblxuYnVmLnB1c2goXCI8L3RyPlwiKTtcbn1cbmVsc2VcbntcbmJ1Zi5wdXNoKFwiPHRyIGNsYXNzPVxcXCJ0YWJsZV9fcm93LS1oZWFkZXJcXFwiPlwiKTtcbi8vIGl0ZXJhdGUgbG9jYWxzWydzZWxlY3QnXSB8fCBbXVxuOyhmdW5jdGlvbigpe1xuICB2YXIgJCRvYmogPSBsb2NhbHNbJ3NlbGVjdCddIHx8IFtdO1xuICBpZiAoJ251bWJlcicgPT0gdHlwZW9mICQkb2JqLmxlbmd0aCkge1xuXG4gICAgZm9yICh2YXIgJGluZGV4ID0gMCwgJCRsID0gJCRvYmoubGVuZ3RoOyAkaW5kZXggPCAkJGw7ICRpbmRleCsrKSB7XG4gICAgICB2YXIgY29sdW1uTmFtZSA9ICQkb2JqWyRpbmRleF07XG5cbmphZGVfbWl4aW5zW1widGhcIl0oY29sdW1uc1tjb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdmFyICQkbCA9IDA7XG4gICAgZm9yICh2YXIgJGluZGV4IGluICQkb2JqKSB7XG4gICAgICAkJGwrKzsgICAgICB2YXIgY29sdW1uTmFtZSA9ICQkb2JqWyRpbmRleF07XG5cbmphZGVfbWl4aW5zW1widGhcIl0oY29sdW1uc1tjb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbmJ1Zi5wdXNoKFwiPC90cj5cIik7XG59XG5idWYucHVzaChcIjwvdGhlYWQ+XCIpO1xufVxuYnVmLnB1c2goXCI8dGJvZHk+XCIpO1xuLy8gaXRlcmF0ZSB2YWx1ZVxuOyhmdW5jdGlvbigpe1xuICB2YXIgJCRvYmogPSB2YWx1ZTtcbiAgaWYgKCdudW1iZXInID09IHR5cGVvZiAkJG9iai5sZW5ndGgpIHtcblxuICAgIGZvciAodmFyIGkgPSAwLCAkJGwgPSAkJG9iai5sZW5ndGg7IGkgPCAkJGw7IGkrKykge1xuICAgICAgdmFyIHJvdyA9ICQkb2JqW2ldO1xuXG52YXIgYXR0ciA9IChyb3cuJG1ldGFkYXRhIHx8IHt9KS5hdHRyIHx8IHt9XG5idWYucHVzaChcIjx0clwiICsgKGphZGUuYXR0cnMoamFkZS5tZXJnZShbe1wiY2xhc3NcIjogXCJ0YWJsZV9fcm93LS1ib2R5XCJ9LGF0dHJdKSwgdHJ1ZSkpICsgXCI+XCIpO1xuLy8gaXRlcmF0ZSBsb2NhbHNbJ3NlbGVjdEV4cGFuZCddIHx8IGxvY2Fscy5zZWxlY3RcbjsoZnVuY3Rpb24oKXtcbiAgdmFyICQkb2JqID0gbG9jYWxzWydzZWxlY3RFeHBhbmQnXSB8fCBsb2NhbHMuc2VsZWN0O1xuICBpZiAoJ251bWJlcicgPT0gdHlwZW9mICQkb2JqLmxlbmd0aCkge1xuXG4gICAgZm9yICh2YXIgJGluZGV4ID0gMCwgJCRsID0gJCRvYmoubGVuZ3RoOyAkaW5kZXggPCAkJGw7ICRpbmRleCsrKSB7XG4gICAgICB2YXIgY29sdW1uTmFtZSA9ICQkb2JqWyRpbmRleF07XG5cbmphZGVfbWl4aW5zW1widGRcIl0ocm93LCBjb2x1bW5zW2NvbHVtbk5hbWVdKTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB2YXIgJCRsID0gMDtcbiAgICBmb3IgKHZhciAkaW5kZXggaW4gJCRvYmopIHtcbiAgICAgICQkbCsrOyAgICAgIHZhciBjb2x1bW5OYW1lID0gJCRvYmpbJGluZGV4XTtcblxuamFkZV9taXhpbnNbXCJ0ZFwiXShyb3csIGNvbHVtbnNbY29sdW1uTmFtZV0pO1xuICAgIH1cblxuICB9XG59KS5jYWxsKHRoaXMpO1xuXG5idWYucHVzaChcIjwvdHI+XCIpO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHZhciAkJGwgPSAwO1xuICAgIGZvciAodmFyIGkgaW4gJCRvYmopIHtcbiAgICAgICQkbCsrOyAgICAgIHZhciByb3cgPSAkJG9ialtpXTtcblxudmFyIGF0dHIgPSAocm93LiRtZXRhZGF0YSB8fCB7fSkuYXR0ciB8fCB7fVxuYnVmLnB1c2goXCI8dHJcIiArIChqYWRlLmF0dHJzKGphZGUubWVyZ2UoW3tcImNsYXNzXCI6IFwidGFibGVfX3Jvdy0tYm9keVwifSxhdHRyXSksIHRydWUpKSArIFwiPlwiKTtcbi8vIGl0ZXJhdGUgbG9jYWxzWydzZWxlY3RFeHBhbmQnXSB8fCBsb2NhbHMuc2VsZWN0XG47KGZ1bmN0aW9uKCl7XG4gIHZhciAkJG9iaiA9IGxvY2Fsc1snc2VsZWN0RXhwYW5kJ10gfHwgbG9jYWxzLnNlbGVjdDtcbiAgaWYgKCdudW1iZXInID09IHR5cGVvZiAkJG9iai5sZW5ndGgpIHtcblxuICAgIGZvciAodmFyICRpbmRleCA9IDAsICQkbCA9ICQkb2JqLmxlbmd0aDsgJGluZGV4IDwgJCRsOyAkaW5kZXgrKykge1xuICAgICAgdmFyIGNvbHVtbk5hbWUgPSAkJG9ialskaW5kZXhdO1xuXG5qYWRlX21peGluc1tcInRkXCJdKHJvdywgY29sdW1uc1tjb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdmFyICQkbCA9IDA7XG4gICAgZm9yICh2YXIgJGluZGV4IGluICQkb2JqKSB7XG4gICAgICAkJGwrKzsgICAgICB2YXIgY29sdW1uTmFtZSA9ICQkb2JqWyRpbmRleF07XG5cbmphZGVfbWl4aW5zW1widGRcIl0ocm93LCBjb2x1bW5zW2NvbHVtbk5hbWVdKTtcbiAgICB9XG5cbiAgfVxufSkuY2FsbCh0aGlzKTtcblxuYnVmLnB1c2goXCI8L3RyPlwiKTtcbiAgICB9XG5cbiAgfVxufSkuY2FsbCh0aGlzKTtcblxuYnVmLnB1c2goXCI8L3Rib2R5PjwvdGFibGU+XCIpO30uY2FsbCh0aGlzLFwiJG1ldGFkYXRhXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC4kbWV0YWRhdGE6dHlwZW9mICRtZXRhZGF0YSE9PVwidW5kZWZpbmVkXCI/JG1ldGFkYXRhOnVuZGVmaW5lZCxcImNvbHVtbnNcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLmNvbHVtbnM6dHlwZW9mIGNvbHVtbnMhPT1cInVuZGVmaW5lZFwiP2NvbHVtbnM6dW5kZWZpbmVkLFwiaGlkZUhlYWRlcnNcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLmhpZGVIZWFkZXJzOnR5cGVvZiBoaWRlSGVhZGVycyE9PVwidW5kZWZpbmVkXCI/aGlkZUhlYWRlcnM6dW5kZWZpbmVkLFwiaXNBcHBseUdyb3VwXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC5pc0FwcGx5R3JvdXA6dHlwZW9mIGlzQXBwbHlHcm91cCE9PVwidW5kZWZpbmVkXCI/aXNBcHBseUdyb3VwOnVuZGVmaW5lZCxcInN1YlNlbGVjdFwiIGluIGxvY2Fsc19mb3Jfd2l0aD9sb2NhbHNfZm9yX3dpdGguc3ViU2VsZWN0OnR5cGVvZiBzdWJTZWxlY3QhPT1cInVuZGVmaW5lZFwiP3N1YlNlbGVjdDp1bmRlZmluZWQsXCJ1bmRlZmluZWRcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLnVuZGVmaW5lZDp0eXBlb2YgdW5kZWZpbmVkIT09XCJ1bmRlZmluZWRcIj91bmRlZmluZWQ6dW5kZWZpbmVkLFwidmFsdWVcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLnZhbHVlOnR5cGVvZiB2YWx1ZSE9PVwidW5kZWZpbmVkXCI/dmFsdWU6dW5kZWZpbmVkKSk7O3JldHVybiBidWYuam9pbihcIlwiKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2pzL2xheW91dC90ZW1wbGF0ZS90YWJsZS5qYWRlXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZXJnZSB0d28gYXR0cmlidXRlIG9iamVjdHMgZ2l2aW5nIHByZWNlZGVuY2VcbiAqIHRvIHZhbHVlcyBpbiBvYmplY3QgYGJgLiBDbGFzc2VzIGFyZSBzcGVjaWFsLWNhc2VkXG4gKiBhbGxvd2luZyBmb3IgYXJyYXlzIGFuZCBtZXJnaW5nL2pvaW5pbmcgYXBwcm9wcmlhdGVseVxuICogcmVzdWx0aW5nIGluIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBhdHRycyA9IGFbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhdHRycyA9IG1lcmdlKGF0dHJzLCBhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG4gIHZhciBhYyA9IGFbJ2NsYXNzJ107XG4gIHZhciBiYyA9IGJbJ2NsYXNzJ107XG5cbiAgaWYgKGFjIHx8IGJjKSB7XG4gICAgYWMgPSBhYyB8fCBbXTtcbiAgICBiYyA9IGJjIHx8IFtdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhYykpIGFjID0gW2FjXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYmMpKSBiYyA9IFtiY107XG4gICAgYVsnY2xhc3MnXSA9IGFjLmNvbmNhdChiYykuZmlsdGVyKG51bGxzKTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgaWYgKGtleSAhPSAnY2xhc3MnKSB7XG4gICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIEZpbHRlciBudWxsIGB2YWxgcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG51bGxzKHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGwgJiYgdmFsICE9PSAnJztcbn1cblxuLyoqXG4gKiBqb2luIGFycmF5IGFzIGNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5qb2luQ2xhc3NlcyA9IGpvaW5DbGFzc2VzO1xuZnVuY3Rpb24gam9pbkNsYXNzZXModmFsKSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsLm1hcChqb2luQ2xhc3NlcykgOlxuICAgICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpID8gT2JqZWN0LmtleXModmFsKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdmFsW2tleV07IH0pIDpcbiAgICBbdmFsXSkuZmlsdGVyKG51bGxzKS5qb2luKCcgJyk7XG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSBnaXZlbiBjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGNsYXNzZXNcbiAqIEBwYXJhbSB7QXJyYXkuPEJvb2xlYW4+fSBlc2NhcGVkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuY2xzID0gZnVuY3Rpb24gY2xzKGNsYXNzZXMsIGVzY2FwZWQpIHtcbiAgdmFyIGJ1ZiA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZXNjYXBlZCAmJiBlc2NhcGVkW2ldKSB7XG4gICAgICBidWYucHVzaChleHBvcnRzLmVzY2FwZShqb2luQ2xhc3NlcyhbY2xhc3Nlc1tpXV0pKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5wdXNoKGpvaW5DbGFzc2VzKGNsYXNzZXNbaV0pKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRleHQgPSBqb2luQ2xhc3NlcyhidWYpO1xuICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gJyBjbGFzcz1cIicgKyB0ZXh0ICsgJ1wiJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cblxuZXhwb3J0cy5zdHlsZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWwpLm1hcChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIHJldHVybiBzdHlsZSArICc6JyArIHZhbFtzdHlsZV07XG4gICAgfSkuam9pbignOycpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbn07XG4vKipcbiAqIFJlbmRlciB0aGUgZ2l2ZW4gYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZXNjYXBlZFxuICogQHBhcmFtIHtCb29sZWFufSB0ZXJzZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmF0dHIgPSBmdW5jdGlvbiBhdHRyKGtleSwgdmFsLCBlc2NhcGVkLCB0ZXJzZSkge1xuICBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgdmFsID0gZXhwb3J0cy5zdHlsZSh2YWwpO1xuICB9XG4gIGlmICgnYm9vbGVhbicgPT0gdHlwZW9mIHZhbCB8fCBudWxsID09IHZhbCkge1xuICAgIGlmICh2YWwpIHtcbiAgICAgIHJldHVybiAnICcgKyAodGVyc2UgPyBrZXkgOiBrZXkgKyAnPVwiJyArIGtleSArICdcIicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9IGVsc2UgaWYgKDAgPT0ga2V5LmluZGV4T2YoJ2RhdGEnKSAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB7XG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KHZhbCkuaW5kZXhPZignJicpICE9PSAtMSkge1xuICAgICAgY29uc29sZS53YXJuKCdTaW5jZSBKYWRlIDIuMC4wLCBhbXBlcnNhbmRzIChgJmApIGluIGRhdGEgYXR0cmlidXRlcyAnICtcbiAgICAgICAgICAgICAgICAgICAnd2lsbCBiZSBlc2NhcGVkIHRvIGAmYW1wO2AnKTtcbiAgICB9O1xuICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbC50b0lTT1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKCdKYWRlIHdpbGwgZWxpbWluYXRlIHRoZSBkb3VibGUgcXVvdGVzIGFyb3VuZCBkYXRlcyBpbiAnICtcbiAgICAgICAgICAgICAgICAgICAnSVNPIGZvcm0gYWZ0ZXIgMi4wLjAnKTtcbiAgICB9XG4gICAgcmV0dXJuICcgJyArIGtleSArIFwiPSdcIiArIEpTT04uc3RyaW5naWZ5KHZhbCkucmVwbGFjZSgvJy9nLCAnJmFwb3M7JykgKyBcIidcIjtcbiAgfSBlbHNlIGlmIChlc2NhcGVkKSB7XG4gICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsLnRvSVNPU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0phZGUgd2lsbCBzdHJpbmdpZnkgZGF0ZXMgaW4gSVNPIGZvcm0gYWZ0ZXIgMi4wLjAnKTtcbiAgICB9XG4gICAgcmV0dXJuICcgJyArIGtleSArICc9XCInICsgZXhwb3J0cy5lc2NhcGUodmFsKSArICdcIic7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsLnRvSVNPU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0phZGUgd2lsbCBzdHJpbmdpZnkgZGF0ZXMgaW4gSVNPIGZvcm0gYWZ0ZXIgMi4wLjAnKTtcbiAgICB9XG4gICAgcmV0dXJuICcgJyArIGtleSArICc9XCInICsgdmFsICsgJ1wiJztcbiAgfVxufTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlc2NhcGVkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYXR0cnMgPSBmdW5jdGlvbiBhdHRycyhvYmosIHRlcnNlKXtcbiAgdmFyIGJ1ZiA9IFtdO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblxuICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgICAgICwgdmFsID0gb2JqW2tleV07XG5cbiAgICAgIGlmICgnY2xhc3MnID09IGtleSkge1xuICAgICAgICBpZiAodmFsID0gam9pbkNsYXNzZXModmFsKSkge1xuICAgICAgICAgIGJ1Zi5wdXNoKCcgJyArIGtleSArICc9XCInICsgdmFsICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5wdXNoKGV4cG9ydHMuYXR0cihrZXksIHZhbCwgZmFsc2UsIHRlcnNlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogRXNjYXBlIHRoZSBnaXZlbiBzdHJpbmcgb2YgYGh0bWxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgamFkZV9lbmNvZGVfaHRtbF9ydWxlcyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnXG59O1xudmFyIGphZGVfbWF0Y2hfaHRtbCA9IC9bJjw+XCJdL2c7XG5cbmZ1bmN0aW9uIGphZGVfZW5jb2RlX2NoYXIoYykge1xuICByZXR1cm4gamFkZV9lbmNvZGVfaHRtbF9ydWxlc1tjXSB8fCBjO1xufVxuXG5leHBvcnRzLmVzY2FwZSA9IGphZGVfZXNjYXBlO1xuZnVuY3Rpb24gamFkZV9lc2NhcGUoaHRtbCl7XG4gIHZhciByZXN1bHQgPSBTdHJpbmcoaHRtbCkucmVwbGFjZShqYWRlX21hdGNoX2h0bWwsIGphZGVfZW5jb2RlX2NoYXIpO1xuICBpZiAocmVzdWx0ID09PSAnJyArIGh0bWwpIHJldHVybiBodG1sO1xuICBlbHNlIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJlLXRocm93IHRoZSBnaXZlbiBgZXJyYCBpbiBjb250ZXh0IHRvIHRoZVxuICogdGhlIGphZGUgaW4gYGZpbGVuYW1lYCBhdCB0aGUgZ2l2ZW4gYGxpbmVub2AuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lbm9cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmV0aHJvdyA9IGZ1bmN0aW9uIHJldGhyb3coZXJyLCBmaWxlbmFtZSwgbGluZW5vLCBzdHIpe1xuICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHRocm93IGVycjtcbiAgaWYgKCh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnIHx8ICFmaWxlbmFtZSkgJiYgIXN0cikge1xuICAgIGVyci5tZXNzYWdlICs9ICcgb24gbGluZSAnICsgbGluZW5vO1xuICAgIHRocm93IGVycjtcbiAgfVxuICB0cnkge1xuICAgIHN0ciA9IHN0ciB8fCByZXF1aXJlKCdmcycpLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgJ3V0ZjgnKVxuICB9IGNhdGNoIChleCkge1xuICAgIHJldGhyb3coZXJyLCBudWxsLCBsaW5lbm8pXG4gIH1cbiAgdmFyIGNvbnRleHQgPSAzXG4gICAgLCBsaW5lcyA9IHN0ci5zcGxpdCgnXFxuJylcbiAgICAsIHN0YXJ0ID0gTWF0aC5tYXgobGluZW5vIC0gY29udGV4dCwgMClcbiAgICAsIGVuZCA9IE1hdGgubWluKGxpbmVzLmxlbmd0aCwgbGluZW5vICsgY29udGV4dCk7XG5cbiAgLy8gRXJyb3IgY29udGV4dFxuICB2YXIgY29udGV4dCA9IGxpbmVzLnNsaWNlKHN0YXJ0LCBlbmQpLm1hcChmdW5jdGlvbihsaW5lLCBpKXtcbiAgICB2YXIgY3VyciA9IGkgKyBzdGFydCArIDE7XG4gICAgcmV0dXJuIChjdXJyID09IGxpbmVubyA/ICcgID4gJyA6ICcgICAgJylcbiAgICAgICsgY3VyclxuICAgICAgKyAnfCAnXG4gICAgICArIGxpbmU7XG4gIH0pLmpvaW4oJ1xcbicpO1xuXG4gIC8vIEFsdGVyIGV4Y2VwdGlvbiBtZXNzYWdlXG4gIGVyci5wYXRoID0gZmlsZW5hbWU7XG4gIGVyci5tZXNzYWdlID0gKGZpbGVuYW1lIHx8ICdKYWRlJykgKyAnOicgKyBsaW5lbm9cbiAgICArICdcXG4nICsgY29udGV4dCArICdcXG5cXG4nICsgZXJyLm1lc3NhZ2U7XG4gIHRocm93IGVycjtcbn07XG5cbmV4cG9ydHMuRGVidWdJdGVtID0gZnVuY3Rpb24gRGVidWdJdGVtKGxpbmVubywgZmlsZW5hbWUpIHtcbiAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG4gIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9qYWRlL2xpYi9ydW50aW1lLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZnMgKGlnbm9yZWQpXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIEZpeGVkSGVhZGVyOiByZXF1aXJlKCcuL2ZpeGVkLWhlYWRlcicpLFxyXG4gIFZpcnR1YWxpemF0aW9uOiByZXF1aXJlKCcuL3ZpcnR1YWxpemF0aW9uJyksXHJcbn07XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvbGF5b3V0L3JlbmRlcmVyL2luZGV4LmpzXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL2pxdWVyeScsXHJcbiAgJ2xpYi91bmRlcnNjb3JlJyxcclxuICAnY29tcG9uZW50L2dyaWQvbGF5b3V0L21lYXN1cmUnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9sYXlvdXQvcHgnLFxyXG5dLCBmdW5jdGlvbiAoJCwgXywgbWVhc3VyZSwgcHgpIHtcclxuICB2YXIgc3RhdGUgPSAnbm9ybWFsJztcclxuXHJcbiAgZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICB0aGlzLm5hbWUgPSAnZml4ZWQtaGVhZGVyJztcclxuICAgIHRoaXMubGF5b3V0ID0gdGhpcy5vcHRpb25zLmxheW91dDtcclxuICAgIHRoaXMuYWRqdXN0Q29sdW1uV2lkdGggPSAoKSA9PiB7XHJcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5mcmVlemVDb2x1bW5XaWR0aCkpIHtcclxuICAgICAgICB0aGlzLmZyZWV6ZUNvbHVtbldpZHRoKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZScsIHRoaXMuYWRqdXN0Q29sdW1uV2lkdGgpO1xyXG4gIH1cclxuXHJcbiAgUmVuZGVyZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoZGF0YSwgY2IpIHtcclxuICAgIHZhciBuZXdTdGF0ZSA9ICdub3JtYWwnO1xyXG5cclxuICAgIGRhdGEudnBNZWFzdXJlcyA9IG1lYXN1cmUudmlld3BvcnQuY2FsbCh0aGlzLmxheW91dCk7XHJcblxyXG4gICAgLy8gVE9ETyBbd2V3ZWldIHRoaXMgaXMgYSBoYWNrIHRvIHRlbXBvcmFyaWx5IHNvbHZlIHRoZSBzdGlja3kgaGVhZGVyIGRvZXNuJ3RcclxuICAgIC8vIHJlc3BlY3QgdGhlIG5hdmJhciBwcm9ibGVtLlxyXG4gICAgLy8gV2UgbmVlZCBhIGJldHRlciBzb2x1dGlvbiBvbiB0aGlzLlxyXG4gICAgaWYgKGRhdGEudnBNZWFzdXJlcy52aWV3cG9ydFRvcCArICh0aGlzLmxheW91dC50b3AgfHwgMCkgPiBkYXRhLnZwTWVhc3VyZXMuYm91bmRzVG9wKSB7XHJcbiAgICAgIHZhciAkZWwgPSB0aGlzLmxheW91dC4kZWw7XHJcblxyXG4gICAgICBuZXdTdGF0ZSA9ICdzdGlja3knO1xyXG4gICAgICAvLyB0b2RvIFtha2FtZWxdIGFzc3VtZXMgd2UgaGF2ZSB0YWJsZSByZW5kZXJlZDsgbWVhc3VyZS9lc3RpbWF0ZSBvdGhlcndpc2VcclxuXHJcbiAgICAgIC8vIGEuIGNvbXBlbnNhdGUgZm9yIGhlYWRlciBkaXNwbGFjZW1lbnRcclxuICAgICAgLy8gLi4gYXMgd2Ugc2V0ICd0aGVhZCA+IHRyJyBjc3MgcG9zaXRpb24gJ2Fic29sdXRlJ1xyXG4gICAgICB2YXIgZGlzcGxhY2VtZW50ID0gJGVsLmZpbmQoJ3RoZWFkIHRyJykub3V0ZXJIZWlnaHQoKTtcclxuICAgICAgXy5leHRlbmQoZGF0YS5jc3MsIHtcclxuICAgICAgICAncGFkZGluZy10b3AnOiBweC5waXhlbGlmeShweC5wYXJzZShkYXRhLmNzc1sncGFkZGluZy10b3AnXSkgKyBkaXNwbGFjZW1lbnQpLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGRhdGEuY2FuU2tpcERyYXcgPSB0cnVlO1xyXG5cclxuICAgICAgLy8gYi4geWllbGQgdG8gcmVuZGVyXHJcbiAgICAgIGNiKHVuZGVmaW5lZCwgZGF0YSk7XHJcblxyXG4gICAgICAvLyBjLiBnZXQgbmV3bHkgcmVuZGVyZWQgaGVhZGVyXHJcbiAgICAgIHZhciAkdGhlYWQgPSAkZWwuZmluZCgndGhlYWQnKTtcclxuICAgICAgdmFyICRoZWFkVFIgPSAkZWwuZmluZCgndGhlYWQgPiB0cicpO1xyXG4gICAgICB2YXIgJGhlYWRURCA9ICRoZWFkVFIuZmlyc3QoKS5jaGlsZHJlbigpO1xyXG4gICAgICB2YXIgJHNlY29uZEhlYWRURCA9ICRoZWFkVFIuZXEoMSkuY2hpbGRyZW4oKTtcclxuICAgICAgdmFyICRib2R5VEQgPSAkZWwuZmluZCgndGJvZHkgPiB0cjpmaXJzdC1jaGlsZCcpLmNoaWxkcmVuKCk7XHJcblxyXG4gICAgICB2YXIgJHJlZiA9ICRib2R5VEQ7XHJcbiAgICAgIHZhciAkdGFyZ2V0ID0gJGhlYWRURDtcclxuXHJcbiAgICAgIHRoaXMuZnJlZXplQ29sdW1uV2lkdGggPSAoKSA9PiB7XHJcbiAgICAgICAgLy8gZC4gY2FwdHVyZSBoZWFkZXIgY29sIGNvbXB1dGVkIHdpZHRoXHJcbiAgICAgICAgLy8gdG9kbyBbYWthbWVsXSBbcGVyZl0gMTYlXHJcbiAgICAgICAgdGhpcy5jb2xXaWR0aCA9IHRoaXMuY29sV2lkdGggfHwgXy5tYXAoJHJlZiwgZnVuY3Rpb24gKHRkKSB7XHJcbiAgICAgICAgICByZXR1cm4gJCh0ZCkud2lkdGgoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gdG9kbyBbYWthbWVsXSBbcGVyZl0gMTIlIC0tIGNvbnNpZGVyIHJlcGxhY2luZyB3aXRoIGNzcyBydWxlIGdlbmVyYXRpb25cclxuICAgICAgICAvLyBlLiBmcmVlemUgY29sdW1uIHdpZHRoXHJcbiAgICAgICAgLy8gZS4xIGZyZWV6ZSBjb2wgd2lkdGhcclxuICAgICAgICB2YXIgY29sSW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBzZWNvbmRIZWFkVERJbmRleCA9IDA7XHJcbiAgICAgICAgXy5lYWNoKCR0YXJnZXQsIGZ1bmN0aW9uICh0ZCkge1xyXG4gICAgICAgICAgdmFyIGNvbHNwYW4gPSBwYXJzZUludCgkKHRkKS5hdHRyKCdjb2xzcGFuJyksIDEwKTtcclxuICAgICAgICAgIHZhciByb3dzcGFuID0gcGFyc2VJbnQoJCh0ZCkuYXR0cigncm93c3BhbicpLCAxMCk7XHJcbiAgICAgICAgICB2YXIgd2lkdGggPSAwO1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xzcGFuOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGNvbFdpZHRoID0gcHgucGl4ZWxpZnkodGhpcy5jb2xXaWR0aFtjb2xJbmRleCArIGldKTtcclxuICAgICAgICAgICAgd2lkdGggKz0gY29sV2lkdGg7XHJcbiAgICAgICAgICAgIGlmIChyb3dzcGFuID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgJHNlY29uZEhlYWRURC5lcShzZWNvbmRIZWFkVERJbmRleCArIGkpLndpZHRoKGNvbFdpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgJCh0ZCkud2lkdGgod2lkdGgpO1xyXG4gICAgICAgICAgY29sSW5kZXggKz0gY29sc3BhbjtcclxuICAgICAgICAgIGlmIChyb3dzcGFuID09PSAxKSB7XHJcbiAgICAgICAgICAgIHNlY29uZEhlYWRUREluZGV4ICs9IGNvbHNwYW47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgXy5lYWNoKCRyZWYsIGZ1bmN0aW9uICh0ZCwgaW5kZXgpIHtcclxuICAgICAgICAgICQodGQpLndpZHRoKHB4LnBpeGVsaWZ5KHRoaXMuY29sV2lkdGhbaW5kZXhdKSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuZnJlZXplQ29sdW1uV2lkdGgoKTtcclxuXHJcbiAgICAgIC8vIGYuIHNldCBwb3NpdGlvbiAnZml4ZWQnIGFuZCBsb2NrIGhlYWRlciBhdCB0b3Agb2YgdGFibGVcclxuICAgICAgJHRoZWFkLmNzcyh7XHJcbiAgICAgICAgJ3Bvc2l0aW9uJzogdGhpcy5sYXlvdXQuY29udGFpbmVyLmVsID09PSB3aW5kb3cgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyxcclxuICAgICAgICAndG9wJzogcHgucGl4ZWxpZnkodGhpcy5sYXlvdXQuY29udGFpbmVyLmVsID09PSB3aW5kb3cgPyAwIDogdGhpcy5sYXlvdXQuY29udGFpbmVyLiRlbC5zY3JvbGxUb3AoKSksXHJcbiAgICAgICAgJ21hcmdpbi1sZWZ0JzogcHgucGl4ZWxpZnkoLWRhdGEudnBNZWFzdXJlcy5vZmZzZXRMZWZ0KSxcclxuICAgICAgICAnei1pbmRleCc6IDEwMDAsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbmV3U3RhdGUgPSAnbm9ybWFsJztcclxuXHJcbiAgICAgIF8uZXh0ZW5kKGRhdGEuY3NzLCB7XHJcbiAgICAgICAgJ3BhZGRpbmctdG9wJzogcHgucGl4ZWxpZnkocHgucGFyc2UoZGF0YS5jc3NbJ3BhZGRpbmctdG9wJ10pKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjYih1bmRlZmluZWQsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0ZSAhPT0gbmV3U3RhdGUpIHtcclxuICAgICAgdGhpcy5sYXlvdXQuZ3JpZC50cmlnZ2VyKCdjaGFuZ2U6aGVhZGVyLXN0YXRlJywgbmV3U3RhdGUpO1xyXG4gICAgICBzdGF0ZSA9IG5ld1N0YXRlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIFJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUnLCB0aGlzLmFkanVzdENvbHVtbldpZHRoKTtcclxuICB9O1xyXG5cclxuICBSZW5kZXJlci5wYXJ0aWFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobykge1xyXG4gICAgICByZXR1cm4gbmV3IFJlbmRlcmVyKF8uZGVmYXVsdHMoe30sIG8sIG9wdGlvbnMpKTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFJlbmRlcmVyO1xyXG59KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy9sYXlvdXQvcmVuZGVyZXIvZml4ZWQtaGVhZGVyLmpzXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL2pxdWVyeScsXHJcbiAgJ2xpYi91bmRlcnNjb3JlJyxcclxuXSwgZnVuY3Rpb24gKCQsIF8pIHtcclxuICBmdW5jdGlvbiB2aWV3cG9ydChlbCwgY29udGFpbmVyKSB7XHJcbiAgICB2YXIgJGVsID0gZWwgPyAkKGVsKSA6IHRoaXMuJGVsO1xyXG5cclxuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCB0aGlzLmNvbnRhaW5lcjtcclxuICAgIHZhciAkdmlld3BvcnQgPSBjb250YWluZXIuJGVsO1xyXG5cclxuICAgIHZhciB2aWV3cG9ydFRvcCA9ICR2aWV3cG9ydC5zY3JvbGxUb3AoKTtcclxuICAgIHZhciB2aWV3cG9ydEJvdHRvbSA9IHZpZXdwb3J0VG9wICsgJHZpZXdwb3J0LmhlaWdodCgpO1xyXG4gICAgdmFyIHZpZXdwb3J0TGVmdCA9ICR2aWV3cG9ydC5zY3JvbGxMZWZ0KCk7XHJcblxyXG4gICAgdmFyIGJvdW5kc1RvcCA9IGNvbnRhaW5lci5vZmZzZXQoJGVsKS50b3A7XHJcbiAgICB2YXIgYm91bmRzQm90dG9tID0gYm91bmRzVG9wICsgJGVsLmlubmVySGVpZ2h0KCk7XHJcbiAgICAvLyB2YXIgYm91bmRzTGVmdCA9ICRlbC5vZmZzZXQoKS5sZWZ0O1xyXG5cclxuICAgIHZhciB2aXNpYmxlVG9wID0gTWF0aC5tYXgoYm91bmRzVG9wLCB2aWV3cG9ydFRvcCk7XHJcbiAgICB2YXIgdmlzaWJsZUJvdHRvbSA9IE1hdGgubWluKGJvdW5kc0JvdHRvbSwgdmlld3BvcnRCb3R0b20pO1xyXG4gICAgLy8gdmFyIHZpc2libGVMZWZ0ID0gTWF0aC5tYXgoYm91bmRzTGVmdCwgdmlld3BvcnRMZWZ0KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBib3VuZHNUb3A6IGJvdW5kc1RvcCxcclxuICAgICAgdmlld3BvcnRUb3A6IHZpZXdwb3J0VG9wLFxyXG4gICAgICB0b3A6IHZpc2libGVUb3AgLSBib3VuZHNUb3AsXHJcbiAgICAgIGJvdHRvbTogdmlzaWJsZUJvdHRvbSAtIGJvdW5kc1RvcCxcclxuICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRMZWZ0LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRpbWVuc2lvbnMoZWwpIHtcclxuICAgIHZhciAkZWwgPSBlbCA/ICQoZWwpIDogdGhpcy4kZWw7XHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIGhlaWdodHNcclxuICAgIC8vIGEuIGhlYWRlclxyXG4gICAgdmFyIHJldCA9IHtcclxuICAgICAgcm93czogW10sXHJcbiAgICAgIHRoZWFkOiAkZWwuZmluZCgndGhlYWQgPiB0cicpLm91dGVySGVpZ2h0KCksXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGIuIGtlZXAgcm93IGluZm9cclxuICAgICRlbC5maW5kKCd0Ym9keScpLmNoaWxkcmVuKCd0cicpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXQucm93cy5wdXNoKCQodGhpcykub3V0ZXJIZWlnaHQoKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBjLiB1cGRhdGUgYXZlcmFnZSByb3cgaGVpZ2h0XHJcbiAgICB2YXIgYXZnID0gXy5yZWR1Y2UocmV0LnJvd3MsIGZ1bmN0aW9uIChtZW1vLCBudW0pIHtcclxuICAgICAgcmV0dXJuIG1lbW8gKyBudW07XHJcbiAgICB9LCAwKSAvIChyZXQucm93cy5sZW5ndGggPT09IDAgPyAxIDogcmV0LnJvd3MubGVuZ3RoKTtcclxuXHJcbiAgICByZXQuYXZnUm93SGVpZ2h0ID0gYXZnO1xyXG4gICAgcmV0LmVzdGltYXRlSGVpZ2h0ID0gKF8uc2l6ZSh0aGlzLmRhdGEudmFsdWUpICogYXZnKSArIHJldC50aGVhZDtcclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2FtcGxlKCkge1xyXG4gICAgLy8gYS4gcmVuZGVyIHRlc3QgcGFzc1xyXG4gICAgdmFyICR0bXBFbCA9ICQoJzxkaXYgc3R5bGU9XCJ2aXNpYmlsaXR5OmhpZGRlblwiIC8+Jyk7XHJcbiAgICB2YXIgc2FtcGxlID0gXy5maXJzdCh0aGlzLmRhdGEudmFsdWUsIDIwKTtcclxuXHJcbiAgICB0aGlzLiRlbC5hcHBlbmQoJHRtcEVsKTtcclxuXHJcbiAgICAkdG1wRWxbMF0uaW5uZXJIVE1MID0gdGhpcy50b0hUTUwoc2FtcGxlKTtcclxuXHJcbiAgICAvLyBiLiB0YWtlIG1lYXN1cmVzXHJcbiAgICB2YXIgcmV0ID0gZGltZW5zaW9ucy5jYWxsKHRoaXMsICR0bXBFbCk7XHJcblxyXG4gICAgLy8gYy4gY2xlYW4tdXBcclxuICAgICR0bXBFbC5yZW1vdmUoKTtcclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcclxuICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXHJcbiAgICBzYW1wbGU6IHNhbXBsZSxcclxuICB9O1xyXG59KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy9sYXlvdXQvbWVhc3VyZS5qc1xuICoqLyIsIi8vIHRvZG8gW2FrYW1lbF0gbW92ZSB0byAvY29tcG9uZW50XHJcbmRlZmluZShbJ2xpYi91bmRlcnNjb3JlJ10sIGZ1bmN0aW9uIChfKSB7XHJcbiAgZnVuY3Rpb24gcGFyc2UoYSkge1xyXG4gICAgcmV0dXJuIGFicyhwYXJzZUZsb2F0KGEpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFicyhhKSB7XHJcbiAgICByZXR1cm4gXy5pc0Zpbml0ZShhKSA/IGEgOiAwO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGl4ZWxpZnkoYSkge1xyXG4gICAgcmV0dXJuIGFicyhhKSArICdweCc7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcGFyc2U6IHBhcnNlLFxyXG4gICAgcGl4ZWxpZnk6IHBpeGVsaWZ5LFxyXG4gIH07XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL2xheW91dC9weC5qc1xuICoqLyIsIi8vIFRPRE8gW2FrYW1lbF0gW2J1Z10gd2l0aCBsYXJnZSBkYXRhIHNldCwgaml0dGVycyB3aGVuIHNjcm9sbGluZyB0byBib3R0b21cclxuXHJcbmRlZmluZShbXHJcbiAgJ2xpYi9qcXVlcnknLFxyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL2xheW91dC9tZWFzdXJlJyxcclxuICAnY29tcG9uZW50L2dyaWQvbGF5b3V0L3B4JyxcclxuXSwgZnVuY3Rpb24gKCQsIF8sIG1lYXN1cmUsIHB4KSB7XHJcbiAgZnVuY3Rpb24gcm93SGVpZ2h0KHJvdykge1xyXG4gICAgcmV0dXJuIF8uaXNOdW1iZXIocm93Ll9faGVpZ2h0KSA/IHJvdy5fX2hlaWdodCA6IHRoaXMuX19tZWFzdXJlcy5hdmdSb3dIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlc3RpbWF0ZUhlaWdodChmaXJzdCwgbGFzdCkge1xyXG4gICAgdmFyIHJvd3MgPSB0aGlzLmxheW91dC5kYXRhLnZhbHVlO1xyXG5cclxuICAgIHZhciByZXQgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IGZpcnN0OyBpIDw9IGxhc3Q7IGkrKykge1xyXG4gICAgICByZXQgKz0gcm93SGVpZ2h0LmNhbGwodGhpcywgcm93c1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJvd0F0T2Zmc2V0KG9mZnNldCkge1xyXG4gICAgdmFyIHJlbSA9IG9mZnNldDtcclxuXHJcbiAgICBpZiAocmVtIDw9IDApIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJldCA9IC0xO1xyXG4gICAgdmFyIGNvdW50ID0gXy5zaXplKHRoaXMubGF5b3V0LmRhdGEudmFsdWUpO1xyXG5cclxuICAgIHdoaWxlIChyZW0gPiAwICYmIHJldCA8IGNvdW50IC0gMSkge1xyXG4gICAgICByZXQrKztcclxuICAgICAgcmVtIC09IHJvd0hlaWdodC5jYWxsKHRoaXMsIHJldCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChyZXQgPCBjb3VudCkgPyByZXQgOiAtMTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIFJlbmRlcmVyKG9wdGlvbnMpIHtcclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgdGhpcy5uYW1lID0gJ3ZpcnR1YWxpemF0aW9uJztcclxuICAgIHRoaXMubGF5b3V0ID0gdGhpcy5vcHRpb25zLmxheW91dDtcclxuICB9XHJcblxyXG4gIFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGRhdGEsIGNiKSB7XHJcbiAgICAvLyBhLiBkZWZpbmUgZGF0YSBzZXRcclxuICAgIHZhciB2YWx1ZSA9IHRoaXMubGF5b3V0LmRhdGEudmFsdWU7XHJcbiAgICB2YXIgY291bnQgPSBfLnNpemUodmFsdWUpO1xyXG4gICAgdmFyIGZpcnN0ID0gMDtcclxuICAgIHZhciBsYXN0ID0gY291bnQgLSAxO1xyXG5cclxuICAgIC8vIGIuIHJlbmRlciB0ZXN0IHBhc3MgLyB0YWtlIGluaXRpYWwgbWVhc3VyZXNcclxuICAgIGlmICghdGhpcy5fX21lYXN1cmVzKSB7XHJcbiAgICAgIHZhciBzbXBsID0gbWVhc3VyZS5zYW1wbGUuY2FsbCh0aGlzLmxheW91dCk7XHJcbiAgICAgIHRoaXMuX19tZWFzdXJlcyA9IF8ucGljayhzbXBsLCAnYXZnUm93SGVpZ2h0JywgJ2VzdGltYXRlSGVpZ2h0JywgJ3RoZWFkJyk7XHJcblxyXG4gICAgICAvLyBiLjEgc2V0IGhlaWdodCBiYXNlZCBvbiBtZWFzdXJlcyBlc3RpbWF0ZVxyXG4gICAgICB0aGlzLmxheW91dC4kZWwuY3NzKHtcclxuICAgICAgICAncGFkZGluZy10b3AnOiBweC5waXhlbGlmeSh0aGlzLl9fbWVhc3VyZXMuZXN0aW1hdGVIZWlnaHQpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjLiBmaW5kIHZpc2libGUgdmlld3BvcnRcclxuICAgIGRhdGEudnBNZWFzdXJlcyA9IGRhdGEudnBNZWFzdXJlcyB8fCBtZWFzdXJlLnZpZXdwb3J0LmNhbGwodGhpcy5sYXlvdXQpO1xyXG5cclxuICAgIC8vIGQuIGZpbmQgcmVuZGFibGUgcm93c1xyXG4gICAgZmlyc3QgPSByb3dBdE9mZnNldC5jYWxsKHRoaXMsIGRhdGEudnBNZWFzdXJlcy50b3AgLSB0aGlzLl9fbWVhc3VyZXMudGhlYWQpO1xyXG4gICAgbGFzdCA9IHJvd0F0T2Zmc2V0LmNhbGwodGhpcywgZGF0YS52cE1lYXN1cmVzLmJvdHRvbSAtIHRoaXMuX19tZWFzdXJlcy50aGVhZCk7XHJcblxyXG4gICAgLy8gZC4xIGFkZCBhIGZldyByb3dzIGJlZm9yZSBhbmQgYWZ0ZXIgb3VyIGNhbGN1bGF0aW9ucyB0byBhY2NvdW50IGZvciBtZWFzdXJtZW50IGVzdGltYXRpb24gZXJyXHJcbiAgICB2YXIgZXJyTWFyZ2luUm93Q291bnQgPSA1O1xyXG5cclxuICAgIGZpcnN0IC09IGVyck1hcmdpblJvd0NvdW50O1xyXG4gICAgbGFzdCArPSBlcnJNYXJnaW5Sb3dDb3VudDtcclxuXHJcbiAgICBmaXJzdCA9IE1hdGgubWF4KDAsIGZpcnN0KTtcclxuICAgIGxhc3QgPSBNYXRoLm1pbigobGFzdCA8IDApID8gY291bnQgLSAxIDogbGFzdCwgY291bnQgLSAxKTtcclxuXHJcbiAgICB2YXIgcFRvcCA9IGVzdGltYXRlSGVpZ2h0LmNhbGwodGhpcywgMCwgZmlyc3QgLSAxKTtcclxuICAgIHZhciBwQm90dG9tID0gZXN0aW1hdGVIZWlnaHQuY2FsbCh0aGlzLCBsYXN0ICsgMSwgY291bnQgLSAxKTtcclxuXHJcbiAgICBkYXRhLnJvd3MgPSB2YWx1ZS5zbGljZShmaXJzdCwgbGFzdCArIDEpO1xyXG5cclxuICAgIF8uZXh0ZW5kKGRhdGEuY3NzLCB7XHJcbiAgICAgICdwYWRkaW5nLXRvcCc6IHB4LnBpeGVsaWZ5KHBUb3AgKyBweC5wYXJzZShkYXRhLmNzc1sncGFkZGluZy10b3AnXSkpLFxyXG4gICAgICAncGFkZGluZy1ib3R0b20nOiBweC5waXhlbGlmeShwQm90dG9tICsgcHgucGFyc2UoZGF0YS5jc3NbJ3BhZGRpbmctYm90dG9tJ10pKSxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLmZpcnN0ID09PSBmaXJzdCAmJiB0aGlzLmxhc3QgPT09IGxhc3QpIHtcclxuICAgICAgZGF0YS5jYW5Ta2lwRHJhdyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZS4geWllbGQgdG8gcmVuZGVyXHJcbiAgICBjYih1bmRlZmluZWQsIGRhdGEpO1xyXG5cclxuICAgIC8vIGYuIHRha2UgbmV3IG1lYXN1cmVzIGFuZCB1cGRhdGUgYXZnIHJvdyBoZWlnaHRcclxuICAgIC8vIHRvZG8gW2FrYW1lbF0gW3BlcmZdIDcuNSVcclxuICAgIHZhciB0YmxNZWFzdXJlID0gbWVhc3VyZS5kaW1lbnNpb25zLmNhbGwodGhpcy5sYXlvdXQpO1xyXG4gICAgXy5lYWNoKHRibE1lYXN1cmUucm93cywgZnVuY3Rpb24gKGhlaWdodCwgaSkge1xyXG4gICAgICB2YWx1ZVtpICsgZmlyc3RdLl9faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGhlaWdodHMgPSBfLmNoYWluKHZhbHVlKVxyXG4gICAgICAubWFwKGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICByZXR1cm4gcm93Ll9faGVpZ2h0O1xyXG4gICAgICB9KS5jb21wYWN0KCkudmFsdWUoKTtcclxuXHJcbiAgICBpZiAoXy5zaXplKGhlaWdodHMpKSB7XHJcbiAgICAgIHRoaXMuX19tZWFzdXJlcy5hdmdSb3dIZWlnaHQgPSBfLnJlZHVjZShoZWlnaHRzLCBmdW5jdGlvbiAobWVtbywgbnVtKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lbW8gKyBudW07XHJcbiAgICAgIH0sIDApIC8gXy5zaXplKGhlaWdodHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZmlyc3QgPSBmaXJzdDtcclxuICAgIHRoaXMubGFzdCA9IGxhc3Q7XHJcbiAgfTtcclxuXHJcbiAgUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9fbWVhc3VyZXM7XHJcbiAgfTtcclxuXHJcbiAgUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZSA9IF8ubm9vcDtcclxuXHJcbiAgUmVuZGVyZXIucGFydGlhbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgcmV0dXJuIG5ldyBSZW5kZXJlcihfLmRlZmF1bHRzKHt9LCBvLCBvcHRpb25zKSk7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBSZW5kZXJlcjtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvbGF5b3V0L3JlbmRlcmVyL3ZpcnR1YWxpemF0aW9uLmpzXG4gKiovIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XHJcbmltcG9ydCBCYWNrYm9uZSBmcm9tICdiYWNrYm9uZSc7XHJcbmltcG9ydCBwcm9qZWN0aW9ucyBmcm9tICcuLi9wcm9qZWN0aW9uL2luZGV4JztcclxuaW1wb3J0IHsgZGVsZWdhdGVFdmVudHMgfSBmcm9tICcuL3V0aWxpdHknO1xyXG5pbXBvcnQgcHJvbXB0IGZyb20gJy4uL3BvcHVwLWVkaXRvci9pbmRleCc7XHJcblxyXG5jb25zdCBwcm9qZWN0aW9uQ29uZmlncyA9IHtcclxuICBBMTF5KGNvbmZpZykge1xyXG4gICAgY29uc3QgYWNjQ29uZmlnID0ge307XHJcblxyXG4gICAgLy8gdGVtcCBjb25maWcgdG8gZml4IGExMXkgYnVnIG9mIGxhdGVuY3kgcHJvamVjdGlvbiBncmlkLCBzaG91bGQgbm90IHRvIHJldXNlIGl0LiBcclxuICAgIGlmIChfLmhhcyhjb25maWcuYTExeSwgJ3NlbGVjdGlvbicpICYmIF8uaGFzKGNvbmZpZy5hMTF5LnNlbGVjdGlvbiwgJ3NlbGVjdEFsbExhYmVsJykpIHtcclxuICAgICAgYWNjQ29uZmlnWydhMTF5LnNlbGVjdGlvbi5zZWxlY3RBbGxMYWJlbCddID0gY29uZmlnLmExMXkuc2VsZWN0aW9uLnNlbGVjdEFsbExhYmVsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhY2NDb25maWc7XHJcbiAgfSxcclxuXHJcbiAgQWdncmVnYXRlUm93KGNvbmZpZykge1xyXG4gICAgY29uc3QgY29uZmlnQWdnID0ge307XHJcblxyXG4gICAgaWYgKF8uaGFzKGNvbmZpZy5hZ2dyZWdhdGUsICd0b3AnKSkge1xyXG4gICAgICBjb25maWdBZ2dbJ2FnZ3JlZ2F0ZS50b3AnXSA9IGNvbmZpZy5hZ2dyZWdhdGUudG9wO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChfLmhhcyhjb25maWcuYWdncmVnYXRlLCAnYm90dG9tJykpIHtcclxuICAgICAgY29uZmlnQWdnWydhZ2dyZWdhdGUuYm90dG9tJ10gPSBjb25maWcuYWdncmVnYXRlLmJvdHRvbTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29uZmlnQWdnO1xyXG4gIH0sXHJcblxyXG4gIEpTRGF0YShjb25maWcpIHtcclxuICAgIHJldHVybiBfLmV4dGVuZChfLnBpY2soY29uZmlnLmRhdGFTb3VyY2UsIFtcclxuICAgICAgJ3NraXAnLFxyXG4gICAgICAndGFrZScsXHJcbiAgICAgICdmaWx0ZXInLFxyXG4gICAgICAnb3JkZXJieScsXHJcbiAgICAgICdzZWxlY3QnLFxyXG4gICAgXSksIHtcclxuICAgICAgJ2pzZGF0YS5lbnRpdHknOiBjb25maWcuZGF0YVNvdXJjZS5yZXNvdXJjZSxcclxuICAgICAgJ2pzZGF0YS5xdWVyeSc6IGNvbmZpZy5kYXRhU291cmNlLnF1ZXJ5LFxyXG4gICAgICAnanNkYXRhLm9wdGlvbnMnOiBjb25maWcuZGF0YVNvdXJjZS5vcHRpb25zLFxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgTWFwKGNvbmZpZykge1xyXG4gICAgY29uc3QgcHJvcGVydGllcyA9IF8ucmVkdWNlKGNvbmZpZy5jb2x1bW5zLCAobWVtbywgeyBuYW1lLCB2YWx1ZSwgZmllbGQgfSkgPT4ge1xyXG4gICAgICBtZW1vW25hbWVdID0gdmFsdWUgfHwgKGl0ZW0gPT4gXy5yZWR1Y2UoXHJcbiAgICAgICAgKGZpZWxkIHx8IG5hbWUpLnNwbGl0KCcvJyksXHJcbiAgICAgICAgKG1lbW8sIHByb3ApID0+IF8ucmVzdWx0KG1lbW8sIHByb3ApLFxyXG4gICAgICAgIGl0ZW1cclxuICAgICAgKSk7XHJcbiAgICAgIHJldHVybiBtZW1vO1xyXG4gICAgfSwge30pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIG1hcChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIF8ucmVkdWNlKGNvbmZpZy5jb2x1bW5zLCAobWVtbywgeyBuYW1lIH0pID0+IHtcclxuICAgICAgICAgIG1lbW9bbmFtZV0gPSBwcm9wZXJ0aWVzW25hbWVdKGl0ZW0pO1xyXG4gICAgICAgICAgcmV0dXJuIG1lbW87XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICBDb2x1bW5zKGNvbmZpZykge1xyXG4gICAgY29uc3QgY29sdW1ucyA9IF8ucmVkdWNlKGNvbmZpZy5jb2x1bW5zLCAoY29sdW1ucywgY29sdW1uKSA9PiB7XHJcbiAgICAgIGNvbnN0ICRtZXRhZGF0YSA9IHt9O1xyXG5cclxuICAgICAgaWYgKGNvbHVtbi5hdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgJG1ldGFkYXRhWydhdHRyLmJvZHknXSA9IGNvbHVtbi5hdHRyaWJ1dGVzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY29sdW1uLmhlYWRlckF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAkbWV0YWRhdGFbJ2F0dHIuaGVhZCddID0gY29sdW1uLmhlYWRlckF0dHJpYnV0ZXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbHVtbnNbY29sdW1uLm5hbWVdID0ge1xyXG4gICAgICAgIHNvcnRhYmxlOiBjb2x1bW4uc29ydGFibGUsXHJcbiAgICAgICAgJG1ldGFkYXRhLFxyXG4gICAgICAgIGhlYWRlckJ1aWxkZXI6IGNvbHVtbi5oZWFkZXJCdWlsZGVyLFxyXG4gICAgICAgIGNvbmZpZzogY29sdW1uLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIGNvbHVtbnM7XHJcbiAgICB9LCB7fSk7XHJcblxyXG4gICAgaWYgKGNvbmZpZy5zZWxlY3RhYmxlKSB7XHJcbiAgICAgIGNvbHVtbnMuY2hlY2tib3ggPSB7XHJcbiAgICAgICAgY29uZmlnOiB7IG5hbWU6ICdzZWxlY3Rpb24nIH0sXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKF8uaGFzKGNvbmZpZy5jb2x1bW5TaGlmdGVyLCAndG90YWxDb2x1bW5zJykpIHtcclxuICAgICAgY29sdW1uc1snY29sdW1uLnNraXAubGVzcyddID0ge1xyXG4gICAgICAgIGNvbmZpZzogeyBuYW1lOiAnc2tpcC1sZXNzJyB9LFxyXG4gICAgICB9O1xyXG4gICAgICBjb2x1bW5zWydjb2x1bW4uc2tpcC5tb3JlJ10gPSB7XHJcbiAgICAgICAgY29uZmlnOiB7IG5hbWU6ICdza2lwLW1vcmUnIH0sXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgY29sdW1ucyB9O1xyXG4gIH0sXHJcblxyXG4gIENvbHVtbkkxOG4oY29uZmlnKSB7XHJcbiAgICByZXR1cm4gXy5yZWR1Y2UoY29uZmlnLmNvbHVtbnMsIChjb2x1bW5JMThuLCBjb2x1bW4pID0+IHtcclxuICAgICAgY29sdW1uSTE4blsnY29sdW1uLmkxOG4nXVtjb2x1bW4ubmFtZV0gPSBjb2x1bW4udGl0bGUgfHwgY29sdW1uLm5hbWU7XHJcbiAgICAgIGNvbHVtbkkxOG5bJ3N1YkNvbHVtbi5pMThuJ11bY29sdW1uLm5hbWVdID0gY29sdW1uLnN1YkNvbFRpdGxlO1xyXG4gICAgICByZXR1cm4gY29sdW1uSTE4bjtcclxuICAgIH0sIHsgJ2NvbHVtbi5pMThuJzoge30sICdzdWJDb2x1bW4uaTE4bic6IHt9IH0pO1xyXG4gIH0sXHJcblxyXG4gIENvbHVtblF1ZXJ5YWJsZShjb25maWcpIHtcclxuICAgIGNvbnN0IGNvbHVtbkluID0gXy5jaGFpbihjb25maWcuY29sdW1ucylcclxuICAgICAgLnJlamVjdChfLnByb3BlcnR5KCdoaWRkZW4nKSlcclxuICAgICAgLm1hcChfLnByb3BlcnR5KCduYW1lJykpXHJcbiAgICAgIC52YWx1ZSgpO1xyXG4gICAgY29uc3QgY29sdW1uTG9jayA9IF8uY2hhaW4oY29uZmlnLmNvbHVtbnMpXHJcbiAgICAgIC5maWx0ZXIoXy5wcm9wZXJ0eSgnbG9ja2VkJykpXHJcbiAgICAgIC5tYXAoXy5wcm9wZXJ0eSgnbmFtZScpKVxyXG4gICAgICAudmFsdWUoKTtcclxuICAgIGNvbnN0IGNvbHFDb25maWcgPSB7XHJcbiAgICAgICdjb2x1bW4ubG9jayc6IGNvbHVtbkxvY2ssXHJcbiAgICAgICdjb2x1bW4uaW4nOiBjb2x1bW5JbixcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGNvbmZpZy5zZWxlY3RhYmxlKSB7XHJcbiAgICAgIGNvbHVtbkluLnVuc2hpZnQoJ2NoZWNrYm94Jyk7XHJcbiAgICAgIGNvbHVtbkxvY2sudW5zaGlmdCgnY2hlY2tib3gnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXy5oYXMoY29uZmlnLmNvbHVtblNoaWZ0ZXIsICd0b3RhbENvbHVtbnMnKSkge1xyXG4gICAgICBjb2xxQ29uZmlnWydjb2x1bW4udGFrZSddID0gY29uZmlnLmNvbHVtblNoaWZ0ZXIudG90YWxDb2x1bW5zO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbHFDb25maWc7XHJcbiAgfSxcclxuXHJcbiAgQ29sdW1uR3JvdXAoY29uZmlnKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAnY29sdW1uLmdyb3VwJzogY29uZmlnLmNvbHVtbkdyb3VwLFxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICBDb2x1bW5TaGlmdGVyKCkge30sXHJcblxyXG4gIENvbHVtblRlbXBsYXRlKGNvbmZpZykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgJ2NvbHVtbi50ZW1wbGF0ZSc6IF8ucmVkdWNlKGNvbmZpZy5jb2x1bW5zLCAoY29sdW1uVG1wbCwgY29sdW1uKSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbHVtbi5oZWFkZXJUZW1wbGF0ZSkge1xyXG4gICAgICAgICAgY29sdW1uVG1wbFtjb2x1bW4ubmFtZV0gPSBjb2x1bW4uaGVhZGVyVGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2x1bW5UbXBsO1xyXG4gICAgICB9LCB7fSksXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIENvbHVtbkhvdmVyVGV4dCgpIHt9LFxyXG5cclxuICBFZGl0YWJsZShjb25maWcpIHtcclxuICAgIGNvbnN0IGVkaXRhYmxlT3B0aW9ucyA9IHt9O1xyXG5cclxuICAgIF8uZWFjaChjb25maWcuY29sdW1ucywgY29sdW1uID0+IHtcclxuICAgICAgaWYgKGNvbHVtbi5lZGl0YWJsZSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBlZGl0YWJsZU9wdGlvbnNbY29sdW1uLm5hbWVdID0ge1xyXG4gICAgICAgICAgY29uZGl0aW9uOiAoKSA9PiB0cnVlLFxyXG4gICAgICAgICAgZWRpdG9yOiBwcm9tcHQsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb2x1bW4uZWRpdGFibGUpKSB7XHJcbiAgICAgICAgICBvcHRpb25zLmNvbmRpdGlvbiA9IGNvbHVtbi5lZGl0YWJsZTtcclxuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoY29sdW1uLmVkaXRhYmxlKSkge1xyXG4gICAgICAgICAgXy5leHRlbmQob3B0aW9ucywgY29sdW1uLmVkaXRhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHRvb2x0aXBUZXh0ID0gXy5yZXN1bHQoY29uZmlnLmVkaXRhYmxlLCAndG9vbHRpcFRleHQnLCAnRWRpdCcpO1xyXG4gICAgY29uc3QgaWNvbkNsYXNzZXMgPSBfLnJlc3VsdChjb25maWcuZWRpdGFibGUsICdpY29uQ2xhc3NlcycsIFsnZ2x5cGhpY29uJywgJ2dseXBoaWNvbi1wZW5jaWwnXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgJ2NvbHVtbi5lZGl0YWJsZSc6IGVkaXRhYmxlT3B0aW9ucyxcclxuICAgICAgJ2VkaXRhYmxlLnRvb2x0aXAudGV4dCc6IHRvb2x0aXBUZXh0LFxyXG4gICAgICAnZWRpdGFibGUuaWNvbi5jbGFzcyc6IGljb25DbGFzc2VzLFxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICBNZW1vcnlRdWVyeWFibGUoY29uZmlnKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAnY29sdW1uLnNvcnRhYmxlJzogXy5yZWR1Y2UoY29uZmlnLmNvbHVtbnMsIChjb2x1bW5Tb3J0YWJsZSwgY29sdW1uKSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbHVtbi5zb3J0YWJsZSkge1xyXG4gICAgICAgICAgY29sdW1uU29ydGFibGVbY29sdW1uLm5hbWVdID0gY29sdW1uLnNvcnRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29sdW1uU29ydGFibGU7XHJcbiAgICAgIH0sIHt9KSxcclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgT2RhdGEoY29uZmlnKSB7XHJcbiAgICByZXR1cm4gXy5leHRlbmQoXy5waWNrKGNvbmZpZy5kYXRhU291cmNlLCBbXHJcbiAgICAgICd1cmwnLFxyXG4gICAgICAnc2tpcCcsXHJcbiAgICAgICd0YWtlJyxcclxuICAgICAgJ2ZpbHRlcicsXHJcbiAgICAgICdvcmRlcmJ5JyxcclxuICAgICAgJ3NlbGVjdCcsXHJcbiAgICBdKSk7XHJcbiAgfSxcclxuXHJcbiAgUHJvcGVydHlUZW1wbGF0ZShjb25maWcpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICdwcm9wZXJ0eS50ZW1wbGF0ZSc6IF8ucmVkdWNlKGNvbmZpZy5jb2x1bW5zLCAocHJvcFRtcGwsIGNvbHVtbikgPT4ge1xyXG4gICAgICAgIGlmIChjb2x1bW4udGVtcGxhdGUpIHtcclxuICAgICAgICAgIHByb3BUbXBsW2NvbHVtbi5uYW1lXSA9IGNvbHVtbi50ZW1wbGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3BUbXBsO1xyXG4gICAgICB9LCB7fSksXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIFJvd0luZGV4KCkgeyB9LFxyXG5cclxuICBSb3coY29uZmlnKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAncm93LmNsYXNzZXMnOiBfLnJlc3VsdChjb25maWcucm93cywgJ2NsYXNzZXMnKSxcclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgUm93Q2hlY2tib3goY29uZmlnKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAncm93LmNoZWNrLmlkJzogXy5jaGFpbihjb25maWcpXHJcbiAgICAgICAgLnJlc3VsdCgnZGF0YVNvdXJjZScpXHJcbiAgICAgICAgLnJlc3VsdCgnc2NoZW1hJylcclxuICAgICAgICAucmVzdWx0KCdrZXknLCAncm93SW5kZXgnKVxyXG4gICAgICAgIC52YWx1ZSgpLFxyXG4gICAgICAncm93LmNoZWNrLnNpbmdsZSc6IGNvbmZpZy5zZWxlY3RhYmxlID09PSAnc2luZ2xlJyxcclxuICAgICAgJ2NvbHVtbi5jaGVja2VkJzogJ2NoZWNrYm94JyxcclxuICAgICAgJ3Jvdy5jaGVjay5hbGxvdyc6IGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgIHZhciB0eXBlID0gXy5jaGFpbihtb2RlbCkucmVzdWx0KCckbWV0YWRhdGEnKS5yZXN1bHQoJ3R5cGUnKS52YWx1ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoW1xyXG4gICAgICAgICAgJ3NlZ21lbnRhdGlvbicsXHJcbiAgICAgICAgICAnYWdncmVnYXRlJyxcclxuICAgICAgICBdLCB0eXBlKTtcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgUGFnZShjb25maWcpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICdwYWdlLnNpemUnOiBjb25maWcucGFnZWFibGUucGFnZVNpemUsXHJcbiAgICAgICdwYWdlLm51bWJlcic6IDAsXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIFNpbmsoY29uZmlnKSB7XHJcbiAgICBjb25zdCBkYXRhID0gXy5yZXN1bHQoY29uZmlnLmRhdGFTb3VyY2UsICdkYXRhJywgW10pO1xyXG5cclxuICAgIGlmIChfLmlzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgcmV0dXJuIHsgc2VlZDogZGF0YSB9O1xyXG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQmFja2JvbmUuQ29sbGVjdGlvbikge1xyXG4gICAgICByZXR1cm4geyBzZWVkOiBkYXRhLnRvSlNPTigpIH07XHJcbiAgICB9XHJcbiAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGRlZmluZVBsdWdpbiA9PiBkZWZpbmVQbHVnaW4oJ3Byb2plY3Rpb24nLCBbXHJcbiAgJ2NvbmZpZycsXHJcbl0sIGZ1bmN0aW9uIChjb25maWcpIHtcclxuICBsZXQgcHJvamVjdGlvbiA9IG51bGw7XHJcblxyXG4gIGZ1bmN0aW9uIHBpcGVQcm9qZWN0aW9uKG5hbWUpIHtcclxuICAgIGNvbnN0IFByb2plY3Rpb24gPSBwcm9qZWN0aW9uc1tuYW1lXTtcclxuICAgIGNvbnN0IGNvbmZpZ1Byb2ogPSBwcm9qZWN0aW9uQ29uZmlnc1tuYW1lXShjb25maWcpO1xyXG4gICAgY29uc3QgcHJvamVjdGlvbkRlc3QgPSBuZXcgUHJvamVjdGlvbihjb25maWdQcm9qKTtcclxuXHJcbiAgICBpZiAocHJvamVjdGlvbikge1xyXG4gICAgICBwcm9qZWN0aW9uID0gcHJvamVjdGlvbi5waXBlKHByb2plY3Rpb25EZXN0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByb2plY3Rpb24gPSBwcm9qZWN0aW9uRGVzdDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IGRhdGFTb3VyY2VUeXBlID0gY29uZmlnLmRhdGFTb3VyY2UudHlwZSB8fCAnbWVtb3J5JztcclxuICBpZiAoZGF0YVNvdXJjZVR5cGUgPT09ICdqcy1kYXRhJykge1xyXG4gICAgcGlwZVByb2plY3Rpb24oJ0pTRGF0YScpO1xyXG4gIH0gZWxzZSBpZiAoZGF0YVNvdXJjZVR5cGUgPT09ICdtZW1vcnknKSB7XHJcbiAgICBwaXBlUHJvamVjdGlvbignU2luaycpO1xyXG4gICAgcGlwZVByb2plY3Rpb24oJ01lbW9yeVF1ZXJ5YWJsZScpO1xyXG4gICAgaWYgKGNvbmZpZy5kYXRhU291cmNlLmRhdGEgaW5zdGFuY2VvZiBCYWNrYm9uZS5Db2xsZWN0aW9uKSB7XHJcbiAgICAgIGxldCB1cGRhdGluZyA9IGZhbHNlO1xyXG4gICAgICBjb25zdCBzY2hlZHVsZVVwZGF0ZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAoIXVwZGF0aW5nKSB7XHJcbiAgICAgICAgICB1cGRhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHByb2plY3Rpb24uc2V0KCdzZWVkJywgY29uZmlnLmRhdGFTb3VyY2UuZGF0YS50b0pTT04oKSk7XHJcbiAgICAgICAgICAgIHVwZGF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIGNvbmZpZy5kYXRhU291cmNlLmRhdGEub24oJ2FsbCcsIHNjaGVkdWxlVXBkYXRlKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGRhdGFTb3VyY2VUeXBlID09PSAnb2RhdGEnKSB7XHJcbiAgICBwaXBlUHJvamVjdGlvbignT2RhdGEnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBkYXRhU291cmNlLnR5cGUgXCIke2NvbmZpZy5kYXRhU291cmNlLnR5cGV9XCIgaXMgbm90IHN1cHBvcnRlZGApO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZGF0YVNvdXJjZVByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xyXG5cclxuICBwaXBlUHJvamVjdGlvbignQTExeScpO1xyXG4gIHBpcGVQcm9qZWN0aW9uKCdDb2x1bW5zJyk7XHJcbiAgcGlwZVByb2plY3Rpb24oJ01hcCcpO1xyXG4gIGlmIChjb25maWcuYWdncmVnYXRlKSB7XHJcbiAgICBwaXBlUHJvamVjdGlvbignQWdncmVnYXRlUm93Jyk7XHJcbiAgfVxyXG4gIHBpcGVQcm9qZWN0aW9uKCdDb2x1bW5RdWVyeWFibGUnKTtcclxuICBwaXBlUHJvamVjdGlvbignQ29sdW1uSTE4bicpO1xyXG4gIGlmIChjb25maWcuZW5hYmxlUG9QKSB7XHJcbiAgICBwaXBlUHJvamVjdGlvbignQ29sdW1uR3JvdXAnKTtcclxuICB9XHJcbiAgaWYgKF8uaGFzKGNvbmZpZy5jb2x1bW5TaGlmdGVyLCAndG90YWxDb2x1bW5zJykpIHtcclxuICAgIHBpcGVQcm9qZWN0aW9uKCdDb2x1bW5TaGlmdGVyJyk7XHJcbiAgfVxyXG4gIHBpcGVQcm9qZWN0aW9uKCdDb2x1bW5UZW1wbGF0ZScpO1xyXG4gIHBpcGVQcm9qZWN0aW9uKCdDb2x1bW5Ib3ZlclRleHQnKTtcclxuICBwaXBlUHJvamVjdGlvbignUHJvcGVydHlUZW1wbGF0ZScpO1xyXG4gIGlmIChjb25maWcuc2VsZWN0YWJsZSkge1xyXG4gICAgcGlwZVByb2plY3Rpb24oJ1Jvd0luZGV4Jyk7XHJcbiAgICBwaXBlUHJvamVjdGlvbignUm93Q2hlY2tib3gnKTtcclxuICB9XHJcbiAgaWYgKGNvbmZpZy5yb3dzIHx8IChjb25maWcuc2VsZWN0YWJsZSkpIHtcclxuICAgIHBpcGVQcm9qZWN0aW9uKCdSb3cnKTtcclxuICB9XHJcbiAgaWYgKF8uaGFzKGNvbmZpZy5wYWdlYWJsZSwgJ3BhZ2VTaXplJykpIHtcclxuICAgIHBpcGVQcm9qZWN0aW9uKCdQYWdlJyk7XHJcbiAgfVxyXG4gIGlmIChfLmZpbmQoY29uZmlnLmNvbHVtbnMsIF8ucHJvcGVydHkoJ2VkaXRhYmxlJykpKSB7XHJcbiAgICBwaXBlUHJvamVjdGlvbignRWRpdGFibGUnKTtcclxuICB9XHJcblxyXG4gIGRlbGVnYXRlRXZlbnRzKHtcclxuICAgIGZyb206IGRhdGFTb3VyY2VQcm9qZWN0aW9uLFxyXG4gICAgdG86IHByb2plY3Rpb24sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgJ3VwZGF0ZTpiZWdpbm5pbmcnLFxyXG4gICAgICAndXBkYXRlOmZpbmlzaGVkJyxcclxuICAgIF0sXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBwcm9qZWN0aW9uO1xyXG59KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy9mYWN0b3J5L3Byb2plY3Rpb24tcGx1Z2luLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgQTExeTogcmVxdWlyZSgnLi9hMTF5JyksXHJcbiAgQWdncmVnYXRlUm93OiByZXF1aXJlKCcuL2FnZ3JlZ2F0ZS1yb3cnKSxcclxuICBCYXNlOiByZXF1aXJlKCcuL2Jhc2UnKSxcclxuICBDb2x1bW5JMThuOiByZXF1aXJlKCcuL2NvbHVtbi1pMThuJyksXHJcbiAgQ29sdW1uUXVlcnlhYmxlOiByZXF1aXJlKCcuL2NvbHVtbi1xdWVyeWFibGUnKSxcclxuICBDb2x1bW5TaGlmdGVyOiByZXF1aXJlKCcuL2NvbHVtbi1zaGlmdGVyJyksXHJcbiAgQ29sdW1uVGVtcGxhdGU6IHJlcXVpcmUoJy4vY29sdW1uLXRlbXBsYXRlJyksXHJcbiAgRWRpdGFibGVTdHJpbmc6IHJlcXVpcmUoJy4vZWRpdGFibGUtc3RyaW5nJyksXHJcbiAgRWRpdGFibGU6IHJlcXVpcmUoJy4vZWRpdGFibGUnKSxcclxuICBKU0RhdGE6IHJlcXVpcmUoJy4vanNkYXRhJyksXHJcbiAgTWFwOiByZXF1aXJlKCcuL21hcCcpLFxyXG4gIE1lbW9yeVF1ZXJ5YWJsZTogcmVxdWlyZSgnLi9tZW1vcnktcXVlcnlhYmxlJyksXHJcbiAgTWVtb3J5OiByZXF1aXJlKCcuL21lbW9yeScpLFxyXG4gIE1vY2s6IHJlcXVpcmUoJy4vbW9jaycpLFxyXG4gIE9kYXRhOiByZXF1aXJlKCcuL29kYXRhJyksXHJcbiAgUGFnZTogcmVxdWlyZSgnLi9wYWdlJyksXHJcbiAgUHJvcGVydHlUZW1wbGF0ZTogcmVxdWlyZSgnLi9wcm9wZXJ0eS10ZW1wbGF0ZScpLFxyXG4gIFJvd0NoZWNrYm94OiByZXF1aXJlKCcuL3Jvdy1jaGVja2JveCcpLFxyXG4gIFJvdzogcmVxdWlyZSgnLi9yb3cnKSxcclxuICBSb3dUcmlTdGF0ZUNoZWNrYm94UHJvamVjdGlvbjogcmVxdWlyZSgnLi9yb3ctdHJpLXN0YXRlLWNoZWNrYm94JyksXHJcbiAgUm93SW5kZXg6IHJlcXVpcmUoJy4vcm93LWluZGV4JyksXHJcbiAgU2luazogcmVxdWlyZSgnLi9zaW5rJyksXHJcbiAgQ29sdW1uR3JvdXA6IHJlcXVpcmUoJy4vY29sdW1uLWdyb3VwJyksXHJcbiAgQ29sdW1uSG92ZXJUZXh0OiByZXF1aXJlKCcuL2NvbHVtbi1ob3ZlcnRleHQnKSxcclxuICBDb2x1bW5zOiByZXF1aXJlKCcuL2NvbHVtbnMnKS5kZWZhdWx0LFxyXG59O1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vaW5kZXguanNcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2xpYi9iYWNrYm9uZScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL3Byb2plY3Rpb24vYmFzZScsXHJcbl0sIGZ1bmN0aW9uIChfLCBCYWNrYm9uZSwgQmFzZVByb2plY3Rpb24gLyogLCBzY2hlbWFQcm9wZXJ0aWVzLCBSZXNwb25zZSAqLykge1xyXG4gIGNvbnN0IGRlZmF1bHRzZWxlY3RBbGxMYWJlbCA9ICdTZWxlY3QgQWxsJztcclxuICB2YXIgTW9kZWwgPSBCYXNlUHJvamVjdGlvbi5leHRlbmQoe1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgJ2ExMXkuc2VsZWN0aW9uLnNlbGVjdEFsbExhYmVsJzogJ1NlbGVjdCBBbGwnXHJcbiAgICB9LFxyXG4gICAgbmFtZTogJ2ExMXknLFxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICB2YXIgc2VsZWN0QWxsTGFiZWwgPSB0aGlzLmdldCgnYTExeS5zZWxlY3Rpb24uc2VsZWN0QWxsTGFiZWwnKTtcclxuICAgICAgaWYgKE1vZGVsLl9fc3VwZXJfXy51cGRhdGUuY2FsbCh0aGlzLCBvcHRpb25zKSkge1xyXG4gICAgICAgIHRoaXMucGF0Y2goe1xyXG4gICAgICAgICAgJ2ExMXkuc2VsZWN0aW9uLnVuaXF1ZUlkJzogXy51bmlxdWVJZCgpLmNvbmNhdCgnLScpLFxyXG4gICAgICAgICAgJ2ExMXkuc2VsZWN0aW9uLnNlbGVjdEFsbExhYmVsJzogXy5pc1N0cmluZyhzZWxlY3RBbGxMYWJlbCkgPyBzZWxlY3RBbGxMYWJlbCA6IGRlZmF1bHRzZWxlY3RBbGxMYWJlbCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9KTtcclxuICByZXR1cm4gTW9kZWw7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vYTExeS5qc1xuICoqLyIsImRlZmluZShbXHJcbiAgJ2xpYi91bmRlcnNjb3JlJyxcclxuICAnbGliL2JhY2tib25lJyxcclxuICAnY29tcG9uZW50L2dyaWQvbW9kZWwvcmVzcG9uc2UnLFxyXG5dLCBmdW5jdGlvbiAoXywgQmFja2JvbmUsIFJlc3BvbnNlKSB7XHJcbiAgdmFyIE1vZGVsID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcclxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgXy5iaW5kQWxsKHRoaXMsICdvblNyY1VwZGF0ZScsICdiZWZvcmVTZXQnLCAnYWZ0ZXJTZXQnLCAndXBkYXRlJyk7XHJcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBSZXNwb25zZSgpO1xyXG4gICAgICB0aGlzLnNyYyA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5vbignY2hhbmdlJywgZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICAgICAgLy8gdG9kbyBbYWthbWVsXSB0aGUgbW9kZWwgaGVyZSBpcyB0aGUgc2V0dGluZ3MgbW9kZWxcclxuICAgICAgICB0aGlzLnVwZGF0ZSh7IG1vZGVsOiBtb2RlbCB9KTtcclxuICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH0sXHJcblxyXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgLy8gdXNlZCB0byBmaWd1cmUgb3V0IHdoaWNoIG9wdGlvbnMgdG8gc2V0IGxvY2FseSBhbmQgd2hpY2ggb25lcyB0byBwYXNzIGRvd24gdGhlIHBpcGVcclxuICAgICAgdGhpcy5sb2NhbEtleXMgPSBfLmtleXModGhpcy5kZWZhdWx0cyk7XHJcbiAgICAgIC8vIHRvZG8gW2FrYW1lbF0gdGhpcyBtaWdodCBwcmV2ZW50IHVzIGZyb20gb3ZlcnJpZGluZyBpbml0aWFsaXplXHJcbiAgICAgIE1vZGVsLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBwaXBlOiBmdW5jdGlvbiAodG8pIHtcclxuICAgICAgaWYgKHRvKSB7XHJcbiAgICAgICAgdG8uc2V0U3JjKHRoaXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdG87XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNyYzogZnVuY3Rpb24gKHNyYykge1xyXG4gICAgICB0aGlzLnNyYyA9IHNyYztcclxuICAgICAgaWYgKHRoaXMuc3JjKSB7XHJcbiAgICAgICAgdGhpcy5zcmMuZGF0YS5vZmYoJ2NoYW5nZScsIHRoaXMub25TcmNVcGRhdGUpO1xyXG4gICAgICAgIHRoaXMuc3JjLm9mZignYWxsJywgdGhpcy5idWJibGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5zcmMpIHtcclxuICAgICAgICB0aGlzLnNyYy5kYXRhLm9uKCdjaGFuZ2UnLCB0aGlzLm9uU3JjVXBkYXRlKTtcclxuICAgICAgICB0aGlzLnNyYy5vbignYWxsJywgdGhpcy5idWJibGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBwYXRjaDogZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgIHZhciBzcmMgPSB0aGlzLnNyYyA/IHRoaXMuc3JjLmRhdGEudG9KU09OKCkgOiB7fTtcclxuICAgICAgZGVsdGEgPSBfLmlzT2JqZWN0KGRlbHRhKSA/IGRlbHRhIDoge307XHJcblxyXG4gICAgICB0aGlzLmRhdGEuc2V0KF8uZGVmYXVsdHMoZGVsdGEsIHRoaXMuYXR0cmlidXRlcywgc3JjKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGJlZm9yZVNldDogZnVuY3Rpb24gKC8qIGxvY2FsLCBvdGhlciAqLykge30sXHJcbiAgICBhZnRlclNldDogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gICAgb25TcmNVcGRhdGU6IGZ1bmN0aW9uICgvKiBtb2RlbCAqLykge1xyXG4gICAgICB0aGlzLnVwZGF0ZSgvKiB7IG1vZGVsIDogbW9kZWwgfSAqLyk7XHJcbiAgICB9LFxyXG4gICAgYnViYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBrZXkgPSBfLmZpcnN0KGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICBpZiAoXy5oYXModGhpcy5ldmVudHMsIGtleSkpIHtcclxuICAgICAgICB2YXIgZmN0ID0gdGhpc1t0aGlzLmV2ZW50c1trZXldXTtcclxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGZjdCkpIHtcclxuICAgICAgICAgIGZjdC5hcHBseSh0aGlzLCBfLnJlc3QoYXJndW1lbnRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0b2RvIFtha2FtZWxdIGNhbiB0aGlzIHJlc3VsdCBpbiBtdWx0aXBsZSByZWRyYXcgY2FsbHM/XHJcbiAgICAgIGlmICh0aGlzLnNyYykge1xyXG4gICAgICAgIHRoaXMuc3JjLmJ1YmJsZS5hcHBseSh0aGlzLnNyYywgXy50b0FycmF5KGFyZ3VtZW50cykpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICBpZiAodGhpcy5zcmMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5kZWVwKSB7XHJcbiAgICAgICAgICB0aGlzLnNyYy51cGRhdGUob3B0aW9ucyk7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgTW9kZWwucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgb2JqID0ge307XHJcblxyXG4gICAgaWYgKF8uaXNTdHJpbmcoa2V5KSkge1xyXG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb2JqID0ga2V5O1xyXG4gICAgICBvcHRpb25zID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxvY2FsID0gXy5waWNrKG9iaiwgdGhpcy5sb2NhbEtleXMpO1xyXG4gICAgdmFyIG90aGVyID0gXy5vbWl0KG9iaiwgdGhpcy5sb2NhbEtleXMpO1xyXG5cclxuICAgIHRoaXMuYmVmb3JlU2V0KGxvY2FsLCBvdGhlcik7XHJcblxyXG4gICAgdmFyIHJldCA9IE1vZGVsLl9fc3VwZXJfXy5zZXQuY2FsbCh0aGlzLCBsb2NhbCwgb3B0aW9ucyk7XHJcblxyXG4gICAgLy8gdG9kbyBbYWthbWVsXSBpZiB3ZSBzZXQgb3B0aW9ucyB0aGF0IHNwYW4gbXVsdGlwbGUgZGF0YSBzb3VyY2VzIHdlIHdpbGwgdHJpZ2dlciBjaGFuZ2UgbXVsdGlwbGUgdGltZXMgaW4gdGhlIGNoYWluPz9cclxuICAgIC8vIHBhc3MgYWxvbmcgbm9uLWxvY2FsIG9wdGlvbnNcclxuICAgIGlmIChfLnNpemUob3RoZXIpKSB7XHJcbiAgICAgIGlmICh0aGlzLnNyYykge1xyXG4gICAgICAgIHRoaXMuc3JjLnNldChvdGhlciwgb3B0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuYWZ0ZXJTZXQoKTtcclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH07XHJcblxyXG4gIE1vZGVsLmtleVJlZ2V4ID0gL14oW1xcd19cXC0kXSspOiguKykkLztcclxuXHJcbiAgTW9kZWwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHZhciBtYXRjaCA9IE1vZGVsLmtleVJlZ2V4LmV4ZWMoa2V5KTtcclxuXHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcclxuICAgICAgdmFyIG5hbWUgPSBtYXRjaFsyXTtcclxuXHJcbiAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3Byb2plY3Rpb24nOiB7XHJcbiAgICAgICAgICB2YXIgcCA9IHRoaXM7XHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwID0gcC5zcmM7XHJcbiAgICAgICAgICB9IHdoaWxlIChwKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gc3BlY2lhbCBnZXQga2V5IHR5cGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciByZXQgPSBNb2RlbC5fX3N1cGVyX18uZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChyZXQpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3JjKSB7XHJcbiAgICAgICAgICByZXQgPSB0aGlzLnNyYy5nZXQuYXBwbHkodGhpcy5zcmMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBNb2RlbDtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvcHJvamVjdGlvbi9iYXNlLmpzXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL3VuZGVyc2NvcmUnLFxyXG4gICdsaWIvYmFja2JvbmUnLFxyXG5dLCBmdW5jdGlvbiAoXywgQmFja2JvbmUpIHtcclxuICByZXR1cm4gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgIHZhbHVlOiBbXSxcclxuICAgICAgc2VsZWN0OiBudWxsLFxyXG4gICAgICBjb3VudDogMCxcclxuICAgICAgYWdncmVnYXRlOiBbXSxcclxuICAgIH0sXHJcbiAgfSk7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL21vZGVsL3Jlc3BvbnNlLmpzXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL3VuZGVyc2NvcmUnLFxyXG4gICdsaWIvYmFja2JvbmUnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9wcm9qZWN0aW9uL2Jhc2UnLFxyXG5dLCBmdW5jdGlvbiAoXywgQmFja2JvbmUsIEJhc2VQcm9qZWN0aW9uKSB7XHJcbiAgdmFyIGNyZWF0ZVJvd3MgPSBmdW5jdGlvbiAoZm4sIGRhdGEpIHtcclxuICAgIHZhciByb3dzID0gZm4oZGF0YSk7XHJcblxyXG4gICAgXy5lYWNoKHJvd3MsIGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgcm93LiRtZXRhZGF0YSA9IF8uZXh0ZW5kKHt9LCByb3cuJG1ldGFkYXRhLCB7IHR5cGU6ICdhZ2dyZWdhdGUnIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJvd3M7XHJcbiAgfTtcclxuXHJcbiAgdmFyIE1vZGVsID0gQmFzZVByb2plY3Rpb24uZXh0ZW5kKHtcclxuXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAnYWdncmVnYXRlLnRvcCc6IG51bGwsXHJcbiAgICAgICdhZ2dyZWdhdGUuYm90dG9tJzogbnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgbmFtZTogJ2FnZ3JlZ2F0ZS1yb3cnLFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgdmFyIHZhbHVlLCB0b3BGbiwgcm93VG9wLCBib3R0b21Gbiwgcm93Qm90dG9tO1xyXG5cclxuICAgICAgaWYgKE1vZGVsLl9fc3VwZXJfXy51cGRhdGUuY2FsbCh0aGlzLCBvcHRpb25zKSkge1xyXG4gICAgICAgIHZhbHVlID0gdGhpcy5zcmMuZGF0YS5nZXQoJ3ZhbHVlJyk7XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgdG9wRm4gPSB0aGlzLmdldCgnYWdncmVnYXRlLnRvcCcpO1xyXG4gICAgICAgICAgYm90dG9tRm4gPSB0aGlzLmdldCgnYWdncmVnYXRlLmJvdHRvbScpO1xyXG4gICAgICAgICAgcm93VG9wID0gXy5pc0Z1bmN0aW9uKHRvcEZuKSA/IGNyZWF0ZVJvd3ModG9wRm4sIHRoaXMuc3JjLmRhdGEpIDogbnVsbDtcclxuICAgICAgICAgIHJvd0JvdHRvbSA9IF8uaXNGdW5jdGlvbihib3R0b21GbikgPyBjcmVhdGVSb3dzKGJvdHRvbUZuLCB0aGlzLnNyYy5kYXRhKSA6IG51bGw7XHJcblxyXG4gICAgICAgICAgaWYgKHJvd1RvcCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IF8uZmxhdHRlbihyb3dUb3ApLmNvbmNhdCh2YWx1ZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHJvd0JvdHRvbSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNvbmNhdChfLmZsYXR0ZW4ocm93Qm90dG9tKSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5wYXRjaCh7XHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBNb2RlbDtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvcHJvamVjdGlvbi9hZ2dyZWdhdGUtcm93LmpzXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL3VuZGVyc2NvcmUnLFxyXG4gICdsaWIvYmFja2JvbmUnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9wcm9qZWN0aW9uL2Jhc2UnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9zY2hlbWEvcHJvcGVydGllcycsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL21vZGVsL3Jlc3BvbnNlJyxcclxuXSwgZnVuY3Rpb24gKF8sIEJhY2tib25lLCBCYXNlUHJvamVjdGlvbiAvKiAsIHNjaGVtYVByb3BlcnRpZXMsIFJlc3BvbnNlICovKSB7XHJcbiAgdmFyIE1vZGVsID0gQmFzZVByb2plY3Rpb24uZXh0ZW5kKHtcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICdjb2x1bW4uaTE4bic6IHtcclxuICAgICAgICAnJzogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgICdzdWJDb2x1bW4uaTE4bic6IHt9LFxyXG4gICAgfSxcclxuICAgIG5hbWU6ICdjb2x1bW4taTE4bicsXHJcbiAgICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIChsb2NhbCkge1xyXG4gICAgICBpZiAoXy5oYXMobG9jYWwsICdjb2x1bW4uaTE4bicpKSB7XHJcbiAgICAgICAgaWYgKCFfLmlzT2JqZWN0KGxvY2FsWydjb2x1bW4uaTE4biddKSkge1xyXG4gICAgICAgICAgbG9jYWxbJ2NvbHVtbi5pMThuJ10gPSB0aGlzLmRlZmF1bHRzWydjb2x1bW4uaTE4biddO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgLy8gdG9kbyBbYWthbWVsXSB3aGVuIGNhbGxpbmcgYSBkZWVwIHVwZGF0ZTsgc3VwcHJlc3Mgb25jaGFuZ2UgZXZlbnQgYmFzZWQgdXBkYXRlc1xyXG4gICAgICAvLyBNb2RlbC5fX3N1cGVyX18udXBkYXRlLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgICBpZiAoTW9kZWwuX19zdXBlcl9fLnVwZGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpKSB7XHJcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5zcmMuZGF0YTtcclxuICAgICAgICB2YXIgY29sT3B0aW9ucyA9IHRoaXMuZ2V0KCdjb2x1bW4uaTE4bicpO1xyXG4gICAgICAgIHZhciBzdWJDb2xPcHRpb25zID0gdGhpcy5nZXQoJ3N1YkNvbHVtbi5pMThuJyk7XHJcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBtb2RlbC5nZXQoJ2NvbHVtbnMnKSB8fCB7fTtcclxuICAgICAgICB2YXIgJGRlZmF1bHQgPSBjb2xPcHRpb25zWycnXTtcclxuXHJcbiAgICAgICAgdmFyIGkxOG5Db2x1bW5zID0ge307XHJcbiAgICAgICAgXy5lYWNoKF8ua2V5cyhjb2x1bW5zKSwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgIHZhciBvcHQgPSBjb2xPcHRpb25zW2VsZW1lbnRdO1xyXG4gICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQob3B0KSkge1xyXG4gICAgICAgICAgICBvcHQgPSAkZGVmYXVsdDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpMThuQ29sdW1uc1tlbGVtZW50XSA9IF8uZGVmYXVsdHMoe1xyXG4gICAgICAgICAgICAkdGV4dDogXy5pc0Z1bmN0aW9uKG9wdCkgPyBvcHQoZWxlbWVudCkgOiBvcHQsXHJcbiAgICAgICAgICAgIHByb3BlcnR5OiBlbGVtZW50LFxyXG4gICAgICAgICAgfSwgY29sdW1uc1tlbGVtZW50XSk7XHJcblxyXG4gICAgICAgICAgaTE4bkNvbHVtbnNbZWxlbWVudF0uY29uZmlnID0gaTE4bkNvbHVtbnNbZWxlbWVudF0uY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgaTE4bkNvbHVtbnNbZWxlbWVudF0uY29uZmlnLnN1YkNvbFRpdGxlID0gc3ViQ29sT3B0aW9uc1tlbGVtZW50XTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXRjaCh7XHJcbiAgICAgICAgICBjb2x1bW5zOiBpMThuQ29sdW1ucyxcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB0b2RvIFtha2FtZWxdIHVuc2V0IG91ciBwcm9wZXJ0aWVzIG9ubHlcclxuICAgICAgICAvLyB0aGlzLnVuc2V0KCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBNb2RlbDtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvcHJvamVjdGlvbi9jb2x1bW4taTE4bi5qc1xuICoqLyIsImRlZmluZShbXHJcbiAgJ2xpYi91bmRlcnNjb3JlJyxcclxuXSwgZnVuY3Rpb24gKF8pIHtcclxuICBmdW5jdGlvbiBmcm9tKGFycikge1xyXG4gICAgdmFyIG9iaiA9IF8uZmlyc3QoYXJyKTtcclxuXHJcbiAgICByZXR1cm4gXy5rZXlzKG9iaiB8fCB7fSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBmcm9tOiBmcm9tIH07XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3NjaGVtYS9wcm9wZXJ0aWVzLmpzXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL3VuZGVyc2NvcmUnLFxyXG4gICdsaWIvYmFja2JvbmUnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9wcm9qZWN0aW9uL2Jhc2UnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9zY2hlbWEvcHJvcGVydGllcycsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL21vZGVsL3Jlc3BvbnNlJyxcclxuXSwgZnVuY3Rpb24gKF8sIEJhY2tib25lLCBCYXNlUHJvamVjdGlvbiAvKiAsIHNjaGVtYVByb3BlcnRpZXMsIFJlc3BvbnNlICovKSB7XHJcbiAgdmFyIE1vZGVsID0gQmFzZVByb2plY3Rpb24uZXh0ZW5kKHtcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICdjb2x1bW4uc2tpcCc6IDAsXHJcbiAgICAgICdjb2x1bW4udGFrZSc6IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICdjb2x1bW4ubG9jayc6IFtdLFxyXG4gICAgICAnY29sdW1uLmZpbHRlcic6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSxcclxuICAgICAgJ2NvbHVtbi5pbic6IHVuZGVmaW5lZCxcclxuICAgIH0sXHJcbiAgICBuYW1lOiAnY29sdW1uLXF1ZXJ5YWJsZScsXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIGlmIChNb2RlbC5fX3N1cGVyX18udXBkYXRlLmNhbGwodGhpcywgb3B0aW9ucykpIHtcclxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLnNyYy5kYXRhO1xyXG4gICAgICAgIHZhciB0YWtlID0gdGhpcy5nZXQoJ2NvbHVtbi50YWtlJyk7XHJcbiAgICAgICAgdmFyIHNraXAgPSB0aGlzLmdldCgnY29sdW1uLnNraXAnKTtcclxuICAgICAgICB2YXIgbG9jayA9IHRoaXMuZ2V0KCdjb2x1bW4ubG9jaycpIHx8IFtdO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmdldCgnY29sdW1uLmZpbHRlcicpO1xyXG4gICAgICAgIC8vIHRvZG8gW2FrYW1lbF0gY29uc2lkZXIgcmVuYW1pbmcgdG8gY29sdW1uLnNlbGVjdFxyXG4gICAgICAgIHZhciAkaW4gPSB0aGlzLmdldCgnY29sdW1uLmluJyk7XHJcbiAgICAgICAgdmFyIHNlbGVjdCA9IF8uc2l6ZShtb2RlbC5nZXQoJ2NvbHVtbnMnKSkgPyBfLm1hcChtb2RlbC5nZXQoJ2NvbHVtbnMnKSwgZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgIHJldHVybiBpLnByb3BlcnR5O1xyXG4gICAgICAgIH0pIDogbW9kZWwuZ2V0KCdzZWxlY3QnKTtcclxuICAgICAgICB2YXIgdW5sb2NrZWQgPSBfLmlzRnVuY3Rpb24oZmlsdGVyKSA/IF8uZmlsdGVyKCRpbiB8fCBzZWxlY3QsIGZpbHRlcikgOiAoJGluIHx8IHNlbGVjdCk7XHJcbiAgICAgICAgdmFyIGxvb2t1cCA9IG1vZGVsLmdldCgnY29sdW1ucycpO1xyXG4gICAgICAgIHZhciBzZXQgPSBfLmNoYWluKHVubG9ja2VkKS5kaWZmZXJlbmNlKGxvY2spLnZhbHVlKCk7XHJcbiAgICAgICAgdmFyIGNvbCA9IHNldDtcclxuXHJcbiAgICAgICAgaWYgKCFfLmlzTnVtYmVyKHRha2UpKSB7XHJcbiAgICAgICAgICB0YWtlID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRha2UgPSBNYXRoLm1heCh0YWtlIC0gXy5zaXplKGxvY2spLCAwKTtcclxuICAgICAgICBpZiAoXy5zaXplKHNldCkgPCBza2lwKSB7XHJcbiAgICAgICAgICBza2lwID0gMDtcclxuICAgICAgICAgIC8vIHRoaXMuc2V0KHsgJ2NvbHVtbnMuc2tpcCcgOiAwIH0sIHsgc2lsZW50IDogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHN0YXJ0IHF1ZXJ5XHJcbiAgICAgICAgdmFyIHNraXBwZWQgPSBfLmZpcnN0KHNldCwgc2tpcCk7XHJcblxyXG4gICAgICAgIGlmIChza2lwKSB7XHJcbiAgICAgICAgICBjb2wgPSBfLnJlc3Qoc2V0LCBza2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBfLnJlc3QoY29sLCB0YWtlKTtcclxuXHJcbiAgICAgICAgY29sID0gXy51bmlvbihsb2NrLCBfLmZpcnN0KGNvbCwgdGFrZSkpO1xyXG4gICAgICAgIC8vIGVuZCBxdWVyeVxyXG5cclxuICAgICAgICBfLmVhY2goY29sLCBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgaWYgKCFsb29rdXBbZWxlbWVudF0pIHtcclxuICAgICAgICAgICAgbG9va3VwW2VsZW1lbnRdID0geyBwcm9wZXJ0eTogZWxlbWVudCB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbG9va3VwW2VsZW1lbnRdLiRsb2NrID0gXy5jb250YWlucyhsb2NrLCBlbGVtZW50KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXRjaCh7XHJcbiAgICAgICAgICAnc2VsZWN0JzogY29sLFxyXG4gICAgICAgICAgLy8gdG9kbyBbYWthbWVsXSByZW5hbWUgdG8gY29sdW1uLmluPz8/XHJcbiAgICAgICAgICAvLyAsICdjb2x1bW5zLnNlbGVjdCcgIDogc2V0XHJcbiAgICAgICAgICAnY29sdW1ucy5za2lwcGVkJzogc2tpcHBlZCxcclxuICAgICAgICAgICdjb2x1bW5zLnJlbWFpbmluZyc6IHJlbWFpbmluZyxcclxuICAgICAgICAgIC8vICwgJ2NvbHVtbnMuY291bnQnICAgOiBfLnNpemUocmVzKVxyXG4gICAgICAgICAgLy8gdG9kbyBbYWthbWVsXSBkbyB3ZSBzdGlsbCBuZWVkIHRvIHVwZGF0ZSBza2lwP1xyXG4gICAgICAgICAgJ2NvbHVtbi5za2lwJzogc2tpcCxcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB0b2RvIFtha2FtZWxdIHVuc2V0IG91ciBwcm9wZXJ0aWVzIG9ubHlcclxuICAgICAgICAvLyB0aGlzLnVuc2V0KCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBNb2RlbDtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvcHJvamVjdGlvbi9jb2x1bW4tcXVlcnlhYmxlLmpzXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL3VuZGVyc2NvcmUnLFxyXG4gICdsaWIvYmFja2JvbmUnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9wcm9qZWN0aW9uL2Jhc2UnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9zY2hlbWEvcHJvcGVydGllcycsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL21vZGVsL3Jlc3BvbnNlJyxcclxuXSwgZnVuY3Rpb24gKF8sIEJhY2tib25lLCBCYXNlUHJvamVjdGlvbiAvKiAsIHNjaGVtYVByb3BlcnRpZXMsIFJlc3BvbnNlICovKSB7XHJcbiAgdmFyIE1vZGVsID0gQmFzZVByb2plY3Rpb24uZXh0ZW5kKHtcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICB9LFxyXG4gICAgbmFtZTogJ2NvbHVtbi1zaGlmdGVyJyxcclxuICAgIGV2ZW50czoge1xyXG4gICAgICAnbGF5b3V0OmNsaWNrOmhlYWRlcic6ICd0aENsaWNrJyxcclxuICAgIH0sXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIC8vIHRvZG8gW2FrYW1lbF0gd2hlbiBjYWxsaW5nIGEgZGVlcCB1cGRhdGU7IHN1cHByZXNzIG9uY2hhbmdlIGV2ZW50IGJhc2VkIHVwZGF0ZXNcclxuICAgICAgaWYgKE1vZGVsLl9fc3VwZXJfXy51cGRhdGUuY2FsbCh0aGlzLCBvcHRpb25zKSkge1xyXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuc3JjLmRhdGE7XHJcbiAgICAgICAgLy8gdG9kbyBbYWthbWVsXSBoYXZlICdjb2x1bW5zJyBjcmF0ZWQgYXQgdGhlIHNvdXJjZSBzbyB3ZSBkb24ndCBoYXZlIHRvIHB1dCB0aGlzIGFsbCBvdmVyIHRoZSBwbGFjZVxyXG4gICAgICAgIHZhciBjb2x1bW5zID0gbW9kZWwuZ2V0KCdjb2x1bW5zJyk7XHJcbiAgICAgICAgdmFyIHNlbGVjdCA9IG1vZGVsLmdldCgnc2VsZWN0Jyk7XHJcbiAgICAgICAgdmFyIGNvbFNraXBwZWQgPSBtb2RlbC5nZXQoJ2NvbHVtbnMuc2tpcHBlZCcpO1xyXG4gICAgICAgIHZhciBjb2xSZW1haW5pbmcgPSBtb2RlbC5nZXQoJ2NvbHVtbnMucmVtYWluaW5nJyk7XHJcblxyXG4gICAgICAgIHZhciB1bmxvY2tlZEF0ID0gTWF0aC5tYXgoXy5maW5kSW5kZXgoc2VsZWN0LCBmdW5jdGlvbiAoY29sKSB7XHJcbiAgICAgICAgICByZXR1cm4gY29sdW1uc1tjb2xdICYmICFjb2x1bW5zW2NvbF0uJGxvY2s7XHJcbiAgICAgICAgfSksIDApO1xyXG5cclxuICAgICAgICB2YXIgaGFzTGVzcyA9IF8uc2l6ZShjb2xTa2lwcGVkKTtcclxuICAgICAgICB2YXIgaGFzTW9yZSA9IF8uc2l6ZShjb2xSZW1haW5pbmcpO1xyXG5cclxuICAgICAgICB2YXIgY29sTGVzcyA9IHtcclxuICAgICAgICAgIHByb3BlcnR5OiAnY29sdW1uLnNraXAubGVzcycsXHJcbiAgICAgICAgICAkbWV0YWRhdGE6IHtcclxuICAgICAgICAgICAgJ2F0dHIuaGVhZCc6IHsgY2xhc3M6IFsnc2tpcC1sZXNzJ10gfSxcclxuICAgICAgICAgICAgJ2VuYWJsZWQnOiBoYXNMZXNzLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgICRodG1sOiAnPHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXRyaWFuZ2xlLWxlZnRcIiAvPicsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgY29sTW9yZSA9IHtcclxuICAgICAgICAgIHByb3BlcnR5OiAnY29sdW1uLnNraXAubW9yZScsXHJcbiAgICAgICAgICAkbWV0YWRhdGE6IHtcclxuICAgICAgICAgICAgJ2F0dHIuaGVhZCc6IHsgY2xhc3M6IFsnc2tpcC1tb3JlJ10gfSxcclxuICAgICAgICAgICAgJ2VuYWJsZWQnOiBoYXNNb3JlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgICRodG1sOiAnPHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXRyaWFuZ2xlLXJpZ2h0XCIgLz4nLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICghaGFzTGVzcykge1xyXG4gICAgICAgICAgY29sTGVzcy4kbWV0YWRhdGFbJ2F0dHIuaGVhZCddLmNsYXNzLnB1c2goJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWhhc01vcmUpIHtcclxuICAgICAgICAgIGNvbE1vcmUuJG1ldGFkYXRhWydhdHRyLmhlYWQnXS5jbGFzcy5wdXNoKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZWN0LnNwbGljZSh1bmxvY2tlZEF0LCAwLCBjb2xMZXNzLnByb3BlcnR5KTtcclxuICAgICAgICBjb2x1bW5zW2NvbExlc3MucHJvcGVydHldID0gXy5kZWZhdWx0cyhjb2xMZXNzLCBjb2x1bW5zW2NvbExlc3MucHJvcGVydHldKTtcclxuICAgICAgICBzZWxlY3QucHVzaChjb2xNb3JlLnByb3BlcnR5KTtcclxuICAgICAgICBjb2x1bW5zW2NvbE1vcmUucHJvcGVydHldID0gXy5kZWZhdWx0cyhjb2xNb3JlLCBjb2x1bW5zW2NvbE1vcmUucHJvcGVydHldKTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXRjaCh7XHJcbiAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5zLFxyXG4gICAgICAgICAgc2VsZWN0OiBzZWxlY3QsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gdG9kbyBbYWthbWVsXSB1bnNldCBvdXIgcHJvcGVydGllcyBvbmx5XHJcbiAgICAgICAgLy8gdGhpcy51bnNldCgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgdGhDbGljazogZnVuY3Rpb24gKGUsIGFyZykge1xyXG4gICAgICBpZiAoXy5oYXMoYXJnLmNvbHVtbiwgJyRtZXRhZGF0YScpICYmIGFyZy5jb2x1bW4uJG1ldGFkYXRhLmVuYWJsZWQpIHtcclxuICAgICAgICB2YXIgcmV0ID0gMDtcclxuICAgICAgICB2YXIgc2tpcCA9IHRoaXMuZ2V0KCdjb2x1bW4uc2tpcCcpO1xyXG5cclxuICAgICAgICAvLyB0b2RvIFtha2FtZWxdIGlzIHRoaXMgbG9naWMgc29saWQ/XHJcbiAgICAgICAgc3dpdGNoIChhcmcucHJvcGVydHkpIHtcclxuICAgICAgICAgIGNhc2UgJ2NvbHVtbi5za2lwLmxlc3MnOiB7XHJcbiAgICAgICAgICAgIHJldCA9IF8uaXNOdW1iZXIoc2tpcCkgPyBNYXRoLm1heChza2lwIC0gMSwgMCkgOiAwO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNhc2UgJ2NvbHVtbi5za2lwLm1vcmUnOiB7XHJcbiAgICAgICAgICAgIHJldCA9IF8uaXNOdW1iZXIoc2tpcCkgPyBza2lwICsgMSA6IDA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0KHsgJ2NvbHVtbi5za2lwJzogcmV0IH0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gTW9kZWw7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vY29sdW1uLXNoaWZ0ZXIuanNcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL3Byb2plY3Rpb24vYmFzZScsXHJcbl0sIGZ1bmN0aW9uIChfLCBCYXNlUHJvamVjdGlvbikge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdmFyIE1vZGVsID0gQmFzZVByb2plY3Rpb24uZXh0ZW5kKHtcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICdjb2x1bW4udGVtcGxhdGUnOiB7fSxcclxuICAgIH0sXHJcbiAgICBuYW1lOiAnY29sdW1uLXRlbXBsYXRlJyxcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgLy8gdG9kbyBbYWthbWVsXSB3aGVuIGNhbGxpbmcgYSBkZWVwIHVwZGF0ZTsgc3VwcHJlc3Mgb25jaGFuZ2UgZXZlbnQgYmFzZWQgdXBkYXRlc1xyXG4gICAgICAvLyBNb2RlbC5fX3N1cGVyX18udXBkYXRlLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAvLyBUT0RPIFtpbWFuZ106IGNvbHVtbnM6IGlkZWFsbHkgd2Ugc2hvdWxkIG5vdCBuZWVkIHRvIHJlYWQgZnJvbSBzZWxlY3QuXHJcbiAgICAgIGlmIChNb2RlbC5fX3N1cGVyX18udXBkYXRlLmNhbGwodGhpcywgb3B0aW9ucykpIHtcclxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLnNyYy5kYXRhO1xyXG4gICAgICAgIHZhciBjb2xUZW1wbGF0ZSA9IHRoaXMuZ2V0KCdjb2x1bW4udGVtcGxhdGUnKTtcclxuICAgICAgICB2YXIgY29sdW1ucyA9IG1vZGVsLmdldCgnY29sdW1ucycpO1xyXG4gICAgICAgIF8uZWFjaChjb2x1bW5zLCBmdW5jdGlvbiAoaXRlbSwgcHJvcGVydHkpIHtcclxuICAgICAgICAgIHZhciByZXQgPSBfLmNsb25lKGl0ZW0pO1xyXG4gICAgICAgICAgdmFyIHRlbXBsYXRlVmFsdWUgPSBjb2xUZW1wbGF0ZVtwcm9wZXJ0eV07XHJcblxyXG4gICAgICAgICAgaWYgKF8uaGFzKGNvbFRlbXBsYXRlLCBwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgcmV0LiRodG1sID0gXy5pc0Z1bmN0aW9uKHRlbXBsYXRlVmFsdWUpID8gdGVtcGxhdGVWYWx1ZShyZXQpIDogdGVtcGxhdGVWYWx1ZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb2x1bW5zW3Byb3BlcnR5XSA9IHJldDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXRjaCh7IGNvbHVtbnM6IGNvbHVtbnMgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gdG9kbyBbYWthbWVsXSB1bnNldCBvdXIgcHJvcGVydGllcyBvbmx5XHJcbiAgICAgICAgLy8gdGhpcy51bnNldCgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gTW9kZWw7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vY29sdW1uLXRlbXBsYXRlLmpzXG4gKiovIiwiLyoqXHJcbiAqXHJcbiAqIEltcG9ydGFudCEhIVxyXG4gKlxyXG4gKiBUaGUgaW5pdGlhbCBjaGVjay1pbiBpcyBmb3IgdW5ibG9jayB0aGUgc2ltcGxlIGdyaWQgaW4gYWR2YW5jZWQgY2FtcGFpZ24gY3JlYXRpb24gYW5kXHJcbiAqIG1heSBjYXVzZSBidWdzIGlmIHlvdSB0cnkgdG8gdXNlIGl0IHdpdGggc29tZSBtb3JlIGNvbXBsZXggZ3JpZC4gUGxlYXNlIERPIE5PVCB1c2UgdGhpc1xyXG4gKiBwcm9qZWN0aW9uIHVudGlsIHdlIHVwZGF0ZSB0aGlzIGFuZCByZW1vdmUgdGhlIGNvbW1lbnRzIGhlcmUuXHJcbiAqXHJcbiAqIHRvZG8gW3l1Y29uZ2osIHdld2VpXSBhZGQgdGhlIG1vZGVsIHRvIG1haW50YWlsIHRoZSBpbnB1dCBkYXRhLlxyXG4gKlxyXG4gKi9cclxuXHJcbmRlZmluZShbXHJcbiAgJ2xpYi91bmRlcnNjb3JlJyxcclxuICAnbGliL2pxdWVyeScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL3Byb2plY3Rpb24vYmFzZScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL2xheW91dC90ZW1wbGF0ZS9yb3cuZWRpdGFibGUuc3RyaW5nLmphZGUnLFxyXG5dLCBmdW5jdGlvbiAoXywganF1ZXJ5LCBCYXNlUHJvamVjdGlvbiwgZWRpdGFibGVUZW1wbGF0ZSkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdmFyIE1vZGVsID0gQmFzZVByb2plY3Rpb24uZXh0ZW5kKHtcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICdjb2x1bW4uZWRpdGFibGUuc3RyaW5nJzoge30sXHJcbiAgICB9LFxyXG4gICAgbmFtZTogJ2NvbHVtbi1lZGl0YWJsZS1zdHJpbmcnLFxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICBpZiAoTW9kZWwuX19zdXBlcl9fLnVwZGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpKSB7XHJcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5zcmMuZGF0YTtcclxuICAgICAgICB2YXIgY29sdW1uRWRpdGFibGUgPSB0aGlzLmdldCgnY29sdW1uLmVkaXRhYmxlLnN0cmluZycpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IF8ubWFwKG1vZGVsLmdldCgndmFsdWUnKSwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgIHZhciByZXQgPSBfLmNsb25lKGl0ZW0pO1xyXG5cclxuICAgICAgICAgIF8uZWFjaChjb2x1bW5FZGl0YWJsZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgaWYgKF8uaGFzKHJldCwga2V5KSkge1xyXG4gICAgICAgICAgICAgIGlmICghXy5pc09iamVjdChyZXRba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBuZXcgT2JqZWN0KHJldFtrZXldKTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQocmV0W2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgIG9iai4kdW5kZWZpbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoXy5pc051bGwocmV0W2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgIG9iai4kbnVsbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBvYmo7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gKHJldFtrZXldLiR1bmRlZmluZWQgfHwgcmV0W2tleV0uJG51bGwpID8gdmFsdWUuZGVmYXVsdFZhbHVlIDogcmV0W2tleV07XHJcblxyXG4gICAgICAgICAgICAgIHJldFtrZXldLiRodG1sID0gZWRpdGFibGVUZW1wbGF0ZSh7IGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnBhdGNoKHsgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gTW9kZWw7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vZWRpdGFibGUtc3RyaW5nLmpzXG4gKiovIiwidmFyIGphZGUgPSByZXF1aXJlKFwiRDpcXFxcd29ya3NwYWNlXFxcXGZvcmtcXFxccHJvamVjdGlvbi1ncmlkXFxcXG5vZGVfbW9kdWxlc1xcXFxqYWRlXFxcXGxpYlxcXFxydW50aW1lLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRlbXBsYXRlKGxvY2Fscykge1xudmFyIGJ1ZiA9IFtdO1xudmFyIGphZGVfbWl4aW5zID0ge307XG52YXIgamFkZV9pbnRlcnA7XG47dmFyIGxvY2Fsc19mb3Jfd2l0aCA9IChsb2NhbHMgfHwge30pOyhmdW5jdGlvbiAoZGVmYXVsdFZhbHVlKSB7XG5idWYucHVzaChcIjxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIlwiICsgKGphZGUuYXR0cihcInZhbHVlXCIsIGRlZmF1bHRWYWx1ZSwgdHJ1ZSwgdHJ1ZSkpICsgXCIgc3R5bGU9XFxcIndpZHRoOjEwMCVcXFwiIGNsYXNzPVxcXCJncmlkLXRleHQtaW5wdXRcXFwiPlwiKTt9LmNhbGwodGhpcyxcImRlZmF1bHRWYWx1ZVwiIGluIGxvY2Fsc19mb3Jfd2l0aD9sb2NhbHNfZm9yX3dpdGguZGVmYXVsdFZhbHVlOnR5cGVvZiBkZWZhdWx0VmFsdWUhPT1cInVuZGVmaW5lZFwiP2RlZmF1bHRWYWx1ZTp1bmRlZmluZWQpKTs7cmV0dXJuIGJ1Zi5qb2luKFwiXCIpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vanMvbGF5b3V0L3RlbXBsYXRlL3Jvdy5lZGl0YWJsZS5zdHJpbmcuamFkZVxuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2xpYi9qcXVlcnknLFxyXG4gICdjb21wb25lbnQvZ3JpZC9wcm9qZWN0aW9uL2Jhc2UnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9sYXlvdXQvdGVtcGxhdGUvZWRpdGFibGUuamFkZScsXHJcbiAgJ2NvbXBvbmVudC9wb3B1cC1lZGl0b3IvaW5kZXgnLFxyXG4gICcuLi8uLi9sZXNzL2VkaXRhYmxlLmxlc3MnLFxyXG5dLCBmdW5jdGlvbiAoXywgJCwgQmFzZVByb2plY3Rpb24sIGRlZmF1bHRFZGl0YWJsZVRlbXBsYXRlLCBwcm9tcHQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGZ1bmN0aW9uIGlzUmVhZG9ubHlSb3coaXRlbSkge1xyXG4gICAgcmV0dXJuICFpdGVtIHx8IChpdGVtLiRtZXRhZGF0YSAmJiBfLmNvbnRhaW5zKFtcclxuICAgICAgJ2FnZ3JlZ2F0ZScsXHJcbiAgICAgICdzZWdtZW50YXRpb24nLFxyXG4gICAgXSwgaXRlbS4kbWV0YWRhdGEudHlwZSkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEJhc2VQcm9qZWN0aW9uLmV4dGVuZCh7XHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAnY29sdW1uLmVkaXRhYmxlJzogW10sXHJcbiAgICAgICdlZGl0YWJsZS5pY29uLmNsYXNzJzogWydnbHlwaGljb24nLCAnZ2x5cGhpY29uLXBlbmNpbCddLFxyXG4gICAgICAnZWRpdGFibGUudG9vbHRpcC50ZXh0JzogJ0VkaXQnLFxyXG4gICAgICAnZWRpdGFibGUudGVtcGxhdGUnOiBkZWZhdWx0RWRpdGFibGVUZW1wbGF0ZSxcclxuICAgIH0sXHJcbiAgICBuYW1lOiAnY29sdW1uLWVkaXRhYmxlJyxcclxuICAgIGV2ZW50czoge1xyXG4gICAgICAnbGF5b3V0OmNsaWNrOmNlbGwnOiAndGRDbGljaycsXHJcbiAgICB9LFxyXG5cclxuICAgIGJlZm9yZVNldDogZnVuY3Rpb24gKGxvY2FsKSB7XHJcbiAgICAgIHZhciBlZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChfLmhhcyhsb2NhbCwgJ2NvbHVtbi5lZGl0YWJsZScpKSB7XHJcbiAgICAgICAgbGV0IGVkaXRhYmxlT3B0aW9ucyA9IGxvY2FsWydjb2x1bW4uZWRpdGFibGUnXTtcclxuICAgICAgICBsZXQgdmlld0NvbmZpZyA9IHt9O1xyXG4gICAgICAgIGxldCBjb25kaXRpb25zID0ge307XHJcblxyXG4gICAgICAgIGlmIChfLmlzQXJyYXkoZWRpdGFibGVPcHRpb25zKSkge1xyXG4gICAgICAgICAgXy5lYWNoKGVkaXRhYmxlT3B0aW9ucywgZWRpdGFibGVDb2x1bW4gPT4ge1xyXG4gICAgICAgICAgICBpZiAoXy5pc1N0cmluZyhlZGl0YWJsZUNvbHVtbikpIHtcclxuICAgICAgICAgICAgICBjb25kaXRpb25zW2VkaXRhYmxlQ29sdW1uXSA9IGVkaXRhYmxlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoZWRpdGFibGVDb2x1bW4pICYmIF8uaXNTdHJpbmcoZWRpdGFibGVDb2x1bW4ubmFtZSkpIHtcclxuICAgICAgICAgICAgICBjb25kaXRpb25zW2VkaXRhYmxlQ29sdW1uLm5hbWVdID0gXy5pc0Z1bmN0aW9uKGVkaXRhYmxlQ29sdW1uLmNvbmRpdGlvbikgPyBlZGl0YWJsZUNvbHVtbi5jb25kaXRpb24gOiBlZGl0YWJsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2aWV3Q29uZmlnW2VkaXRhYmxlQ29sdW1uXSA9IG51bGw7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgXy5lYWNoKGVkaXRhYmxlT3B0aW9ucywgKG9wdGlvbnMsIGNvbHVtbk5hbWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgIGNvbmRpdGlvbnNbY29sdW1uTmFtZV0gPSBlZGl0YWJsZTtcclxuICAgICAgICAgICAgICB2aWV3Q29uZmlnW2NvbHVtbk5hbWVdID0gb3B0aW9ucztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgY29uZGl0aW9uc1tjb2x1bW5OYW1lXSA9IG9wdGlvbnMuY29uZGl0aW9uO1xyXG4gICAgICAgICAgICAgIHZpZXdDb25maWdbY29sdW1uTmFtZV0gPSBvcHRpb25zLmVkaXRvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZpZXdDb25maWcgPSB2aWV3Q29uZmlnO1xyXG4gICAgICAgIHRoaXMuaXNFZGl0YWJsZSA9IGZ1bmN0aW9uIChrZXksIGl0ZW0pIHtcclxuICAgICAgICAgIHJldHVybiBfLmlzRnVuY3Rpb24oY29uZGl0aW9uc1trZXldKSAmJiBjb25kaXRpb25zW2tleV0oaXRlbSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIGlmIChCYXNlUHJvamVjdGlvbi5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgb3B0aW9ucykpIHtcclxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLnNyYy5kYXRhO1xyXG4gICAgICAgIHZhciBjb2x1bW5zID0gbW9kZWwuZ2V0KCdjb2x1bW5zJyk7XHJcbiAgICAgICAgdmFyIGljb25DbGFzc2VzID0gdGhpcy5nZXQoJ2VkaXRhYmxlLmljb24uY2xhc3MnKTtcclxuICAgICAgICB2YXIgdG9vbHRpcFRleHQgPSB0aGlzLmdldCgnZWRpdGFibGUudG9vbHRpcC50ZXh0Jyk7XHJcbiAgICAgICAgdmFyIGVkaXRhYmxlVGVtcGxhdGUgPSB0aGlzLmdldCgnZWRpdGFibGUudGVtcGxhdGUnKTtcclxuXHJcbiAgICAgICAgXy5lYWNoKHRoaXMudmlld0NvbmZpZywgZnVuY3Rpb24gKHZpZXcsIGtleSkge1xyXG4gICAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNba2V5XSB8fCB7IHByb3BlcnR5OiBrZXkgfTtcclxuICAgICAgICAgIHZhciAkbWV0YWRhdGEgPSBjb2x1bW4uJG1ldGFkYXRhID0gY29sdW1uLiRtZXRhZGF0YSB8fCB7fTtcclxuICAgICAgICAgIHZhciBhdHRyQm9keSA9ICRtZXRhZGF0YVsnYXR0ci5ib2R5J10gPSAkbWV0YWRhdGFbJ2F0dHIuYm9keSddIHx8IHt9O1xyXG4gICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGF0dHJCb2R5LmNsYXNzIHx8IFtdO1xyXG5cclxuICAgICAgICAgIGlmIChfLmlzU3RyaW5nKGNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhdHRyQm9keS5jbGFzcyA9IF8udW5pb24oY2xhc3NOYW1lLCBbJ2dyaWQtZWRpdGFibGUtY2VsbCddKTtcclxuXHJcbiAgICAgICAgICBjb2x1bW5zW2tleV0gPSBjb2x1bW47XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZSA9IF8ubWFwKG1vZGVsLmdldCgndmFsdWUnKSwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5Um93KGl0ZW0pID8gaXRlbSA6IF8ubWFwT2JqZWN0KGl0ZW0sIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRWRpdGFibGUoa2V5LCBpdGVtKSkge1xyXG4gICAgICAgICAgICAgIHZhciAkaHRtbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICRodG1sID0gdmFsdWUuJGh0bWw7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRleHQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0ge307XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB2YWx1ZS4kaHRtbCA9IGVkaXRhYmxlVGVtcGxhdGUoe1xyXG4gICAgICAgICAgICAgICAgJGh0bWw6ICRodG1sLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBUZXh0OiB0b29sdGlwVGV4dCxcclxuICAgICAgICAgICAgICAgIGNsYXNzZXM6IGljb25DbGFzc2VzLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLnBhdGNoKHsgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHRkQ2xpY2s6IGZ1bmN0aW9uIChlLCBhcmcpIHtcclxuICAgICAgdmFyIHNjaGVtYSA9IG51bGw7XHJcbiAgICAgIHZhciBtZXRhZGF0YSA9IGFyZy5jb2x1bW4uJG1ldGFkYXRhO1xyXG4gICAgICAvLyBUT0RPOiB3ZXdlaVxyXG4gICAgICAvLyBsZXQncyByZXRoaW5rIHRoaXNcclxuICAgICAgdmFyIHByb3BlcnR5ID0gKG1ldGFkYXRhICYmIG1ldGFkYXRhLm1hcCkgfHwgYXJnLnByb3BlcnR5O1xyXG5cclxuICAgICAgaWYgKCFpc1JlYWRvbmx5Um93KGFyZy5tb2RlbCkgJiZcclxuICAgICAgICB0aGlzLmlzRWRpdGFibGUoYXJnLnByb3BlcnR5LCBhcmcubW9kZWwpICYmXHJcbiAgICAgICAgZS50YXJnZXQudGFnTmFtZSAhPT0gJ0EnICYmXHJcbiAgICAgICAgJChlLnRhcmdldCkuY2xvc2VzdCgnLmlzLW5vdC10cmlnZ2VyJykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgc2NoZW1hID0gYXJnLmdyaWQub3B0aW9ucy5nZXQoJ3NjaGVtYScpO1xyXG4gICAgICAgIGxldCBlZGl0b3IgPSB0aGlzLnZpZXdDb25maWdbYXJnLnByb3BlcnR5XSB8fCBwcm9tcHQ7XHJcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gYXJnLmdyaWQubGF5b3V0LmNvbnRhaW5lci5vZmZzZXQoZS5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgICBsZXQgJHRkID0gJChlLmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHBvc2l0aW9uLnJpZ2h0ID0gcG9zaXRpb24ubGVmdCArICR0ZC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgcG9zaXRpb24uYm90dG9tID0gcG9zaXRpb24udG9wICsgJHRkLm91dGVySGVpZ2h0KCk7XHJcbiAgICAgICAgZWRpdG9yKHtcclxuICAgICAgICAgIG1vZGVsOiBhcmcubW9kZWwsXHJcbiAgICAgICAgICBzY2hlbWE6IHNjaGVtYSxcclxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcclxuICAgICAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eSxcclxuICAgICAgICAgIG9uU3VibWl0OiBtb2RlbCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZWRpdCcsIG1vZGVsLCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICB9KTtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvcHJvamVjdGlvbi9lZGl0YWJsZS5qc1xuICoqLyIsInZhciBqYWRlID0gcmVxdWlyZShcIkQ6XFxcXHdvcmtzcGFjZVxcXFxmb3JrXFxcXHByb2plY3Rpb24tZ3JpZFxcXFxub2RlX21vZHVsZXNcXFxcamFkZVxcXFxsaWJcXFxccnVudGltZS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZW1wbGF0ZShsb2NhbHMpIHtcbnZhciBidWYgPSBbXTtcbnZhciBqYWRlX21peGlucyA9IHt9O1xudmFyIGphZGVfaW50ZXJwO1xuO3ZhciBsb2NhbHNfZm9yX3dpdGggPSAobG9jYWxzIHx8IHt9KTsoZnVuY3Rpb24gKCRodG1sLCBjbGFzc2VzLCB0ZXh0LCB0b29sdGlwVGV4dCkge1xuYnVmLnB1c2goXCI8ZGl2XCIgKyAoamFkZS5hdHRyKFwidGl0bGVcIiwgdG9vbHRpcFRleHQsIHRydWUsIHRydWUpKSArIChqYWRlLmNscyhbJ2dyaWQtZWRpdC1pY29uJyxjbGFzc2VzXSwgW251bGwsdHJ1ZV0pKSArIFwiPjwvZGl2PlwiICsgKG51bGwgPT0gKGphZGVfaW50ZXJwID0gJGh0bWwpID8gXCJcIiA6IGphZGVfaW50ZXJwKSArIChqYWRlLmVzY2FwZShudWxsID09IChqYWRlX2ludGVycCA9IHRleHQpID8gXCJcIiA6IGphZGVfaW50ZXJwKSkpO30uY2FsbCh0aGlzLFwiJGh0bWxcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLiRodG1sOnR5cGVvZiAkaHRtbCE9PVwidW5kZWZpbmVkXCI/JGh0bWw6dW5kZWZpbmVkLFwiY2xhc3Nlc1wiIGluIGxvY2Fsc19mb3Jfd2l0aD9sb2NhbHNfZm9yX3dpdGguY2xhc3Nlczp0eXBlb2YgY2xhc3NlcyE9PVwidW5kZWZpbmVkXCI/Y2xhc3Nlczp1bmRlZmluZWQsXCJ0ZXh0XCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC50ZXh0OnR5cGVvZiB0ZXh0IT09XCJ1bmRlZmluZWRcIj90ZXh0OnVuZGVmaW5lZCxcInRvb2x0aXBUZXh0XCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC50b29sdGlwVGV4dDp0eXBlb2YgdG9vbHRpcFRleHQhPT1cInVuZGVmaW5lZFwiP3Rvb2x0aXBUZXh0OnVuZGVmaW5lZCkpOztyZXR1cm4gYnVmLmpvaW4oXCJcIik7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9qcy9sYXlvdXQvdGVtcGxhdGUvZWRpdGFibGUuamFkZVxuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdqcXVlcnknLFxyXG4gICdibHVlYmlyZCcsXHJcbiAgJ2JhY2tib25lJyxcclxuICAndW5kZXJzY29yZScsXHJcbiAgJy4vaW5kZXguamFkZScsXHJcbl0sIGZ1bmN0aW9uICgkLCBQcm9taXNlLCBCYWNrYm9uZSwgXywgdGVtcGxhdGUpIHtcclxuICB2YXIgUG9wdXBFZGl0b3IgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgICBldmVudHM6IHtcclxuICAgICAgJ2NsaWNrIC5zYXZlJzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignc2F2ZScsIHRoaXMubW9kZWwpO1xyXG4gICAgICB9LFxyXG4gICAgICAnY2xpY2sgLmNhbmNlbCc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NhbmNlbCcpO1xyXG4gICAgICB9LFxyXG4gICAgICAnY2hhbmdlIC5lZGl0b3InOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHRoaXMuc2V0VmFsdWUoZS50YXJnZXQudmFsdWUpO1xyXG4gICAgICB9LFxyXG4gICAgICAnY2xpY2sgZm9ybSc6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgfSxcclxuICAgICAgJ3N1Ym1pdCBmb3JtJzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignc2F2ZScsIHRoaXMubW9kZWwpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgdGhpcy5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xyXG4gICAgICB0aGlzLnByb3BlcnR5ID0gb3B0aW9ucy5wcm9wZXJ0eTtcclxuICAgICAgdGhpcy5zYXZlQnV0dG9uVGV4dCA9IG9wdGlvbnMuc2F2ZUJ1dHRvblRleHQgfHwgJ1NhdmUnO1xyXG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvblRleHQgPSBvcHRpb25zLmNhbmNlbEJ1dHRvblRleHQgfHwgJ0NhbmNlbCc7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLnByb3BlcnR5ICYmIF8uaXNPYmplY3QodGhpcy5wcm9wZXJ0eSkpIHtcclxuICAgICAgICBjb25zdCB7IG5hbWUsIHZhbHVlIH0gPSB0aGlzLnByb3BlcnR5O1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLm1vZGVsKVtuYW1lXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuICh0aGlzLm1vZGVsIHx8IHt9KVt0aGlzLnByb3BlcnR5XTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgaWYgKHRoaXMucHJvcGVydHkgJiYgXy5pc09iamVjdCh0aGlzLnByb3BlcnR5KSkge1xyXG4gICAgICAgIGNvbnN0IHsgbmFtZSwgdmFsdWUgfSA9IHRoaXMucHJvcGVydHk7XHJcbiAgICAgICAgdmFsdWUodGhpcy5tb2RlbClbbmFtZV0gPSB2YWw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbFt0aGlzLnByb3BlcnR5XSA9IHZhbDtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHZhbCA9IHRoaXMuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoe1xyXG4gICAgICAgIHZhbHVlOiB2YWwsXHJcbiAgICAgICAgc2F2ZUJ1dHRvblRleHQ6IHRoaXMuc2F2ZUJ1dHRvblRleHQsXHJcbiAgICAgICAgY2FuY2VsQnV0dG9uVGV4dDogdGhpcy5jYW5jZWxCdXR0b25UZXh0LFxyXG4gICAgICB9KSk7XHJcbiAgICAgIHRoaXMuJGVsLmNzcyh7IHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0pO1xyXG5cclxuICAgICAgaWYgKHRoaXMucG9zaXRpb24ubGVmdCkge1xyXG4gICAgICAgIHRoaXMuJGVsLmNzcyh7IGxlZnQ6IHRoaXMucG9zaXRpb24ubGVmdCB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLiRlbC5jc3MoeyByaWdodDogdGhpcy5wb3NpdGlvbi5yaWdodCB9KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5wb3NpdGlvbi50b3ApIHtcclxuICAgICAgICB0aGlzLiRlbC5jc3MoeyB0b3A6IHRoaXMucG9zaXRpb24udG9wIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuJGVsLmNzcyh7IGJvdHRvbTogdGhpcy5wb3NpdGlvbi5ib3R0b20gfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZGlzbWlzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NhbmNlbCcpO1xyXG4gICAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdjbGljaycsIHRoaXMuZGlzbWlzcyk7XHJcbiAgICAgIH0sIDApO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAkKHdpbmRvdykub2ZmKCdjbGljaycsIHRoaXMuZGlzbWlzcyk7XHJcbiAgICAgIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmb2N1czogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLiRlbC5maW5kKCcuZWRpdG9yJyk7XHJcbiAgICAgIGlucHV0LnNlbGVjdCgpO1xyXG4gICAgfSxcclxuXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGVkaXRvciA9IG5ldyBQb3B1cEVkaXRvcihvcHRpb25zKTtcclxuXHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVkaXRvci5yZW5kZXIoKS5lbCk7XHJcblxyXG4gICAgZWRpdG9yLmZvY3VzKCk7XHJcblxyXG4gICAgZWRpdG9yLm9uKCdzYXZlJywgZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcclxuICAgICAgb3B0aW9ucy5vblN1Ym1pdCAmJiBvcHRpb25zLm9uU3VibWl0KG1vZGVsKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGVkaXRvci5vbignY2FuY2VsJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBlZGl0b3IucmVtb3ZlKCk7XHJcbiAgICAgIG9wdGlvbnMub25DYW5jZWwgJiYgb3B0aW9ucy5vbkNhbmNlbCgpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvcG9wdXAtZWRpdG9yL2luZGV4LmpzXG4gKiovIiwiLyogQHByZXNlcnZlXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgUGV0a2EgQW50b25vdlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICogXG4gKi9cbi8qKlxuICogYmx1ZWJpcmQgYnVpbGQgdmVyc2lvbiAzLjQuNlxuICogRmVhdHVyZXMgZW5hYmxlZDogY29yZSwgcmFjZSwgY2FsbF9nZXQsIGdlbmVyYXRvcnMsIG1hcCwgbm9kZWlmeSwgcHJvbWlzaWZ5LCBwcm9wcywgcmVkdWNlLCBzZXR0bGUsIHNvbWUsIHVzaW5nLCB0aW1lcnMsIGZpbHRlciwgYW55LCBlYWNoXG4qL1xuIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYuUHJvbWlzZT1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgX2RlcmVxXz09XCJmdW5jdGlvblwiJiZfZGVyZXFfO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiBfZGVyZXFfPT1cImZ1bmN0aW9uXCImJl9kZXJlcV87Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgU29tZVByb21pc2VBcnJheSA9IFByb21pc2UuX1NvbWVQcm9taXNlQXJyYXk7XG5mdW5jdGlvbiBhbnkocHJvbWlzZXMpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFNvbWVQcm9taXNlQXJyYXkocHJvbWlzZXMpO1xuICAgIHZhciBwcm9taXNlID0gcmV0LnByb21pc2UoKTtcbiAgICByZXQuc2V0SG93TWFueSgxKTtcbiAgICByZXQuc2V0VW53cmFwKCk7XG4gICAgcmV0LmluaXQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5hbnkgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gYW55KHByb21pc2VzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYW55KHRoaXMpO1xufTtcblxufTtcblxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBmaXJzdExpbmVFcnJvcjtcbnRyeSB7dGhyb3cgbmV3IEVycm9yKCk7IH0gY2F0Y2ggKGUpIHtmaXJzdExpbmVFcnJvciA9IGU7fVxudmFyIHNjaGVkdWxlID0gX2RlcmVxXyhcIi4vc2NoZWR1bGVcIik7XG52YXIgUXVldWUgPSBfZGVyZXFfKFwiLi9xdWV1ZVwiKTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gQXN5bmMoKSB7XG4gICAgdGhpcy5fY3VzdG9tU2NoZWR1bGVyID0gZmFsc2U7XG4gICAgdGhpcy5faXNUaWNrVXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xhdGVRdWV1ZSA9IG5ldyBRdWV1ZSgxNik7XG4gICAgdGhpcy5fbm9ybWFsUXVldWUgPSBuZXcgUXVldWUoMTYpO1xuICAgIHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzID0gZmFsc2U7XG4gICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSB0cnVlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRyYWluUXVldWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9kcmFpblF1ZXVlcygpO1xuICAgIH07XG4gICAgdGhpcy5fc2NoZWR1bGUgPSBzY2hlZHVsZTtcbn1cblxuQXN5bmMucHJvdG90eXBlLnNldFNjaGVkdWxlciA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIHByZXYgPSB0aGlzLl9zY2hlZHVsZTtcbiAgICB0aGlzLl9zY2hlZHVsZSA9IGZuO1xuICAgIHRoaXMuX2N1c3RvbVNjaGVkdWxlciA9IHRydWU7XG4gICAgcmV0dXJuIHByZXY7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuaGFzQ3VzdG9tU2NoZWR1bGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1c3RvbVNjaGVkdWxlcjtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5lbmFibGVUcmFtcG9saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSB0cnVlO1xufTtcblxuQXN5bmMucHJvdG90eXBlLmRpc2FibGVUcmFtcG9saW5lSWZOZWNlc3NhcnkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5oYXNEZXZUb29scykge1xuICAgICAgICB0aGlzLl90cmFtcG9saW5lRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS5oYXZlSXRlbXNRdWV1ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVGlja1VzZWQgfHwgdGhpcy5faGF2ZURyYWluZWRRdWV1ZXM7XG59O1xuXG5cbkFzeW5jLnByb3RvdHlwZS5mYXRhbEVycm9yID0gZnVuY3Rpb24oZSwgaXNOb2RlKSB7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShcIkZhdGFsIFwiICsgKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUuc3RhY2sgOiBlKSArXG4gICAgICAgICAgICBcIlxcblwiKTtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGhyb3dMYXRlcihlKTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUudGhyb3dMYXRlciA9IGZ1bmN0aW9uKGZuLCBhcmcpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBhcmcgPSBmbjtcbiAgICAgICAgZm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IGFyZzsgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbihhcmcpO1xuICAgICAgICB9LCAwKTtcbiAgICB9IGVsc2UgdHJ5IHtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbihhcmcpO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIEFzeW5jSW52b2tlTGF0ZXIoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB0aGlzLl9sYXRlUXVldWUucHVzaChmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgdGhpcy5fcXVldWVUaWNrKCk7XG59XG5cbmZ1bmN0aW9uIEFzeW5jSW52b2tlKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdGhpcy5fbm9ybWFsUXVldWUucHVzaChmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgdGhpcy5fcXVldWVUaWNrKCk7XG59XG5cbmZ1bmN0aW9uIEFzeW5jU2V0dGxlUHJvbWlzZXMocHJvbWlzZSkge1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlLl9wdXNoT25lKHByb21pc2UpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5pZiAoIXV0aWwuaGFzRGV2VG9vbHMpIHtcbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlTGF0ZXIgPSBBc3luY0ludm9rZUxhdGVyO1xuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2UgPSBBc3luY0ludm9rZTtcbiAgICBBc3luYy5wcm90b3R5cGUuc2V0dGxlUHJvbWlzZXMgPSBBc3luY1NldHRsZVByb21pc2VzO1xufSBlbHNlIHtcbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlTGF0ZXIgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICBBc3luY0ludm9rZUxhdGVyLmNhbGwodGhpcywgZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIEFzeW5jSW52b2tlLmNhbGwodGhpcywgZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFzeW5jLnByb3RvdHlwZS5zZXR0bGVQcm9taXNlcyA9IGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICBBc3luY1NldHRsZVByb21pc2VzLmNhbGwodGhpcywgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5Bc3luYy5wcm90b3R5cGUuaW52b2tlRmlyc3QgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS51bnNoaWZ0KGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fZHJhaW5RdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCgpID4gMCkge1xuICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZuLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdmFyIGFyZyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kcmFpblF1ZXVlKHRoaXMuX25vcm1hbFF1ZXVlKTtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzID0gdHJ1ZTtcbiAgICB0aGlzLl9kcmFpblF1ZXVlKHRoaXMuX2xhdGVRdWV1ZSk7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuX3F1ZXVlVGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2lzVGlja1VzZWQpIHtcbiAgICAgICAgdGhpcy5faXNUaWNrVXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuZHJhaW5RdWV1ZXMpO1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNUaWNrVXNlZCA9IGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3luYztcbm1vZHVsZS5leHBvcnRzLmZpcnN0TGluZUVycm9yID0gZmlyc3RMaW5lRXJyb3I7XG5cbn0se1wiLi9xdWV1ZVwiOjI2LFwiLi9zY2hlZHVsZVwiOjI5LFwiLi91dGlsXCI6MzZ9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgZGVidWcpIHtcbnZhciBjYWxsZWRCaW5kID0gZmFsc2U7XG52YXIgcmVqZWN0VGhpcyA9IGZ1bmN0aW9uKF8sIGUpIHtcbiAgICB0aGlzLl9yZWplY3QoZSk7XG59O1xuXG52YXIgdGFyZ2V0UmVqZWN0ZWQgPSBmdW5jdGlvbihlLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5wcm9taXNlUmVqZWN0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICBjb250ZXh0LmJpbmRpbmdQcm9taXNlLl90aGVuKHJlamVjdFRoaXMsIHJlamVjdFRoaXMsIG51bGwsIHRoaXMsIGUpO1xufTtcblxudmFyIGJpbmRpbmdSZXNvbHZlZCA9IGZ1bmN0aW9uKHRoaXNBcmcsIGNvbnRleHQpIHtcbiAgICBpZiAoKCh0aGlzLl9iaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKGNvbnRleHQudGFyZ2V0KTtcbiAgICB9XG59O1xuXG52YXIgYmluZGluZ1JlamVjdGVkID0gZnVuY3Rpb24oZSwgY29udGV4dCkge1xuICAgIGlmICghY29udGV4dC5wcm9taXNlUmVqZWN0aW9uUXVldWVkKSB0aGlzLl9yZWplY3QoZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICBpZiAoIWNhbGxlZEJpbmQpIHtcbiAgICAgICAgY2FsbGVkQmluZCA9IHRydWU7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gZGVidWcucHJvcGFnYXRlRnJvbUZ1bmN0aW9uKCk7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9ib3VuZFZhbHVlID0gZGVidWcuYm91bmRWYWx1ZUZ1bmN0aW9uKCk7XG4gICAgfVxuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXNBcmcpO1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9wcm9wYWdhdGVGcm9tKHRoaXMsIDEpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICByZXQuX3NldEJvdW5kVG8obWF5YmVQcm9taXNlKTtcbiAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHByb21pc2VSZWplY3Rpb25RdWV1ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvbWlzZTogcmV0LFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBiaW5kaW5nUHJvbWlzZTogbWF5YmVQcm9taXNlXG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldC5fdGhlbihJTlRFUk5BTCwgdGFyZ2V0UmVqZWN0ZWQsIHVuZGVmaW5lZCwgcmV0LCBjb250ZXh0KTtcbiAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKFxuICAgICAgICAgICAgYmluZGluZ1Jlc29sdmVkLCBiaW5kaW5nUmVqZWN0ZWQsIHVuZGVmaW5lZCwgcmV0LCBjb250ZXh0KTtcbiAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChtYXliZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5fcmVzb2x2ZUNhbGxiYWNrKHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Qm91bmRUbyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDIwOTcxNTI7XG4gICAgICAgIHRoaXMuX2JvdW5kVG8gPSBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MjA5NzE1Mik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDIwOTcxNTIpID09PSAyMDk3MTUyO1xufTtcblxuUHJvbWlzZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkuYmluZCh0aGlzQXJnKTtcbn07XG59O1xuXG59LHt9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIG9sZDtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIikgb2xkID0gUHJvbWlzZTtcbmZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgdHJ5IHsgaWYgKFByb21pc2UgPT09IGJsdWViaXJkKSBQcm9taXNlID0gb2xkOyB9XG4gICAgY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGJsdWViaXJkO1xufVxudmFyIGJsdWViaXJkID0gX2RlcmVxXyhcIi4vcHJvbWlzZVwiKSgpO1xuYmx1ZWJpcmQubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGJsdWViaXJkO1xuXG59LHtcIi4vcHJvbWlzZVwiOjIyfV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBjciA9IE9iamVjdC5jcmVhdGU7XG5pZiAoY3IpIHtcbiAgICB2YXIgY2FsbGVyQ2FjaGUgPSBjcihudWxsKTtcbiAgICB2YXIgZ2V0dGVyQ2FjaGUgPSBjcihudWxsKTtcbiAgICBjYWxsZXJDYWNoZVtcIiBzaXplXCJdID0gZ2V0dGVyQ2FjaGVbXCIgc2l6ZVwiXSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIGNhbkV2YWx1YXRlID0gdXRpbC5jYW5FdmFsdWF0ZTtcbnZhciBpc0lkZW50aWZpZXIgPSB1dGlsLmlzSWRlbnRpZmllcjtcblxudmFyIGdldE1ldGhvZENhbGxlcjtcbnZhciBnZXRHZXR0ZXI7XG5pZiAoIXRydWUpIHtcbnZhciBtYWtlTWV0aG9kQ2FsbGVyID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiZW5zdXJlTWV0aG9kXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGVuc3VyZU1ldGhvZChvYmosICdtZXRob2ROYW1lJyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHN3aXRjaChsZW4pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBvYmoubWV0aG9kTmFtZSh0aGlzWzBdKTsgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBvYmoubWV0aG9kTmFtZSh0aGlzWzBdLCB0aGlzWzFdKTsgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBvYmoubWV0aG9kTmFtZSh0aGlzWzBdLCB0aGlzWzFdLCB0aGlzWzJdKTsgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBvYmoubWV0aG9kTmFtZSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5tZXRob2ROYW1lLmFwcGx5KG9iaiwgdGhpcyk7ICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgXCIucmVwbGFjZSgvbWV0aG9kTmFtZS9nLCBtZXRob2ROYW1lKSkoZW5zdXJlTWV0aG9kKTtcbn07XG5cbnZhciBtYWtlR2V0dGVyID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJvYmpcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gb2JqLnByb3BlcnR5TmFtZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKFwicHJvcGVydHlOYW1lXCIsIHByb3BlcnR5TmFtZSkpO1xufTtcblxudmFyIGdldENvbXBpbGVkID0gZnVuY3Rpb24obmFtZSwgY29tcGlsZXIsIGNhY2hlKSB7XG4gICAgdmFyIHJldCA9IGNhY2hlW25hbWVdO1xuICAgIGlmICh0eXBlb2YgcmV0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXIobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IGNvbXBpbGVyKG5hbWUpO1xuICAgICAgICBjYWNoZVtuYW1lXSA9IHJldDtcbiAgICAgICAgY2FjaGVbXCIgc2l6ZVwiXSsrO1xuICAgICAgICBpZiAoY2FjaGVbXCIgc2l6ZVwiXSA+IDUxMikge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjYWNoZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSBkZWxldGUgY2FjaGVba2V5c1tpXV07XG4gICAgICAgICAgICBjYWNoZVtcIiBzaXplXCJdID0ga2V5cy5sZW5ndGggLSAyNTY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmdldE1ldGhvZENhbGxlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gZ2V0Q29tcGlsZWQobmFtZSwgbWFrZU1ldGhvZENhbGxlciwgY2FsbGVyQ2FjaGUpO1xufTtcblxuZ2V0R2V0dGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBnZXRDb21waWxlZChuYW1lLCBtYWtlR2V0dGVyLCBnZXR0ZXJDYWNoZSk7XG59O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgdmFyIGZuO1xuICAgIGlmIChvYmogIT0gbnVsbCkgZm4gPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJPYmplY3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKG9iaikgKyBcIiBoYXMgbm8gbWV0aG9kICdcIiArXG4gICAgICAgICAgICB1dGlsLnRvU3RyaW5nKG1ldGhvZE5hbWUpICsgXCInXCI7XG4gICAgICAgIHRocm93IG5ldyBQcm9taXNlLlR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZuO1xufVxuXG5mdW5jdGlvbiBjYWxsZXIob2JqKSB7XG4gICAgdmFyIG1ldGhvZE5hbWUgPSB0aGlzLnBvcCgpO1xuICAgIHZhciBmbiA9IGVuc3VyZU1ldGhvZChvYmosIG1ldGhvZE5hbWUpO1xuICAgIHJldHVybiBmbi5hcHBseShvYmosIHRoaXMpO1xufVxuUHJvbWlzZS5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7O1xuICAgIGlmICghdHJ1ZSkge1xuICAgICAgICBpZiAoY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgIHZhciBtYXliZUNhbGxlciA9IGdldE1ldGhvZENhbGxlcihtZXRob2ROYW1lKTtcbiAgICAgICAgICAgIGlmIChtYXliZUNhbGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICAgICAgICAgICAgICBtYXliZUNhbGxlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3MsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXJncy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgIHJldHVybiB0aGlzLl90aGVuKGNhbGxlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3MsIHVuZGVmaW5lZCk7XG59O1xuXG5mdW5jdGlvbiBuYW1lZEdldHRlcihvYmopIHtcbiAgICByZXR1cm4gb2JqW3RoaXNdO1xufVxuZnVuY3Rpb24gaW5kZXhlZEdldHRlcihvYmopIHtcbiAgICB2YXIgaW5kZXggPSArdGhpcztcbiAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IE1hdGgubWF4KDAsIGluZGV4ICsgb2JqLmxlbmd0aCk7XG4gICAgcmV0dXJuIG9ialtpbmRleF07XG59XG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgdmFyIGlzSW5kZXggPSAodHlwZW9mIHByb3BlcnR5TmFtZSA9PT0gXCJudW1iZXJcIik7XG4gICAgdmFyIGdldHRlcjtcbiAgICBpZiAoIWlzSW5kZXgpIHtcbiAgICAgICAgaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF5YmVHZXR0ZXIgPSBnZXRHZXR0ZXIocHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGdldHRlciA9IG1heWJlR2V0dGVyICE9PSBudWxsID8gbWF5YmVHZXR0ZXIgOiBuYW1lZEdldHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldHRlciA9IG5hbWVkR2V0dGVyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gaW5kZXhlZEdldHRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZ2V0dGVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcHJvcGVydHlOYW1lLCB1bmRlZmluZWQpO1xufTtcbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgZGVidWcpIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG5cblByb21pc2UucHJvdG90eXBlW1wiYnJlYWtcIl0gPSBQcm9taXNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWRlYnVnLmNhbmNlbGxhdGlvbigpKSByZXR1cm4gdGhpcy5fd2FybihcImNhbmNlbGxhdGlvbiBpcyBkaXNhYmxlZFwiKTtcblxuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY2hpbGQgPSBwcm9taXNlO1xuICAgIHdoaWxlIChwcm9taXNlLl9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgaWYgKCFwcm9taXNlLl9jYW5jZWxCeShjaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5faXNGb2xsb3dpbmcoKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLl9mb2xsb3dlZSgpLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fY2FuY2VsQnJhbmNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHByb21pc2UuX2NhbmNlbGxhdGlvblBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCA9PSBudWxsIHx8ICFwYXJlbnQuX2lzQ2FuY2VsbGFibGUoKSkge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2lzRm9sbG93aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9mb2xsb3dlZSgpLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9jYW5jZWxCcmFuY2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faXNGb2xsb3dpbmcoKSkgcHJvbWlzZS5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIHByb21pc2UuX3NldFdpbGxCZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgY2hpbGQgPSBwcm9taXNlO1xuICAgICAgICAgICAgcHJvbWlzZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9icmFuY2hIYXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsLS07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZW5vdWdoQnJhbmNoZXNIYXZlQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsIDw9IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsQnkgPSBmdW5jdGlvbihjYW5jZWxsZXIpIHtcbiAgICBpZiAoY2FuY2VsbGVyID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSAwO1xuICAgICAgICB0aGlzLl9pbnZva2VPbkNhbmNlbCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9icmFuY2hIYXNDYW5jZWxsZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VPbkNhbmNlbCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbEJyYW5jaGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCgpKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuO1xuICAgIHRoaXMuX3NldENhbmNlbGxlZCgpO1xuICAgIGFzeW5jLmludm9rZSh0aGlzLl9jYW5jZWxQcm9taXNlcywgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWxQcm9taXNlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9sZW5ndGgoKSA+IDApIHRoaXMuX3NldHRsZVByb21pc2VzKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX29uQ2FuY2VsRmllbGQgPSB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGVuZGluZygpICYmICF0aGlzLl9pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGVuZGluZygpICYmICF0aGlzLmlzQ2FuY2VsbGVkKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZG9JbnZva2VPbkNhbmNlbCA9IGZ1bmN0aW9uKG9uQ2FuY2VsQ2FsbGJhY2ssIGludGVybmFsT25seSkge1xuICAgIGlmICh1dGlsLmlzQXJyYXkob25DYW5jZWxDYWxsYmFjaykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbkNhbmNlbENhbGxiYWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLl9kb0ludm9rZU9uQ2FuY2VsKG9uQ2FuY2VsQ2FsbGJhY2tbaV0sIGludGVybmFsT25seSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9uQ2FuY2VsQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9uQ2FuY2VsQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbE9ubHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRyeUNhdGNoKG9uQ2FuY2VsQ2FsbGJhY2spLmNhbGwodGhpcy5fYm91bmRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAoZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNoRXh0cmFUcmFjZShlLmUpO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUuZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25DYW5jZWxDYWxsYmFjay5fcmVzdWx0Q2FuY2VsbGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ludm9rZU9uQ2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uQ2FuY2VsQ2FsbGJhY2sgPSB0aGlzLl9vbkNhbmNlbCgpO1xuICAgIHRoaXMuX3Vuc2V0T25DYW5jZWwoKTtcbiAgICBhc3luYy5pbnZva2UodGhpcy5fZG9JbnZva2VPbkNhbmNlbCwgdGhpcywgb25DYW5jZWxDYWxsYmFjayk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faW52b2tlSW50ZXJuYWxPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgdGhpcy5fZG9JbnZva2VPbkNhbmNlbCh0aGlzLl9vbkNhbmNlbCgpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fdW5zZXRPbkNhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbmNlbCgpO1xufTtcblxufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5FWFRfRklMVEVSKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgZ2V0S2V5cyA9IF9kZXJlcV8oXCIuL2VzNVwiKS5rZXlzO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG5cbmZ1bmN0aW9uIGNhdGNoRmlsdGVyKGluc3RhbmNlcywgY2IsIHByb21pc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgYm91bmRUbyA9IHByb21pc2UuX2JvdW5kVmFsdWUoKTtcbiAgICAgICAgcHJlZGljYXRlTG9vcDogZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaW5zdGFuY2VzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gRXJyb3IgfHxcbiAgICAgICAgICAgICAgICAoaXRlbSAhPSBudWxsICYmIGl0ZW0ucHJvdG90eXBlIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlDYXRjaChjYikuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlc1ByZWRpY2F0ZSA9IHRyeUNhdGNoKGl0ZW0pLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNQcmVkaWNhdGUgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzUHJlZGljYXRlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlc1ByZWRpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5Q2F0Y2goY2IpLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBnZXRLZXlzKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1ba2V5XSAhPSBlW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHByZWRpY2F0ZUxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBORVhUX0ZJTFRFUjtcbiAgICB9O1xufVxuXG5yZXR1cm4gY2F0Y2hGaWx0ZXI7XG59O1xuXG59LHtcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciBsb25nU3RhY2tUcmFjZXMgPSBmYWxzZTtcbnZhciBjb250ZXh0U3RhY2sgPSBbXTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IGZ1bmN0aW9uKCkge3JldHVybiBudWxsO307XG5Qcm9taXNlLl9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IGZ1bmN0aW9uKCkge307XG5cbmZ1bmN0aW9uIENvbnRleHQoKSB7XG4gICAgdGhpcy5fdHJhY2UgPSBuZXcgQ29udGV4dC5DYXB0dXJlZFRyYWNlKHBlZWtDb250ZXh0KCkpO1xufVxuQ29udGV4dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl90cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3RyYWNlLl9wcm9taXNlQ3JlYXRlZCA9IG51bGw7XG4gICAgICAgIGNvbnRleHRTdGFjay5wdXNoKHRoaXMuX3RyYWNlKTtcbiAgICB9XG59O1xuXG5Db250ZXh0LnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdHJhY2UgPSBjb250ZXh0U3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZXQgPSB0cmFjZS5fcHJvbWlzZUNyZWF0ZWQ7XG4gICAgICAgIHRyYWNlLl9wcm9taXNlQ3JlYXRlZCA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dCgpIHtcbiAgICBpZiAobG9uZ1N0YWNrVHJhY2VzKSByZXR1cm4gbmV3IENvbnRleHQoKTtcbn1cblxuZnVuY3Rpb24gcGVla0NvbnRleHQoKSB7XG4gICAgdmFyIGxhc3RJbmRleCA9IGNvbnRleHRTdGFjay5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dFN0YWNrW2xhc3RJbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5Db250ZXh0LkNhcHR1cmVkVHJhY2UgPSBudWxsO1xuQ29udGV4dC5jcmVhdGUgPSBjcmVhdGVDb250ZXh0O1xuQ29udGV4dC5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7fTtcbkNvbnRleHQuYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgUHJvbWlzZV9wdXNoQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wb3BDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfUGVla0NvbnRleHQgPSBQcm9taXNlLl9wZWVrQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wcm9taXNlQ3JlYXRlZCA9IFByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZDtcbiAgICBDb250ZXh0LmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gUHJvbWlzZV9wdXNoQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBQcm9taXNlX3BvcENvbnRleHQ7XG4gICAgICAgIFByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZV9QZWVrQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gUHJvbWlzZV9wZWVrQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gUHJvbWlzZV9wcm9taXNlQ3JlYXRlZDtcbiAgICAgICAgbG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG4gICAgfTtcbiAgICBsb25nU3RhY2tUcmFjZXMgPSB0cnVlO1xuICAgIFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IENvbnRleHQucHJvdG90eXBlLl9wdXNoQ29udGV4dDtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IENvbnRleHQucHJvdG90eXBlLl9wb3BDb250ZXh0O1xuICAgIFByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gcGVla0NvbnRleHQ7XG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9wZWVrQ29udGV4dCgpO1xuICAgICAgICBpZiAoY3R4ICYmIGN0eC5fcHJvbWlzZUNyZWF0ZWQgPT0gbnVsbCkgY3R4Ll9wcm9taXNlQ3JlYXRlZCA9IHRoaXM7XG4gICAgfTtcbn07XG5yZXR1cm4gQ29udGV4dDtcbn07XG5cbn0se31dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIENvbnRleHQpIHtcbnZhciBnZXREb21haW4gPSBQcm9taXNlLl9nZXREb21haW47XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcbnZhciBXYXJuaW5nID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpLldhcm5pbmc7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgY2FuQXR0YWNoVHJhY2UgPSB1dGlsLmNhbkF0dGFjaFRyYWNlO1xudmFyIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQ7XG52YXIgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb247XG52YXIgYmx1ZWJpcmRGcmFtZVBhdHRlcm4gPVxuICAgIC9bXFxcXFxcL11ibHVlYmlyZFtcXFxcXFwvXWpzW1xcXFxcXC9dKHJlbGVhc2V8ZGVidWd8aW5zdHJ1bWVudGVkKS87XG52YXIgbm9kZUZyYW1lUGF0dGVybiA9IC9cXCgoPzp0aW1lcnNcXC5qcyk6XFxkKzpcXGQrXFwpLztcbnZhciBwYXJzZUxpbmVQYXR0ZXJuID0gL1tcXC88XFwoXSguKz8pOihcXGQrKTooXFxkKylcXCk/XFxzKiQvO1xudmFyIHN0YWNrRnJhbWVQYXR0ZXJuID0gbnVsbDtcbnZhciBmb3JtYXRTdGFjayA9IG51bGw7XG52YXIgaW5kZW50U3RhY2tGcmFtZXMgPSBmYWxzZTtcbnZhciBwcmludFdhcm5pbmc7XG52YXIgZGVidWdnaW5nID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9ERUJVR1wiKSAhPSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodHJ1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuZW52KFwiQkxVRUJJUkRfREVCVUdcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmVudihcIk5PREVfRU5WXCIpID09PSBcImRldmVsb3BtZW50XCIpKTtcblxudmFyIHdhcm5pbmdzID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9XQVJOSU5HU1wiKSAhPSAwICYmXG4gICAgKGRlYnVnZ2luZyB8fCB1dGlsLmVudihcIkJMVUVCSVJEX1dBUk5JTkdTXCIpKSk7XG5cbnZhciBsb25nU3RhY2tUcmFjZXMgPSAhISh1dGlsLmVudihcIkJMVUVCSVJEX0xPTkdfU1RBQ0tfVFJBQ0VTXCIpICE9IDAgJiZcbiAgICAoZGVidWdnaW5nIHx8IHV0aWwuZW52KFwiQkxVRUJJUkRfTE9OR19TVEFDS19UUkFDRVNcIikpKTtcblxudmFyIHdGb3Jnb3R0ZW5SZXR1cm4gPSB1dGlsLmVudihcIkJMVUVCSVJEX1dfRk9SR09UVEVOX1JFVFVSTlwiKSAhPSAwICYmXG4gICAgKHdhcm5pbmdzIHx8ICEhdXRpbC5lbnYoXCJCTFVFQklSRF9XX0ZPUkdPVFRFTl9SRVRVUk5cIikpO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgdGFyZ2V0Ll9iaXRGaWVsZCA9ICgodGFyZ2V0Ll9iaXRGaWVsZCAmICh+MTA0ODU3NikpIHxcbiAgICAgICAgICAgICAgICAgICAgICA1MjQyODgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Vuc3VyZVBvc3NpYmxlUmVqZWN0aW9uSGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoKHRoaXMuX2JpdEZpZWxkICYgNTI0Mjg4KSAhPT0gMCkgcmV0dXJuO1xuICAgIHRoaXMuX3NldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgYXN5bmMuaW52b2tlTGF0ZXIodGhpcy5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uLCB0aGlzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmaXJlUmVqZWN0aW9uRXZlbnQoXCJyZWplY3Rpb25IYW5kbGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCwgdW5kZWZpbmVkLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZXR1cm5lZE5vblVuZGVmaW5lZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAyNjg0MzU0NTY7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmV0dXJuZWROb25VbmRlZmluZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMjY4NDM1NDU2KSAhPT0gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2lzUmVqZWN0aW9uVW5oYW5kbGVkKCkpIHtcbiAgICAgICAgdmFyIHJlYXNvbiA9IHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xuICAgICAgICB0aGlzLl9zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkKCk7XG4gICAgICAgIGZpcmVSZWplY3Rpb25FdmVudChcInVuaGFuZGxlZFJlamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiwgcmVhc29uLCB0aGlzKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjYyMTQ0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4yNjIxNDQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzVW5oYW5kbGVkUmVqZWN0aW9uTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDI2MjE0NCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFJlamVjdGlvbklzVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMDQ4NTc2O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MTA0ODU3Nik7XG4gICAgaWYgKHRoaXMuX2lzVW5oYW5kbGVkUmVqZWN0aW9uTm90aWZpZWQoKSkge1xuICAgICAgICB0aGlzLl91bnNldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzUmVqZWN0aW9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMDQ4NTc2KSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fd2FybiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHNob3VsZFVzZU93blRyYWNlLCBwcm9taXNlKSB7XG4gICAgcmV0dXJuIHdhcm4obWVzc2FnZSwgc2hvdWxkVXNlT3duVHJhY2UsIHByb21pc2UgfHwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLm9uUG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24gPVxuICAgICAgICB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIiA/IChkb21haW4gPT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xufTtcblxuUHJvbWlzZS5vblVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCA9XG4gICAgICAgIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiID8gKGRvbWFpbiA9PT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZGlzYWJsZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLmxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXN5bmMuaGF2ZUl0ZW1zUXVldWVkKCkgJiYgIWNvbmZpZy5sb25nU3RhY2tUcmFjZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuYWJsZSBsb25nIHN0YWNrIHRyYWNlcyBhZnRlciBwcm9taXNlcyBoYXZlIGJlZW4gY3JlYXRlZFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIGlmICghY29uZmlnLmxvbmdTdGFja1RyYWNlcyAmJiBsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIHZhciBQcm9taXNlX2NhcHR1cmVTdGFja1RyYWNlID0gUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICB2YXIgUHJvbWlzZV9hdHRhY2hFeHRyYVRyYWNlID0gUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2U7XG4gICAgICAgIGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgPSB0cnVlO1xuICAgICAgICBkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoYXN5bmMuaGF2ZUl0ZW1zUXVldWVkKCkgJiYgIWNvbmZpZy5sb25nU3RhY2tUcmFjZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5hYmxlIGxvbmcgc3RhY2sgdHJhY2VzIGFmdGVyIHByb21pc2VzIGhhdmUgYmVlbiBjcmVhdGVkXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZSA9IFByb21pc2VfY2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZSA9IFByb21pc2VfYXR0YWNoRXh0cmFUcmFjZTtcbiAgICAgICAgICAgIENvbnRleHQuZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICAgICAgYXN5bmMuZW5hYmxlVHJhbXBvbGluZSgpO1xuICAgICAgICAgICAgY29uZmlnLmxvbmdTdGFja1RyYWNlcyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBsb25nU3RhY2tUcmFjZXNDYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2UgPSBsb25nU3RhY2tUcmFjZXNBdHRhY2hFeHRyYVRyYWNlO1xuICAgICAgICBDb250ZXh0LmFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgIGFzeW5jLmRpc2FibGVUcmFtcG9saW5lSWZOZWNlc3NhcnkoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLmhhc0xvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29uZmlnLmxvbmdTdGFja1RyYWNlcyAmJiBsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpO1xufTtcblxudmFyIGZpcmVEb21FdmVudCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZS50b0xvd2VyQ2FzZSgpLCB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZG9tRXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICB1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21FdmVudCA9IG5ldyBFdmVudChuYW1lLnRvTG93ZXJDYXNlKCksIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRvbUV2ZW50LmRldGFpbCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiAhdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChkb21FdmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChcInRlc3Rpbmd0aGVldmVudFwiLCBmYWxzZSwgdHJ1ZSwge30pO1xuICAgICAgICAgICAgdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgICAgIGRvbUV2ZW50LmluaXRDdXN0b21FdmVudChuYW1lLnRvTG93ZXJDYXNlKCksIGZhbHNlLCB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGRvbUV2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59KSgpO1xuXG52YXIgZmlyZUdsb2JhbEV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmlzTm9kZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbWl0LmFwcGx5KHByb2Nlc3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF1dGlsLmdsb2JhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gXCJvblwiICsgbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHV0aWwuZ2xvYmFsW21ldGhvZE5hbWVdO1xuICAgICAgICAgICAgaWYgKCFtZXRob2QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG1ldGhvZC5hcHBseSh1dGlsLmdsb2JhbCwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0KG5hbWUsIHByb21pc2UpIHtcbiAgICByZXR1cm4ge3Byb21pc2U6IHByb21pc2V9O1xufVxuXG52YXIgZXZlbnRUb09iamVjdEdlbmVyYXRvciA9IHtcbiAgICBwcm9taXNlQ3JlYXRlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZUZ1bGZpbGxlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZVJlamVjdGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlUmVzb2x2ZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VDYW5jZWxsZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VDaGFpbmVkOiBmdW5jdGlvbihuYW1lLCBwcm9taXNlLCBjaGlsZCkge1xuICAgICAgICByZXR1cm4ge3Byb21pc2U6IHByb21pc2UsIGNoaWxkOiBjaGlsZH07XG4gICAgfSxcbiAgICB3YXJuaW5nOiBmdW5jdGlvbihuYW1lLCB3YXJuaW5nKSB7XG4gICAgICAgIHJldHVybiB7d2FybmluZzogd2FybmluZ307XG4gICAgfSxcbiAgICB1bmhhbmRsZWRSZWplY3Rpb246IGZ1bmN0aW9uIChuYW1lLCByZWFzb24sIHByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHtyZWFzb246IHJlYXNvbiwgcHJvbWlzZTogcHJvbWlzZX07XG4gICAgfSxcbiAgICByZWplY3Rpb25IYW5kbGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdFxufTtcblxudmFyIGFjdGl2ZUZpcmVFdmVudCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGdsb2JhbEV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBnbG9iYWxFdmVudEZpcmVkID0gZmlyZUdsb2JhbEV2ZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUpO1xuICAgICAgICBnbG9iYWxFdmVudEZpcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZG9tRXZlbnRGaXJlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGRvbUV2ZW50RmlyZWQgPSBmaXJlRG9tRXZlbnQobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUb09iamVjdEdlbmVyYXRvcltuYW1lXS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZSk7XG4gICAgICAgIGRvbUV2ZW50RmlyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBkb21FdmVudEZpcmVkIHx8IGdsb2JhbEV2ZW50RmlyZWQ7XG59O1xuXG5Qcm9taXNlLmNvbmZpZyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICBvcHRzID0gT2JqZWN0KG9wdHMpO1xuICAgIGlmIChcImxvbmdTdGFja1RyYWNlc1wiIGluIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgICAgICBQcm9taXNlLmxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLmxvbmdTdGFja1RyYWNlcyAmJiBQcm9taXNlLmhhc0xvbmdTdGFja1RyYWNlcygpKSB7XG4gICAgICAgICAgICBkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKFwid2FybmluZ3NcIiBpbiBvcHRzKSB7XG4gICAgICAgIHZhciB3YXJuaW5nc09wdGlvbiA9IG9wdHMud2FybmluZ3M7XG4gICAgICAgIGNvbmZpZy53YXJuaW5ncyA9ICEhd2FybmluZ3NPcHRpb247XG4gICAgICAgIHdGb3Jnb3R0ZW5SZXR1cm4gPSBjb25maWcud2FybmluZ3M7XG5cbiAgICAgICAgaWYgKHV0aWwuaXNPYmplY3Qod2FybmluZ3NPcHRpb24pKSB7XG4gICAgICAgICAgICBpZiAoXCJ3Rm9yZ290dGVuUmV0dXJuXCIgaW4gd2FybmluZ3NPcHRpb24pIHtcbiAgICAgICAgICAgICAgICB3Rm9yZ290dGVuUmV0dXJuID0gISF3YXJuaW5nc09wdGlvbi53Rm9yZ290dGVuUmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChcImNhbmNlbGxhdGlvblwiIGluIG9wdHMgJiYgb3B0cy5jYW5jZWxsYXRpb24gJiYgIWNvbmZpZy5jYW5jZWxsYXRpb24pIHtcbiAgICAgICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJjYW5ub3QgZW5hYmxlIGNhbmNlbGxhdGlvbiBhZnRlciBwcm9taXNlcyBhcmUgaW4gdXNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEgPVxuICAgICAgICAgICAgY2FuY2VsbGF0aW9uQ2xlYXJDYW5jZWxsYXRpb25EYXRhO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHJvcGFnYXRlRnJvbSA9IGNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb207XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9vbkNhbmNlbCA9IGNhbmNlbGxhdGlvbk9uQ2FuY2VsO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0T25DYW5jZWwgPSBjYW5jZWxsYXRpb25TZXRPbkNhbmNlbDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrID1cbiAgICAgICAgICAgIGNhbmNlbGxhdGlvbkF0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGNhbmNlbGxhdGlvbkV4ZWN1dGU7XG4gICAgICAgIHByb3BhZ2F0ZUZyb21GdW5jdGlvbiA9IGNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb207XG4gICAgICAgIGNvbmZpZy5jYW5jZWxsYXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoXCJtb25pdG9yaW5nXCIgaW4gb3B0cykge1xuICAgICAgICBpZiAob3B0cy5tb25pdG9yaW5nICYmICFjb25maWcubW9uaXRvcmluZykge1xuICAgICAgICAgICAgY29uZmlnLm1vbml0b3JpbmcgPSB0cnVlO1xuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGFjdGl2ZUZpcmVFdmVudDtcbiAgICAgICAgfSBlbHNlIGlmICghb3B0cy5tb25pdG9yaW5nICYmIGNvbmZpZy5tb25pdG9yaW5nKSB7XG4gICAgICAgICAgICBjb25maWcubW9uaXRvcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGRlZmF1bHRGaXJlRXZlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiBkZWZhdWx0RmlyZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGRlZmF1bHRGaXJlRXZlbnQ7XG5Qcm9taXNlLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uKGV4ZWN1dG9yLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxufTtcblByb21pc2UucHJvdG90eXBlLl9vbkNhbmNlbCA9IGZ1bmN0aW9uICgpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3NldE9uQ2FuY2VsID0gZnVuY3Rpb24gKGhhbmRsZXIpIHsgOyB9O1xuUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24ob25DYW5jZWwpIHtcbiAgICA7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZSA9IGZ1bmN0aW9uICgpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fcHJvcGFnYXRlRnJvbSA9IGZ1bmN0aW9uIChwYXJlbnQsIGZsYWdzKSB7XG4gICAgO1xuICAgIDtcbn07XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbkV4ZWN1dGUoZXhlY3V0b3IsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvcihyZXNvbHZlLCByZWplY3QsIGZ1bmN0aW9uKG9uQ2FuY2VsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uQ2FuY2VsICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib25DYW5jZWwgbXVzdCBiZSBhIGZ1bmN0aW9uLCBnb3Q6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwudG9TdHJpbmcob25DYW5jZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKG9uQ2FuY2VsKTtcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbkF0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKG9uQ2FuY2VsKSB7XG4gICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxhYmxlKCkpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIHByZXZpb3VzT25DYW5jZWwgPSB0aGlzLl9vbkNhbmNlbCgpO1xuICAgIGlmIChwcmV2aW91c09uQ2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNBcnJheShwcmV2aW91c09uQ2FuY2VsKSkge1xuICAgICAgICAgICAgcHJldmlvdXNPbkNhbmNlbC5wdXNoKG9uQ2FuY2VsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldE9uQ2FuY2VsKFtwcmV2aW91c09uQ2FuY2VsLCBvbkNhbmNlbF0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0T25DYW5jZWwob25DYW5jZWwpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uT25DYW5jZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uQ2FuY2VsRmllbGQ7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvblNldE9uQ2FuY2VsKG9uQ2FuY2VsKSB7XG4gICAgdGhpcy5fb25DYW5jZWxGaWVsZCA9IG9uQ2FuY2VsO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25DbGVhckNhbmNlbGxhdGlvbkRhdGEoKSB7XG4gICAgdGhpcy5fY2FuY2VsbGF0aW9uUGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29uQ2FuY2VsRmllbGQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb20ocGFyZW50LCBmbGFncykge1xuICAgIGlmICgoZmxhZ3MgJiAxKSAhPT0gMCkge1xuICAgICAgICB0aGlzLl9jYW5jZWxsYXRpb25QYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHZhciBicmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gcGFyZW50Ll9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsO1xuICAgICAgICBpZiAoYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBicmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSBicmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsICsgMTtcbiAgICB9XG4gICAgaWYgKChmbGFncyAmIDIpICE9PSAwICYmIHBhcmVudC5faXNCb3VuZCgpKSB7XG4gICAgICAgIHRoaXMuX3NldEJvdW5kVG8ocGFyZW50Ll9ib3VuZFRvKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRpbmdQcm9wYWdhdGVGcm9tKHBhcmVudCwgZmxhZ3MpIHtcbiAgICBpZiAoKGZsYWdzICYgMikgIT09IDAgJiYgcGFyZW50Ll9pc0JvdW5kKCkpIHtcbiAgICAgICAgdGhpcy5fc2V0Qm91bmRUbyhwYXJlbnQuX2JvdW5kVG8pO1xuICAgIH1cbn1cbnZhciBwcm9wYWdhdGVGcm9tRnVuY3Rpb24gPSBiaW5kaW5nUHJvcGFnYXRlRnJvbTtcblxuZnVuY3Rpb24gYm91bmRWYWx1ZUZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB0aGlzLl9ib3VuZFRvO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgaWYgKHJldC5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldC52YWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGxvbmdTdGFja1RyYWNlc0NhcHR1cmVTdGFja1RyYWNlKCkge1xuICAgIHRoaXMuX3RyYWNlID0gbmV3IENhcHR1cmVkVHJhY2UodGhpcy5fcGVla0NvbnRleHQoKSk7XG59XG5cbmZ1bmN0aW9uIGxvbmdTdGFja1RyYWNlc0F0dGFjaEV4dHJhVHJhY2UoZXJyb3IsIGlnbm9yZVNlbGYpIHtcbiAgICBpZiAoY2FuQXR0YWNoVHJhY2UoZXJyb3IpKSB7XG4gICAgICAgIHZhciB0cmFjZSA9IHRoaXMuX3RyYWNlO1xuICAgICAgICBpZiAodHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZVNlbGYpIHRyYWNlID0gdHJhY2UuX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhY2UuYXR0YWNoRXh0cmFUcmFjZShlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVycm9yLl9fc3RhY2tDbGVhbmVkX18pIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVN0YWNrQW5kTWVzc2FnZShlcnJvcik7XG4gICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcInN0YWNrXCIsXG4gICAgICAgICAgICAgICAgcGFyc2VkLm1lc3NhZ2UgKyBcIlxcblwiICsgcGFyc2VkLnN0YWNrLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJfX3N0YWNrQ2xlYW5lZF9fXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ZvcmdvdHRlblJldHVybnMocmV0dXJuVmFsdWUsIHByb21pc2VDcmVhdGVkLCBuYW1lLCBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCkge1xuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gdW5kZWZpbmVkICYmIHByb21pc2VDcmVhdGVkICE9PSBudWxsICYmXG4gICAgICAgIHdGb3Jnb3R0ZW5SZXR1cm4pIHtcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkICYmIHBhcmVudC5fcmV0dXJuZWROb25VbmRlZmluZWQoKSkgcmV0dXJuO1xuICAgICAgICBpZiAoKHByb21pc2UuX2JpdEZpZWxkICYgNjU1MzUpID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgaWYgKG5hbWUpIG5hbWUgPSBuYW1lICsgXCIgXCI7XG4gICAgICAgIHZhciBoYW5kbGVyTGluZSA9IFwiXCI7XG4gICAgICAgIHZhciBjcmVhdG9yTGluZSA9IFwiXCI7XG4gICAgICAgIGlmIChwcm9taXNlQ3JlYXRlZC5fdHJhY2UpIHtcbiAgICAgICAgICAgIHZhciB0cmFjZUxpbmVzID0gcHJvbWlzZUNyZWF0ZWQuX3RyYWNlLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gY2xlYW5TdGFjayh0cmFjZUxpbmVzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlRnJhbWVQYXR0ZXJuLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVNYXRjaGVzID0gbGluZS5tYXRjaChwYXJzZUxpbmVQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVNYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyTGluZSAgPSBcImF0IFwiICsgbGluZU1hdGNoZXNbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiOlwiICsgbGluZU1hdGNoZXNbMl0gKyBcIjpcIiArIGxpbmVNYXRjaGVzWzNdICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFVzZXJMaW5lID0gc3RhY2tbMF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFjZUxpbmVzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNlTGluZXNbaV0gPT09IGZpcnN0VXNlckxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0b3JMaW5lID0gXCJcXG5cIiArIHRyYWNlTGluZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbXNnID0gXCJhIHByb21pc2Ugd2FzIGNyZWF0ZWQgaW4gYSBcIiArIG5hbWUgK1xuICAgICAgICAgICAgXCJoYW5kbGVyIFwiICsgaGFuZGxlckxpbmUgKyBcImJ1dCB3YXMgbm90IHJldHVybmVkIGZyb20gaXQsIFwiICtcbiAgICAgICAgICAgIFwic2VlIGh0dHA6Ly9nb28uZ2wvclJxTVV3XCIgK1xuICAgICAgICAgICAgY3JlYXRvckxpbmU7XG4gICAgICAgIHByb21pc2UuX3dhcm4obXNnLCB0cnVlLCBwcm9taXNlQ3JlYXRlZCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkKG5hbWUsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBuYW1lICtcbiAgICAgICAgXCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXCI7XG4gICAgaWYgKHJlcGxhY2VtZW50KSBtZXNzYWdlICs9IFwiIFVzZSBcIiArIHJlcGxhY2VtZW50ICsgXCIgaW5zdGVhZC5cIjtcbiAgICByZXR1cm4gd2FybihtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gd2FybihtZXNzYWdlLCBzaG91bGRVc2VPd25UcmFjZSwgcHJvbWlzZSkge1xuICAgIGlmICghY29uZmlnLndhcm5pbmdzKSByZXR1cm47XG4gICAgdmFyIHdhcm5pbmcgPSBuZXcgV2FybmluZyhtZXNzYWdlKTtcbiAgICB2YXIgY3R4O1xuICAgIGlmIChzaG91bGRVc2VPd25UcmFjZSkge1xuICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHdhcm5pbmcpO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmxvbmdTdGFja1RyYWNlcyAmJiAoY3R4ID0gUHJvbWlzZS5fcGVla0NvbnRleHQoKSkpIHtcbiAgICAgICAgY3R4LmF0dGFjaEV4dHJhVHJhY2Uod2FybmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKHdhcm5pbmcpO1xuICAgICAgICB3YXJuaW5nLnN0YWNrID0gcGFyc2VkLm1lc3NhZ2UgKyBcIlxcblwiICsgcGFyc2VkLnN0YWNrLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuXG4gICAgaWYgKCFhY3RpdmVGaXJlRXZlbnQoXCJ3YXJuaW5nXCIsIHdhcm5pbmcpKSB7XG4gICAgICAgIGZvcm1hdEFuZExvZ0Vycm9yKHdhcm5pbmcsIFwiXCIsIHRydWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVjb25zdHJ1Y3RTdGFjayhtZXNzYWdlLCBzdGFja3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgc3RhY2tzW2ldLnB1c2goXCJGcm9tIHByZXZpb3VzIGV2ZW50OlwiKTtcbiAgICAgICAgc3RhY2tzW2ldID0gc3RhY2tzW2ldLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIGlmIChpIDwgc3RhY2tzLmxlbmd0aCkge1xuICAgICAgICBzdGFja3NbaV0gPSBzdGFja3NbaV0uam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2tzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZU9yRW1wdHlKdW1wcyhzdGFja3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc3RhY2tzW2ldLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgKChpICsgMSA8IHN0YWNrcy5sZW5ndGgpICYmIHN0YWNrc1tpXVswXSA9PT0gc3RhY2tzW2krMV1bMF0pKSB7XG4gICAgICAgICAgICBzdGFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDb21tb25Sb290cyhzdGFja3MpIHtcbiAgICB2YXIgY3VycmVudCA9IHN0YWNrc1swXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHN0YWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcHJldiA9IHN0YWNrc1tpXTtcbiAgICAgICAgdmFyIGN1cnJlbnRMYXN0SW5kZXggPSBjdXJyZW50Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBjdXJyZW50TGFzdExpbmUgPSBjdXJyZW50W2N1cnJlbnRMYXN0SW5kZXhdO1xuICAgICAgICB2YXIgY29tbW9uUm9vdE1lZXRQb2ludCA9IC0xO1xuXG4gICAgICAgIGZvciAodmFyIGogPSBwcmV2Lmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICBpZiAocHJldltqXSA9PT0gY3VycmVudExhc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgY29tbW9uUm9vdE1lZXRQb2ludCA9IGo7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gY29tbW9uUm9vdE1lZXRQb2ludDsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gcHJldltqXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50W2N1cnJlbnRMYXN0SW5kZXhdID09PSBsaW5lKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGFzdEluZGV4LS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBwcmV2O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5TdGFjayhzdGFjaykge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gc3RhY2tbaV07XG4gICAgICAgIHZhciBpc1RyYWNlTGluZSA9IFwiICAgIChObyBzdGFjayB0cmFjZSlcIiA9PT0gbGluZSB8fFxuICAgICAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4udGVzdChsaW5lKTtcbiAgICAgICAgdmFyIGlzSW50ZXJuYWxGcmFtZSA9IGlzVHJhY2VMaW5lICYmIHNob3VsZElnbm9yZShsaW5lKTtcbiAgICAgICAgaWYgKGlzVHJhY2VMaW5lICYmICFpc0ludGVybmFsRnJhbWUpIHtcbiAgICAgICAgICAgIGlmIChpbmRlbnRTdGFja0ZyYW1lcyAmJiBsaW5lLmNoYXJBdCgwKSAhPT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gXCIgICAgXCIgKyBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0LnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc3RhY2tGcmFtZXNBc0FycmF5KGVycm9yKSB7XG4gICAgdmFyIHN0YWNrID0gZXJyb3Iuc3RhY2sucmVwbGFjZSgvXFxzKyQvZywgXCJcIikuc3BsaXQoXCJcXG5cIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHN0YWNrW2ldO1xuICAgICAgICBpZiAoXCIgICAgKE5vIHN0YWNrIHRyYWNlKVwiID09PSBsaW5lIHx8IHN0YWNrRnJhbWVQYXR0ZXJuLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpID4gMCkge1xuICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2s7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKSB7XG4gICAgdmFyIHN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgdmFyIG1lc3NhZ2UgPSBlcnJvci50b1N0cmluZygpO1xuICAgIHN0YWNrID0gdHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiICYmIHN0YWNrLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICA/IHN0YWNrRnJhbWVzQXNBcnJheShlcnJvcikgOiBbXCIgICAgKE5vIHN0YWNrIHRyYWNlKVwiXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBzdGFjazogY2xlYW5TdGFjayhzdGFjaylcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBbmRMb2dFcnJvcihlcnJvciwgdGl0bGUsIGlzU29mdCkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoZXJyb3IpKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIGZvcm1hdFN0YWNrKHN0YWNrLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGl0bGUgKyBTdHJpbmcoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJpbnRXYXJuaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhtZXNzYWdlLCBpc1NvZnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS5sb2cgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaXJlUmVqZWN0aW9uRXZlbnQobmFtZSwgbG9jYWxIYW5kbGVyLCByZWFzb24sIHByb21pc2UpIHtcbiAgICB2YXIgbG9jYWxFdmVudEZpcmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbEhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbG9jYWxFdmVudEZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcInJlamVjdGlvbkhhbmRsZWRcIikge1xuICAgICAgICAgICAgICAgIGxvY2FsSGFuZGxlcihwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYWxIYW5kbGVyKHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IFwidW5oYW5kbGVkUmVqZWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCFhY3RpdmVGaXJlRXZlbnQobmFtZSwgcmVhc29uLCBwcm9taXNlKSAmJiAhbG9jYWxFdmVudEZpcmVkKSB7XG4gICAgICAgICAgICBmb3JtYXRBbmRMb2dFcnJvcihyZWFzb24sIFwiVW5oYW5kbGVkIHJlamVjdGlvbiBcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVGaXJlRXZlbnQobmFtZSwgcHJvbWlzZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXROb25FcnJvcihvYmopIHtcbiAgICB2YXIgc3RyO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc3RyID0gXCJbZnVuY3Rpb24gXCIgK1xuICAgICAgICAgICAgKG9iai5uYW1lIHx8IFwiYW5vbnltb3VzXCIpICtcbiAgICAgICAgICAgIFwiXVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IG9iaiAmJiB0eXBlb2Ygb2JqLnRvU3RyaW5nID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gb2JqLnRvU3RyaW5nKCkgOiB1dGlsLnRvU3RyaW5nKG9iaik7XG4gICAgICAgIHZhciBydXNlbGVzc1RvU3RyaW5nID0gL1xcW29iamVjdCBbYS16QS1aMC05JF9dK1xcXS87XG4gICAgICAgIGlmIChydXNlbGVzc1RvU3RyaW5nLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U3RyID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBuZXdTdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3RyID0gXCIoZW1wdHkgYXJyYXkpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChcIig8XCIgKyBzbmlwKHN0cikgKyBcIj4sIG5vIHN0YWNrIHRyYWNlKVwiKTtcbn1cblxuZnVuY3Rpb24gc25pcChzdHIpIHtcbiAgICB2YXIgbWF4Q2hhcnMgPSA0MTtcbiAgICBpZiAoc3RyLmxlbmd0aCA8IG1heENoYXJzKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIG1heENoYXJzIC0gMykgKyBcIi4uLlwiO1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbnZhciBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xudmFyIHBhcnNlTGluZUluZm9SZWdleCA9IC9bXFwvPFxcKF0oW146XFwvXSspOihcXGQrKTooPzpcXGQrKVxcKT9cXHMqJC87XG5mdW5jdGlvbiBwYXJzZUxpbmVJbmZvKGxpbmUpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2gocGFyc2VMaW5lSW5mb1JlZ2V4KTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoZXNbMV0sXG4gICAgICAgICAgICBsaW5lOiBwYXJzZUludChtYXRjaGVzWzJdLCAxMClcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldEJvdW5kcyhmaXJzdExpbmVFcnJvciwgbGFzdExpbmVFcnJvcikge1xuICAgIGlmICghbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBmaXJzdFN0YWNrTGluZXMgPSBmaXJzdExpbmVFcnJvci5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgbGFzdFN0YWNrTGluZXMgPSBsYXN0TGluZUVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBmaXJzdEluZGV4ID0gLTE7XG4gICAgdmFyIGxhc3RJbmRleCA9IC0xO1xuICAgIHZhciBmaXJzdEZpbGVOYW1lO1xuICAgIHZhciBsYXN0RmlsZU5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8oZmlyc3RTdGFja0xpbmVzW2ldKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgZmlyc3RGaWxlTmFtZSA9IHJlc3VsdC5maWxlTmFtZTtcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8obGFzdFN0YWNrTGluZXNbaV0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBsYXN0RmlsZU5hbWUgPSByZXN1bHQuZmlsZU5hbWU7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmaXJzdEluZGV4IDwgMCB8fCBsYXN0SW5kZXggPCAwIHx8ICFmaXJzdEZpbGVOYW1lIHx8ICFsYXN0RmlsZU5hbWUgfHxcbiAgICAgICAgZmlyc3RGaWxlTmFtZSAhPT0gbGFzdEZpbGVOYW1lIHx8IGZpcnN0SW5kZXggPj0gbGFzdEluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIGlmIChibHVlYmlyZEZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGluZm8gPSBwYXJzZUxpbmVJbmZvKGxpbmUpO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKGluZm8uZmlsZU5hbWUgPT09IGZpcnN0RmlsZU5hbWUgJiZcbiAgICAgICAgICAgICAgICAoZmlyc3RJbmRleCA8PSBpbmZvLmxpbmUgJiYgaW5mby5saW5lIDw9IGxhc3RJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gQ2FwdHVyZWRUcmFjZShwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fcHJvbWlzZXNDcmVhdGVkID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoID0gMSArIChwYXJlbnQgPT09IHVuZGVmaW5lZCA/IDAgOiBwYXJlbnQuX2xlbmd0aCk7XG4gICAgY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ2FwdHVyZWRUcmFjZSk7XG4gICAgaWYgKGxlbmd0aCA+IDMyKSB0aGlzLnVuY3ljbGUoKTtcbn1cbnV0aWwuaW5oZXJpdHMoQ2FwdHVyZWRUcmFjZSwgRXJyb3IpO1xuQ29udGV4dC5DYXB0dXJlZFRyYWNlID0gQ2FwdHVyZWRUcmFjZTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUudW5jeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDIpIHJldHVybjtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgc3RhY2tUb0luZGV4ID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbm9kZSA9IHRoaXM7IG5vZGUgIT09IHVuZGVmaW5lZDsgKytpKSB7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLl9wYXJlbnQ7XG4gICAgfVxuICAgIGxlbmd0aCA9IHRoaXMuX2xlbmd0aCA9IGk7XG4gICAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBzdGFjayA9IG5vZGVzW2ldLnN0YWNrO1xuICAgICAgICBpZiAoc3RhY2tUb0luZGV4W3N0YWNrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFja1RvSW5kZXhbc3RhY2tdID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjdXJyZW50U3RhY2sgPSBub2Rlc1tpXS5zdGFjaztcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhY2tUb0luZGV4W2N1cnJlbnRTdGFja107XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbaW5kZXggLSAxXS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG5vZGVzW2luZGV4IC0gMV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlc1tpXS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbm9kZXNbaV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB2YXIgY3ljbGVFZGdlTm9kZSA9IGkgPiAwID8gbm9kZXNbaSAtIDFdIDogdGhpcztcblxuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IG5vZGVzW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50LnVuY3ljbGUoKTtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggPVxuICAgICAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQuX2xlbmd0aCArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGlsZExlbmd0aCA9IGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSAtIDI7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbal0uX2xlbmd0aCA9IGN1cnJlbnRDaGlsZExlbmd0aDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2hpbGRMZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkNhcHR1cmVkVHJhY2UucHJvdG90eXBlLmF0dGFjaEV4dHJhVHJhY2UgPSBmdW5jdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSByZXR1cm47XG4gICAgdGhpcy51bmN5Y2xlKCk7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKTtcbiAgICB2YXIgbWVzc2FnZSA9IHBhcnNlZC5tZXNzYWdlO1xuICAgIHZhciBzdGFja3MgPSBbcGFyc2VkLnN0YWNrXTtcblxuICAgIHZhciB0cmFjZSA9IHRoaXM7XG4gICAgd2hpbGUgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RhY2tzLnB1c2goY2xlYW5TdGFjayh0cmFjZS5zdGFjay5zcGxpdChcIlxcblwiKSkpO1xuICAgICAgICB0cmFjZSA9IHRyYWNlLl9wYXJlbnQ7XG4gICAgfVxuICAgIHJlbW92ZUNvbW1vblJvb3RzKHN0YWNrcyk7XG4gICAgcmVtb3ZlRHVwbGljYXRlT3JFbXB0eUp1bXBzKHN0YWNrcyk7XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJzdGFja1wiLCByZWNvbnN0cnVjdFN0YWNrKG1lc3NhZ2UsIHN0YWNrcykpO1xuICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwiX19zdGFja0NsZWFuZWRfX1wiLCB0cnVlKTtcbn07XG5cbnZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IChmdW5jdGlvbiBzdGFja0RldGVjdGlvbigpIHtcbiAgICB2YXIgdjhzdGFja0ZyYW1lUGF0dGVybiA9IC9eXFxzKmF0XFxzKi87XG4gICAgdmFyIHY4c3RhY2tGb3JtYXR0ZXIgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmIChlcnJvci5uYW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE5vbkVycm9yKGVycm9yKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBFcnJvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICB2YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcblxuICAgICAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gYmx1ZWJpcmRGcmFtZVBhdHRlcm4udGVzdChsaW5lKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlY2VpdmVyLCBpZ25vcmVVbnRpbCkge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgICAgICBjYXB0dXJlU3RhY2tUcmFjZShyZWNlaXZlciwgaWdub3JlVW50aWwpO1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0IC09IDY7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcblxuICAgIGlmICh0eXBlb2YgZXJyLnN0YWNrID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIGVyci5zdGFjay5zcGxpdChcIlxcblwiKVswXS5pbmRleE9mKFwic3RhY2tEZXRlY3Rpb25AXCIpID49IDApIHtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSAvQC87XG4gICAgICAgIGZvcm1hdFN0YWNrID0gdjhzdGFja0Zvcm1hdHRlcjtcbiAgICAgICAgaW5kZW50U3RhY2tGcmFtZXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgby5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBoYXNTdGFja0FmdGVyVGhyb3c7XG4gICAgdHJ5IHsgdGhyb3cgbmV3IEVycm9yKCk7IH1cbiAgICBjYXRjaChlKSB7XG4gICAgICAgIGhhc1N0YWNrQWZ0ZXJUaHJvdyA9IChcInN0YWNrXCIgaW4gZSk7XG4gICAgfVxuICAgIGlmICghKFwic3RhY2tcIiBpbiBlcnIpICYmIGhhc1N0YWNrQWZ0ZXJUaHJvdyAmJlxuICAgICAgICB0eXBlb2YgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgICAgICB0cnkgeyB0aHJvdyBuZXcgRXJyb3IoKTsgfVxuICAgICAgICAgICAgY2F0Y2goZSkgeyBvLnN0YWNrID0gZS5zdGFjazsgfVxuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0IC09IDY7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9ybWF0U3RhY2sgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmICgodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgICAgIGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0Tm9uRXJyb3IoZXJyb3IpO1xuICAgIH07XG5cbiAgICByZXR1cm4gbnVsbDtcblxufSkoW10pO1xuXG5pZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUud2FybiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9O1xuICAgIGlmICh1dGlsLmlzTm9kZSAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSkge1xuICAgICAgICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbihtZXNzYWdlLCBpc1NvZnQpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGlzU29mdCA/IFwiXFx1MDAxYlszM21cIiA6IFwiXFx1MDAxYlszMW1cIjtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihjb2xvciArIG1lc3NhZ2UgKyBcIlxcdTAwMWJbMG1cXG5cIik7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICghdXRpbC5pc05vZGUgJiYgdHlwZW9mIChuZXcgRXJyb3IoKS5zdGFjaykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24obWVzc2FnZSwgaXNTb2Z0KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCIlY1wiICsgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU29mdCA/IFwiY29sb3I6IGRhcmtvcmFuZ2VcIiA6IFwiY29sb3I6IHJlZFwiKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbnZhciBjb25maWcgPSB7XG4gICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgIGxvbmdTdGFja1RyYWNlczogZmFsc2UsXG4gICAgY2FuY2VsbGF0aW9uOiBmYWxzZSxcbiAgICBtb25pdG9yaW5nOiBmYWxzZVxufTtcblxuaWYgKGxvbmdTdGFja1RyYWNlcykgUHJvbWlzZS5sb25nU3RhY2tUcmFjZXMoKTtcblxucmV0dXJuIHtcbiAgICBsb25nU3RhY2tUcmFjZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmxvbmdTdGFja1RyYWNlcztcbiAgICB9LFxuICAgIHdhcm5pbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy53YXJuaW5ncztcbiAgICB9LFxuICAgIGNhbmNlbGxhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcuY2FuY2VsbGF0aW9uO1xuICAgIH0sXG4gICAgbW9uaXRvcmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcubW9uaXRvcmluZztcbiAgICB9LFxuICAgIHByb3BhZ2F0ZUZyb21GdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwcm9wYWdhdGVGcm9tRnVuY3Rpb247XG4gICAgfSxcbiAgICBib3VuZFZhbHVlRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYm91bmRWYWx1ZUZ1bmN0aW9uO1xuICAgIH0sXG4gICAgY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zOiBjaGVja0ZvcmdvdHRlblJldHVybnMsXG4gICAgc2V0Qm91bmRzOiBzZXRCb3VuZHMsXG4gICAgd2Fybjogd2FybixcbiAgICBkZXByZWNhdGVkOiBkZXByZWNhdGVkLFxuICAgIENhcHR1cmVkVHJhY2U6IENhcHR1cmVkVHJhY2UsXG4gICAgZmlyZURvbUV2ZW50OiBmaXJlRG9tRXZlbnQsXG4gICAgZmlyZUdsb2JhbEV2ZW50OiBmaXJlR2xvYmFsRXZlbnRcbn07XG59O1xuXG59LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiByZXR1cm5lcigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn1cbmZ1bmN0aW9uIHRocm93ZXIoKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG59XG5cblByb21pc2UucHJvdG90eXBlW1wicmV0dXJuXCJdID1cblByb21pc2UucHJvdG90eXBlLnRoZW5SZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB2YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgcmV0dXJuZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7dmFsdWU6IHZhbHVlfSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlW1widGhyb3dcIl0gPVxuUHJvbWlzZS5wcm90b3R5cGUudGhlblRocm93ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICB0aHJvd2VyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge3JlYXNvbjogcmVhc29ufSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhdGNoVGhyb3cgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgdGhyb3dlciwgdW5kZWZpbmVkLCB7cmVhc29uOiByZWFzb259LCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVhc29uID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCkge3Rocm93IF9yZWFzb247fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F1Z2h0KHJlYXNvbiwgaGFuZGxlcik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hSZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHZhbHVlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgcmV0dXJuZXIsIHVuZGVmaW5lZCwge3ZhbHVlOiB2YWx1ZX0sIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF92YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKF92YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIF92YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtyZXR1cm4gX3ZhbHVlO307XG4gICAgICAgIHJldHVybiB0aGlzLmNhdWdodCh2YWx1ZSwgaGFuZGxlcik7XG4gICAgfVxufTtcbn07XG5cbn0se31dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VSZWR1Y2UgPSBQcm9taXNlLnJlZHVjZTtcbnZhciBQcm9taXNlQWxsID0gUHJvbWlzZS5hbGw7XG5cbmZ1bmN0aW9uIHByb21pc2VBbGxUaGlzKCkge1xuICAgIHJldHVybiBQcm9taXNlQWxsKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBQcm9taXNlTWFwU2VyaWVzKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIElOVEVSTkFMKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgMClcbiAgICAgICAgICAgICAgLl90aGVuKHByb21pc2VBbGxUaGlzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcFNlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5lYWNoID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIDApXG4gICAgICAgICAgICAgIC5fdGhlbihwcm9taXNlQWxsVGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb21pc2VzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5tYXBTZXJpZXMgPSBQcm9taXNlTWFwU2VyaWVzO1xufTtcblxuXG59LHt9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG52YXIgT2JqZWN0ZnJlZXplID0gZXM1LmZyZWV6ZTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBpbmhlcml0cyA9IHV0aWwuaW5oZXJpdHM7XG52YXIgbm90RW51bWVyYWJsZVByb3AgPSB1dGlsLm5vdEVudW1lcmFibGVQcm9wO1xuXG5mdW5jdGlvbiBzdWJFcnJvcihuYW1lUHJvcGVydHksIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgZnVuY3Rpb24gU3ViRXJyb3IobWVzc2FnZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ViRXJyb3IpKSByZXR1cm4gbmV3IFN1YkVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJuYW1lXCIsIG5hbWVQcm9wZXJ0eSk7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaGVyaXRzKFN1YkVycm9yLCBFcnJvcik7XG4gICAgcmV0dXJuIFN1YkVycm9yO1xufVxuXG52YXIgX1R5cGVFcnJvciwgX1JhbmdlRXJyb3I7XG52YXIgV2FybmluZyA9IHN1YkVycm9yKFwiV2FybmluZ1wiLCBcIndhcm5pbmdcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBzdWJFcnJvcihcIkNhbmNlbGxhdGlvbkVycm9yXCIsIFwiY2FuY2VsbGF0aW9uIGVycm9yXCIpO1xudmFyIFRpbWVvdXRFcnJvciA9IHN1YkVycm9yKFwiVGltZW91dEVycm9yXCIsIFwidGltZW91dCBlcnJvclwiKTtcbnZhciBBZ2dyZWdhdGVFcnJvciA9IHN1YkVycm9yKFwiQWdncmVnYXRlRXJyb3JcIiwgXCJhZ2dyZWdhdGUgZXJyb3JcIik7XG50cnkge1xuICAgIF9UeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgX1JhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xufSBjYXRjaChlKSB7XG4gICAgX1R5cGVFcnJvciA9IHN1YkVycm9yKFwiVHlwZUVycm9yXCIsIFwidHlwZSBlcnJvclwiKTtcbiAgICBfUmFuZ2VFcnJvciA9IHN1YkVycm9yKFwiUmFuZ2VFcnJvclwiLCBcInJhbmdlIGVycm9yXCIpO1xufVxuXG52YXIgbWV0aG9kcyA9IChcImpvaW4gcG9wIHB1c2ggc2hpZnQgdW5zaGlmdCBzbGljZSBmaWx0ZXIgZm9yRWFjaCBzb21lIFwiICtcbiAgICBcImV2ZXJ5IG1hcCBpbmRleE9mIGxhc3RJbmRleE9mIHJlZHVjZSByZWR1Y2VSaWdodCBzb3J0IHJldmVyc2VcIikuc3BsaXQoXCIgXCIpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZVttZXRob2RzW2ldXSA9IEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXTtcbiAgICB9XG59XG5cbmVzNS5kZWZpbmVQcm9wZXJ0eShBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICB2YWx1ZTogMCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbn0pO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlW1wiaXNPcGVyYXRpb25hbFwiXSA9IHRydWU7XG52YXIgbGV2ZWwgPSAwO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGVudCA9IEFycmF5KGxldmVsICogNCArIDEpLmpvaW4oXCIgXCIpO1xuICAgIHZhciByZXQgPSBcIlxcblwiICsgaW5kZW50ICsgXCJBZ2dyZWdhdGVFcnJvciBvZjpcIiArIFwiXFxuXCI7XG4gICAgbGV2ZWwrKztcbiAgICBpbmRlbnQgPSBBcnJheShsZXZlbCAqIDQgKyAxKS5qb2luKFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXNbaV0gPT09IHRoaXMgPyBcIltDaXJjdWxhciBBZ2dyZWdhdGVFcnJvcl1cIiA6IHRoaXNbaV0gKyBcIlwiO1xuICAgICAgICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGxpbmVzW2pdID0gaW5kZW50ICsgbGluZXNbal07XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgcmV0ICs9IHN0ciArIFwiXFxuXCI7XG4gICAgfVxuICAgIGxldmVsLS07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIE9wZXJhdGlvbmFsRXJyb3IobWVzc2FnZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPcGVyYXRpb25hbEVycm9yKSlcbiAgICAgICAgcmV0dXJuIG5ldyBPcGVyYXRpb25hbEVycm9yKG1lc3NhZ2UpO1xuICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibmFtZVwiLCBcIk9wZXJhdGlvbmFsRXJyb3JcIik7XG4gICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBtZXNzYWdlO1xuICAgIHRoaXNbXCJpc09wZXJhdGlvbmFsXCJdID0gdHJ1ZTtcblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwic3RhY2tcIiwgbWVzc2FnZS5zdGFjayk7XG4gICAgfSBlbHNlIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbn1cbmluaGVyaXRzKE9wZXJhdGlvbmFsRXJyb3IsIEVycm9yKTtcblxudmFyIGVycm9yVHlwZXMgPSBFcnJvcltcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIl07XG5pZiAoIWVycm9yVHlwZXMpIHtcbiAgICBlcnJvclR5cGVzID0gT2JqZWN0ZnJlZXplKHtcbiAgICAgICAgQ2FuY2VsbGF0aW9uRXJyb3I6IENhbmNlbGxhdGlvbkVycm9yLFxuICAgICAgICBUaW1lb3V0RXJyb3I6IFRpbWVvdXRFcnJvcixcbiAgICAgICAgT3BlcmF0aW9uYWxFcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgUmVqZWN0aW9uRXJyb3I6IE9wZXJhdGlvbmFsRXJyb3IsXG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yOiBBZ2dyZWdhdGVFcnJvclxuICAgIH0pO1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShFcnJvciwgXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCIsIHtcbiAgICAgICAgdmFsdWU6IGVycm9yVHlwZXMsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXJyb3I6IEVycm9yLFxuICAgIFR5cGVFcnJvcjogX1R5cGVFcnJvcixcbiAgICBSYW5nZUVycm9yOiBfUmFuZ2VFcnJvcixcbiAgICBDYW5jZWxsYXRpb25FcnJvcjogZXJyb3JUeXBlcy5DYW5jZWxsYXRpb25FcnJvcixcbiAgICBPcGVyYXRpb25hbEVycm9yOiBlcnJvclR5cGVzLk9wZXJhdGlvbmFsRXJyb3IsXG4gICAgVGltZW91dEVycm9yOiBlcnJvclR5cGVzLlRpbWVvdXRFcnJvcixcbiAgICBBZ2dyZWdhdGVFcnJvcjogZXJyb3JUeXBlcy5BZ2dyZWdhdGVFcnJvcixcbiAgICBXYXJuaW5nOiBXYXJuaW5nXG59O1xuXG59LHtcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc0VTNSA9IChmdW5jdGlvbigpe1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzID09PSB1bmRlZmluZWQ7XG59KSgpO1xuXG5pZiAoaXNFUzUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZnJlZXplOiBPYmplY3QuZnJlZXplLFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICBnZXREZXNjcmlwdG9yOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgICAgICBrZXlzOiBPYmplY3Qua2V5cyxcbiAgICAgICAgbmFtZXM6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAgICAgICBnZXRQcm90b3R5cGVPZjogT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuICAgICAgICBpc0VTNTogaXNFUzUsXG4gICAgICAgIHByb3BlcnR5SXNXcml0YWJsZTogZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgICAgICAgIHJldHVybiAhISghZGVzY3JpcHRvciB8fCBkZXNjcmlwdG9yLndyaXRhYmxlIHx8IGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgICAgfVxuICAgIH07XG59IGVsc2Uge1xuICAgIHZhciBoYXMgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgc3RyID0ge30udG9TdHJpbmc7XG4gICAgdmFyIHByb3RvID0ge30uY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gICAgdmFyIE9iamVjdEtleXMgPSBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwobywga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEdldERlc2NyaXB0b3IgPSBmdW5jdGlvbihvLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHt2YWx1ZTogb1trZXldfTtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdERlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG8sIGtleSwgZGVzYykge1xuICAgICAgICBvW2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEZyZWV6ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChvYmopLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBBcnJheUlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgaXNBcnJheTogQXJyYXlJc0FycmF5LFxuICAgICAgICBrZXlzOiBPYmplY3RLZXlzLFxuICAgICAgICBuYW1lczogT2JqZWN0S2V5cyxcbiAgICAgICAgZGVmaW5lUHJvcGVydHk6IE9iamVjdERlZmluZVByb3BlcnR5LFxuICAgICAgICBnZXREZXNjcmlwdG9yOiBPYmplY3RHZXREZXNjcmlwdG9yLFxuICAgICAgICBmcmVlemU6IE9iamVjdEZyZWV6ZSxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2Y6IE9iamVjdEdldFByb3RvdHlwZU9mLFxuICAgICAgICBpc0VTNTogaXNFUzUsXG4gICAgICAgIHByb3BlcnR5SXNXcml0YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbn0se31dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VNYXAgPSBQcm9taXNlLm1hcDtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2VNYXAodGhpcywgZm4sIG9wdGlvbnMsIElOVEVSTkFMKTtcbn07XG5cblByb21pc2UuZmlsdGVyID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBQcm9taXNlTWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgSU5URVJOQUwpO1xufTtcbn07XG5cbn0se31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCB0cnlDb252ZXJ0VG9Qcm9taXNlKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dChwcm9taXNlLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdGhpcy5jYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbmNlbFByb21pc2UgPSBudWxsO1xufVxuXG5QYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0LnByb3RvdHlwZS5pc0ZpbmFsbHlIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIEZpbmFsbHlIYW5kbGVyQ2FuY2VsUmVhY3Rpb24oZmluYWxseUhhbmRsZXIpIHtcbiAgICB0aGlzLmZpbmFsbHlIYW5kbGVyID0gZmluYWxseUhhbmRsZXI7XG59XG5cbkZpbmFsbHlIYW5kbGVyQ2FuY2VsUmVhY3Rpb24ucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBjaGVja0NhbmNlbCh0aGlzLmZpbmFsbHlIYW5kbGVyKTtcbn07XG5cbmZ1bmN0aW9uIGNoZWNrQ2FuY2VsKGN0eCwgcmVhc29uKSB7XG4gICAgaWYgKGN0eC5jYW5jZWxQcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjdHguY2FuY2VsUHJvbWlzZS5fcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguY2FuY2VsUHJvbWlzZS5fY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNhbmNlbFByb21pc2UgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzdWNjZWVkKCkge1xuICAgIHJldHVybiBmaW5hbGx5SGFuZGxlci5jYWxsKHRoaXMsIHRoaXMucHJvbWlzZS5fdGFyZ2V0KCkuX3NldHRsZWRWYWx1ZSgpKTtcbn1cbmZ1bmN0aW9uIGZhaWwocmVhc29uKSB7XG4gICAgaWYgKGNoZWNrQ2FuY2VsKHRoaXMsIHJlYXNvbikpIHJldHVybjtcbiAgICBlcnJvck9iai5lID0gcmVhc29uO1xuICAgIHJldHVybiBlcnJvck9iajtcbn1cbmZ1bmN0aW9uIGZpbmFsbHlIYW5kbGVyKHJlYXNvbk9yVmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcjtcblxuICAgIGlmICghdGhpcy5jYWxsZWQpIHtcbiAgICAgICAgdGhpcy5jYWxsZWQgPSB0cnVlO1xuICAgICAgICB2YXIgcmV0ID0gdGhpcy5pc0ZpbmFsbHlIYW5kbGVyKClcbiAgICAgICAgICAgID8gaGFuZGxlci5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSlcbiAgICAgICAgICAgIDogaGFuZGxlci5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSwgcmVhc29uT3JWYWx1ZSk7XG4gICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvbWlzZS5fc2V0UmV0dXJuZWROb25VbmRlZmluZWQoKTtcbiAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbFByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlLl9pc0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhc29uID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yT2JqLmUgPSByZWFzb247XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF5YmVQcm9taXNlLmlzUGVuZGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBGaW5hbGx5SGFuZGxlckNhbmNlbFJlYWN0aW9uKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlLl90aGVuKFxuICAgICAgICAgICAgICAgICAgICBzdWNjZWVkLCBmYWlsLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZS5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgY2hlY2tDYW5jZWwodGhpcyk7XG4gICAgICAgIGVycm9yT2JqLmUgPSByZWFzb25PclZhbHVlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tDYW5jZWwodGhpcyk7XG4gICAgICAgIHJldHVybiByZWFzb25PclZhbHVlO1xuICAgIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuX3Bhc3NUaHJvdWdoID0gZnVuY3Rpb24oaGFuZGxlciwgdHlwZSwgc3VjY2VzcywgZmFpbCkge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdGhpcy50aGVuKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICBmYWlsLFxuICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dCh0aGlzLCB0eXBlLCBoYW5kbGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubGFzdGx5ID1cblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHlIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChoYW5kbGVyLCAxLCBmaW5hbGx5SGFuZGxlcik7XG59O1xuXG5yZXR1cm4gUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dDtcbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwxNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVqZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJveHlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zykge1xudmFyIGVycm9ycyA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKTtcbnZhciBUeXBlRXJyb3IgPSBlcnJvcnMuVHlwZUVycm9yO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgeWllbGRIYW5kbGVycyA9IFtdO1xuXG5mdW5jdGlvbiBwcm9taXNlRnJvbVlpZWxkSGFuZGxlcih2YWx1ZSwgeWllbGRIYW5kbGVycywgdHJhY2VQYXJlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHlpZWxkSGFuZGxlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdHJhY2VQYXJlbnQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh5aWVsZEhhbmRsZXJzW2ldKSh2YWx1ZSk7XG4gICAgICAgIHRyYWNlUGFyZW50Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICB0cmFjZVBhcmVudC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciByZXQgPSBQcm9taXNlLnJlamVjdChlcnJvck9iai5lKTtcbiAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJlc3VsdCwgdHJhY2VQYXJlbnQpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb21pc2VTcGF3bihnZW5lcmF0b3JGdW5jdGlvbiwgcmVjZWl2ZXIsIHlpZWxkSGFuZGxlciwgc3RhY2spIHtcbiAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkpIHtcbiAgICAgICAgdmFyIGludGVybmFsID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICB2YXIgX2ZpbmFsbHlQcm9taXNlID0gdGhpcy5fZmluYWxseVByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBpbnRlcm5hbC5sYXN0bHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZpbmFsbHlQcm9taXNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaW50ZXJuYWwuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIGludGVybmFsLl9zZXRPbkNhbmNlbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gICAgdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jdGlvbjtcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl95aWVsZEhhbmRsZXJzID0gdHlwZW9mIHlpZWxkSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gW3lpZWxkSGFuZGxlcl0uY29uY2F0KHlpZWxkSGFuZGxlcnMpXG4gICAgICAgIDogeWllbGRIYW5kbGVycztcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UgPSBmYWxzZTtcbn1cbnV0aWwuaW5oZXJpdHMoUHJvbWlzZVNwYXduLCBQcm94eWFibGUpO1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9pc1Jlc29sdmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2UgPT09IG51bGw7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcHJvbWlzZSA9IHRoaXMuX2dlbmVyYXRvciA9IG51bGw7XG4gICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpICYmIHRoaXMuX2ZpbmFsbHlQcm9taXNlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsbHlQcm9taXNlLl9mdWxmaWxsKCk7XG4gICAgICAgIHRoaXMuX2ZpbmFsbHlQcm9taXNlID0gbnVsbDtcbiAgICB9XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBpbXBsZW1lbnRzUmV0dXJuID0gdHlwZW9mIHRoaXMuX2dlbmVyYXRvcltcInJldHVyblwiXSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKCFpbXBsZW1lbnRzUmV0dXJuKSB7XG4gICAgICAgIHZhciByZWFzb24gPSBuZXcgUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvcihcbiAgICAgICAgICAgIFwiZ2VuZXJhdG9yIC5yZXR1cm4oKSBzZW50aW5lbFwiKTtcbiAgICAgICAgUHJvbWlzZS5jb3JvdXRpbmUucmV0dXJuU2VudGluZWwgPSByZWFzb247XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1widGhyb3dcIl0pLmNhbGwodGhpcy5fZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvcltcInJldHVyblwiXSkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIH1cbiAgICB0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSA9IHRydWU7XG4gICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yLm5leHQpLmNhbGwodGhpcy5fZ2VuZXJhdG9yLCB2YWx1ZSk7XG4gICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvcltcInRocm93XCJdKVxuICAgICAgICAuY2FsbCh0aGlzLl9nZW5lcmF0b3IsIHJlYXNvbik7XG4gICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5feWllbGRlZFByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5feWllbGRlZFByb21pc2U7XG4gICAgICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgcHJvbWlzZS5jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLnByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZ2VuZXJhdG9yID0gdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24uY2FsbCh0aGlzLl9yZWNlaXZlcik7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPVxuICAgICAgICB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9jb250aW51ZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICBpZiAodGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgaWYgKHJlc3VsdC5kb25lID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodmFsdWUsIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICBpZiAoIShtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlID1cbiAgICAgICAgICAgICAgICBwcm9taXNlRnJvbVlpZWxkSGFuZGxlcihtYXliZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5feWllbGRIYW5kbGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlUmVqZWN0ZWQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkEgdmFsdWUgJXMgd2FzIHlpZWxkZWQgdGhhdCBjb3VsZCBub3QgYmUgdHJlYXRlZCBhcyBhIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXFx1MDAwYVwiLnJlcGxhY2UoXCIlc1wiLCB2YWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJGcm9tIGNvcm91dGluZTpcXHUwMDBhXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSwgLTcpLmpvaW4oXCJcXG5cIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgIHZhciBiaXRGaWVsZCA9IG1heWJlUHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIDtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fcHJveHkodGhpcywgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIFByb21pc2UuX2FzeW5jLmludm9rZShcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkLCB0aGlzLCBtYXliZVByb21pc2UuX3ZhbHVlKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIFByb21pc2UuX2FzeW5jLmludm9rZShcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlUmVqZWN0ZWQsIHRoaXMsIG1heWJlUHJvbWlzZS5fcmVhc29uKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlQ2FuY2VsbGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLmNvcm91dGluZSA9IGZ1bmN0aW9uIChnZW5lcmF0b3JGdW5jdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZ2VuZXJhdG9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZ2VuZXJhdG9yRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHlpZWxkSGFuZGxlciA9IE9iamVjdChvcHRpb25zKS55aWVsZEhhbmRsZXI7XG4gICAgdmFyIFByb21pc2VTcGF3biQgPSBQcm9taXNlU3Bhd247XG4gICAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IGdlbmVyYXRvckZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBzcGF3biA9IG5ldyBQcm9taXNlU3Bhd24kKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB5aWVsZEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrKTtcbiAgICAgICAgdmFyIHJldCA9IHNwYXduLnByb21pc2UoKTtcbiAgICAgICAgc3Bhd24uX2dlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICAgICAgc3Bhd24uX3Byb21pc2VGdWxmaWxsZWQodW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5jb3JvdXRpbmUuYWRkWWllbGRIYW5kbGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHlpZWxkSGFuZGxlcnMucHVzaChmbik7XG59O1xuXG5Qcm9taXNlLnNwYXduID0gZnVuY3Rpb24gKGdlbmVyYXRvckZ1bmN0aW9uKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIlByb21pc2Uuc3Bhd24oKVwiLCBcIlByb21pc2UuY29yb3V0aW5lKClcIik7XG4gICAgaWYgKHR5cGVvZiBnZW5lcmF0b3JGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJnZW5lcmF0b3JGdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB2YXIgc3Bhd24gPSBuZXcgUHJvbWlzZVNwYXduKGdlbmVyYXRvckZ1bmN0aW9uLCB0aGlzKTtcbiAgICB2YXIgcmV0ID0gc3Bhd24ucHJvbWlzZSgpO1xuICAgIHNwYXduLl9ydW4oUHJvbWlzZS5zcGF3bik7XG4gICAgcmV0dXJuIHJldDtcbn07XG59O1xuXG59LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgYXN5bmMsXG4gICAgICAgICBnZXREb21haW4pIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciByZWplY3Q7XG5cbmlmICghdHJ1ZSkge1xuaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgdmFyIHRoZW5DYWxsYmFjayA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInZhbHVlXCIsIFwiaG9sZGVyXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLmNoZWNrRnVsZmlsbG1lbnQodGhpcyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgIH07XG5cbiAgICB2YXIgcHJvbWlzZVNldHRlciA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInByb21pc2VcIiwgXCJob2xkZXJcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2VuZXJhdGVIb2xkZXJDbGFzcyA9IGZ1bmN0aW9uKHRvdGFsKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IG5ldyBBcnJheSh0b3RhbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHByb3BzW2ldID0gXCJ0aGlzLnBcIiArIChpKzEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3NpZ25tZW50ID0gcHJvcHMuam9pbihcIiA9IFwiKSArIFwiID0gbnVsbDtcIjtcbiAgICAgICAgdmFyIGNhbmNlbGxhdGlvbkNvZGU9IFwidmFyIHByb21pc2U7XFxuXCIgKyBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gXCIgKyBwcm9wICsgXCI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmNhbmNlbCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCI7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIHZhciBwYXNzZWRBcmd1bWVudHMgPSBwcm9wcy5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBuYW1lID0gXCJIb2xkZXIkXCIgKyB0b3RhbDtcblxuXG4gICAgICAgIHZhciBjb2RlID0gXCJyZXR1cm4gZnVuY3Rpb24odHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYykgeyAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZnVuY3Rpb24gW1RoZU5hbWVdKGZuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtUaGVQcm9wZXJ0aWVzXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMuZm4gPSBmbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMuYXN5bmNOZWVkZWQgPSB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMubm93ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5fY2FsbEZ1bmN0aW9uID0gZnVuY3Rpb24ocHJvbWlzZSkgeyAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHZhciByZXQgPSB0cnlDYXRjaCh0aGlzLmZuKShbVGhlUGFzc2VkQXJndW1lbnRzXSk7ICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3BvcENvbnRleHQoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXQuZSwgZmFsc2UpOyAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2socmV0KTsgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5jaGVja0Z1bGZpbGxtZW50ID0gZnVuY3Rpb24ocHJvbWlzZSkgeyAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHZhciBub3cgPSArK3RoaXMubm93OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChub3cgPT09IFtUaGVUb3RhbF0pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hc3luY05lZWRlZCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMuaW52b2tlKHRoaXMuX2NhbGxGdW5jdGlvbiwgdGhpcywgcHJvbWlzZSk7ICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbEZ1bmN0aW9uKHByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7ICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtDYW5jZWxsYXRpb25Db2RlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIFtUaGVOYW1lXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9KHRyeUNhdGNoLCBlcnJvck9iaiwgUHJvbWlzZSwgYXN5bmMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIjtcblxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9cXFtUaGVOYW1lXFxdL2csIG5hbWUpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlVG90YWxcXF0vZywgdG90YWwpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlUGFzc2VkQXJndW1lbnRzXFxdL2csIHBhc3NlZEFyZ3VtZW50cylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtUaGVQcm9wZXJ0aWVzXFxdL2csIGFzc2lnbm1lbnQpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbQ2FuY2VsbGF0aW9uQ29kZVxcXS9nLCBjYW5jZWxsYXRpb25Db2RlKTtcblxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidHJ5Q2F0Y2hcIiwgXCJlcnJvck9ialwiLCBcIlByb21pc2VcIiwgXCJhc3luY1wiLCBjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRyeUNhdGNoLCBlcnJvck9iaiwgUHJvbWlzZSwgYXN5bmMpO1xuICAgIH07XG5cbiAgICB2YXIgaG9sZGVyQ2xhc3NlcyA9IFtdO1xuICAgIHZhciB0aGVuQ2FsbGJhY2tzID0gW107XG4gICAgdmFyIHByb21pc2VTZXR0ZXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICBob2xkZXJDbGFzc2VzLnB1c2goZ2VuZXJhdGVIb2xkZXJDbGFzcyhpICsgMSkpO1xuICAgICAgICB0aGVuQ2FsbGJhY2tzLnB1c2godGhlbkNhbGxiYWNrKGkgKyAxKSk7XG4gICAgICAgIHByb21pc2VTZXR0ZXJzLnB1c2gocHJvbWlzZVNldHRlcihpICsgMSkpO1xuICAgIH1cblxuICAgIHJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgfTtcbn19XG5cblByb21pc2Uuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHZhciBmbjtcbiAgICBpZiAobGFzdCA+IDAgJiYgdHlwZW9mIGFyZ3VtZW50c1tsYXN0XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZuID0gYXJndW1lbnRzW2xhc3RdO1xuICAgICAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgICAgIGlmIChsYXN0IDw9IDggJiYgY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgSG9sZGVyQ2xhc3MgPSBob2xkZXJDbGFzc2VzW2xhc3QgLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgaG9sZGVyID0gbmV3IEhvbGRlckNsYXNzKGZuKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhlbkNhbGxiYWNrcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKGFyZ3VtZW50c1tpXSwgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKGNhbGxiYWNrc1tpXSwgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHJldCwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlU2V0dGVyc1tpXShtYXliZVByb21pc2UsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmFzeW5jTmVlZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwocmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdmFsdWUoKSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCwgbWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXQuX2lzRmF0ZVNlYWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuYXN5bmNOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm4gPSB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBob2xkZXIuZm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwoaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTs7XG4gICAgaWYgKGZuKSBhcmdzLnBvcCgpO1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZUFycmF5KGFyZ3MpLnByb21pc2UoKTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IHJldC5zcHJlYWQoZm4pIDogcmV0O1xufTtcblxufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcblxuZnVuY3Rpb24gTWFwcGluZ1Byb21pc2VBcnJheShwcm9taXNlcywgZm4sIGxpbWl0LCBfZmlsdGVyKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQocHJvbWlzZXMpO1xuICAgIHRoaXMuX3Byb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbik7XG4gICAgdGhpcy5fcHJlc2VydmVkVmFsdWVzID0gX2ZpbHRlciA9PT0gSU5URVJOQUxcbiAgICAgICAgPyBuZXcgQXJyYXkodGhpcy5sZW5ndGgoKSlcbiAgICAgICAgOiBudWxsO1xuICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgdGhpcy5faW5GbGlnaHQgPSAwO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgYXN5bmMuaW52b2tlKHRoaXMuX2FzeW5jSW5pdCwgdGhpcywgdW5kZWZpbmVkKTtcbn1cbnV0aWwuaW5oZXJpdHMoTWFwcGluZ1Byb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2FzeW5jSW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTIpO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICB2YXIgcHJlc2VydmVkVmFsdWVzID0gdGhpcy5fcHJlc2VydmVkVmFsdWVzO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2xpbWl0O1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IChpbmRleCAqIC0xKSAtIDE7XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGxpbWl0ID49IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2luRmxpZ2h0LS07XG4gICAgICAgICAgICB0aGlzLl9kcmFpblF1ZXVlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsaW1pdCA+PSAxICYmIHRoaXMuX2luRmxpZ2h0ID49IGxpbWl0KSB7XG4gICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlc2VydmVkVmFsdWVzICE9PSBudWxsKSBwcmVzZXJ2ZWRWYWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2goY2FsbGJhY2spLmNhbGwocmVjZWl2ZXIsIHZhbHVlLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBwcm9taXNlQ3JlYXRlZCxcbiAgICAgICAgICAgIHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCA/IFwiUHJvbWlzZS5maWx0ZXJcIiA6IFwiUHJvbWlzZS5tYXBcIixcbiAgICAgICAgICAgIHByb21pc2VcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChyZXQuZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgdmFyIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+PSAxKSB0aGlzLl9pbkZsaWdodCsrO1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCAoaW5kZXggKyAxKSAqIC0xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbWF5YmVQcm9taXNlLl92YWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHJldDtcbiAgICB9XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gbGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcih2YWx1ZXMsIHByZXNlcnZlZFZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2xpbWl0O1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDAgJiYgdGhpcy5faW5GbGlnaHQgPCBsaW1pdCkge1xuICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgICAgIHZhciBpbmRleCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlc1tpbmRleF0sIGluZGV4KTtcbiAgICB9XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZmlsdGVyID0gZnVuY3Rpb24gKGJvb2xlYW5zLCB2YWx1ZXMpIHtcbiAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGxlbik7XG4gICAgdmFyIGogPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGJvb2xlYW5zW2ldKSByZXRbaisrXSA9IHZhbHVlc1tpXTtcbiAgICB9XG4gICAgcmV0Lmxlbmd0aCA9IGo7XG4gICAgdGhpcy5fcmVzb2x2ZShyZXQpO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUucHJlc2VydmVkVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXM7XG59O1xuXG5mdW5jdGlvbiBtYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cblxuICAgIHZhciBsaW1pdCA9IDA7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbmN1cnJlbmN5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICAgICAgICBuZXcgVHlwZUVycm9yKFwiJ2NvbmN1cnJlbmN5JyBtdXN0IGJlIGEgbnVtYmVyIGJ1dCBpdCBpcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKG9wdGlvbnMuY29uY3VycmVuY3kpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1pdCA9IG9wdGlvbnMuY29uY3VycmVuY3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QgYnV0IGl0IGlzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhvcHRpb25zKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbWl0ID0gdHlwZW9mIGxpbWl0ID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIGlzRmluaXRlKGxpbWl0KSAmJiBsaW1pdCA+PSAxID8gbGltaXQgOiAwO1xuICAgIHJldHVybiBuZXcgTWFwcGluZ1Byb21pc2VBcnJheShwcm9taXNlcywgZm4sIGxpbWl0LCBfZmlsdGVyKS5wcm9taXNlKCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBtYXAodGhpcywgZm4sIG9wdGlvbnMsIG51bGwpO1xufTtcblxuUHJvbWlzZS5tYXAgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKSB7XG4gICAgcmV0dXJuIG1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpO1xufTtcblxuXG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCBkZWJ1Zykge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcblxuUHJvbWlzZS5tZXRob2QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByb21pc2UuVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyeUNhdGNoKGZuKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSByZXQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICAgICAgdmFsdWUsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UubWV0aG9kXCIsIHJldCk7XG4gICAgICAgIHJldC5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59O1xuXG5Qcm9taXNlLmF0dGVtcHQgPSBQcm9taXNlW1widHJ5XCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiY2FsbGluZyBQcm9taXNlLnRyeSB3aXRoIG1vcmUgdGhhbiAxIGFyZ3VtZW50XCIpO1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgY3R4ID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YWx1ZSA9IHV0aWwuaXNBcnJheShhcmcpID8gdHJ5Q2F0Y2goZm4pLmFwcGx5KGN0eCwgYXJnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ5Q2F0Y2goZm4pLmNhbGwoY3R4LCBhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdHJ5Q2F0Y2goZm4pKCk7XG4gICAgfVxuICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHJldC5fcG9wQ29udGV4dCgpO1xuICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgdmFsdWUsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UudHJ5XCIsIHJldCk7XG4gICAgcmV0Ll9yZXNvbHZlRnJvbVN5bmNWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlRnJvbVN5bmNWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdXRpbC5lcnJvck9iaikge1xuICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjayh2YWx1ZS5lLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlLCB0cnVlKTtcbiAgICB9XG59O1xufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIG1heWJlV3JhcEFzRXJyb3IgPSB1dGlsLm1heWJlV3JhcEFzRXJyb3I7XG52YXIgZXJyb3JzID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpO1xudmFyIE9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcbnZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG5cbmZ1bmN0aW9uIGlzVW50eXBlZEVycm9yKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICBlczUuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gRXJyb3IucHJvdG90eXBlO1xufVxuXG52YXIgckVycm9yS2V5ID0gL14oPzpuYW1lfG1lc3NhZ2V8c3RhY2t8Y2F1c2UpJC87XG5mdW5jdGlvbiB3cmFwQXNPcGVyYXRpb25hbEVycm9yKG9iaikge1xuICAgIHZhciByZXQ7XG4gICAgaWYgKGlzVW50eXBlZEVycm9yKG9iaikpIHtcbiAgICAgICAgcmV0ID0gbmV3IE9wZXJhdGlvbmFsRXJyb3Iob2JqKTtcbiAgICAgICAgcmV0Lm5hbWUgPSBvYmoubmFtZTtcbiAgICAgICAgcmV0Lm1lc3NhZ2UgPSBvYmoubWVzc2FnZTtcbiAgICAgICAgcmV0LnN0YWNrID0gb2JqLnN0YWNrO1xuICAgICAgICB2YXIga2V5cyA9IGVzNS5rZXlzKG9iaik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIXJFcnJvcktleS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHV0aWwubWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UsIG11bHRpQXJncykge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnIsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9taXNlID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkID0gd3JhcEFzT3BlcmF0aW9uYWxFcnJvcihtYXliZVdyYXBBc0Vycm9yKGVycikpO1xuICAgICAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZSh3cmFwcGVkKTtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdCh3cmFwcGVkKTtcbiAgICAgICAgfSBlbHNlIGlmICghbXVsdGlBcmdzKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOztcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub2RlYmFja0ZvclByb21pc2U7XG5cbn0se1wiLi9lcnJvcnNcIjoxMixcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuXG5mdW5jdGlvbiBzcHJlYWRBZGFwdGVyKHZhbCwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgaWYgKCF1dGlsLmlzQXJyYXkodmFsKSkgcmV0dXJuIHN1Y2Nlc3NBZGFwdGVyLmNhbGwocHJvbWlzZSwgdmFsLCBub2RlYmFjayk7XG4gICAgdmFyIHJldCA9XG4gICAgICAgIHRyeUNhdGNoKG5vZGViYWNrKS5hcHBseShwcm9taXNlLl9ib3VuZFZhbHVlKCksIFtudWxsXS5jb25jYXQodmFsKSk7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdWNjZXNzQWRhcHRlcih2YWwsIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciByZWNlaXZlciA9IHByb21pc2UuX2JvdW5kVmFsdWUoKTtcbiAgICB2YXIgcmV0ID0gdmFsID09PSB1bmRlZmluZWRcbiAgICAgICAgPyB0cnlDYXRjaChub2RlYmFjaykuY2FsbChyZWNlaXZlciwgbnVsbClcbiAgICAgICAgOiB0cnlDYXRjaChub2RlYmFjaykuY2FsbChyZWNlaXZlciwgbnVsbCwgdmFsKTtcbiAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlcnJvckFkYXB0ZXIocmVhc29uLCBub2RlYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKHJlYXNvbiArIFwiXCIpO1xuICAgICAgICBuZXdSZWFzb24uY2F1c2UgPSByZWFzb247XG4gICAgICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgICB9XG4gICAgdmFyIHJldCA9IHRyeUNhdGNoKG5vZGViYWNrKS5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSwgcmVhc29uKTtcbiAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLmFzQ2FsbGJhY2sgPSBQcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKG5vZGViYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygbm9kZWJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBhZGFwdGVyID0gc3VjY2Vzc0FkYXB0ZXI7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0KG9wdGlvbnMpLnNwcmVhZCkge1xuICAgICAgICAgICAgYWRhcHRlciA9IHNwcmVhZEFkYXB0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGhlbihcbiAgICAgICAgICAgIGFkYXB0ZXIsXG4gICAgICAgICAgICBlcnJvckFkYXB0ZXIsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgbm9kZWJhY2tcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbnZhciBtYWtlU2VsZlJlc29sdXRpb25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImNpcmN1bGFyIHByb21pc2UgcmVzb2x1dGlvbiBjaGFpblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG59O1xudmFyIHJlZmxlY3RIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHRoaXMuX3RhcmdldCgpKTtcbn07XG52YXIgYXBpUmVqZWN0aW9uID0gZnVuY3Rpb24obXNnKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IobXNnKSk7XG59O1xuZnVuY3Rpb24gUHJveHlhYmxlKCkge31cbnZhciBVTkRFRklORURfQklORElORyA9IHt9O1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuXG52YXIgZ2V0RG9tYWluO1xuaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgZ2V0RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXQgPSBwcm9jZXNzLmRvbWFpbjtcbiAgICAgICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSByZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59IGVsc2Uge1xuICAgIGdldERvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLCBcIl9nZXREb21haW5cIiwgZ2V0RG9tYWluKTtcblxudmFyIGVzNSA9IF9kZXJlcV8oXCIuL2VzNVwiKTtcbnZhciBBc3luYyA9IF9kZXJlcV8oXCIuL2FzeW5jXCIpO1xudmFyIGFzeW5jID0gbmV3IEFzeW5jKCk7XG5lczUuZGVmaW5lUHJvcGVydHkoUHJvbWlzZSwgXCJfYXN5bmNcIiwge3ZhbHVlOiBhc3luY30pO1xudmFyIGVycm9ycyA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKTtcbnZhciBUeXBlRXJyb3IgPSBQcm9taXNlLlR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG5Qcm9taXNlLlJhbmdlRXJyb3IgPSBlcnJvcnMuUmFuZ2VFcnJvcjtcbnZhciBDYW5jZWxsYXRpb25FcnJvciA9IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IgPSBlcnJvcnMuQ2FuY2VsbGF0aW9uRXJyb3I7XG5Qcm9taXNlLlRpbWVvdXRFcnJvciA9IGVycm9ycy5UaW1lb3V0RXJyb3I7XG5Qcm9taXNlLk9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuUmVqZWN0aW9uRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuQWdncmVnYXRlRXJyb3IgPSBlcnJvcnMuQWdncmVnYXRlRXJyb3I7XG52YXIgSU5URVJOQUwgPSBmdW5jdGlvbigpe307XG52YXIgQVBQTFkgPSB7fTtcbnZhciBORVhUX0ZJTFRFUiA9IHt9O1xudmFyIHRyeUNvbnZlcnRUb1Byb21pc2UgPSBfZGVyZXFfKFwiLi90aGVuYWJsZXNcIikoUHJvbWlzZSwgSU5URVJOQUwpO1xudmFyIFByb21pc2VBcnJheSA9XG4gICAgX2RlcmVxXyhcIi4vcHJvbWlzZV9hcnJheVwiKShQcm9taXNlLCBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sIFByb3h5YWJsZSk7XG52YXIgQ29udGV4dCA9IF9kZXJlcV8oXCIuL2NvbnRleHRcIikoUHJvbWlzZSk7XG4gLypqc2hpbnQgdW51c2VkOmZhbHNlKi9cbnZhciBjcmVhdGVDb250ZXh0ID0gQ29udGV4dC5jcmVhdGU7XG52YXIgZGVidWcgPSBfZGVyZXFfKFwiLi9kZWJ1Z2dhYmlsaXR5XCIpKFByb21pc2UsIENvbnRleHQpO1xudmFyIENhcHR1cmVkVHJhY2UgPSBkZWJ1Zy5DYXB0dXJlZFRyYWNlO1xudmFyIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQgPVxuICAgIF9kZXJlcV8oXCIuL2ZpbmFsbHlcIikoUHJvbWlzZSwgdHJ5Q29udmVydFRvUHJvbWlzZSk7XG52YXIgY2F0Y2hGaWx0ZXIgPSBfZGVyZXFfKFwiLi9jYXRjaF9maWx0ZXJcIikoTkVYVF9GSUxURVIpO1xudmFyIG5vZGViYWNrRm9yUHJvbWlzZSA9IF9kZXJlcV8oXCIuL25vZGViYWNrXCIpO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5mdW5jdGlvbiBjaGVjayhzZWxmLCBleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZXhlY3V0b3IpKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuY29uc3RydWN0b3IgIT09IFByb21pc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIGRpcmVjdGx5XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IDA7XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wcm9taXNlMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWNlaXZlcjAgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGV4ZWN1dG9yICE9PSBJTlRFUk5BTCkge1xuICAgICAgICBjaGVjayh0aGlzLCBleGVjdXRvcik7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVGcm9tRXhlY3V0b3IoZXhlY3V0b3IpO1xuICAgIH1cbiAgICB0aGlzLl9wcm9taXNlQ3JlYXRlZCgpO1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VDcmVhdGVkXCIsIHRoaXMpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXVnaHQgPSBQcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgaiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlc1tqKytdID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiQSBjYXRjaCBzdGF0ZW1lbnQgcHJlZGljYXRlIFwiICsgdXRpbC5jbGFzc1N0cmluZyhpdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2hJbnN0YW5jZXMubGVuZ3RoID0gajtcbiAgICAgICAgZm4gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBjYXRjaEZpbHRlcihjYXRjaEluc3RhbmNlcywgZm4sIHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGZuKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJlZmxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4ocmVmbGVjdEhhbmRsZXIsXG4gICAgICAgIHJlZmxlY3RIYW5kbGVyLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCkge1xuICAgIGlmIChkZWJ1Zy53YXJuaW5ncygpICYmIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmXG4gICAgICAgIHR5cGVvZiBkaWRGdWxmaWxsICE9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGRpZFJlamVjdCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBtc2cgPSBcIi50aGVuKCkgb25seSBhY2NlcHRzIGZ1bmN0aW9ucyBidXQgd2FzIHBhc3NlZDogXCIgK1xuICAgICAgICAgICAgICAgIHV0aWwuY2xhc3NTdHJpbmcoZGlkRnVsZmlsbCk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbXNnICs9IFwiLCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZGlkUmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93YXJuKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCkge1xuICAgIHZhciBwcm9taXNlID1cbiAgICAgICAgdGhpcy5fdGhlbihkaWRGdWxmaWxsLCBkaWRSZWplY3QsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIHByb21pc2UuX3NldElzRmluYWwoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNwcmVhZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWxsKCkuX3RoZW4oZm4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBBUFBMWSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmV0ID0ge1xuICAgICAgICBpc0Z1bGZpbGxlZDogZmFsc2UsXG4gICAgICAgIGlzUmVqZWN0ZWQ6IGZhbHNlLFxuICAgICAgICBmdWxmaWxsbWVudFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIHJlamVjdGlvblJlYXNvbjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAodGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgIHJldC5mdWxmaWxsbWVudFZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICByZXQuaXNGdWxmaWxsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgcmV0LnJlamVjdGlvblJlYXNvbiA9IHRoaXMucmVhc29uKCk7XG4gICAgICAgIHJldC5pc1JlamVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5fd2FybihcIi5hbGwoKSB3YXMgcGFzc2VkIGFyZ3VtZW50cyBidXQgaXQgZG9lcyBub3QgdGFrZSBhbnlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZUFycmF5KHRoaXMpLnByb21pc2UoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuY2F1Z2h0KHV0aWwub3JpZ2luYXRlc0Zyb21SZWplY3Rpb24sIGZuKTtcbn07XG5cblByb21pc2UuZ2V0TmV3TGlicmFyeUNvcHkgPSBtb2R1bGUuZXhwb3J0cztcblxuUHJvbWlzZS5pcyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgUHJvbWlzZTtcbn07XG5cblByb21pc2UuZnJvbU5vZGUgPSBQcm9taXNlLmZyb21DYWxsYmFjayA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdmFyIG11bHRpQXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gISFPYmplY3QoYXJndW1lbnRzWzFdKS5tdWx0aUFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goZm4pKG5vZGViYWNrRm9yUHJvbWlzZShyZXQsIG11bHRpQXJncykpO1xuICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHJldC5fcmVqZWN0Q2FsbGJhY2socmVzdWx0LmUsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoIXJldC5faXNGYXRlU2VhbGVkKCkpIHJldC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlQXJyYXkocHJvbWlzZXMpLnByb21pc2UoKTtcbn07XG5cblByb21pc2UuY2FzdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmV0ID0gdHJ5Q29udmVydFRvUHJvbWlzZShvYmopO1xuICAgIGlmICghKHJldCBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICByZXQuX3NldEZ1bGZpbGxlZCgpO1xuICAgICAgICByZXQuX3JlamVjdGlvbkhhbmRsZXIwID0gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5yZXNvbHZlID0gUHJvbWlzZS5mdWxmaWxsZWQgPSBQcm9taXNlLmNhc3Q7XG5cblByb21pc2UucmVqZWN0ID0gUHJvbWlzZS5yZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICByZXQuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2Uuc2V0U2NoZWR1bGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHJldHVybiBhc3luYy5zZXRTY2hlZHVsZXIoZm4pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3RoZW4gPSBmdW5jdGlvbiAoXG4gICAgZGlkRnVsZmlsbCxcbiAgICBkaWRSZWplY3QsXG4gICAgXywgICAgcmVjZWl2ZXIsXG4gICAgaW50ZXJuYWxEYXRhXG4pIHtcbiAgICB2YXIgaGF2ZUludGVybmFsRGF0YSA9IGludGVybmFsRGF0YSAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBwcm9taXNlID0gaGF2ZUludGVybmFsRGF0YSA/IGludGVybmFsRGF0YSA6IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgdmFyIGJpdEZpZWxkID0gdGFyZ2V0Ll9iaXRGaWVsZDtcblxuICAgIGlmICghaGF2ZUludGVybmFsRGF0YSkge1xuICAgICAgICBwcm9taXNlLl9wcm9wYWdhdGVGcm9tKHRoaXMsIDMpO1xuICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKCh0aGlzLl9iaXRGaWVsZCAmIDIwOTcxNTIpICE9PSAwKSkge1xuICAgICAgICAgICAgaWYgKCEoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0gdGhpcy5fYm91bmRWYWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9IHRhcmdldCA9PT0gdGhpcyA/IHVuZGVmaW5lZCA6IHRoaXMuX2JvdW5kVG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUNoYWluZWRcIiwgdGhpcywgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIGlmICghKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIsIHZhbHVlLCBzZXR0bGVyID0gdGFyZ2V0Ll9zZXR0bGVQcm9taXNlQ3R4O1xuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0Ll9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBkaWRGdWxmaWxsO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRhcmdldC5fZnVsZmlsbG1lbnRIYW5kbGVyMDtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBkaWRSZWplY3Q7XG4gICAgICAgICAgICB0YXJnZXQuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHRsZXIgPSB0YXJnZXQuX3NldHRsZVByb21pc2VMYXRlQ2FuY2VsbGF0aW9uT2JzZXJ2ZXI7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBDYW5jZWxsYXRpb25FcnJvcihcImxhdGUgY2FuY2VsbGF0aW9uIG9ic2VydmVyXCIpO1xuICAgICAgICAgICAgdGFyZ2V0Ll9hdHRhY2hFeHRyYVRyYWNlKHZhbHVlKTtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBkaWRSZWplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYy5pbnZva2Uoc2V0dGxlciwgdGFyZ2V0LCB7XG4gICAgICAgICAgICBoYW5kbGVyOiBkb21haW4gPT09IG51bGwgPyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgOiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgICB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBoYW5kbGVyKSksXG4gICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICAgICAgcmVjZWl2ZXI6IHJlY2VpdmVyLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5fYWRkQ2FsbGJhY2tzKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgcHJvbWlzZSwgcmVjZWl2ZXIsIGRvbWFpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRGaWVsZCAmIDY1NTM1O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRmF0ZVNlYWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTE3NTA2MDQ4KSAhPT0gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0ZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNjcxMDg4NjQpID09PSA2NzEwODg2NDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSAodGhpcy5fYml0RmllbGQgJiAtNjU1MzYpIHxcbiAgICAgICAgKGxlbiAmIDY1NTM1KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRGdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDMzNTU0NDMyO1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VGdWxmaWxsZWRcIiwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0UmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDE2Nzc3MjE2O1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VSZWplY3RlZFwiLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRGb2xsb3dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDY3MTA4ODY0O1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VSZXNvbHZlZFwiLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRJc0ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA0MTk0MzA0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDQxOTQzMDQpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjY1NTM2KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNjU1MzY7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUNhbmNlbGxlZFwiLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRXaWxsQmVDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgODM4ODYwODtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRBc3luY0d1YXJhbnRlZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXN5bmMuaGFzQ3VzdG9tU2NoZWR1bGVyKCkpIHJldHVybjtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTM0MjE3NzI4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlY2VpdmVyQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gaW5kZXggPT09IDAgPyB0aGlzLl9yZWNlaXZlcjAgOiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDNdO1xuICAgIGlmIChyZXQgPT09IFVOREVGSU5FRF9CSU5ESU5HKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChyZXQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9pc0JvdW5kKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kVmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpc1tcbiAgICAgICAgICAgIGluZGV4ICogNCAtIDQgKyAyXTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsbWVudEhhbmRsZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDBdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdGlvbkhhbmRsZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDFdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2JvdW5kVmFsdWUgPSBmdW5jdGlvbigpIHt9O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrMCA9IGZ1bmN0aW9uIChmb2xsb3dlcikge1xuICAgIHZhciBiaXRGaWVsZCA9IGZvbGxvd2VyLl9iaXRGaWVsZDtcbiAgICB2YXIgZnVsZmlsbCA9IGZvbGxvd2VyLl9mdWxmaWxsbWVudEhhbmRsZXIwO1xuICAgIHZhciByZWplY3QgPSBmb2xsb3dlci5fcmVqZWN0aW9uSGFuZGxlcjA7XG4gICAgdmFyIHByb21pc2UgPSBmb2xsb3dlci5fcHJvbWlzZTA7XG4gICAgdmFyIHJlY2VpdmVyID0gZm9sbG93ZXIuX3JlY2VpdmVyQXQoMCk7XG4gICAgaWYgKHJlY2VpdmVyID09PSB1bmRlZmluZWQpIHJlY2VpdmVyID0gVU5ERUZJTkVEX0JJTkRJTkc7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKGZ1bGZpbGwsIHJlamVjdCwgcHJvbWlzZSwgcmVjZWl2ZXIsIG51bGwpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX21pZ3JhdGVDYWxsYmFja0F0ID0gZnVuY3Rpb24gKGZvbGxvd2VyLCBpbmRleCkge1xuICAgIHZhciBmdWxmaWxsID0gZm9sbG93ZXIuX2Z1bGZpbGxtZW50SGFuZGxlckF0KGluZGV4KTtcbiAgICB2YXIgcmVqZWN0ID0gZm9sbG93ZXIuX3JlamVjdGlvbkhhbmRsZXJBdChpbmRleCk7XG4gICAgdmFyIHByb21pc2UgPSBmb2xsb3dlci5fcHJvbWlzZUF0KGluZGV4KTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBmb2xsb3dlci5fcmVjZWl2ZXJBdChpbmRleCk7XG4gICAgaWYgKHJlY2VpdmVyID09PSB1bmRlZmluZWQpIHJlY2VpdmVyID0gVU5ERUZJTkVEX0JJTkRJTkc7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKGZ1bGZpbGwsIHJlamVjdCwgcHJvbWlzZSwgcmVjZWl2ZXIsIG51bGwpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2FkZENhbGxiYWNrcyA9IGZ1bmN0aW9uIChcbiAgICBmdWxmaWxsLFxuICAgIHJlamVjdCxcbiAgICBwcm9taXNlLFxuICAgIHJlY2VpdmVyLFxuICAgIGRvbWFpblxuKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fbGVuZ3RoKCk7XG5cbiAgICBpZiAoaW5kZXggPj0gNjU1MzUgLSA0KSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9wcm9taXNlMCA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuX3JlY2VpdmVyMCA9IHJlY2VpdmVyO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bGZpbGwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9XG4gICAgICAgICAgICAgICAgZG9tYWluID09PSBudWxsID8gZnVsZmlsbCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZ1bGZpbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyByZWplY3QgOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJhc2UgPSBpbmRleCAqIDQgLSA0O1xuICAgICAgICB0aGlzW2Jhc2UgKyAyXSA9IHByb21pc2U7XG4gICAgICAgIHRoaXNbYmFzZSArIDNdID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZnVsZmlsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzW2Jhc2UgKyAwXSA9XG4gICAgICAgICAgICAgICAgZG9tYWluID09PSBudWxsID8gZnVsZmlsbCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZ1bGZpbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDFdID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyByZWplY3QgOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldExlbmd0aChpbmRleCArIDEpO1xuICAgIHJldHVybiBpbmRleDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm94eSA9IGZ1bmN0aW9uIChwcm94eWFibGUsIGFyZykge1xuICAgIHRoaXMuX2FkZENhbGxiYWNrcyh1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJnLCBwcm94eWFibGUsIG51bGwpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Jlc29sdmVDYWxsYmFjayA9IGZ1bmN0aW9uKHZhbHVlLCBzaG91bGRCaW5kKSB7XG4gICAgaWYgKCgodGhpcy5fYml0RmllbGQgJiAxMTc1MDYwNDgpICE9PSAwKSkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcylcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdENhbGxiYWNrKG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCksIGZhbHNlKTtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZSwgdGhpcyk7XG4gICAgaWYgKCEobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHJldHVybiB0aGlzLl9mdWxmaWxsKHZhbHVlKTtcblxuICAgIGlmIChzaG91bGRCaW5kKSB0aGlzLl9wcm9wYWdhdGVGcm9tKG1heWJlUHJvbWlzZSwgMik7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdGhpcykge1xuICAgICAgICB0aGlzLl9yZWplY3QobWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYml0RmllbGQgPSBwcm9taXNlLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2xlbmd0aCgpO1xuICAgICAgICBpZiAobGVuID4gMCkgcHJvbWlzZS5fbWlncmF0ZUNhbGxiYWNrMCh0aGlzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fbWlncmF0ZUNhbGxiYWNrQXQodGhpcywgaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Rm9sbG93aW5nKCk7XG4gICAgICAgIHRoaXMuX3NldExlbmd0aCgwKTtcbiAgICAgICAgdGhpcy5fc2V0Rm9sbG93ZWUocHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICB0aGlzLl9mdWxmaWxsKHByb21pc2UuX3ZhbHVlKCkpO1xuICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHByb21pc2UuX3JlYXNvbigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVhc29uID0gbmV3IENhbmNlbGxhdGlvbkVycm9yKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7XG4gICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdENhbGxiYWNrID1cbmZ1bmN0aW9uKHJlYXNvbiwgc3luY2hyb25vdXMsIGlnbm9yZU5vbkVycm9yV2FybmluZ3MpIHtcbiAgICB2YXIgdHJhY2UgPSB1dGlsLmVuc3VyZUVycm9yT2JqZWN0KHJlYXNvbik7XG4gICAgdmFyIGhhc1N0YWNrID0gdHJhY2UgPT09IHJlYXNvbjtcbiAgICBpZiAoIWhhc1N0YWNrICYmICFpZ25vcmVOb25FcnJvcldhcm5pbmdzICYmIGRlYnVnLndhcm5pbmdzKCkpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcImEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIG5vbi1lcnJvcjogXCIgK1xuICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhyZWFzb24pO1xuICAgICAgICB0aGlzLl93YXJuKG1lc3NhZ2UsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLl9hdHRhY2hFeHRyYVRyYWNlKHRyYWNlLCBzeW5jaHJvbm91cyA/IGhhc1N0YWNrIDogZmFsc2UpO1xuICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Jlc29sdmVGcm9tRXhlY3V0b3IgPSBmdW5jdGlvbiAoZXhlY3V0b3IpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdGhpcy5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHIgPSB0aGlzLl9leGVjdXRlKGV4ZWN1dG9yLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cyk7XG4gICAgfSk7XG4gICAgc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICB0aGlzLl9wb3BDb250ZXh0KCk7XG5cbiAgICBpZiAociAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHIsIHRydWUpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIgPSBmdW5jdGlvbiAoXG4gICAgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlXG4pIHtcbiAgICB2YXIgYml0RmllbGQgPSBwcm9taXNlLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDY1NTM2KSAhPT0gMCkpIHJldHVybjtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciB4O1xuICAgIGlmIChyZWNlaXZlciA9PT0gQVBQTFkpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB4ID0gZXJyb3JPYmo7XG4gICAgICAgICAgICB4LmUgPSBuZXcgVHlwZUVycm9yKFwiY2Fubm90IC5zcHJlYWQoKSBhIG5vbi1hcnJheTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmFwcGx5KHRoaXMuX2JvdW5kVmFsdWUoKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIGJpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSByZXR1cm47XG5cbiAgICBpZiAoeCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHggPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHguZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyh4LCBwcm9taXNlQ3JlYXRlZCwgXCJcIiwgIHByb21pc2UsIHRoaXMpO1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2soeCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3RhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB0aGlzO1xuICAgIHdoaWxlIChyZXQuX2lzRm9sbG93aW5nKCkpIHJldCA9IHJldC5fZm9sbG93ZWUoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZvbGxvd2VlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2VlID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlID0gZnVuY3Rpb24ocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKSB7XG4gICAgdmFyIGlzUHJvbWlzZSA9IHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIHZhciBhc3luY0d1YXJhbnRlZWQgPSAoKGJpdEZpZWxkICYgMTM0MjE3NzI4KSAhPT0gMCk7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UpIHByb21pc2UuX2ludm9rZUludGVybmFsT25DYW5jZWwoKTtcblxuICAgICAgICBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0ICYmXG4gICAgICAgICAgICByZWNlaXZlci5pc0ZpbmFsbHlIYW5kbGVyKCkpIHtcbiAgICAgICAgICAgIHJlY2VpdmVyLmNhbmNlbFByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3QoZXJyb3JPYmouZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9PT0gcmVmbGVjdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwocmVmbGVjdEhhbmRsZXIuY2FsbChyZWNlaXZlcikpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJveHlhYmxlKSB7XG4gICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZUNhbmNlbGxlZChwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UgfHwgcHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2VBcnJheSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzUHJvbWlzZSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFByb3h5YWJsZSkge1xuICAgICAgICBpZiAoIXJlY2VpdmVyLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VSZWplY3RlZCh2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciBoYW5kbGVyID0gY3R4LmhhbmRsZXI7XG4gICAgdmFyIHByb21pc2UgPSBjdHgucHJvbWlzZTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBjdHgucmVjZWl2ZXI7XG4gICAgdmFyIHZhbHVlID0gY3R4LnZhbHVlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIoaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUN0eCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UoY3R4LnByb21pc2UsIGN0eC5oYW5kbGVyLCBjdHgucmVjZWl2ZXIsIGN0eC52YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZTAgPSBmdW5jdGlvbihoYW5kbGVyLCB2YWx1ZSwgYml0RmllbGQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UwO1xuICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoMCk7XG4gICAgdGhpcy5fcHJvbWlzZTAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVjZWl2ZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHZhciBiYXNlID0gaW5kZXggKiA0IC0gNDtcbiAgICB0aGlzW2Jhc2UgKyAyXSA9XG4gICAgdGhpc1tiYXNlICsgM10gPVxuICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICB0aGlzW2Jhc2UgKyAxXSA9IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiAxMTc1MDYwNDgpID4+PiAxNikpIHJldHVybjtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMpIHtcbiAgICAgICAgdmFyIGVyciA9IG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdChlcnIpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRGdWxmaWxsZWQoKTtcbiAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHZhbHVlO1xuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAxMzQyMTc3MjgpICE9PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLnNldHRsZVByb21pc2VzKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDExNzUwNjA0OCkgPj4+IDE2KSkgcmV0dXJuO1xuICAgIHRoaXMuX3NldFJlamVjdGVkKCk7XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHJlYXNvbjtcblxuICAgIGlmICh0aGlzLl9pc0ZpbmFsKCkpIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLmZhdGFsRXJyb3IocmVhc29uLCB1dGlsLmlzTm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgYXN5bmMuc2V0dGxlUHJvbWlzZXModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxQcm9taXNlcyA9IGZ1bmN0aW9uIChsZW4sIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlckF0KGkpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2VBdChpKTtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdChpKTtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4KGkpO1xuICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdFByb21pc2VzID0gZnVuY3Rpb24gKGxlbiwgcmVhc29uKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX3JlamVjdGlvbkhhbmRsZXJBdChpKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlQXQoaSk7XG4gICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoaSk7XG4gICAgICAgIHRoaXMuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleChpKTtcbiAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZShwcm9taXNlLCBoYW5kbGVyLCByZWNlaXZlciwgcmVhc29uKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgdmFyIGxlbiA9IChiaXRGaWVsZCAmIDY1NTM1KTtcblxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMTY4NDI3NTIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlMCh0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCwgcmVhc29uLCBiaXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3RQcm9taXNlcyhsZW4sIHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UwKHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAsIHZhbHVlLCBiaXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsUHJvbWlzZXMobGVuLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZGVmZXJSZXNvbHZlKHYpIHt0aGlzLnByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2KTt9XG5mdW5jdGlvbiBkZWZlclJlamVjdCh2KSB7dGhpcy5wcm9taXNlLl9yZWplY3RDYWxsYmFjayh2LCBmYWxzZSk7fVxuXG5Qcm9taXNlLmRlZmVyID0gUHJvbWlzZS5wZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIlByb21pc2UuZGVmZXJcIiwgXCJuZXcgUHJvbWlzZVwiKTtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICByZXNvbHZlOiBkZWZlclJlc29sdmUsXG4gICAgICAgIHJlamVjdDogZGVmZXJSZWplY3RcbiAgICB9O1xufTtcblxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICBcIl9tYWtlU2VsZlJlc29sdXRpb25FcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICBtYWtlU2VsZlJlc29sdXRpb25FcnJvcik7XG5cbl9kZXJlcV8oXCIuL21ldGhvZFwiKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLFxuICAgIGRlYnVnKTtcbl9kZXJlcV8oXCIuL2JpbmRcIikoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGRlYnVnKTtcbl9kZXJlcV8oXCIuL2NhbmNlbFwiKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgZGVidWcpO1xuX2RlcmVxXyhcIi4vZGlyZWN0X3Jlc29sdmVcIikoUHJvbWlzZSk7XG5fZGVyZXFfKFwiLi9zeW5jaHJvbm91c19pbnNwZWN0aW9uXCIpKFByb21pc2UpO1xuX2RlcmVxXyhcIi4vam9pblwiKShcbiAgICBQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBhc3luYywgZ2V0RG9tYWluKTtcblByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5Qcm9taXNlLnZlcnNpb24gPSBcIjMuNC42XCI7XG5fZGVyZXFfKCcuL21hcC5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpO1xuX2RlcmVxXygnLi9jYWxsX2dldC5qcycpKFByb21pc2UpO1xuX2RlcmVxXygnLi91c2luZy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgY3JlYXRlQ29udGV4dCwgSU5URVJOQUwsIGRlYnVnKTtcbl9kZXJlcV8oJy4vdGltZXJzLmpzJykoUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKTtcbl9kZXJlcV8oJy4vZ2VuZXJhdG9ycy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIFByb3h5YWJsZSwgZGVidWcpO1xuX2RlcmVxXygnLi9ub2RlaWZ5LmpzJykoUHJvbWlzZSk7XG5fZGVyZXFfKCcuL3Byb21pc2lmeS5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbl9kZXJlcV8oJy4vcHJvcHMuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG5fZGVyZXFfKCcuL3JhY2UuanMnKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKTtcbl9kZXJlcV8oJy4vcmVkdWNlLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBkZWJ1Zyk7XG5fZGVyZXFfKCcuL3NldHRsZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgZGVidWcpO1xuX2RlcmVxXygnLi9zb21lLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pO1xuX2RlcmVxXygnLi9maWx0ZXIuanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5fZGVyZXFfKCcuL2VhY2guanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5fZGVyZXFfKCcuL2FueS5qcycpKFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKFByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhQcm9taXNlLnByb3RvdHlwZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmdW5jdGlvbiBmaWxsVHlwZXModmFsdWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBwID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcmVqZWN0aW9uSGFuZGxlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3Byb21pc2UwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9yZWNlaXZlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgLy8gQ29tcGxldGUgc2xhY2sgdHJhY2tpbmcsIG9wdCBvdXQgb2YgZmllbGQtdHlwZSB0cmFja2luZyBhbmQgICAgICAgICAgIFxuICAgIC8vIHN0YWJpbGl6ZSBtYXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoe2E6IDF9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHtiOiAyfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh7YzogM30pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKGZ1bmN0aW9uKCl7fSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh1bmRlZmluZWQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKG5ldyBQcm9taXNlKElOVEVSTkFMKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGRlYnVnLnNldEJvdW5kcyhBc3luYy5maXJzdExpbmVFcnJvciwgdXRpbC5sYXN0TGluZUVycm9yKTsgICAgICAgICAgICAgICBcbiAgICByZXR1cm4gUHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbn07XG5cbn0se1wiLi9hbnkuanNcIjoxLFwiLi9hc3luY1wiOjIsXCIuL2JpbmRcIjozLFwiLi9jYWxsX2dldC5qc1wiOjUsXCIuL2NhbmNlbFwiOjYsXCIuL2NhdGNoX2ZpbHRlclwiOjcsXCIuL2NvbnRleHRcIjo4LFwiLi9kZWJ1Z2dhYmlsaXR5XCI6OSxcIi4vZGlyZWN0X3Jlc29sdmVcIjoxMCxcIi4vZWFjaC5qc1wiOjExLFwiLi9lcnJvcnNcIjoxMixcIi4vZXM1XCI6MTMsXCIuL2ZpbHRlci5qc1wiOjE0LFwiLi9maW5hbGx5XCI6MTUsXCIuL2dlbmVyYXRvcnMuanNcIjoxNixcIi4vam9pblwiOjE3LFwiLi9tYXAuanNcIjoxOCxcIi4vbWV0aG9kXCI6MTksXCIuL25vZGViYWNrXCI6MjAsXCIuL25vZGVpZnkuanNcIjoyMSxcIi4vcHJvbWlzZV9hcnJheVwiOjIzLFwiLi9wcm9taXNpZnkuanNcIjoyNCxcIi4vcHJvcHMuanNcIjoyNSxcIi4vcmFjZS5qc1wiOjI3LFwiLi9yZWR1Y2UuanNcIjoyOCxcIi4vc2V0dGxlLmpzXCI6MzAsXCIuL3NvbWUuanNcIjozMSxcIi4vc3luY2hyb25vdXNfaW5zcGVjdGlvblwiOjMyLFwiLi90aGVuYWJsZXNcIjozMyxcIi4vdGltZXJzLmpzXCI6MzQsXCIuL3VzaW5nLmpzXCI6MzUsXCIuL3V0aWxcIjozNn1dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICBhcGlSZWplY3Rpb24sIFByb3h5YWJsZSkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG5cbmZ1bmN0aW9uIHRvUmVzb2x1dGlvblZhbHVlKHZhbCkge1xuICAgIHN3aXRjaCh2YWwpIHtcbiAgICBjYXNlIC0yOiByZXR1cm4gW107XG4gICAgY2FzZSAtMzogcmV0dXJuIHt9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlLl9wcm9wYWdhdGVGcm9tKHZhbHVlcywgMyk7XG4gICAgfVxuICAgIHByb21pc2UuX3NldE9uQ2FuY2VsKHRoaXMpO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX3RvdGFsUmVzb2x2ZWQgPSAwO1xuICAgIHRoaXMuX2luaXQodW5kZWZpbmVkLCAtMik7XG59XG51dGlsLmluaGVyaXRzKFByb21pc2VBcnJheSwgUHJveHlhYmxlKTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KF8sIHJlc29sdmVWYWx1ZUlmRW1wdHkpIHtcbiAgICB2YXIgdmFsdWVzID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzLl92YWx1ZXMsIHRoaXMuX3Byb21pc2UpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5fdGFyZ2V0KCk7XG4gICAgICAgIHZhciBiaXRGaWVsZCA9IHZhbHVlcy5fYml0RmllbGQ7XG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuXG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzLl90aGVuKFxuICAgICAgICAgICAgICAgIGluaXQsXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0LFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVWYWx1ZUlmRW1wdHlcbiAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLl92YWx1ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0KHZhbHVlcy5fcmVhc29uKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbHVlcyA9IHV0aWwuYXNBcnJheSh2YWx1ZXMpO1xuICAgIGlmICh2YWx1ZXMgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGVyciA9IGFwaVJlamVjdGlvbihcbiAgICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIGFycmF5IG9yIGFuIGl0ZXJhYmxlIG9iamVjdCBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyh2YWx1ZXMpKS5yZWFzb24oKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2soZXJyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAocmVzb2x2ZVZhbHVlSWZFbXB0eSA9PT0gLTUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eUFycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRvUmVzb2x1dGlvblZhbHVlKHJlc29sdmVWYWx1ZUlmRW1wdHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2l0ZXJhdGUodmFsdWVzKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2l0ZXJhdGUgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5nZXRBY3R1YWxMZW5ndGgodmFsdWVzLmxlbmd0aCk7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHRoaXMuc2hvdWxkQ29weVZhbHVlcygpID8gbmV3IEFycmF5KGxlbikgOiB0aGlzLl92YWx1ZXM7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX3Byb21pc2U7XG4gICAgdmFyIGlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB2YXIgYml0RmllbGQgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodmFsdWVzW2ldLCByZXN1bHQpO1xuXG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYml0RmllbGQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlmIChiaXRGaWVsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChiaXRGaWVsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCBpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaV0gPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VGdWxmaWxsZWQobWF5YmVQcm9taXNlLl92YWx1ZSgpLCBpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZVJlamVjdGVkKG1heWJlUHJvbWlzZS5fcmVhc29uKCksIGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZUNhbmNlbGxlZChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKG1heWJlUHJvbWlzZSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1Jlc29sdmVkKSByZXN1bHQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXNSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVzID09PSBudWxsO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpIHx8ICF0aGlzLl9wcm9taXNlLl9pc0NhbmNlbGxhYmxlKCkpIHJldHVybjtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX2NhbmNlbCgpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBmYWxzZSk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3RvdGFsUmVzb2x2ZWQrKztcbiAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhbHVlcy5jYW5jZWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1tpXSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0uY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLmdldEFjdHVhbExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICByZXR1cm4gbGVuO1xufTtcblxucmV0dXJuIFByb21pc2VBcnJheTtcbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciBUSElTID0ge307XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgbm9kZWJhY2tGb3JQcm9taXNlID0gX2RlcmVxXyhcIi4vbm9kZWJhY2tcIik7XG52YXIgd2l0aEFwcGVuZGVkID0gdXRpbC53aXRoQXBwZW5kZWQ7XG52YXIgbWF5YmVXcmFwQXNFcnJvciA9IHV0aWwubWF5YmVXcmFwQXNFcnJvcjtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgVHlwZUVycm9yID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpLlR5cGVFcnJvcjtcbnZhciBkZWZhdWx0U3VmZml4ID0gXCJBc3luY1wiO1xudmFyIGRlZmF1bHRQcm9taXNpZmllZCA9IHtfX2lzUHJvbWlzaWZpZWRfXzogdHJ1ZX07XG52YXIgbm9Db3B5UHJvcHMgPSBbXG4gICAgXCJhcml0eVwiLCAgICBcImxlbmd0aFwiLFxuICAgIFwibmFtZVwiLFxuICAgIFwiYXJndW1lbnRzXCIsXG4gICAgXCJjYWxsZXJcIixcbiAgICBcImNhbGxlZVwiLFxuICAgIFwicHJvdG90eXBlXCIsXG4gICAgXCJfX2lzUHJvbWlzaWZpZWRfX1wiXG5dO1xudmFyIG5vQ29weVByb3BzUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeKD86XCIgKyBub0NvcHlQcm9wcy5qb2luKFwifFwiKSArIFwiKSRcIik7XG5cbnZhciBkZWZhdWx0RmlsdGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB1dGlsLmlzSWRlbnRpZmllcihuYW1lKSAmJlxuICAgICAgICBuYW1lLmNoYXJBdCgwKSAhPT0gXCJfXCIgJiZcbiAgICAgICAgbmFtZSAhPT0gXCJjb25zdHJ1Y3RvclwiO1xufTtcblxuZnVuY3Rpb24gcHJvcHNGaWx0ZXIoa2V5KSB7XG4gICAgcmV0dXJuICFub0NvcHlQcm9wc1BhdHRlcm4udGVzdChrZXkpO1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2lmaWVkKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuLl9faXNQcm9taXNpZmllZF9fID09PSB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNQcm9taXNpZmllZChvYmosIGtleSwgc3VmZml4KSB7XG4gICAgdmFyIHZhbCA9IHV0aWwuZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0KG9iaiwga2V5ICsgc3VmZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvbWlzaWZpZWQpO1xuICAgIHJldHVybiB2YWwgPyBpc1Byb21pc2lmaWVkKHZhbCkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsaWQocmV0LCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXRbaV07XG4gICAgICAgIGlmIChzdWZmaXhSZWdleHAudGVzdChrZXkpKSB7XG4gICAgICAgICAgICB2YXIga2V5V2l0aG91dEFzeW5jU3VmZml4ID0ga2V5LnJlcGxhY2Uoc3VmZml4UmVnZXhwLCBcIlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmV0Lmxlbmd0aDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldFtqXSA9PT0ga2V5V2l0aG91dEFzeW5jU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcHJvbWlzaWZ5IGFuIEFQSSB0aGF0IGhhcyBub3JtYWwgbWV0aG9kcyB3aXRoICclcyctc3VmZml4XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIiVzXCIsIHN1ZmZpeCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZpYWJsZU1ldGhvZHMob2JqLCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCwgZmlsdGVyKSB7XG4gICAgdmFyIGtleXMgPSB1dGlsLmluaGVyaXRlZERhdGFLZXlzKG9iaik7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIHZhciBwYXNzZXNEZWZhdWx0RmlsdGVyID0gZmlsdGVyID09PSBkZWZhdWx0RmlsdGVyXG4gICAgICAgICAgICA/IHRydWUgOiBkZWZhdWx0RmlsdGVyKGtleSwgdmFsdWUsIG9iaik7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgIWlzUHJvbWlzaWZpZWQodmFsdWUpICYmXG4gICAgICAgICAgICAhaGFzUHJvbWlzaWZpZWQob2JqLCBrZXksIHN1ZmZpeCkgJiZcbiAgICAgICAgICAgIGZpbHRlcihrZXksIHZhbHVlLCBvYmosIHBhc3Nlc0RlZmF1bHRGaWx0ZXIpKSB7XG4gICAgICAgICAgICByZXQucHVzaChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1ZhbGlkKHJldCwgc3VmZml4LCBzdWZmaXhSZWdleHApO1xuICAgIHJldHVybiByZXQ7XG59XG5cbnZhciBlc2NhcGVJZGVudFJlZ2V4ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWyRdKS8sIFwiXFxcXCRcIik7XG59O1xuXG52YXIgbWFrZU5vZGVQcm9taXNpZmllZEV2YWw7XG5pZiAoIXRydWUpIHtcbnZhciBzd2l0Y2hDYXNlQXJndW1lbnRPcmRlciA9IGZ1bmN0aW9uKGxpa2VseUFyZ3VtZW50Q291bnQpIHtcbiAgICB2YXIgcmV0ID0gW2xpa2VseUFyZ3VtZW50Q291bnRdO1xuICAgIHZhciBtaW4gPSBNYXRoLm1heCgwLCBsaWtlbHlBcmd1bWVudENvdW50IC0gMSAtIDMpO1xuICAgIGZvcih2YXIgaSA9IGxpa2VseUFyZ3VtZW50Q291bnQgLSAxOyBpID49IG1pbjsgLS1pKSB7XG4gICAgICAgIHJldC5wdXNoKGkpO1xuICAgIH1cbiAgICBmb3IodmFyIGkgPSBsaWtlbHlBcmd1bWVudENvdW50ICsgMTsgaSA8PSAzOyArK2kpIHtcbiAgICAgICAgcmV0LnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG52YXIgYXJndW1lbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uKGFyZ3VtZW50Q291bnQpIHtcbiAgICByZXR1cm4gdXRpbC5maWxsZWRSYW5nZShhcmd1bWVudENvdW50LCBcIl9hcmdcIiwgXCJcIik7XG59O1xuXG52YXIgcGFyYW1ldGVyRGVjbGFyYXRpb24gPSBmdW5jdGlvbihwYXJhbWV0ZXJDb3VudCkge1xuICAgIHJldHVybiB1dGlsLmZpbGxlZFJhbmdlKFxuICAgICAgICBNYXRoLm1heChwYXJhbWV0ZXJDb3VudCwgMyksIFwiX2FyZ1wiLCBcIlwiKTtcbn07XG5cbnZhciBwYXJhbWV0ZXJDb3VudCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbi5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGZuLmxlbmd0aCwgMTAyMyArIDEpLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuXG5tYWtlTm9kZVByb21pc2lmaWVkRXZhbCA9XG5mdW5jdGlvbihjYWxsYmFjaywgcmVjZWl2ZXIsIG9yaWdpbmFsTmFtZSwgZm4sIF8sIG11bHRpQXJncykge1xuICAgIHZhciBuZXdQYXJhbWV0ZXJDb3VudCA9IE1hdGgubWF4KDAsIHBhcmFtZXRlckNvdW50KGZuKSAtIDEpO1xuICAgIHZhciBhcmd1bWVudE9yZGVyID0gc3dpdGNoQ2FzZUFyZ3VtZW50T3JkZXIobmV3UGFyYW1ldGVyQ291bnQpO1xuICAgIHZhciBzaG91bGRQcm94eVRoaXMgPSB0eXBlb2YgY2FsbGJhY2sgPT09IFwic3RyaW5nXCIgfHwgcmVjZWl2ZXIgPT09IFRISVM7XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNhbGxGb3JBcmd1bWVudENvdW50KGNvdW50KSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRTZXF1ZW5jZShjb3VudCkuam9pbihcIiwgXCIpO1xuICAgICAgICB2YXIgY29tbWEgPSBjb3VudCA+IDAgPyBcIiwgXCIgOiBcIlwiO1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBpZiAoc2hvdWxkUHJveHlUaGlzKSB7XG4gICAgICAgICAgICByZXQgPSBcInJldCA9IGNhbGxiYWNrLmNhbGwodGhpcywge3thcmdzfX0sIG5vZGViYWNrKTsgYnJlYWs7XFxuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSByZWNlaXZlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBcInJldCA9IGNhbGxiYWNrKHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiXG4gICAgICAgICAgICAgICAgOiBcInJldCA9IGNhbGxiYWNrLmNhbGwocmVjZWl2ZXIsIHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQucmVwbGFjZShcInt7YXJnc319XCIsIGFyZ3MpLnJlcGxhY2UoXCIsIFwiLCBjb21tYSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVBcmd1bWVudFN3aXRjaENhc2UoKSB7XG4gICAgICAgIHZhciByZXQgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50T3JkZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJldCArPSBcImNhc2UgXCIgKyBhcmd1bWVudE9yZGVyW2ldICtcIjpcIiArXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVDYWxsRm9yQXJndW1lbnRDb3VudChhcmd1bWVudE9yZGVyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCArPSBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBkZWZhdWx0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGkgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgYXJnc1tpXSA9IG5vZGViYWNrOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW0NvZGVGb3JDYWxsXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKFwiW0NvZGVGb3JDYWxsXVwiLCAoc2hvdWxkUHJveHlUaGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJyZXQgPSBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcXG5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwicmV0ID0gY2FsbGJhY2suYXBwbHkocmVjZWl2ZXIsIGFyZ3MpO1xcblwiKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdmFyIGdldEZ1bmN0aW9uQ29kZSA9IHR5cGVvZiBjYWxsYmFjayA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChcInRoaXMgIT0gbnVsbCA/IHRoaXNbJ1wiK2NhbGxiYWNrK1wiJ10gOiBmblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiZm5cIjtcbiAgICB2YXIgYm9keSA9IFwiJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHZhciByZXQgPSBmdW5jdGlvbiAoUGFyYW1ldGVycykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgbm9kZWJhY2sgPSBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSwgXCIgKyBtdWx0aUFyZ3MgKyBcIik7ICAgXFxuXFxcbiAgICAgICAgICAgIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHRyeUNhdGNoKFtHZXRGdW5jdGlvbkNvZGVdKTsgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHN3aXRjaChsZW4pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBbQ29kZUZvclN3aXRjaENhc2VdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhtYXliZVdyYXBBc0Vycm9yKHJldC5lKSwgdHJ1ZSwgdHJ1ZSk7XFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGlmICghcHJvbWlzZS5faXNGYXRlU2VhbGVkKCkpIHByb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpOyAgICAgXFxuXFxcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AocmV0LCAnX19pc1Byb21pc2lmaWVkX18nLCB0cnVlKTsgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgcmV0dXJuIHJldDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICBcIi5yZXBsYWNlKFwiW0NvZGVGb3JTd2l0Y2hDYXNlXVwiLCBnZW5lcmF0ZUFyZ3VtZW50U3dpdGNoQ2FzZSgpKVxuICAgICAgICAucmVwbGFjZShcIltHZXRGdW5jdGlvbkNvZGVdXCIsIGdldEZ1bmN0aW9uQ29kZSk7XG4gICAgYm9keSA9IGJvZHkucmVwbGFjZShcIlBhcmFtZXRlcnNcIiwgcGFyYW1ldGVyRGVjbGFyYXRpb24obmV3UGFyYW1ldGVyQ291bnQpKTtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiUHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWNlaXZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aXRoQXBwZW5kZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWF5YmVXcmFwQXNFcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJub2RlYmFja0ZvclByb21pc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHJ5Q2F0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXJyb3JPYmpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibm90RW51bWVyYWJsZVByb3BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiSU5URVJOQUxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkpKFxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBmbixcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXIsXG4gICAgICAgICAgICAgICAgICAgIHdpdGhBcHBlbmRlZCxcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVXcmFwQXNFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgbm9kZWJhY2tGb3JQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICB1dGlsLnRyeUNhdGNoLFxuICAgICAgICAgICAgICAgICAgICB1dGlsLmVycm9yT2JqLFxuICAgICAgICAgICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wLFxuICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCk7XG59O1xufVxuXG5mdW5jdGlvbiBtYWtlTm9kZVByb21pc2lmaWVkQ2xvc3VyZShjYWxsYmFjaywgcmVjZWl2ZXIsIF8sIGZuLCBfXywgbXVsdGlBcmdzKSB7XG4gICAgdmFyIGRlZmF1bHRUaGlzID0gKGZ1bmN0aW9uKCkge3JldHVybiB0aGlzO30pKCk7XG4gICAgdmFyIG1ldGhvZCA9IGNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb21pc2lmaWVkKCkge1xuICAgICAgICB2YXIgX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gVEhJUykgX3JlY2VpdmVyID0gdGhpcztcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHZhciBjYiA9IHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIgJiYgdGhpcyAhPT0gZGVmYXVsdFRoaXNcbiAgICAgICAgICAgID8gdGhpc1ttZXRob2RdIDogY2FsbGJhY2s7XG4gICAgICAgIHZhciBmbiA9IG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlLCBtdWx0aUFyZ3MpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2IuYXBwbHkoX3JlY2VpdmVyLCB3aXRoQXBwZW5kZWQoYXJndW1lbnRzLCBmbikpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKG1heWJlV3JhcEFzRXJyb3IoZSksIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvbWlzZS5faXNGYXRlU2VhbGVkKCkpIHByb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChwcm9taXNpZmllZCwgXCJfX2lzUHJvbWlzaWZpZWRfX1wiLCB0cnVlKTtcbiAgICByZXR1cm4gcHJvbWlzaWZpZWQ7XG59XG5cbnZhciBtYWtlTm9kZVByb21pc2lmaWVkID0gY2FuRXZhbHVhdGVcbiAgICA/IG1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsXG4gICAgOiBtYWtlTm9kZVByb21pc2lmaWVkQ2xvc3VyZTtcblxuZnVuY3Rpb24gcHJvbWlzaWZ5QWxsKG9iaiwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLCBtdWx0aUFyZ3MpIHtcbiAgICB2YXIgc3VmZml4UmVnZXhwID0gbmV3IFJlZ0V4cChlc2NhcGVJZGVudFJlZ2V4KHN1ZmZpeCkgKyBcIiRcIik7XG4gICAgdmFyIG1ldGhvZHMgPVxuICAgICAgICBwcm9taXNpZmlhYmxlTWV0aG9kcyhvYmosIHN1ZmZpeCwgc3VmZml4UmVnZXhwLCBmaWx0ZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuOyBpKz0gMikge1xuICAgICAgICB2YXIga2V5ID0gbWV0aG9kc1tpXTtcbiAgICAgICAgdmFyIGZuID0gbWV0aG9kc1tpKzFdO1xuICAgICAgICB2YXIgcHJvbWlzaWZpZWRLZXkgPSBrZXkgKyBzdWZmaXg7XG4gICAgICAgIGlmIChwcm9taXNpZmllciA9PT0gbWFrZU5vZGVQcm9taXNpZmllZCkge1xuICAgICAgICAgICAgb2JqW3Byb21pc2lmaWVkS2V5XSA9XG4gICAgICAgICAgICAgICAgbWFrZU5vZGVQcm9taXNpZmllZChrZXksIFRISVMsIGtleSwgZm4sIHN1ZmZpeCwgbXVsdGlBcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNpZmllZCA9IHByb21pc2lmaWVyKGZuLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU5vZGVQcm9taXNpZmllZChrZXksIFRISVMsIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiwgc3VmZml4LCBtdWx0aUFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKHByb21pc2lmaWVkLCBcIl9faXNQcm9taXNpZmllZF9fXCIsIHRydWUpO1xuICAgICAgICAgICAgb2JqW3Byb21pc2lmaWVkS2V5XSA9IHByb21pc2lmaWVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhvYmopO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHByb21pc2lmeShjYWxsYmFjaywgcmVjZWl2ZXIsIG11bHRpQXJncykge1xuICAgIHJldHVybiBtYWtlTm9kZVByb21pc2lmaWVkKGNhbGxiYWNrLCByZWNlaXZlciwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaywgbnVsbCwgbXVsdGlBcmdzKTtcbn1cblxuUHJvbWlzZS5wcm9taXNpZnkgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIGlmIChpc1Byb21pc2lmaWVkKGZuKSkge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIG9wdGlvbnMgPSBPYmplY3Qob3B0aW9ucyk7XG4gICAgdmFyIHJlY2VpdmVyID0gb3B0aW9ucy5jb250ZXh0ID09PSB1bmRlZmluZWQgPyBUSElTIDogb3B0aW9ucy5jb250ZXh0O1xuICAgIHZhciBtdWx0aUFyZ3MgPSAhIW9wdGlvbnMubXVsdGlBcmdzO1xuICAgIHZhciByZXQgPSBwcm9taXNpZnkoZm4sIHJlY2VpdmVyLCBtdWx0aUFyZ3MpO1xuICAgIHV0aWwuY29weURlc2NyaXB0b3JzKGZuLCByZXQsIHByb3BzRmlsdGVyKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm9taXNpZnlBbGwgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGUgdGFyZ2V0IG9mIHByb21pc2lmeUFsbCBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdChvcHRpb25zKTtcbiAgICB2YXIgbXVsdGlBcmdzID0gISFvcHRpb25zLm11bHRpQXJncztcbiAgICB2YXIgc3VmZml4ID0gb3B0aW9ucy5zdWZmaXg7XG4gICAgaWYgKHR5cGVvZiBzdWZmaXggIT09IFwic3RyaW5nXCIpIHN1ZmZpeCA9IGRlZmF1bHRTdWZmaXg7XG4gICAgdmFyIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgdmFyIHByb21pc2lmaWVyID0gb3B0aW9ucy5wcm9taXNpZmllcjtcbiAgICBpZiAodHlwZW9mIHByb21pc2lmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHByb21pc2lmaWVyID0gbWFrZU5vZGVQcm9taXNpZmllZDtcblxuICAgIGlmICghdXRpbC5pc0lkZW50aWZpZXIoc3VmZml4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInN1ZmZpeCBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSB1dGlsLmluaGVyaXRlZERhdGFLZXlzKHRhcmdldCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRhcmdldFtrZXlzW2ldXTtcbiAgICAgICAgaWYgKGtleXNbaV0gIT09IFwiY29uc3RydWN0b3JcIiAmJlxuICAgICAgICAgICAgdXRpbC5pc0NsYXNzKHZhbHVlKSkge1xuICAgICAgICAgICAgcHJvbWlzaWZ5QWxsKHZhbHVlLnByb3RvdHlwZSwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLFxuICAgICAgICAgICAgICAgIG11bHRpQXJncyk7XG4gICAgICAgICAgICBwcm9taXNpZnlBbGwodmFsdWUsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllciwgbXVsdGlBcmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNpZnlBbGwodGFyZ2V0LCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsIG11bHRpQXJncyk7XG59O1xufTtcblxuXG59LHtcIi4vZXJyb3JzXCI6MTIsXCIuL25vZGViYWNrXCI6MjAsXCIuL3V0aWxcIjozNn1dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihcbiAgICBQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbikge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcbnZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG52YXIgRXM2TWFwO1xuaWYgKHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIikgRXM2TWFwID0gTWFwO1xuXG52YXIgbWFwVG9FbnRyaWVzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNpemUgPSAwO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEVudHJ5KHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdGhpc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpc1tpbmRleCArIHNpemVdID0ga2V5O1xuICAgICAgICBpbmRleCsrO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBtYXBUb0VudHJpZXMobWFwKSB7XG4gICAgICAgIHNpemUgPSBtYXAuc2l6ZTtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB2YXIgcmV0ID0gbmV3IEFycmF5KG1hcC5zaXplICogMik7XG4gICAgICAgIG1hcC5mb3JFYWNoKGV4dHJhY3RFbnRyeSwgcmV0KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufSkoKTtcblxudmFyIGVudHJpZXNUb01hcCA9IGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICB2YXIgcmV0ID0gbmV3IEVzNk1hcCgpO1xuICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aCAvIDIgfCAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGVudHJpZXNbbGVuZ3RoICsgaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGVudHJpZXNbaV07XG4gICAgICAgIHJldC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBQcm9wZXJ0aWVzUHJvbWlzZUFycmF5KG9iaikge1xuICAgIHZhciBpc01hcCA9IGZhbHNlO1xuICAgIHZhciBlbnRyaWVzO1xuICAgIGlmIChFczZNYXAgIT09IHVuZGVmaW5lZCAmJiBvYmogaW5zdGFuY2VvZiBFczZNYXApIHtcbiAgICAgICAgZW50cmllcyA9IG1hcFRvRW50cmllcyhvYmopO1xuICAgICAgICBpc01hcCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBlczUua2V5cyhvYmopO1xuICAgICAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGVudHJpZXMgPSBuZXcgQXJyYXkobGVuICogMik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgZW50cmllc1tpXSA9IG9ialtrZXldO1xuICAgICAgICAgICAgZW50cmllc1tpICsgbGVuXSA9IGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnN0cnVjdG9yJChlbnRyaWVzKTtcbiAgICB0aGlzLl9pc01hcCA9IGlzTWFwO1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTMpO1xufVxudXRpbC5pbmhlcml0cyhQcm9wZXJ0aWVzUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIGlmICh0aGlzLl9pc01hcCkge1xuICAgICAgICAgICAgdmFsID0gZW50cmllc1RvTWFwKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSB7fTtcbiAgICAgICAgICAgIHZhciBrZXlPZmZzZXQgPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoKCk7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhbFt0aGlzLl92YWx1ZXNbaSArIGtleU9mZnNldF1dID0gdGhpcy5fdmFsdWVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodmFsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgIHJldHVybiBsZW4gPj4gMTtcbn07XG5cbmZ1bmN0aW9uIHByb3BzKHByb21pc2VzKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgY2FzdFZhbHVlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcyk7XG5cbiAgICBpZiAoIWlzT2JqZWN0KGNhc3RWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImNhbm5vdCBhd2FpdCBwcm9wZXJ0aWVzIG9mIGEgbm9uLW9iamVjdFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfSBlbHNlIGlmIChjYXN0VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldCA9IGNhc3RWYWx1ZS5fdGhlbihcbiAgICAgICAgICAgIFByb21pc2UucHJvcHMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb3BlcnRpZXNQcm9taXNlQXJyYXkoY2FzdFZhbHVlKS5wcm9taXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKGNhc3RWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0Ll9wcm9wYWdhdGVGcm9tKGNhc3RWYWx1ZSwgMik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblByb21pc2UucHJvdG90eXBlLnByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9wcyh0aGlzKTtcbn07XG5cblByb21pc2UucHJvcHMgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gcHJvcHMocHJvbWlzZXMpO1xufTtcbn07XG5cbn0se1wiLi9lczVcIjoxMyxcIi4vdXRpbFwiOjM2fV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBhcnJheU1vdmUoc3JjLCBzcmNJbmRleCwgZHN0LCBkc3RJbmRleCwgbGVuKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgICBkc3RbaiArIGRzdEluZGV4XSA9IHNyY1tqICsgc3JjSW5kZXhdO1xuICAgICAgICBzcmNbaiArIHNyY0luZGV4XSA9IHZvaWQgMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFF1ZXVlKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX2Zyb250ID0gMDtcbn1cblxuUXVldWUucHJvdG90eXBlLl93aWxsQmVPdmVyQ2FwYWNpdHkgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhY2l0eSA8IHNpemU7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3B1c2hPbmUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGggKyAxKTtcbiAgICB2YXIgaSA9ICh0aGlzLl9mcm9udCArIGxlbmd0aCkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzW2ldID0gYXJnO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aCArIDE7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3Vuc2hpZnRPbmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBjYXBhY2l0eSA9IHRoaXMuX2NhcGFjaXR5O1xuICAgIHRoaXMuX2NoZWNrQ2FwYWNpdHkodGhpcy5sZW5ndGgoKSArIDEpO1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIHZhciBpID0gKCgoKCBmcm9udCAtIDEgKSAmXG4gICAgICAgICAgICAgICAgICAgICggY2FwYWNpdHkgLSAxKSApIF4gY2FwYWNpdHkgKSAtIGNhcGFjaXR5ICk7XG4gICAgdGhpc1tpXSA9IHZhbHVlO1xuICAgIHRoaXMuX2Zyb250ID0gaTtcbiAgICB0aGlzLl9sZW5ndGggPSB0aGlzLmxlbmd0aCgpICsgMTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB0aGlzLl91bnNoaWZ0T25lKGFyZyk7XG4gICAgdGhpcy5fdW5zaGlmdE9uZShyZWNlaXZlcik7XG4gICAgdGhpcy5fdW5zaGlmdE9uZShmbik7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpICsgMztcbiAgICBpZiAodGhpcy5fd2lsbEJlT3ZlckNhcGFjaXR5KGxlbmd0aCkpIHtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShmbik7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUocmVjZWl2ZXIpO1xuICAgICAgICB0aGlzLl9wdXNoT25lKGFyZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGogPSB0aGlzLl9mcm9udCArIGxlbmd0aCAtIDM7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGgpO1xuICAgIHZhciB3cmFwTWFzayA9IHRoaXMuX2NhcGFjaXR5IC0gMTtcbiAgICB0aGlzWyhqICsgMCkgJiB3cmFwTWFza10gPSBmbjtcbiAgICB0aGlzWyhqICsgMSkgJiB3cmFwTWFza10gPSByZWNlaXZlcjtcbiAgICB0aGlzWyhqICsgMikgJiB3cmFwTWFza10gPSBhcmc7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250LFxuICAgICAgICByZXQgPSB0aGlzW2Zyb250XTtcblxuICAgIHRoaXNbZnJvbnRdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Zyb250ID0gKGZyb250ICsgMSkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzLl9sZW5ndGgtLTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUXVldWUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9jaGVja0NhcGFjaXR5ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICBpZiAodGhpcy5fY2FwYWNpdHkgPCBzaXplKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVRvKHRoaXMuX2NhcGFjaXR5IDw8IDEpO1xuICAgIH1cbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fcmVzaXplVG8gPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcbiAgICB2YXIgb2xkQ2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgdmFyIG1vdmVJdGVtc0NvdW50ID0gKGZyb250ICsgbGVuZ3RoKSAmIChvbGRDYXBhY2l0eSAtIDEpO1xuICAgIGFycmF5TW92ZSh0aGlzLCAwLCB0aGlzLCBvbGRDYXBhY2l0eSwgbW92ZUl0ZW1zQ291bnQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcblxufSx7fV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFxuICAgIFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcblxudmFyIHJhY2VMYXRlciA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihhcnJheSkge1xuICAgICAgICByZXR1cm4gcmFjZShhcnJheSwgcHJvbWlzZSk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiByYWNlKHByb21pc2VzLCBwYXJlbnQpIHtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcyk7XG5cbiAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gcmFjZUxhdGVyKG1heWJlUHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZXMgPSB1dGlsLmFzQXJyYXkocHJvbWlzZXMpO1xuICAgICAgICBpZiAocHJvbWlzZXMgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGFuIGFycmF5IG9yIGFuIGl0ZXJhYmxlIG9iamVjdCBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhwcm9taXNlcykpO1xuICAgIH1cblxuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldC5fcHJvcGFnYXRlRnJvbShwYXJlbnQsIDMpO1xuICAgIH1cbiAgICB2YXIgZnVsZmlsbCA9IHJldC5fZnVsZmlsbDtcbiAgICB2YXIgcmVqZWN0ID0gcmV0Ll9yZWplY3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb21pc2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciB2YWwgPSBwcm9taXNlc1tpXTtcblxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQgJiYgIShpIGluIHByb21pc2VzKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBQcm9taXNlLmNhc3QodmFsKS5fdGhlbihmdWxmaWxsLCByZWplY3QsIHVuZGVmaW5lZCwgcmV0LCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHJhY2UocHJvbWlzZXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByYWNlKHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2VBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVqZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcpIHtcbnZhciBnZXREb21haW4gPSBQcm9taXNlLl9nZXREb21haW47XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuXG5mdW5jdGlvbiBSZWR1Y3Rpb25Qcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQocHJvbWlzZXMpO1xuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICB0aGlzLl9mbiA9IGRvbWFpbiA9PT0gbnVsbCA/IGZuIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZm4pO1xuICAgIGlmIChpbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbml0aWFsVmFsdWUgPSBQcm9taXNlLnJlc29sdmUoaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgaW5pdGlhbFZhbHVlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZSA9IG51bGw7XG4gICAgaWYoX2VhY2ggPT09IElOVEVSTkFMKSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMgPSBBcnJheSh0aGlzLl9sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoX2VhY2ggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5fcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC01KTtcbn1cbnV0aWwuaW5oZXJpdHMoUmVkdWN0aW9uUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9nb3RBY2N1bSA9IGZ1bmN0aW9uKGFjY3VtKSB7XG4gICAgaWYgKHRoaXMuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCAmJiBcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcyAhPT0gbnVsbCAmJiBcbiAgICAgICAgYWNjdW0gIT09IElOVEVSTkFMKSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMucHVzaChhY2N1bSk7XG4gICAgfVxufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZWFjaENvbXBsZXRlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5fZWFjaFZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZWFjaFZhbHVlcztcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHt9O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlRW1wdHlBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkID8gdGhpcy5fZWFjaFZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5faW5pdGlhbFZhbHVlKTtcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLl9wcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbihzZW5kZXIpIHtcbiAgICBpZiAoc2VuZGVyID09PSB0aGlzLl9pbml0aWFsVmFsdWUpIHJldHVybiB0aGlzLl9jYW5jZWwoKTtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgdGhpcy5fcmVzdWx0Q2FuY2VsbGVkJCgpO1xuICAgIGlmICh0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZS5jYW5jZWwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2luaXRpYWxWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbFZhbHVlLmNhbmNlbCgpO1xuICAgIH1cbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2l0ZXJhdGUgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICBpZiAodGhpcy5faW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9pbml0aWFsVmFsdWU7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1swXSk7XG4gICAgICAgIGkgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZSA9IHZhbHVlO1xuXG4gICAgaWYgKCF2YWx1ZS5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHtcbiAgICAgICAgICAgICAgICBhY2N1bTogbnVsbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2ldLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFycmF5OiB0aGlzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5fdGhlbihnb3RBY2N1bSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGN0eCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgLl90aGVuKHRoaXMuX2VhY2hDb21wbGV0ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHZhbHVlLl90aGVuKGNvbXBsZXRlZCwgY29tcGxldGVkLCB1bmRlZmluZWQsIHZhbHVlLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLCBmbiwgaW5pdGlhbFZhbHVlLCBudWxsKTtcbn07XG5cblByb21pc2UucmVkdWNlID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIHJldHVybiByZWR1Y2UocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKTtcbn07XG5cbmZ1bmN0aW9uIGNvbXBsZXRlZCh2YWx1ZU9yUmVhc29uLCBhcnJheSkge1xuICAgIGlmICh0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgYXJyYXkuX3Jlc29sdmUodmFsdWVPclJlYXNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXkuX3JlamVjdCh2YWx1ZU9yUmVhc29uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHZhciBhcnJheSA9IG5ldyBSZWR1Y3Rpb25Qcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKTtcbiAgICByZXR1cm4gYXJyYXkucHJvbWlzZSgpO1xufVxuXG5mdW5jdGlvbiBnb3RBY2N1bShhY2N1bSkge1xuICAgIHRoaXMuYWNjdW0gPSBhY2N1bTtcbiAgICB0aGlzLmFycmF5Ll9nb3RBY2N1bShhY2N1bSk7XG4gICAgdmFyIHZhbHVlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzLnZhbHVlLCB0aGlzLmFycmF5Ll9wcm9taXNlKTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMuYXJyYXkuX2N1cnJlbnRDYW5jZWxsYWJsZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWUuX3RoZW4oZ290VmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnb3RWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdvdFZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICB2YXIgcHJvbWlzZSA9IGFycmF5Ll9wcm9taXNlO1xuICAgIHZhciBmbiA9IHRyeUNhdGNoKGFycmF5Ll9mbik7XG4gICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmV0O1xuICAgIGlmIChhcnJheS5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldCA9IGZuLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCB2YWx1ZSwgdGhpcy5pbmRleCwgdGhpcy5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGZuLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2N1bSwgdmFsdWUsIHRoaXMuaW5kZXgsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgYXJyYXkuX2N1cnJlbnRDYW5jZWxsYWJsZSA9IHJldDtcbiAgICB9XG4gICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgcmV0LFxuICAgICAgICBwcm9taXNlQ3JlYXRlZCxcbiAgICAgICAgYXJyYXkuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCA/IFwiUHJvbWlzZS5lYWNoXCIgOiBcIlByb21pc2UucmVkdWNlXCIsXG4gICAgICAgIHByb21pc2VcbiAgICApO1xuICAgIHJldHVybiByZXQ7XG59XG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgc2NoZWR1bGU7XG52YXIgbm9Bc3luY1NjaGVkdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xufTtcbnZhciBOYXRpdmVQcm9taXNlID0gdXRpbC5nZXROYXRpdmVQcm9taXNlKCk7XG5pZiAodXRpbC5pc05vZGUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgR2xvYmFsU2V0SW1tZWRpYXRlID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbiAgICB2YXIgUHJvY2Vzc05leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBzY2hlZHVsZSA9IHV0aWwuaXNSZWNlbnROb2RlXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbihmbikgeyBHbG9iYWxTZXRJbW1lZGlhdGUuY2FsbChnbG9iYWwsIGZuKTsgfVxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24oZm4pIHsgUHJvY2Vzc05leHRUaWNrLmNhbGwocHJvY2VzcywgZm4pOyB9O1xufSBlbHNlIGlmICh0eXBlb2YgTmF0aXZlUHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgIHR5cGVvZiBOYXRpdmVQcm9taXNlLnJlc29sdmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBuYXRpdmVQcm9taXNlID0gTmF0aXZlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbihmbikge1xuICAgICAgICBuYXRpdmVQcm9taXNlLnRoZW4oZm4pO1xuICAgIH07XG59IGVsc2UgaWYgKCh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIikgJiZcbiAgICAgICAgICAhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IgJiZcbiAgICAgICAgICAgICh3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUgfHwgd2luZG93LmNvcmRvdmEpKSkge1xuICAgIHNjaGVkdWxlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG9wdHMgPSB7YXR0cmlidXRlczogdHJ1ZX07XG4gICAgICAgIHZhciB0b2dnbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRpdjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgbzIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpO1xuICAgICAgICAgICAgdG9nZ2xlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBvMi5vYnNlcnZlKGRpdjIsIG9wdHMpO1xuXG4gICAgICAgIHZhciBzY2hlZHVsZVRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRvZ2dsZVNjaGVkdWxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRvZ2dsZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGl2Mi5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNjaGVkdWxlKGZuKSB7XG4gICAgICAgICAgICB2YXIgbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG8uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG8ub2JzZXJ2ZShkaXYsIG9wdHMpO1xuICAgICAgICAgICAgc2NoZWR1bGVUb2dnbGUoKTtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICB9O1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0VGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHNjaGVkdWxlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59IGVsc2Uge1xuICAgIHNjaGVkdWxlID0gbm9Bc3luY1NjaGVkdWxlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gc2NoZWR1bGU7XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwzMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbiAgICBmdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIGRlYnVnKSB7XG52YXIgUHJvbWlzZUluc3BlY3Rpb24gPSBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBTZXR0bGVkUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG59XG51dGlsLmluaGVyaXRzKFNldHRsZWRQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVzb2x2ZWQgPSBmdW5jdGlvbiAoaW5kZXgsIGluc3BlY3Rpb24pIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gaW5zcGVjdGlvbjtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlSW5zcGVjdGlvbigpO1xuICAgIHJldC5fYml0RmllbGQgPSAzMzU1NDQzMjtcbiAgICByZXQuX3NldHRsZWRWYWx1ZUZpZWxkID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbn07XG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbiwgaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgcmV0Ll9iaXRGaWVsZCA9IDE2Nzc3MjE2O1xuICAgIHJldC5fc2V0dGxlZFZhbHVlRmllbGQgPSByZWFzb247XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbn07XG5cblByb21pc2Uuc2V0dGxlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIi5zZXR0bGUoKVwiLCBcIi5yZWZsZWN0KClcIik7XG4gICAgcmV0dXJuIG5ldyBTZXR0bGVkUHJvbWlzZUFycmF5KHByb21pc2VzKS5wcm9taXNlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXR0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFByb21pc2Uuc2V0dGxlKHRoaXMpO1xufTtcbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbmZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgUmFuZ2VFcnJvciA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKS5SYW5nZUVycm9yO1xudmFyIEFnZ3JlZ2F0ZUVycm9yID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpLkFnZ3JlZ2F0ZUVycm9yO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG52YXIgQ0FOQ0VMTEFUSU9OID0ge307XG5cblxuZnVuY3Rpb24gU29tZVByb21pc2VBcnJheSh2YWx1ZXMpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJCh2YWx1ZXMpO1xuICAgIHRoaXMuX2hvd01hbnkgPSAwO1xuICAgIHRoaXMuX3Vud3JhcCA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG59XG51dGlsLmluaGVyaXRzKFNvbWVQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5faG93TWFueSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKFtdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC01KTtcbiAgICB2YXIgaXNBcnJheVJlc29sdmVkID0gaXNBcnJheSh0aGlzLl92YWx1ZXMpO1xuICAgIGlmICghdGhpcy5faXNSZXNvbHZlZCgpICYmXG4gICAgICAgIGlzQXJyYXlSZXNvbHZlZCAmJlxuICAgICAgICB0aGlzLl9ob3dNYW55ID4gdGhpcy5fY2FuUG9zc2libHlGdWxmaWxsKCkpIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IodGhpcy5sZW5ndGgoKSkpO1xuICAgIH1cbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2luaXQoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLnNldFVud3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91bndyYXAgPSB0cnVlO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuaG93TWFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faG93TWFueTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLnNldEhvd01hbnkgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICB0aGlzLl9ob3dNYW55ID0gY291bnQ7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX2FkZEZ1bGZpbGxlZCh2YWx1ZSk7XG4gICAgaWYgKHRoaXMuX2Z1bGZpbGxlZCgpID09PSB0aGlzLmhvd01hbnkoKSkge1xuICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gdGhpcy5ob3dNYW55KCk7XG4gICAgICAgIGlmICh0aGlzLmhvd01hbnkoKSA9PT0gMSAmJiB0aGlzLl91bndyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuXG59O1xuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl9hZGRSZWplY3RlZChyZWFzb24pO1xuICAgIHJldHVybiB0aGlzLl9jaGVja091dGNvbWUoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlQ2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl92YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHRoaXMuX3ZhbHVlcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWwoKTtcbiAgICB9XG4gICAgdGhpcy5fYWRkUmVqZWN0ZWQoQ0FOQ0VMTEFUSU9OKTtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tPdXRjb21lKCk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fY2hlY2tPdXRjb21lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaG93TWFueSgpID4gdGhpcy5fY2FuUG9zc2libHlGdWxmaWxsKCkpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgQWdncmVnYXRlRXJyb3IoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoKCk7IGkgPCB0aGlzLl92YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZXNbaV0gIT09IENBTkNFTExBVElPTikge1xuICAgICAgICAgICAgICAgIGUucHVzaCh0aGlzLl92YWx1ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90b3RhbFJlc29sdmVkO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RoIC0gdGhpcy5sZW5ndGgoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9hZGRSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl92YWx1ZXMucHVzaChyZWFzb24pO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2FkZEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlc1t0aGlzLl90b3RhbFJlc29sdmVkKytdID0gdmFsdWU7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fY2FuUG9zc2libHlGdWxmaWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCgpIC0gdGhpcy5fcmVqZWN0ZWQoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9nZXRSYW5nZUVycm9yID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBcIklucHV0IGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBcIiArXG4gICAgICAgICAgICB0aGlzLl9ob3dNYW55ICsgXCIgaXRlbXMgYnV0IGNvbnRhaW5zIG9ubHkgXCIgKyBjb3VudCArIFwiIGl0ZW1zXCI7XG4gICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3JlamVjdCh0aGlzLl9nZXRSYW5nZUVycm9yKDApKTtcbn07XG5cbmZ1bmN0aW9uIHNvbWUocHJvbWlzZXMsIGhvd01hbnkpIHtcbiAgICBpZiAoKGhvd01hbnkgfCAwKSAhPT0gaG93TWFueSB8fCBob3dNYW55IDwgMCkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgcG9zaXRpdmUgaW50ZWdlclxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciByZXQgPSBuZXcgU29tZVByb21pc2VBcnJheShwcm9taXNlcyk7XG4gICAgdmFyIHByb21pc2UgPSByZXQucHJvbWlzZSgpO1xuICAgIHJldC5zZXRIb3dNYW55KGhvd01hbnkpO1xuICAgIHJldC5pbml0KCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2Uuc29tZSA9IGZ1bmN0aW9uIChwcm9taXNlcywgaG93TWFueSkge1xuICAgIHJldHVybiBzb21lKHByb21pc2VzLCBob3dNYW55KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoaG93TWFueSkge1xuICAgIHJldHVybiBzb21lKHRoaXMsIGhvd01hbnkpO1xufTtcblxuUHJvbWlzZS5fU29tZVByb21pc2VBcnJheSA9IFNvbWVQcm9taXNlQXJyYXk7XG59O1xuXG59LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiBQcm9taXNlSW5zcGVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKHByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkID0gcHJvbWlzZS5faXNGYXRlU2VhbGVkKClcbiAgICAgICAgICAgID8gcHJvbWlzZS5fc2V0dGxlZFZhbHVlKCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IDA7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlRmllbGQ7XG59O1xuXG52YXIgdmFsdWUgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgZnVsZmlsbG1lbnQgdmFsdWUgb2YgYSBub24tZnVsZmlsbGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG52YXIgcmVhc29uID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmVycm9yID1cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5yZWFzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGdldCByZWplY3Rpb24gcmVhc29uIG9mIGEgbm9uLXJlamVjdGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG52YXIgaXNGdWxmaWxsZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwO1xufTtcblxudmFyIGlzUmVqZWN0ZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwO1xufTtcblxudmFyIGlzUGVuZGluZyA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMDtcbn07XG5cbnZhciBpc1Jlc29sdmVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUwMzMxNjQ4KSAhPT0gMDtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA4NDU0MTQ0KSAhPT0gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9faXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNjU1MzYpID09PSA2NTUzNjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXQoKS5fX2lzQ2FuY2VsbGVkKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fdGFyZ2V0KCkuX2JpdEZpZWxkICYgODQ1NDE0NCkgIT09IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1JlamVjdGVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1Jlc29sdmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzUmVzb2x2ZWQuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZS5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJlYXNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB0YXJnZXQuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICByZXR1cm4gcmVhc29uLmNhbGwodGFyZ2V0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl92YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWFzb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xufTtcblxuUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2VJbnNwZWN0aW9uO1xufTtcblxufSx7fV0sMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcblxuZnVuY3Rpb24gdHJ5Q29udmVydFRvUHJvbWlzZShvYmosIGNvbnRleHQpIHtcbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIG9iajtcbiAgICAgICAgdmFyIHRoZW4gPSBnZXRUaGVuKG9iaik7XG4gICAgICAgIGlmICh0aGVuID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmV0ID0gUHJvbWlzZS5yZWplY3QodGhlbi5lKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0FueUJsdWViaXJkUHJvbWlzZShvYmopKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICBvYmouX3RoZW4oXG4gICAgICAgICAgICAgICAgICAgIHJldC5fZnVsZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvVGhlbmFibGUob2JqLCB0aGVuLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBkb0dldFRoZW4ob2JqKSB7XG4gICAgcmV0dXJuIG9iai50aGVuO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkb0dldFRoZW4ob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqLmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfVxufVxuXG52YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaXNBbnlCbHVlYmlyZFByb21pc2Uob2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGhhc1Byb3AuY2FsbChvYmosIFwiX3Byb21pc2UwXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZG9UaGVuYWJsZSh4LCB0aGVuLCBjb250ZXh0KSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgdmFyIHJldCA9IHByb21pc2U7XG4gICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWwudHJ5Q2F0Y2godGhlbikuY2FsbCh4LCByZXNvbHZlLCByZWplY3QpO1xuICAgIHN5bmNocm9ub3VzID0gZmFsc2U7XG5cbiAgICBpZiAocHJvbWlzZSAmJiByZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cywgdHJ1ZSk7XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5yZXR1cm4gdHJ5Q29udmVydFRvUHJvbWlzZTtcbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgVGltZW91dEVycm9yID0gUHJvbWlzZS5UaW1lb3V0RXJyb3I7XG5cbmZ1bmN0aW9uIEhhbmRsZVdyYXBwZXIoaGFuZGxlKSAge1xuICAgIHRoaXMuaGFuZGxlID0gaGFuZGxlO1xufVxuXG5IYW5kbGVXcmFwcGVyLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbn07XG5cbnZhciBhZnRlclZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIGRlbGF5KCt0aGlzKS50aGVuUmV0dXJuKHZhbHVlKTsgfTtcbnZhciBkZWxheSA9IFByb21pc2UuZGVsYXkgPSBmdW5jdGlvbiAobXMsIHZhbHVlKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgaGFuZGxlO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldCA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAuX3RoZW4oYWZ0ZXJWYWx1ZSwgbnVsbCwgbnVsbCwgbXMsIHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBoYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyByZXQuX2Z1bGZpbGwoKTsgfSwgK21zKTtcbiAgICAgICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpKSB7XG4gICAgICAgICAgICByZXQuX3NldE9uQ2FuY2VsKG5ldyBIYW5kbGVXcmFwcGVyKGhhbmRsZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB9XG4gICAgcmV0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAobXMpIHtcbiAgICByZXR1cm4gZGVsYXkobXMsIHRoaXMpO1xufTtcblxudmFyIGFmdGVyVGltZW91dCA9IGZ1bmN0aW9uIChwcm9taXNlLCBtZXNzYWdlLCBwYXJlbnQpIHtcbiAgICB2YXIgZXJyO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBlcnIgPSBtZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IFRpbWVvdXRFcnJvcihcIm9wZXJhdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBlcnIgPSBuZXcgVGltZW91dEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB1dGlsLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihlcnIpO1xuICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICBwcm9taXNlLl9yZWplY3QoZXJyKTtcblxuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQuY2FuY2VsKCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc3VjY2Vzc0NsZWFyKHZhbHVlKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGZhaWx1cmVDbGVhcihyZWFzb24pIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgIHRocm93IHJlYXNvbjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcywgbWVzc2FnZSkge1xuICAgIG1zID0gK21zO1xuICAgIHZhciByZXQsIHBhcmVudDtcblxuICAgIHZhciBoYW5kbGVXcmFwcGVyID0gbmV3IEhhbmRsZVdyYXBwZXIoc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0VGltZW91dCgpIHtcbiAgICAgICAgaWYgKHJldC5pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgYWZ0ZXJUaW1lb3V0KHJldCwgbWVzc2FnZSwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgIH0sIG1zKSk7XG5cbiAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkpIHtcbiAgICAgICAgcGFyZW50ID0gdGhpcy50aGVuKCk7XG4gICAgICAgIHJldCA9IHBhcmVudC5fdGhlbihzdWNjZXNzQ2xlYXIsIGZhaWx1cmVDbGVhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIGhhbmRsZVdyYXBwZXIsIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldC5fc2V0T25DYW5jZWwoaGFuZGxlV3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gdGhpcy5fdGhlbihzdWNjZXNzQ2xlYXIsIGZhaWx1cmVDbGVhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIGhhbmRsZVdyYXBwZXIsIHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFByb21pc2UsIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICBjcmVhdGVDb250ZXh0LCBJTlRFUk5BTCwgZGVidWcpIHtcbiAgICB2YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG4gICAgdmFyIFR5cGVFcnJvciA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3I7XG4gICAgdmFyIGluaGVyaXRzID0gX2RlcmVxXyhcIi4vdXRpbFwiKS5pbmhlcml0cztcbiAgICB2YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuICAgIHZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG4gICAgdmFyIE5VTEwgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHRocm93ZXIoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZTt9LCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYXN0UHJlc2VydmluZ0Rpc3Bvc2FibGUodGhlbmFibGUpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhlbmFibGUpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlICE9PSB0aGVuYWJsZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLl9pc0Rpc3Bvc2FibGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLl9nZXREaXNwb3NlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0aGVuYWJsZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fc2V0RGlzcG9zYWJsZSh0aGVuYWJsZS5fZ2V0RGlzcG9zZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcG9zZShyZXNvdXJjZXMsIGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gcmVzb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBsZW4pIHJldHVybiByZXQuX2Z1bGZpbGwoKTtcbiAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSBjYXN0UHJlc2VydmluZ0Rpc3Bvc2FibGUocmVzb3VyY2VzW2krK10pO1xuICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UgJiZcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX2lzRGlzcG9zYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fZ2V0RGlzcG9zZXIoKS50cnlEaXNwb3NlKGluc3BlY3Rpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzLnByb21pc2UpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRocm93ZXIoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXliZVByb21pc2UuX3RoZW4oaXRlcmF0b3IsIHRocm93ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlcmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRvcigpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERpc3Bvc2VyKGRhdGEsIHByb21pc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBwcm9taXNlO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnJlc291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9taXNlKCkuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZSgpLnZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5VTEw7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS50cnlEaXNwb3NlID0gZnVuY3Rpb24oaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgcmVzb3VyY2UgPSB0aGlzLnJlc291cmNlKCk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgY29udGV4dC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJldCA9IHJlc291cmNlICE9PSBOVUxMXG4gICAgICAgICAgICA/IHRoaXMuZG9EaXNwb3NlKHJlc291cmNlLCBpbnNwZWN0aW9uKSA6IG51bGw7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIGNvbnRleHQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fdW5zZXREaXNwb3NhYmxlKCk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5pc0Rpc3Bvc2VyID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIChkICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZC5yZXNvdXJjZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGQudHJ5RGlzcG9zZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25EaXNwb3NlcihmbiwgcHJvbWlzZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yJChmbiwgcHJvbWlzZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGluaGVyaXRzKEZ1bmN0aW9uRGlzcG9zZXIsIERpc3Bvc2VyKTtcblxuICAgIEZ1bmN0aW9uRGlzcG9zZXIucHJvdG90eXBlLmRvRGlzcG9zZSA9IGZ1bmN0aW9uIChyZXNvdXJjZSwgaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgZm4gPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwocmVzb3VyY2UsIHJlc291cmNlLCBpbnNwZWN0aW9uKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWF5YmVVbndyYXBEaXNwb3Nlcih2YWx1ZSkge1xuICAgICAgICBpZiAoRGlzcG9zZXIuaXNEaXNwb3Nlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzW3RoaXMuaW5kZXhdLl9zZXREaXNwb3NhYmxlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5wcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJlc291cmNlTGlzdChsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXNbbGVuZ3RoLTFdID0gbnVsbDtcbiAgICB9XG5cbiAgICBSZXNvdXJjZUxpc3QucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFByb21pc2UudXNpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuIDwgMikgcmV0dXJuIGFwaVJlamVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieW91IG11c3QgcGFzcyBhdCBsZWFzdCAyIGFyZ3VtZW50cyB0byBQcm9taXNlLnVzaW5nXCIpO1xuICAgICAgICB2YXIgZm4gPSBhcmd1bWVudHNbbGVuIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0O1xuICAgICAgICB2YXIgc3ByZWFkQXJncyA9IHRydWU7XG4gICAgICAgIGlmIChsZW4gPT09IDIgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIHNwcmVhZEFyZ3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0ID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgbGVuLS07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc291cmNlcyA9IG5ldyBSZXNvdXJjZUxpc3QobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIHJlc291cmNlID0gaW5wdXRbaV07XG4gICAgICAgICAgICBpZiAoRGlzcG9zZXIuaXNEaXNwb3NlcihyZXNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzcG9zZXIgPSByZXNvdXJjZTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZSA9IHJlc291cmNlLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5fc2V0RGlzcG9zYWJsZShkaXNwb3Nlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3RoZW4obWF5YmVVbndyYXBEaXNwb3NlciwgbnVsbCwgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlczogcmVzb3VyY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgICAgIH0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb3VyY2VzW2ldID0gcmVzb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVmbGVjdGVkUmVzb3VyY2VzID0gbmV3IEFycmF5KHJlc291cmNlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZmxlY3RlZFJlc291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVmbGVjdGVkUmVzb3VyY2VzW2ldID0gUHJvbWlzZS5yZXNvbHZlKHJlc291cmNlc1tpXSkucmVmbGVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdFByb21pc2UgPSBQcm9taXNlLmFsbChyZWZsZWN0ZWRSZXNvdXJjZXMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihpbnNwZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zcGVjdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3BlY3Rpb24gPSBpbnNwZWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3BlY3Rpb24uaXNSZWplY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck9iai5lID0gaW5zcGVjdGlvbi5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpbnNwZWN0aW9uLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5zcGVjdGlvbnNbaV0gPSBpbnNwZWN0aW9uLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG5cbiAgICAgICAgICAgICAgICBmbiA9IHRyeUNhdGNoKGZuKTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gc3ByZWFkQXJnc1xuICAgICAgICAgICAgICAgICAgICA/IGZuLmFwcGx5KHVuZGVmaW5lZCwgaW5zcGVjdGlvbnMpIDogZm4oaW5zcGVjdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHByb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgICAgICAgICAgICAgIHJldCwgcHJvbWlzZUNyZWF0ZWQsIFwiUHJvbWlzZS51c2luZ1wiLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSByZXN1bHRQcm9taXNlLmxhc3RseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0aW9uID0gbmV3IFByb21pc2UuUHJvbWlzZUluc3BlY3Rpb24ocmVzdWx0UHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gZGlzcG9zZShyZXNvdXJjZXMsIGluc3BlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzb3VyY2VzLnByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICBwcm9taXNlLl9zZXRPbkNhbmNlbChyZXNvdXJjZXMpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoZGlzcG9zZXIpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEzMTA3MjtcbiAgICAgICAgdGhpcy5fZGlzcG9zZXIgPSBkaXNwb3NlcjtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX2lzRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDEzMTA3MikgPiAwO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fZ2V0RGlzcG9zZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlcjtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MTMxMDcyKTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLmRpc3Bvc2VyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkRpc3Bvc2VyKGZuLCB0aGlzLCBjcmVhdGVDb250ZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9O1xuXG59O1xuXG59LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIGVzNSA9IF9kZXJlcV8oXCIuL2VzNVwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJ1bmRlZmluZWRcIjtcblxudmFyIGVycm9yT2JqID0ge2U6IHt9fTtcbnZhciB0cnlDYXRjaFRhcmdldDtcbnZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOlxuICAgIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOlxuICAgIHRoaXMgIT09IHVuZGVmaW5lZCA/IHRoaXMgOiBudWxsO1xuXG5mdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0cnlDYXRjaFRhcmdldDtcbiAgICAgICAgdHJ5Q2F0Y2hUYXJnZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24oQ2hpbGQsIFBhcmVudCkge1xuICAgIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgICBmdW5jdGlvbiBUKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IkID0gUGFyZW50O1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gUGFyZW50LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgaWYgKGhhc1Byb3AuY2FsbChQYXJlbnQucHJvdG90eXBlLCBwcm9wZXJ0eU5hbWUpICYmXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lLmNoYXJBdChwcm9wZXJ0eU5hbWUubGVuZ3RoLTEpICE9PSBcIiRcIlxuICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZSArIFwiJFwiXSA9IFBhcmVudC5wcm90b3R5cGVbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBULnByb3RvdHlwZSA9IFBhcmVudC5wcm90b3R5cGU7XG4gICAgQ2hpbGQucHJvdG90eXBlID0gbmV3IFQoKTtcbiAgICByZXR1cm4gQ2hpbGQucHJvdG90eXBlO1xufTtcblxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHxcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiO1xuXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWF5YmVXcmFwQXNFcnJvcihtYXliZUVycm9yKSB7XG4gICAgaWYgKCFpc1ByaW1pdGl2ZShtYXliZUVycm9yKSkgcmV0dXJuIG1heWJlRXJyb3I7XG5cbiAgICByZXR1cm4gbmV3IEVycm9yKHNhZmVUb1N0cmluZyhtYXliZUVycm9yKSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhBcHBlbmRlZCh0YXJnZXQsIGFwcGVuZGVlKSB7XG4gICAgdmFyIGxlbiA9IHRhcmdldC5sZW5ndGg7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gdGFyZ2V0W2ldO1xuICAgIH1cbiAgICByZXRbaV0gPSBhcHBlbmRlZTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQob2JqLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChlczUuaXNFUzUpIHtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcblxuICAgICAgICBpZiAoZGVzYyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQgPT0gbnVsbCAmJiBkZXNjLnNldCA9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gZGVzYy52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSA/IG9ialtrZXldIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbm90RW51bWVyYWJsZVByb3Aob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChpc1ByaW1pdGl2ZShvYmopKSByZXR1cm4gb2JqO1xuICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfTtcbiAgICBlczUuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiB0aHJvd2VyKHIpIHtcbiAgICB0aHJvdyByO1xufVxuXG52YXIgaW5oZXJpdGVkRGF0YUtleXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2x1ZGVkUHJvdG90eXBlcyA9IFtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGVcbiAgICBdO1xuXG4gICAgdmFyIGlzRXhjbHVkZWRQcm90byA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4Y2x1ZGVkUHJvdG90eXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkUHJvdG90eXBlc1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBpZiAoZXM1LmlzRVM1KSB7XG4gICAgICAgIHZhciBnZXRLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgIHZhciB2aXNpdGVkS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB3aGlsZSAob2JqICE9IG51bGwgJiYgIWlzRXhjbHVkZWRQcm90byhvYmopKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IGdldEtleXMob2JqKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRLZXlzW2tleV0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgIT0gbnVsbCAmJiBkZXNjLmdldCA9PSBudWxsICYmIGRlc2Muc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqID0gZXM1LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmIChpc0V4Y2x1ZGVkUHJvdG8ob2JqKSkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICAgICAgICAvKmpzaGludCBmb3JpbjpmYWxzZSAqL1xuICAgICAgICAgICAgZW51bWVyYXRpb246IGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhjbHVkZWRQcm90b3R5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKGV4Y2x1ZGVkUHJvdG90eXBlc1tpXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGVudW1lcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKCk7XG5cbnZhciB0aGlzQXNzaWdubWVudFBhdHRlcm4gPSAvdGhpc1xccypcXC5cXHMqXFxTK1xccyo9LztcbmZ1bmN0aW9uIGlzQ2xhc3MoZm4pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gZXM1Lm5hbWVzKGZuLnByb3RvdHlwZSk7XG5cbiAgICAgICAgICAgIHZhciBoYXNNZXRob2RzID0gZXM1LmlzRVM1ICYmIGtleXMubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIHZhciBoYXNNZXRob2RzT3RoZXJUaGFuQ29uc3RydWN0b3IgPSBrZXlzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAhKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09IFwiY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICB2YXIgaGFzVGhpc0Fzc2lnbm1lbnRBbmRTdGF0aWNNZXRob2RzID1cbiAgICAgICAgICAgICAgICB0aGlzQXNzaWdubWVudFBhdHRlcm4udGVzdChmbiArIFwiXCIpICYmIGVzNS5uYW1lcyhmbikubGVuZ3RoID4gMDtcblxuICAgICAgICAgICAgaWYgKGhhc01ldGhvZHMgfHwgaGFzTWV0aG9kc090aGVyVGhhbkNvbnN0cnVjdG9yIHx8XG4gICAgICAgICAgICAgICAgaGFzVGhpc0Fzc2lnbm1lbnRBbmRTdGF0aWNNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9GYXN0UHJvcGVydGllcyhvYmopIHtcbiAgICAvKmpzaGludCAtVzAyNywtVzA1NSwtVzAzMSovXG4gICAgZnVuY3Rpb24gRmFrZUNvbnN0cnVjdG9yKCkge31cbiAgICBGYWtlQ29uc3RydWN0b3IucHJvdG90eXBlID0gb2JqO1xuICAgIHZhciBsID0gODtcbiAgICB3aGlsZSAobC0tKSBuZXcgRmFrZUNvbnN0cnVjdG9yKCk7XG4gICAgcmV0dXJuIG9iajtcbiAgICBldmFsKG9iaik7XG59XG5cbnZhciByaWRlbnQgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihzdHIpIHtcbiAgICByZXR1cm4gcmlkZW50LnRlc3Qoc3RyKTtcbn1cblxuZnVuY3Rpb24gZmlsbGVkUmFuZ2UoY291bnQsIHByZWZpeCwgc3VmZml4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gcHJlZml4ICsgaSArIHN1ZmZpeDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2FmZVRvU3RyaW5nKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvYmogKyBcIlwiO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFwiW25vIHN0cmluZyByZXByZXNlbnRhdGlvbl1cIjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICAgICB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgIHR5cGVvZiBvYmoubWVzc2FnZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICB0eXBlb2Ygb2JqLm5hbWUgPT09IFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AoZSwgXCJpc09wZXJhdGlvbmFsXCIsIHRydWUpO1xuICAgIH1cbiAgICBjYXRjaChpZ25vcmUpIHt9XG59XG5cbmZ1bmN0aW9uIG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uKGUpIHtcbiAgICBpZiAoZSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICgoZSBpbnN0YW5jZW9mIEVycm9yW1wiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiXS5PcGVyYXRpb25hbEVycm9yKSB8fFxuICAgICAgICBlW1wiaXNPcGVyYXRpb25hbFwiXSA9PT0gdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGNhbkF0dGFjaFRyYWNlKG9iaikge1xuICAgIHJldHVybiBpc0Vycm9yKG9iaikgJiYgZXM1LnByb3BlcnR5SXNXcml0YWJsZShvYmosIFwic3RhY2tcIik7XG59XG5cbnZhciBlbnN1cmVFcnJvck9iamVjdCA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAoIShcInN0YWNrXCIgaW4gbmV3IEVycm9yKCkpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNhbkF0dGFjaFRyYWNlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHt0aHJvdyBuZXcgRXJyb3Ioc2FmZVRvU3RyaW5nKHZhbHVlKSk7fVxuICAgICAgICAgICAgY2F0Y2goZXJyKSB7cmV0dXJuIGVycjt9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY2FuQXR0YWNoVHJhY2UodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKHNhZmVUb1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5cbmZ1bmN0aW9uIGNsYXNzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5cbmZ1bmN0aW9uIGNvcHlEZXNjcmlwdG9ycyhmcm9tLCB0bywgZmlsdGVyKSB7XG4gICAgdmFyIGtleXMgPSBlczUubmFtZXMoZnJvbSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoZmlsdGVyKGtleSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZXM1LmRlZmluZVByb3BlcnR5KHRvLCBrZXksIGVzNS5nZXREZXNjcmlwdG9yKGZyb20sIGtleSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgYXNBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoZXM1LmlzQXJyYXkodikpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgdmFyIEFycmF5RnJvbSA9IHR5cGVvZiBBcnJheS5mcm9tID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHYpO1xuICAgIH0gOiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgdmFyIGl0ID0gdltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIHZhciBpdFJlc3VsdDtcbiAgICAgICAgd2hpbGUgKCEoKGl0UmVzdWx0ID0gaXQubmV4dCgpKS5kb25lKSkge1xuICAgICAgICAgICAgcmV0LnB1c2goaXRSZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIGFzQXJyYXkgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIGlmIChlczUuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0gZWxzZSBpZiAodiAhPSBudWxsICYmIHR5cGVvZiB2W1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5RnJvbSh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuXG52YXIgaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgY2xhc3NTdHJpbmcocHJvY2VzcykudG9Mb3dlckNhc2UoKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCI7XG5cbmZ1bmN0aW9uIGVudihrZXksIGRlZikge1xuICAgIHJldHVybiBpc05vZGUgPyBwcm9jZXNzLmVudltrZXldIDogZGVmO1xufVxuXG5mdW5jdGlvbiBnZXROYXRpdmVQcm9taXNlKCkge1xuICAgIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKCl7fSk7XG4gICAgICAgICAgICBpZiAoe30udG9TdHJpbmcuY2FsbChwcm9taXNlKSA9PT0gXCJbb2JqZWN0IFByb21pc2VdXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRvbWFpbkJpbmQoc2VsZiwgY2IpIHtcbiAgICByZXR1cm4gc2VsZi5iaW5kKGNiKTtcbn1cblxudmFyIHJldCA9IHtcbiAgICBpc0NsYXNzOiBpc0NsYXNzLFxuICAgIGlzSWRlbnRpZmllcjogaXNJZGVudGlmaWVyLFxuICAgIGluaGVyaXRlZERhdGFLZXlzOiBpbmhlcml0ZWREYXRhS2V5cyxcbiAgICBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQ6IGdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdCxcbiAgICB0aHJvd2VyOiB0aHJvd2VyLFxuICAgIGlzQXJyYXk6IGVzNS5pc0FycmF5LFxuICAgIGFzQXJyYXk6IGFzQXJyYXksXG4gICAgbm90RW51bWVyYWJsZVByb3A6IG5vdEVudW1lcmFibGVQcm9wLFxuICAgIGlzUHJpbWl0aXZlOiBpc1ByaW1pdGl2ZSxcbiAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgaXNFcnJvcjogaXNFcnJvcixcbiAgICBjYW5FdmFsdWF0ZTogY2FuRXZhbHVhdGUsXG4gICAgZXJyb3JPYmo6IGVycm9yT2JqLFxuICAgIHRyeUNhdGNoOiB0cnlDYXRjaCxcbiAgICBpbmhlcml0czogaW5oZXJpdHMsXG4gICAgd2l0aEFwcGVuZGVkOiB3aXRoQXBwZW5kZWQsXG4gICAgbWF5YmVXcmFwQXNFcnJvcjogbWF5YmVXcmFwQXNFcnJvcixcbiAgICB0b0Zhc3RQcm9wZXJ0aWVzOiB0b0Zhc3RQcm9wZXJ0aWVzLFxuICAgIGZpbGxlZFJhbmdlOiBmaWxsZWRSYW5nZSxcbiAgICB0b1N0cmluZzogc2FmZVRvU3RyaW5nLFxuICAgIGNhbkF0dGFjaFRyYWNlOiBjYW5BdHRhY2hUcmFjZSxcbiAgICBlbnN1cmVFcnJvck9iamVjdDogZW5zdXJlRXJyb3JPYmplY3QsXG4gICAgb3JpZ2luYXRlc0Zyb21SZWplY3Rpb246IG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uLFxuICAgIG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbjogbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uLFxuICAgIGNsYXNzU3RyaW5nOiBjbGFzc1N0cmluZyxcbiAgICBjb3B5RGVzY3JpcHRvcnM6IGNvcHlEZXNjcmlwdG9ycyxcbiAgICBoYXNEZXZUb29sczogdHlwZW9mIGNocm9tZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjaHJvbWUgJiZcbiAgICAgICAgICAgICAgICAgdHlwZW9mIGNocm9tZS5sb2FkVGltZXMgPT09IFwiZnVuY3Rpb25cIixcbiAgICBpc05vZGU6IGlzTm9kZSxcbiAgICBlbnY6IGVudixcbiAgICBnbG9iYWw6IGdsb2JhbE9iamVjdCxcbiAgICBnZXROYXRpdmVQcm9taXNlOiBnZXROYXRpdmVQcm9taXNlLFxuICAgIGRvbWFpbkJpbmQ6IGRvbWFpbkJpbmRcbn07XG5yZXQuaXNSZWNlbnROb2RlID0gcmV0LmlzTm9kZSAmJiAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoXCIuXCIpLm1hcChOdW1iZXIpO1xuICAgIHJldHVybiAodmVyc2lvblswXSA9PT0gMCAmJiB2ZXJzaW9uWzFdID4gMTApIHx8ICh2ZXJzaW9uWzBdID4gMCk7XG59KSgpO1xuXG5pZiAocmV0LmlzTm9kZSkgcmV0LnRvRmFzdFByb3BlcnRpZXMocHJvY2Vzcyk7XG5cbnRyeSB7dGhyb3cgbmV3IEVycm9yKCk7IH0gY2F0Y2ggKGUpIHtyZXQubGFzdExpbmVFcnJvciA9IGU7fVxubW9kdWxlLmV4cG9ydHMgPSByZXQ7XG5cbn0se1wiLi9lczVcIjoxM31dfSx7fSxbNF0pKDQpXG59KTsgICAgICAgICAgICAgICAgICAgIDtpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICE9PSBudWxsKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5QID0gd2luZG93LlByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmICE9PSBudWxsKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLlAgPSBzZWxmLlByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9ibHVlYmlyZC9qcy9icm93c2VyL2JsdWViaXJkLmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGphZGUgPSByZXF1aXJlKFwiRDpcXFxcd29ya3NwYWNlXFxcXGZvcmtcXFxccHJvamVjdGlvbi1ncmlkXFxcXG5vZGVfbW9kdWxlc1xcXFxqYWRlXFxcXGxpYlxcXFxydW50aW1lLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRlbXBsYXRlKGxvY2Fscykge1xudmFyIGJ1ZiA9IFtdO1xudmFyIGphZGVfbWl4aW5zID0ge307XG52YXIgamFkZV9pbnRlcnA7XG47dmFyIGxvY2Fsc19mb3Jfd2l0aCA9IChsb2NhbHMgfHwge30pOyhmdW5jdGlvbiAoY2FuY2VsQnV0dG9uVGV4dCwgc2F2ZUJ1dHRvblRleHQsIHZhbHVlKSB7XG5idWYucHVzaChcIjxmb3JtIHN0eWxlPVxcXCJwYWRkaW5nOiA1cHg7IGJhY2tncm91bmQ6ICNlMGUwZTBcXFwiIHJvbGU9XFxcImRpYWxvZ1xcXCIgY2xhc3M9XFxcImZvcm0taW5saW5lXFxcIj48aW5wdXQgdHlwZT1cXFwidGV4dFxcXCJcIiArIChqYWRlLmF0dHIoXCJ2YWx1ZVwiLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSkpICsgXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCBlZGl0b3JcXFwiPiZuYnNwPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnkgc2F2ZVxcXCI+XCIgKyAoamFkZS5lc2NhcGUobnVsbCA9PSAoamFkZV9pbnRlcnAgPSBzYXZlQnV0dG9uVGV4dCkgPyBcIlwiIDogamFkZV9pbnRlcnApKSArIFwiPC9idXR0b24+Jm5ic3A8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBjYW5jZWxcXFwiPlwiICsgKGphZGUuZXNjYXBlKG51bGwgPT0gKGphZGVfaW50ZXJwID0gY2FuY2VsQnV0dG9uVGV4dCkgPyBcIlwiIDogamFkZV9pbnRlcnApKSArIFwiPC9idXR0b24+PC9mb3JtPlwiKTt9LmNhbGwodGhpcyxcImNhbmNlbEJ1dHRvblRleHRcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLmNhbmNlbEJ1dHRvblRleHQ6dHlwZW9mIGNhbmNlbEJ1dHRvblRleHQhPT1cInVuZGVmaW5lZFwiP2NhbmNlbEJ1dHRvblRleHQ6dW5kZWZpbmVkLFwic2F2ZUJ1dHRvblRleHRcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLnNhdmVCdXR0b25UZXh0OnR5cGVvZiBzYXZlQnV0dG9uVGV4dCE9PVwidW5kZWZpbmVkXCI/c2F2ZUJ1dHRvblRleHQ6dW5kZWZpbmVkLFwidmFsdWVcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLnZhbHVlOnR5cGVvZiB2YWx1ZSE9PVwidW5kZWZpbmVkXCI/dmFsdWU6dW5kZWZpbmVkKSk7O3JldHVybiBidWYuam9pbihcIlwiKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2pzL3BvcHVwLWVkaXRvci9pbmRleC5qYWRlXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vZWRpdGFibGUubGVzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9lZGl0YWJsZS5sZXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vZWRpdGFibGUubGVzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9sZXNzL2VkaXRhYmxlLmxlc3NcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJ0YWJsZS5ncmlkIHRkLmdyaWQtZWRpdGFibGUtY2VsbCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbnRhYmxlLmdyaWQgdGQuZ3JpZC1lZGl0YWJsZS1jZWxsIC5ncmlkLWVkaXQtaWNvbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAycHg7XFxuICByaWdodDogMnB4O1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbn1cXG50YWJsZS5ncmlkIHRkLmdyaWQtZWRpdGFibGUtY2VsbDpob3ZlciAuZ3JpZC1lZGl0LWljb24ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jc3MtbG9hZGVyIS4uL34vbGVzcy1sb2FkZXIhLi4vbGVzcy9lZGl0YWJsZS5sZXNzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdibHVlYmlyZCcsXHJcbiAgJ2xpYi91bmRlcnNjb3JlJyxcclxuICAnY29tcG9uZW50L2dyaWQvcHJvamVjdGlvbi9iYXNlJyxcclxuICAnY29tcG9uZW50L2dyaWQvc2NoZW1hL3Byb3BlcnRpZXMuanMnLFxyXG5dLCBmdW5jdGlvbiAoUHJvbWlzZSwgXywgQmFzZVByb2plY3Rpb24sIHNjaGVtYVByb3BlcnRpZXMpIHtcclxuICB2YXIgTW9kZWwgPSBCYXNlUHJvamVjdGlvbi5leHRlbmQoe1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgJ2pzZGF0YS5xdWVyeSc6IHVuZGVmaW5lZCxcclxuICAgICAgJ2pzZGF0YS5lbnRpdHknOiB1bmRlZmluZWQsXHJcbiAgICAgICdqc2RhdGEub3B0aW9ucyc6IHVuZGVmaW5lZCxcclxuICAgICAgJ3NraXAnOiB1bmRlZmluZWQsXHJcbiAgICAgICd0YWtlJzogdW5kZWZpbmVkLFxyXG4gICAgICAnZmlsdGVyJzogdW5kZWZpbmVkLFxyXG4gICAgICAnb3JkZXJieSc6IFtdLFxyXG4gICAgICAnc2VsZWN0JzogW10sXHJcbiAgICB9LFxyXG4gICAgbmFtZTogJ2pzZGF0YScsXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBlbnRpdHkgPSB0aGlzLmdldCgnanNkYXRhLmVudGl0eScpO1xyXG4gICAgICB2YXIgb3B0aW9ucyA9IF8uZGVmYXVsdHModGhpcy5nZXQoJ2pzZGF0YS5vcHRpb25zJyksIHsgYWxsOiB0cnVlIH0pO1xyXG4gICAgICB2YXIgb3AgPSB7fTtcclxuXHJcbiAgICAgIHRoaXMucCRmZXRjaERhdGEgfHwgdGhpcy50cmlnZ2VyKCd1cGRhdGU6YmVnaW5uaW5nJyk7XHJcblxyXG4gICAgICB2YXIgdGFrZSA9IHRoaXMuZ2V0KCd0YWtlJyk7XHJcblxyXG4gICAgICBpZiAodGFrZSkge1xyXG4gICAgICAgIG9wLmxpbWl0ID0gdGFrZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNraXAgPSB0aGlzLmdldCgnc2tpcCcpO1xyXG5cclxuICAgICAgaWYgKHNraXApIHtcclxuICAgICAgICBvcC5vZmZzZXQgPSBza2lwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5nZXQoJ2ZpbHRlcicpO1xyXG5cclxuICAgICAgaWYgKGZpbHRlcikge1xyXG4gICAgICAgIG9wLndoZXJlID0gZmlsdGVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLmdldCgnanNkYXRhLnF1ZXJ5Jyk7XHJcblxyXG4gICAgICBpZiAocXVlcnkpIHtcclxuICAgICAgICBvcC5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgb3JkZXJieSA9IHRoaXMuZ2V0KCdvcmRlcmJ5Jyk7XHJcblxyXG4gICAgICBpZiAob3JkZXJieSAmJiBvcmRlcmJ5Lmxlbmd0aCkge1xyXG4gICAgICAgIG9wLm9yZGVyQnkgPSBfLnJlZHVjZShvcmRlcmJ5LCBmdW5jdGlvbiAoYXJyLCBvYmopIHtcclxuICAgICAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgIGFyci5wdXNoKFtrZXksIHZhbHVlID4gMCA/ICdBU0MnIDogJ0RFU0MnXSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgfSwgW10pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcCRmZXRjaERhdGEgPSB0aGlzLnAkZmV0Y2hEYXRhID0gZW50aXR5LmZpbmRBbGwob3AsIG9wdGlvbnMpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgIGlmICh0aGlzLnAkZmV0Y2hEYXRhID09PSBwJGZldGNoRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB7XHJcbiAgICAgICAgICAgICAgdmFsdWU6IGRhdGEsXHJcbiAgICAgICAgICAgICAgY291bnQ6IGRhdGEudG90YWxDb3VudCxcclxuICAgICAgICAgICAgICBzZWxlY3Q6IHNjaGVtYVByb3BlcnRpZXMuZnJvbShkYXRhKSxcclxuICAgICAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoXy5oYXMoZGF0YSwgJ3JhdycpKSB7XHJcbiAgICAgICAgICAgICAgZGVsdGEucmF3VmFsdWUgPSBkYXRhLnJhdztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBhdGNoKGRlbHRhKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgaWYgKHRoaXMucCRmZXRjaERhdGEgPT09IHAkZmV0Y2hEYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGF0Y2goeyBlcnJvciB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMucCRmZXRjaERhdGEgPT09IHAkZmV0Y2hEYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndXBkYXRlOmZpbmlzaGVkJywgdGhpcy5kYXRhLmdldCgnZXJyb3InKSk7XHJcbiAgICAgICAgICAgIHRoaXMucCRmZXRjaERhdGEgPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gTW9kZWw7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vanNkYXRhLmpzXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL3VuZGVyc2NvcmUnLFxyXG4gICdsaWIvYmFja2JvbmUnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9wcm9qZWN0aW9uL2Jhc2UnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9zY2hlbWEvcHJvcGVydGllcycsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL21vZGVsL3Jlc3BvbnNlJyxcclxuXSwgZnVuY3Rpb24gKF8sIEJhY2tib25lLCBCYXNlUHJvamVjdGlvbiwgc2NoZW1hUHJvcGVydGllcyAvKiAsIFJlc3BvbnNlICovKSB7XHJcbiAgdmFyIE1vZGVsID0gQmFzZVByb2plY3Rpb24uZXh0ZW5kKHtcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgIC8vIHRvZG8gW2FrYW1lbF0gY29uc2lkZXIgc3VwcG9ydGluZyBhIHNlbGVjdCBvbiB0aGlzIGxldmVsP1xyXG4gICAgICBtYXA6IF8uaWRlbnRpdHksXHJcbiAgICB9LFxyXG4gICAgbmFtZTogJ21hcCcsXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIC8vIE1vZGVsLl9fc3VwZXJfXy51cGRhdGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgIGlmIChNb2RlbC5fX3N1cGVyX18udXBkYXRlLmNhbGwodGhpcywgb3B0aW9ucykpIHtcclxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLnNyYy5kYXRhO1xyXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLmdldCgnbWFwJyk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gXy5pc0Z1bmN0aW9uKG1hcCkgPyBfLm1hcChtb2RlbC5nZXQoJ3ZhbHVlJyksIG1hcCkgOiBtb2RlbC5nZXQoJ3ZhbHVlJyk7XHJcblxyXG4gICAgICAgIHZhbHVlID0gXy5mbGF0dGVuKHZhbHVlKTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXRjaCh7XHJcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICBzZWxlY3Q6IF8ud2l0aG91dChzY2hlbWFQcm9wZXJ0aWVzLmZyb20odmFsdWUpLCAnJG1ldGFkYXRhJyksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gdG9kbyBbYWthbWVsXSB1bnNldCBvdXIgcHJvcGVydGllcyBvbmx5XHJcbiAgICAgICAgLy8gdGhpcy51bnNldCgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gTW9kZWw7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vbWFwLmpzXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL3VuZGVyc2NvcmUnLFxyXG4gICdsaWIvYmFja2JvbmUnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9wcm9qZWN0aW9uL2Jhc2UnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9zY2hlbWEvcHJvcGVydGllcycsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL21vZGVsL3Jlc3BvbnNlJyxcclxuXSwgZnVuY3Rpb24gKF8sIEJhY2tib25lLCBCYXNlUHJvamVjdGlvbiwgc2NoZW1hUHJvcGVydGllcyAvKiAsIFJlc3BvbnNlICovKSB7XHJcbiAgdmFyIE1vZGVsID0gQmFzZVByb2plY3Rpb24uZXh0ZW5kKHtcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICdza2lwJzogMCxcclxuICAgICAgJ3Rha2UnOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAnZmlsdGVyJzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9LFxyXG4gICAgICAnb3JkZXJieSc6IFtdLFxyXG4gICAgICAnc2VsZWN0JzogW10sXHJcbiAgICAgICdjb2x1bW4uc29ydGFibGUnOiB7fSxcclxuICAgIH0sXHJcbiAgICBuYW1lOiAnbWFwLXF1ZXJ5YWJsZScsXHJcbiAgICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIChsb2NhbCkge1xyXG4gICAgICBpZiAoXy5oYXMobG9jYWwsICdmaWx0ZXInKSkge1xyXG4gICAgICAgIGlmICghXy5pc0Z1bmN0aW9uKGxvY2FsLmZpbHRlcikpIHtcclxuICAgICAgICAgIGxvY2FsLmZpbHRlciA9IHRoaXMuZGVmYXVsdHMuZmlsdGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgLy8gTW9kZWwuX19zdXBlcl9fLnVwZGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgaWYgKE1vZGVsLl9fc3VwZXJfXy51cGRhdGUuY2FsbCh0aGlzLCBvcHRpb25zKSkge1xyXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuc3JjLmRhdGE7XHJcbiAgICAgICAgdmFyIG9yZGVyID0gXy5jaGFpbih0aGlzLmdldCgnb3JkZXJieScpKS5maXJzdCgpLnBhaXJzKCkuZmlyc3QoKS52YWx1ZSgpO1xyXG5cclxuICAgICAgICB2YXIgb3JkZXJLZXkgPSBfLmZpcnN0KG9yZGVyKTtcclxuICAgICAgICB2YXIgb3JkZXJEaXIgPSBfLmxhc3Qob3JkZXIpO1xyXG5cclxuICAgICAgICB2YXIgdmFsdWUgPSBfLmNoYWluKG1vZGVsLmdldCgndmFsdWUnKSkuZmlsdGVyKHRoaXMuZ2V0KCdmaWx0ZXInKSk7XHJcbiAgICAgICAgdmFyIHNvcnRGdW5jID0gdGhpcy5nZXQoJ2NvbHVtbi5zb3J0YWJsZScpW29yZGVyS2V5XTtcclxuXHJcbiAgICAgICAgaWYgKG9yZGVyS2V5KSB7XHJcbiAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHNvcnRGdW5jKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IF8uY2hhaW4oc29ydEZ1bmModmFsdWUudmFsdWUoKSwgb3JkZXJEaXIpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc29ydEJ5KG9yZGVyS2V5KTtcclxuICAgICAgICAgICAgaWYgKG9yZGVyRGlyID09PSAtMSkge1xyXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YWx1ZSA9IHZhbHVlXHJcbiAgICAgICAgICAucmVzdCh0aGlzLmdldCgnc2tpcCcpKVxyXG4gICAgICAgICAgLmZpcnN0KHRoaXMuZ2V0KCd0YWtlJykpXHJcbiAgICAgICAgICAudmFsdWUoKTtcclxuXHJcbiAgICAgICAgdmFyIHNlbGVjdCA9IHRoaXMuZ2V0KCdzZWxlY3QnKTtcclxuICAgICAgICBpZiAoIV8uc2l6ZShzZWxlY3QpKSB7XHJcbiAgICAgICAgICBzZWxlY3QgPSBzY2hlbWFQcm9wZXJ0aWVzLmZyb20odmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wYXRjaCh7XHJcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICBzZWxlY3Q6IHNlbGVjdCxcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB0b2RvIFtha2FtZWxdIHVuc2V0IG91ciBwcm9wZXJ0aWVzIG9ubHlcclxuICAgICAgICAvLyB0aGlzLnVuc2V0KCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBNb2RlbDtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvcHJvamVjdGlvbi9tZW1vcnktcXVlcnlhYmxlLmpzXG4gKiovIiwiZGVmaW5lKFsnY29tcG9uZW50L2dyaWQvcHJvamVjdGlvbi9iYXNlJ10sIGZ1bmN0aW9uIChCYXNlUHJvamVjdGlvbikge1xyXG4gIHZhciBNb2RlbCA9IEJhc2VQcm9qZWN0aW9uLmV4dGVuZCh7XHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICBzZWVkOiBbXSxcclxuICAgIH0sXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKCd1cGRhdGU6YmVnaW5uaW5nJyk7XHJcblxyXG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgnc2VlZCcpO1xyXG5cclxuICAgICAgdGhpcy5kYXRhLnNldCh7XHJcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgIGNvdW50OiB2YWx1ZS5sZW5ndGgsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKCd1cGRhdGU6ZmluaXNoZWQnKTtcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBNb2RlbDtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvcHJvamVjdGlvbi9tZW1vcnkuanNcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2xpYi9iYWNrYm9uZScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL3Byb2plY3Rpb24vYmFzZScsXHJcbl0sIGZ1bmN0aW9uIChfLCBCYWNrYm9uZSwgQmFzZVByb2plY3Rpb24pIHtcclxuICB2YXIgd3JkcyA9IFsndHJvdWJsZXMnLCAna2FobHVhJywgJ3BvbmNobycsICdzdXppZScsICdiYWhleXlhJ107XHJcbiAgdmFyIGlkeCA9IDA7XHJcblxyXG4gIGZ1bmN0aW9uIHJhbmRvbVJvdygpIHtcclxuICAgIHZhciB3cmQxID0gd3Jkc1tfLnJhbmRvbSgwLCB3cmRzLmxlbmd0aCAtIDEpXTtcclxuICAgIHZhciB3cmQyID0gd3Jkc1tfLnJhbmRvbSgwLCB3cmRzLmxlbmd0aCAtIDEpXTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpbmRleDogaWR4KyssXHJcbiAgICAgIG5hbWU6IHdyZDEgKyAnICcgKyB3cmQyLFxyXG4gICAgICBhZ2U6IF8ucmFuZG9tKDAsIDIyKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB2YXIgTW9kZWwgPSBCYXNlUHJvamVjdGlvbi5leHRlbmQoe1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgbjogNTAwMCxcclxuICAgIH0sXHJcbiAgICBuYW1lOiAnbW9jaycsXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKCd1cGRhdGU6YmVnaW5uaW5nJyk7XHJcbiAgICAgIHZhciB2YWx1ZSA9IFtdO1xyXG5cclxuICAgICAgXyh0aGlzLmdldCgnbicpKS50aW1lcyhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFsdWUucHVzaChyYW5kb21Sb3coKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5kYXRhLnNldCh7XHJcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgIGNvdW50OiB2YWx1ZS5sZW5ndGgsXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ3VwZGF0ZTpmaW5pc2hlZCcpO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIE1vZGVsO1xyXG59KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy9wcm9qZWN0aW9uL21vY2suanNcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdibHVlYmlyZCcsXHJcbiAgJ2xpYi91bmRlcnNjb3JlJyxcclxuICAnbGliL2JhY2tib25lJyxcclxuICAnbGliL2pxdWVyeScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL3Byb2plY3Rpb24vYmFzZScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL3NjaGVtYS9wcm9wZXJ0aWVzJyxcclxuXSwgZnVuY3Rpb24gKFByb21pc2UsIF8sIEJhY2tib25lLCAkLCBCYXNlUHJvamVjdGlvbiwgc2NoZW1hUHJvcGVydGllcykge1xyXG4gIHZhciBNb2RlbCA9IEJhc2VQcm9qZWN0aW9uLmV4dGVuZCh7XHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICB2ZXJiOiAnZ2V0JyxcclxuICAgICAgdXJsOiB1bmRlZmluZWQsXHJcbiAgICAgIHNraXA6IHVuZGVmaW5lZCxcclxuICAgICAgdGFrZTogdW5kZWZpbmVkLFxyXG4gICAgICBmaWx0ZXI6IHVuZGVmaW5lZCxcclxuICAgICAgb3JkZXJieTogW10sXHJcbiAgICAgIHNlbGVjdDogW10sXHJcbiAgICB9LFxyXG4gICAgbmFtZTogJ29kYXRhJyxcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLnAkZmV0Y2hEYXRhIHx8IHRoaXMudHJpZ2dlcigndXBkYXRlOmJlZ2lubmluZycpO1xyXG5cclxuICAgICAgdmFyIHVybCA9IHRoaXMuZ2V0KCd1cmwnKTtcclxuXHJcbiAgICAgIHVybCA9IF8uaXNGdW5jdGlvbih1cmwpID8gdXJsKCkgOiB1cmw7XHJcbiAgICAgIHZhciBvcCA9IHtcclxuICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAkZm9ybWF0OiAnanNvbicsXHJcbiAgICAgIC8vIHRvZG8gW2FrYW1lbF0gdGhpcyBpcyBvZGF0YSB2MyBzcGVjaWZpY1xyXG4gICAgICAgICRjb3VudDogdHJ1ZSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciB0YWtlID0gdGhpcy5nZXQoJ3Rha2UnKTtcclxuICAgICAgaWYgKHRha2UpIHtcclxuICAgICAgICBvcC4kdG9wID0gdGFrZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNraXAgPSB0aGlzLmdldCgnc2tpcCcpO1xyXG4gICAgICBpZiAoc2tpcCkge1xyXG4gICAgICAgIG9wLiRza2lwID0gc2tpcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gdG9kbyBbYWthbWVsXSBvbmx5IHN1cHBvcnRzIG9uZSBvcmRlciBjb2x1bW5cclxuICAgICAgdmFyIG9yZGVyYnkgPSB0aGlzLmdldCgnb3JkZXJieScpO1xyXG4gICAgICBpZiAoXy5zaXplKG9yZGVyYnkpKSB7XHJcbiAgICAgICAgdmFyIGNvbCA9IF8uZmlyc3Qob3JkZXJieSk7XHJcbiAgICAgICAgdmFyIGtleSA9IF8ua2V5cyhjb2wpWzBdO1xyXG4gICAgICAgIHZhciBkaXIgPSBjb2xba2V5XTtcclxuXHJcbiAgICAgICAgb3AuJG9yZGVyYnkgPSBrZXkgKyAnICcgKyAoZGlyID4gMCA/ICdhc2MnIDogJ2Rlc2MnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHAkZmV0Y2hEYXRhID0gdGhpcy5wJGZldGNoRGF0YSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAkLmdldEpTT04ob3AudXJsLCBfLm9taXQob3AsICd1cmwnKSlcclxuICAgICAgICAgIC5zdWNjZXNzKHJlc29sdmUpXHJcbiAgICAgICAgICAuZmFpbChmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3JUaHJvd24pKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgaWYgKHAkZmV0Y2hEYXRhID09PSB0aGlzLnAkZmV0Y2hEYXRhKSB7XHJcbiAgICAgICAgICB2YXIgZGVsdGEgPSB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhLnZhbHVlLFxyXG4gICAgICAgICAgICByYXdWYWx1ZTogZGF0YSxcclxuICAgICAgICAgICAgc2VsZWN0OiBzY2hlbWFQcm9wZXJ0aWVzLmZyb20oZGF0YS52YWx1ZSksXHJcbiAgICAgICAgICAgIGNvdW50OiBkYXRhWydAb2RhdGEuY291bnQnXSxcclxuICAgICAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICB0aGlzLnBhdGNoKGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0uYmluZCh0aGlzKSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgaWYgKHAkZmV0Y2hEYXRhID09PSB0aGlzLnAkZmV0Y2hEYXRhKSB7XHJcbiAgICAgICAgICB0aGlzLnBhdGNoKHsgZXJyb3I6IGVycm9yIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfS5iaW5kKHRoaXMpKS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAocCRmZXRjaERhdGEgPT09IHRoaXMucCRmZXRjaERhdGEpIHtcclxuICAgICAgICAgIHRoaXMudHJpZ2dlcigndXBkYXRlOmZpbmlzaGVkJywgdGhpcy5kYXRhLmdldCgnZXJyb3InKSk7XHJcbiAgICAgICAgICB0aGlzLnAkZmV0Y2hEYXRhID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gTW9kZWw7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vb2RhdGEuanNcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2xpYi9iYWNrYm9uZScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL3Byb2plY3Rpb24vYmFzZScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL3NjaGVtYS9wcm9wZXJ0aWVzJyxcclxuICAnY29tcG9uZW50L2dyaWQvbW9kZWwvcmVzcG9uc2UnLFxyXG5dLCBmdW5jdGlvbiAoXywgQmFja2JvbmUsIEJhc2VQcm9qZWN0aW9uIC8qICwgc2NoZW1hUHJvcGVydGllcywgUmVzcG9uc2UgKi8pIHtcclxuICB2YXIgTW9kZWwgPSBCYXNlUHJvamVjdGlvbi5leHRlbmQoe1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgJ3BhZ2Uuc2l6ZSc6IDIwLFxyXG4gICAgICAncGFnZS5udW1iZXInOiAwLCAvLyB6ZXJvIGJhc2VkXHJcbiAgICB9LFxyXG4gICAgbmFtZTogJ3BhZ2UnLFxyXG4gICAgLy8gdG9kbyBbYWthbWVsXSB3aGF0IGlmIHdlIHBpcGVkIGFmdGVyIHRoZSBkYXRhIHdhcyBzZXQ/XHJcbiAgICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIChsb2NhbCwgb3RoZXIpIHtcclxuICAgICAgdmFyIHNpemUgPSBfLmhhcyhsb2NhbCwgJ3BhZ2Uuc2l6ZScpID8gbG9jYWxbJ3BhZ2Uuc2l6ZSddIDogdGhpcy5nZXQoJ3BhZ2Uuc2l6ZScpO1xyXG4gICAgICB2YXIgbnVtYmVyID0gXy5oYXMobG9jYWwsICdwYWdlLm51bWJlcicpID8gbG9jYWxbJ3BhZ2UubnVtYmVyJ10gOiB0aGlzLmdldCgncGFnZS5udW1iZXInKTtcclxuXHJcbiAgICAgIC8vIHRvZG8gW2FrYW1lbF0gc2FuZXRpemUgc2l6ZSBhbmQgbnVtYmVyIGhlcmVcclxuICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIDApO1xyXG4gICAgICBudW1iZXIgPSBNYXRoLm1heChudW1iZXIsIDApO1xyXG5cclxuICAgICAgXy5leHRlbmQob3RoZXIsIHtcclxuICAgICAgICB0YWtlOiBzaXplLFxyXG4gICAgICAgIHNraXA6IHNpemUgKiBudW1iZXIsXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgdmFyIG1vZGVsID0gdGhpcy5zcmMuZGF0YTtcclxuICAgICAgdmFyIHNpemUgPSBNYXRoLm1heCh0aGlzLmdldCgncGFnZS5zaXplJyksIDApO1xyXG4gICAgICB2YXIgY291bnQgPSBNYXRoLm1heCgxLCBtb2RlbC5nZXQoJ2NvdW50JykpO1xyXG4gICAgICB2YXIgbnVtYmVyID0gTWF0aC5tYXgodGhpcy5nZXQoJ3BhZ2UubnVtYmVyJyksIDApO1xyXG4gICAgICB2YXIgcGFnZUNvdW50ID0gTWF0aC5jZWlsKGNvdW50IC8gc2l6ZSk7XHJcbiAgICAgIHZhciBwYWdlTnVtYmVyID0gTWF0aC5taW4obnVtYmVyLCBwYWdlQ291bnQgLSAxKTtcclxuXHJcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgaWYgKG9wdGlvbnMuZGVlcCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNyYykge1xyXG4gICAgICAgICAgdGhpcy5zcmMuc2V0KHtcclxuICAgICAgICAgICAgdGFrZTogc2l6ZSxcclxuICAgICAgICAgICAgc2tpcDogc2l6ZSAqIHBhZ2VOdW1iZXIsXHJcbiAgICAgICAgICB9LCB7IHNpbGVudDogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE1vZGVsLl9fc3VwZXJfXy51cGRhdGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgIC8vIGlmIHdlIGNhbWUgaW4gd2l0aCBhbiB1cGRhdGU6ZGVlcFxyXG4gICAgICBpZiAoTW9kZWwuX19zdXBlcl9fLnVwZGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpKSB7XHJcbiAgICAgICAgdGhpcy5wYXRjaCh7ICdwYWdlLmNvdW50JzogcGFnZUNvdW50IH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHRvZG8gW2FrYW1lbF0gdW5zZXQgb3VyIHByb3BlcnRpZXMgb25seVxyXG4gICAgICAgIC8vIHRoaXMudW5zZXQoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIE1vZGVsO1xyXG59KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy9wcm9qZWN0aW9uL3BhZ2UuanNcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2xpYi9iYWNrYm9uZScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL3Byb2plY3Rpb24vYmFzZScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL3NjaGVtYS9wcm9wZXJ0aWVzJyxcclxuICAnY29tcG9uZW50L2dyaWQvbW9kZWwvcmVzcG9uc2UnLFxyXG5dLCBmdW5jdGlvbiAoXywgQmFja2JvbmUsIEJhc2VQcm9qZWN0aW9uIC8qICwgc2NoZW1hUHJvcGVydGllcywgUmVzcG9uc2UgKi8pIHtcclxuICB2YXIgTW9kZWwgPSBCYXNlUHJvamVjdGlvbi5leHRlbmQoe1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgJ3Byb3BlcnR5LnRlbXBsYXRlJzoge30sXHJcbiAgICB9LFxyXG4gICAgbmFtZTogJ3Byb3BlcnR5LXRlbXBsYXRlJyxcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgLy8gTW9kZWwuX19zdXBlcl9fLnVwZGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgaWYgKE1vZGVsLl9fc3VwZXJfXy51cGRhdGUuY2FsbCh0aGlzLCBvcHRpb25zKSkge1xyXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuc3JjLmRhdGE7XHJcbiAgICAgICAgdmFyIG9wdCA9IHRoaXMuZ2V0KCdwcm9wZXJ0eS50ZW1wbGF0ZScpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IF8ubWFwKG1vZGVsLmdldCgndmFsdWUnKSwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgIHZhciByZXQgPSBfLmNsb25lKGl0ZW0pO1xyXG5cclxuICAgICAgICAgIF8uZWFjaChvcHQsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChfLmhhcyhyZXQsIGtleSkpIHtcclxuICAgICAgICAgICAgICB2YXIgcmVzID0gdmFsdWUoe1xyXG4gICAgICAgICAgICAgICAgbW9kZWw6IGl0ZW0sXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eToga2V5LFxyXG4gICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIV8uaXNPYmplY3QocmV0W2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gbmV3IE9iamVjdChyZXRba2V5XSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChyZXRba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgICAgb2JqLiR1bmRlZmluZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfLmlzTnVsbChyZXRba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgICAgb2JqLiRudWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IG9iajtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHJldFtrZXldLiRodG1sID0gcmVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnBhdGNoKHsgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHRvZG8gW2FrYW1lbF0gdW5zZXQgb3VyIHByb3BlcnRpZXMgb25seVxyXG4gICAgICAgIC8vIHRoaXMudW5zZXQoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIE1vZGVsO1xyXG59KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy9wcm9qZWN0aW9uL3Byb3BlcnR5LXRlbXBsYXRlLmpzXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL3VuZGVyc2NvcmUnLFxyXG4gICdsaWIvYmFja2JvbmUnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9wcm9qZWN0aW9uL2Jhc2UnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9sYXlvdXQvdGVtcGxhdGUvc2VsZWN0YWJsZS5qYWRlJyxcclxuXSwgZnVuY3Rpb24gKF8sIEJhY2tib25lLCBCYXNlUHJvamVjdGlvbiwgc2VsZWN0YWJsZVRlbXBsYXRlKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgTW9kZWwgPSBCYXNlUHJvamVjdGlvbi5leHRlbmQoe1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgJ2NvbHVtbi5jaGVja2VkJzogJ2NoZWNrYm94JywgICAvLyB0aGUgY2hlY2tib3ggY29sdW1uXHJcbiAgICAgICdyb3cuY2hlY2suaWQnOiAnSWQnLFxyXG4gICAgICAncm93LmNoZWNrLmxpc3QnOiBbXSxcclxuICAgICAgJ3Jvdy5jaGVjay5jaGVja2VkLmFsbCc6IGZhbHNlLCAvLyB1c2VkIHRvIHN0b3JlIHVzZXIncyBjaGVjayB2YWx1ZSBmb3IgdGhlIHNwZWNpYWwgY2FzZSBubyByb3dzIG9yIGFsbCByb3dzIGlzIGRpc2FibGVkXHJcbiAgICAgICdyb3cuY2hlY2suc2luZ2xlJzogZmFsc2UsXHJcbiAgICAgICdyb3cuY2hlY2suYWxsb3cnOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgbmFtZTogJ3Jvdy1jaGVjaycsXHJcbiAgICBldmVudHM6IHtcclxuICAgICAgJ2xheW91dDpjbGljazpjZWxsJzogJ3RkQ2xpY2snLFxyXG4gICAgICAnbGF5b3V0OmNsaWNrOmhlYWRlcic6ICd0aENsaWNrJyxcclxuICAgIH0sXHJcbiAgICByZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLnNldCh7XHJcbiAgICAgICAgJ3Jvdy5jaGVjay5jaGVja2VkLmFsbCc6IGZhbHNlLFxyXG4gICAgICAgICdyb3cuY2hlY2subGlzdCc6IFtdLFxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIC8vIE1vZGVsLl9fc3VwZXJfXy51cGRhdGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgIGlmIChNb2RlbC5fX3N1cGVyX18udXBkYXRlLmNhbGwodGhpcywgb3B0aW9ucykpIHtcclxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLnNyYy5kYXRhO1xyXG4gICAgICAgIHZhciBjaGVja0lkID0gdGhpcy5nZXQoJ3Jvdy5jaGVjay5pZCcpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IG1vZGVsLmdldCgndmFsdWUnKTtcclxuICAgICAgICB2YXIgaWRzID0gXy5wbHVjayh2YWx1ZSwgY2hlY2tJZCk7XHJcbiAgICAgICAgdmFyIGNoZWNrZWQgPSBfLmludGVyc2VjdGlvbih0aGlzLmdldCgncm93LmNoZWNrLmxpc3QnKSwgaWRzKTtcclxuICAgICAgICB2YXIgY2hlY2tlZExvb2t1cCA9IF8ub2JqZWN0KGNoZWNrZWQsIFtdKTtcclxuICAgICAgICB2YXIgY29sID0gdGhpcy5nZXQoJ2NvbHVtbi5jaGVja2VkJyk7XHJcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBfLmNsb25lKG1vZGVsLmdldCgnY29sdW1ucycpKTtcclxuICAgICAgICB2YXIgY2hlY2tlZEFsbCA9IHZhbHVlLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgdmFyIGhhc0NoZWNrYm94YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBjaGVja2JveEFsbG93ID0gdGhpcy5nZXQoJ3Jvdy5jaGVjay5hbGxvdycpO1xyXG4gICAgICAgIHZhciBjaGVja2JveENvbHVtbiA9IF8uZmluZChjb2x1bW5zLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgcmV0dXJuIGl0ZW0ucHJvcGVydHkgPT09IGNvbDtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgaXNTaW5nbGUgPSB0aGlzLmdldCgncm93LmNoZWNrLnNpbmdsZScpO1xyXG5cclxuICAgICAgICB0aGlzLnNldCgncm93LmNoZWNrLmxpc3QnLCBjaGVja2VkLCB7IHNpbGVudDogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgLy8gdG9kbyBbYWthbWVsXSBpdCBpcyBub3QgY2xlYXIgaG93ICdoYXNDaGVja2JveGFibGUnIGlzIHVzZWRcclxuICAgICAgICB2YWx1ZSA9IF8ubWFwKHZhbHVlLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgdmFyIHJldCA9IF8uY2xvbmUoaXRlbSk7XHJcbiAgICAgICAgICB2YXIgY2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgdmFyIGRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSBfLmlzRnVuY3Rpb24oY2hlY2tib3hBbGxvdykgPyBjaGVja2JveEFsbG93KHJldCkgOiBjaGVja2JveEFsbG93O1xyXG5cclxuICAgICAgICAgIGlmIChpc0FsbG93ZWQpIHtcclxuICAgICAgICAgICAgY2hlY2tlZCA9IF8uaGFzKGNoZWNrZWRMb29rdXAsIHJldFtjaGVja0lkXSk7XHJcbiAgICAgICAgICAgIGNoZWNrZWRBbGwgPSBjaGVja2VkQWxsICYmIGNoZWNrZWQ7XHJcbiAgICAgICAgICAgIGRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGhhc0NoZWNrYm94YWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgdW5pcXVlSWQgPSBtb2RlbC5nZXQoJ2ExMXkuc2VsZWN0aW9uLnVuaXF1ZUlkJyk7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbGxlZElkID0gKHVuaXF1ZUlkIHx8ICcnKS5jb25jYXQocmV0W2NoZWNrSWRdKTtcclxuXHJcbiAgICAgICAgICAgIHJldFtjb2xdID0gXy5leHRlbmQoe30sIHJldFtjb2xdLCB7XHJcbiAgICAgICAgICAgICAgJGh0bWw6IHNlbGVjdGFibGVUZW1wbGF0ZShfLnBpY2soe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogaXNTaW5nbGUgPyAncmFkaW8nIDogJ2NoZWNrYm94JyxcclxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNoZWNrZWQsXHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXHJcbiAgICAgICAgICAgICAgICBsYWJlbGxlZElkOiBsYWJlbGxlZElkLFxyXG4gICAgICAgICAgICAgIH0sIEJvb2xlYW4pKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gc2V0IHRoZSBjaGVja2JveCBpbiB0aFxyXG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChjaGVja2JveENvbHVtbikpIHtcclxuICAgICAgICAgIGlmIChpc1NpbmdsZSkge1xyXG4gICAgICAgICAgICBjaGVja2JveENvbHVtbi4kaHRtbCA9ICc8c3Bhbi8+JztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IF8uc2l6ZShpZHMpID09PSAwO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxTdHJpbmcgPSBtb2RlbC5nZXQoJ2ExMXkuc2VsZWN0aW9uLnNlbGVjdEFsbExhYmVsJyk7XHJcbiAgICAgICAgICAgIGlmIChoYXNDaGVja2JveGFibGUpIHtcclxuICAgICAgICAgICAgICBjaGVja2JveENvbHVtbi4kaHRtbCA9IHNlbGVjdGFibGVUZW1wbGF0ZShfLnBpY2soe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcclxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNoZWNrZWRBbGwsXHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXHJcbiAgICAgICAgICAgICAgICBsYWJlbFN0cmluZzogbGFiZWxTdHJpbmcsXHJcbiAgICAgICAgICAgICAgfSwgQm9vbGVhbikpO1xyXG4gICAgICAgICAgICAgIGlmICghY2hlY2tlZEFsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzWydyb3cuY2hlY2suY2hlY2tlZC5hbGwnXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjaGVja2JveENvbHVtbi4kaHRtbCA9IHNlbGVjdGFibGVUZW1wbGF0ZShfLnBpY2soe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcclxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHRoaXMuZ2V0KCdyb3cuY2hlY2suY2hlY2tlZC5hbGwnKSxcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcclxuICAgICAgICAgICAgICAgIGxhYmVsU3RyaW5nOiBsYWJlbFN0cmluZyxcclxuICAgICAgICAgICAgICB9LCBCb29sZWFuKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucGF0Y2goe1xyXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgY29sdW1uczogY29sdW1ucyxcclxuICAgICAgICAgICdyb3cuY2hlY2suYWxsb3cnOiBjaGVja2JveEFsbG93LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHRvZG8gW2FrYW1lbF0gdW5zZXQgb3VyIHByb3BlcnRpZXMgb25seVxyXG4gICAgICAgIC8vIHRoaXMudW5zZXQoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRkQ2xpY2s6IGZ1bmN0aW9uIChlLCBhcmcpIHtcclxuICAgICAgdmFyIGNoZWNrYm94UHJvcGVydHkgPSB0aGlzLmdldCgnY29sdW1uLmNoZWNrZWQnKTtcclxuICAgICAgdmFyIGlzU2luZ2xlID0gdGhpcy5nZXQoJ3Jvdy5jaGVjay5zaW5nbGUnKTtcclxuXHJcbiAgICAgIGlmIChhcmcucHJvcGVydHkgPT09IGNoZWNrYm94UHJvcGVydHkpIHtcclxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuZ2V0KCdyb3cuY2hlY2subGlzdCcpO1xyXG4gICAgICAgIHZhciBpZCA9IGFyZy5tb2RlbFt0aGlzLmdldCgncm93LmNoZWNrLmlkJyldO1xyXG5cclxuICAgICAgICBpZiAoaXNTaW5nbGUpIHtcclxuICAgICAgICAgIHRoaXMuc2V0KHsgJ3Jvdy5jaGVjay5saXN0JzogW2lkXSB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5zZXQoe1xyXG4gICAgICAgICAgICAncm93LmNoZWNrLmxpc3QnOiBhcmcuY2hlY2tlZCA/IGxpc3QuY29uY2F0KFtpZF0pIDogXy53aXRob3V0KGxpc3QsIGlkKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRoQ2xpY2s6IGZ1bmN0aW9uIChlLCBhcmcpIHtcclxuICAgICAgdmFyIGNoZWNrYm94UHJvcGVydHkgPSB0aGlzLmdldCgnY29sdW1uLmNoZWNrZWQnKTtcclxuXHJcbiAgICAgIGlmIChhcmcucHJvcGVydHkgPT09IGNoZWNrYm94UHJvcGVydHkpIHtcclxuICAgICAgICB2YXIgbGlzdCA9IFtdO1xyXG5cclxuICAgICAgICBpZiAoYXJnLmNoZWNrZWQpIHtcclxuICAgICAgICAgIHZhciBjaGVja0lkID0gdGhpcy5nZXQoJ3Jvdy5jaGVjay5pZCcpO1xyXG4gICAgICAgICAgLy8gVE9ETyBbYWthbWVsXSB0aGlzIGNvbmNlcHQgb2YgY2hlY2sgYWxsb3cgaXMgc3RyYW5nZVxyXG4gICAgICAgICAgdmFyIGNoZWNrYm94QWxsb3cgPSB0aGlzLmdldCgncm93LmNoZWNrLmFsbG93Jyk7XHJcblxyXG4gICAgICAgICAgLy8gZ2V0IHRoZSBsaXN0IG9mIGFsbG93ZWQgcm93cycgaWRcclxuICAgICAgICAgIGxpc3QgPSBfLmNoYWluKHRoaXMuZGF0YS5nZXQoJ3ZhbHVlJykpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICByZXR1cm4gKF8uaXNGdW5jdGlvbihjaGVja2JveEFsbG93KSA/IGNoZWNrYm94QWxsb3coaXRlbSkgOiBjaGVja2JveEFsbG93KSAmJiAhXy5pc1VuZGVmaW5lZChpdGVtW2NoZWNrSWRdKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBpdGVtW2NoZWNrSWRdO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudmFsdWUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0KHtcclxuICAgICAgICAgICdyb3cuY2hlY2subGlzdCc6IGxpc3QsXHJcbiAgICAgICAgICAncm93LmNoZWNrLmNoZWNrZWQuYWxsJzogYXJnLmNoZWNrZWQsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBNb2RlbDtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvcHJvamVjdGlvbi9yb3ctY2hlY2tib3guanNcbiAqKi8iLCJ2YXIgamFkZSA9IHJlcXVpcmUoXCJEOlxcXFx3b3Jrc3BhY2VcXFxcZm9ya1xcXFxwcm9qZWN0aW9uLWdyaWRcXFxcbm9kZV9tb2R1bGVzXFxcXGphZGVcXFxcbGliXFxcXHJ1bnRpbWUuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7XG52YXIgYnVmID0gW107XG52YXIgamFkZV9taXhpbnMgPSB7fTtcbnZhciBqYWRlX2ludGVycDtcbjt2YXIgbG9jYWxzX2Zvcl93aXRoID0gKGxvY2FscyB8fCB7fSk7KGZ1bmN0aW9uIChjaGVja2VkLCBkaXNhYmxlZCwgbGFiZWxTdHJpbmcsIGxhYmVsbGVkSWQsIHR5cGUpIHtcbmJ1Zi5wdXNoKFwiPGlucHV0XCIgKyAoamFkZS5hdHRyKFwidHlwZVwiLCB0eXBlLCB0cnVlLCB0cnVlKSkgKyAoamFkZS5hdHRyKFwiY2hlY2tlZFwiLCBjaGVja2VkLCB0cnVlLCB0cnVlKSkgKyAoamFkZS5hdHRyKFwiZGlzYWJsZWRcIiwgZGlzYWJsZWQsIHRydWUsIHRydWUpKSArIChqYWRlLmF0dHIoXCJhcmlhLWxhYmVsbGVkYnlcIiwgbGFiZWxsZWRJZCwgdHJ1ZSwgdHJ1ZSkpICsgKGphZGUuYXR0cihcImFyaWEtbGFiZWxcIiwgbGFiZWxTdHJpbmcsIHRydWUsIHRydWUpKSArIFwiIGNsYXNzPVxcXCJjb2x1bW4tc2VsZWN0aW9uXFxcIj5cIik7fS5jYWxsKHRoaXMsXCJjaGVja2VkXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC5jaGVja2VkOnR5cGVvZiBjaGVja2VkIT09XCJ1bmRlZmluZWRcIj9jaGVja2VkOnVuZGVmaW5lZCxcImRpc2FibGVkXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC5kaXNhYmxlZDp0eXBlb2YgZGlzYWJsZWQhPT1cInVuZGVmaW5lZFwiP2Rpc2FibGVkOnVuZGVmaW5lZCxcImxhYmVsU3RyaW5nXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC5sYWJlbFN0cmluZzp0eXBlb2YgbGFiZWxTdHJpbmchPT1cInVuZGVmaW5lZFwiP2xhYmVsU3RyaW5nOnVuZGVmaW5lZCxcImxhYmVsbGVkSWRcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLmxhYmVsbGVkSWQ6dHlwZW9mIGxhYmVsbGVkSWQhPT1cInVuZGVmaW5lZFwiP2xhYmVsbGVkSWQ6dW5kZWZpbmVkLFwidHlwZVwiIGluIGxvY2Fsc19mb3Jfd2l0aD9sb2NhbHNfZm9yX3dpdGgudHlwZTp0eXBlb2YgdHlwZSE9PVwidW5kZWZpbmVkXCI/dHlwZTp1bmRlZmluZWQpKTs7cmV0dXJuIGJ1Zi5qb2luKFwiXCIpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vanMvbGF5b3V0L3RlbXBsYXRlL3NlbGVjdGFibGUuamFkZVxuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2xpYi9iYWNrYm9uZScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL3Byb2plY3Rpb24vYmFzZScsXHJcbl0sIGZ1bmN0aW9uIChfLCBCYWNrYm9uZSwgQmFzZVByb2plY3Rpb24pIHtcclxuICB2YXIgTW9kZWwgPSBCYXNlUHJvamVjdGlvbi5leHRlbmQoe1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgJ3Jvdy5jbGFzc2VzJzoge30sXHJcbiAgICB9LFxyXG4gICAgbmFtZTogJ3JvdycsXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIGlmIChNb2RlbC5fX3N1cGVyX18udXBkYXRlLmNhbGwodGhpcywgb3B0aW9ucykpIHtcclxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLnNyYy5kYXRhO1xyXG4gICAgICAgIHZhciByb3dzID0gbW9kZWwuZ2V0KCd2YWx1ZScpO1xyXG5cclxuICAgICAgICBfLmVhY2gocm93cywgcm93ID0+IHtcclxuICAgICAgICAgIHZhciB0eXBlID0gXy5jaGFpbihyb3cpLnJlc3VsdCgnJG1ldGFkYXRhJykucmVzdWx0KCd0eXBlJykudmFsdWUoKTtcclxuXHJcbiAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0eXBlKSkge1xyXG4gICAgICAgICAgICByb3cuJG1ldGFkYXRhID0gXy5leHRlbmQoe30sIHJvdy4kbWV0YWRhdGEsIHtcclxuICAgICAgICAgICAgICB0eXBlOiAncm93JyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF8uZWFjaChyb3dzLCAocm93KSA9PiB7XHJcbiAgICAgICAgICB2YXIgY2xhc3NBcnIgPSBbXTtcclxuICAgICAgICAgIHZhciBvcmlnaW5DbGFzcyA9IF8uY2hhaW4ocm93KVxyXG4gICAgICAgICAgICAucmVzdWx0KCckbWV0YWRhdGEnKVxyXG4gICAgICAgICAgICAucmVzdWx0KCdhdHRyJylcclxuICAgICAgICAgICAgLnJlc3VsdCgnY2xhc3MnKVxyXG4gICAgICAgICAgICAudmFsdWUoKTtcclxuXHJcbiAgICAgICAgICBpZiAob3JpZ2luQ2xhc3MpIHtcclxuICAgICAgICAgICAgY2xhc3NBcnIucHVzaChvcmlnaW5DbGFzcyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIGNsYXNzZXNSdWxlID0gdGhpcy5nZXQoJ3Jvdy5jbGFzc2VzJyk7XHJcblxyXG4gICAgICAgICAgdmFyIGNoZWNrSWQgPSB0aGlzLmdldCgncm93LmNoZWNrLmlkJyk7XHJcbiAgICAgICAgICB2YXIgY2hlY2tib3hBbGxvdyA9IG1vZGVsLmdldCgncm93LmNoZWNrLmFsbG93Jyk7XHJcblxyXG4gICAgICAgICAgXy5lYWNoKGNsYXNzZXNSdWxlLCAoZnVuYywga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gXy5jaGFpbihyb3cpLnJlc3VsdCgnJG1ldGFkYXRhJykucmVzdWx0KCd0eXBlJykudmFsdWUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oZnVuYykgJiYgZnVuYyhyb3csIHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgY2xhc3NBcnIucHVzaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvL2F0dHIgaW5mbyBmcm9tIG1ldGEgXHJcbiAgICAgICAgICB2YXIgb3JpZ2luSWQgPSBfLmNoYWluKHJvdylcclxuICAgICAgICAgICAgLnJlc3VsdCgnJG1ldGFkYXRlJylcclxuICAgICAgICAgICAgLnJlc3VsdCgnYXR0cicpXHJcbiAgICAgICAgICAgIC5yZXN1bHQoJ2lkJylcclxuICAgICAgICAgICAgLnZhbHVlKCk7XHJcblxyXG4gICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihjaGVja2JveEFsbG93KSA/IGNoZWNrYm94QWxsb3cocm93KSA6IGNoZWNrYm94QWxsb3cpIHtcclxuICAgICAgICAgICAgdmFyIHVuaXF1ZUlkID0gbW9kZWwuZ2V0KCdhMTF5LnNlbGVjdGlvbi51bmlxdWVJZCcpO1xyXG4gICAgICAgICAgICB2YXIgaWQgPSByb3dbY2hlY2tJZF0gfHwgb3JpZ2luSWQ7XHJcbiAgICAgICAgICAgIHZhciBhMTF5SWQgPSB1bmlxdWVJZC5jb25jYXQoaWQpO1xyXG4gICAgICAgICAgICB2YXIgcm9sZSA9ICdyb3cnO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIF8uZXh0ZW5kKHJvdywge1xyXG4gICAgICAgICAgICAkbWV0YWRhdGE6IHtcclxuICAgICAgICAgICAgICBhdHRyOiBfLnBpY2soe1xyXG4gICAgICAgICAgICAgICAgY2xhc3M6IF8uZmxhdHRlbihjbGFzc0Fycikuam9pbignICcpLFxyXG4gICAgICAgICAgICAgICAgaWQ6IGExMXlJZCxcclxuICAgICAgICAgICAgICAgIHJvbGU6IHJvbGUsXHJcbiAgICAgICAgICAgICAgfSwgQm9vbGVhbiksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXRjaCh7IHZhbHVlOiByb3dzIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gTW9kZWw7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vcm93LmpzXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL3VuZGVyc2NvcmUnLFxyXG4gICdsaWIvYmFja2JvbmUnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9wcm9qZWN0aW9uL2Jhc2UnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9sYXlvdXQvdGVtcGxhdGUvcm93LnRyaS1zdGF0ZS1jaGVja2VkLmphZGUnLFxyXG5dLCBmdW5jdGlvbiAoXywgQmFja2JvbmUsIEJhc2VQcm9qZWN0aW9uLCBkZWZhdWx0Um93Q2hlY2tUZW1wKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgQ2hlY2tUcmFuc2l0aW9uUnVsZSA9IHt9O1xyXG5cclxuICAvLyBDaGVja1RyYW5zaXRpb25SdWxlIGZ1bmN0aW9ucyBkZXRlcm1pbmUgdGhlIHN0YXRlIHRyYW5zaXRpb24gb2YgYSBjaGVja2JveC5cclxuICAvLyBTdGF0ZSB0cmFuc2l0aW9uIGRlcGVuZHMgb24gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHdoZWF0aGVyIGEgc2hvcnQgb3IgZnVsbCBjeWNsZSBpcyByZXF1ZXN0ZWQuXHJcbiAgLy8gV2hlbiB0aGUgc2hvcnQgIGN5Y2xlIGlzIHJlcXVlc3RlZCB0aGUgY2hlY2tib3ggY2Fubm90IHJldHVybiB0byB0aGUgaW5kZXRlcm1pbmF0ZSBzdGF0ZSxcclxuICAvLyBldmVudCBpZiBpdCBzdGFydGVkIGluIHRoaXMgc3RhdGUuXHJcbiAgLy8gVHdvIGRpcmVjdGlvbnMgb2YgdHJhbnNpdGlvbiBhcmUgYXZhaWxhYmxlOlxyXG4gIC8vIC4uLiAtPiBpbmRldGVybWluYXRlIC0+IGNoZWNrZWQgLT4gdW5jaGVja2VkIC0+IC4uLlxyXG4gIC8vIC4uLiAtPiBpbmRldGVybWluYXRlIC0+IHVuY2hlY2tlZCAtPiBjaGVja2VkIC0+IC4uLlxyXG4gIENoZWNrVHJhbnNpdGlvblJ1bGUuaW5kZXRlcm1pbmF0ZVRvQ2hlY2tlZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbmV4dFN0YXRlID0ge1xyXG4gICAgICB1bmNoZWNrZWQ6IGZ1bmN0aW9uIChzaG9ydEN5Y2xlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNob3J0Q3ljbGUgPyAnY2hlY2tlZCcgOiAnaW5kZXRlcm1pbmF0ZSc7XHJcbiAgICAgIH0sXHJcbiAgICAgIGNoZWNrZWQ6IF8uY29uc3RhbnQoJ3VuY2hlY2tlZCcpLFxyXG4gICAgICBpbmRldGVybWluYXRlOiBfLmNvbnN0YW50KCdjaGVja2VkJyksXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoc2hvcnRDeWNsZSwgY3VycmVudFN0YXRlKSB7XHJcbiAgICAgIHJldHVybiBfLmhhcyhuZXh0U3RhdGUsIGN1cnJlbnRTdGF0ZSkgJiYgbmV4dFN0YXRlW2N1cnJlbnRTdGF0ZV0oc2hvcnRDeWNsZSkgfHwgJ3VuY2hlY2tlZCc7XHJcbiAgICB9O1xyXG4gIH0pKCk7XHJcblxyXG4gIENoZWNrVHJhbnNpdGlvblJ1bGUuaW5kZXRlcm1pbmF0ZVRvVW5jaGVja2VkID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBuZXh0U3RhdGUgPSB7XHJcbiAgICAgIHVuY2hlY2tlZDogXy5jb25zdGFudCgnY2hlY2tlZCcpLFxyXG4gICAgICBjaGVja2VkOiBmdW5jdGlvbiAoc2hvcnRDeWNsZSkge1xyXG4gICAgICAgIHJldHVybiBzaG9ydEN5Y2xlID8gJ3VuY2hlY2tlZCcgOiAnaW5kZXRlcm1pbmF0ZSc7XHJcbiAgICAgIH0sXHJcbiAgICAgIGluZGV0ZXJtaW5hdGU6IF8uY29uc3RhbnQoJ3VuY2hlY2tlZCcpLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNob3J0Q3ljbGUsIGN1cnJlbnRTdGF0ZSkge1xyXG4gICAgICByZXR1cm4gXy5oYXMobmV4dFN0YXRlLCBjdXJyZW50U3RhdGUpICYmIG5leHRTdGF0ZVtjdXJyZW50U3RhdGVdKHNob3J0Q3ljbGUpIHx8ICd1bmNoZWNrZWQnO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuICBDaGVja1RyYW5zaXRpb25SdWxlLmluZGV0ZXJtaW5hdGVUb0NoZWNrZWRGdWxsQ3ljbGUgPSBmdW5jdGlvbiAoY3VycmVudFN0YXRlKSB7XHJcbiAgICByZXR1cm4gQ2hlY2tUcmFuc2l0aW9uUnVsZS5pbmRldGVybWluYXRlVG9DaGVja2VkKGZhbHNlLCBjdXJyZW50U3RhdGUpO1xyXG4gIH07XHJcblxyXG4gIENoZWNrVHJhbnNpdGlvblJ1bGUuaW5kZXRlcm1pbmF0ZVRvVW5jaGVja2VkRnVsbEN5Y2xlID0gZnVuY3Rpb24gKGN1cnJlbnRTdGF0ZSkge1xyXG4gICAgcmV0dXJuIENoZWNrVHJhbnNpdGlvblJ1bGUuaW5kZXRlcm1pbmF0ZVRvVW5jaGVja2VkKGZhbHNlLCBjdXJyZW50U3RhdGUpO1xyXG4gIH07XHJcblxyXG4gIENoZWNrVHJhbnNpdGlvblJ1bGUuaW5kZXRlcm1pbmF0ZVRvQ2hlY2tlZFNob3J0Q3ljbGUgPSBmdW5jdGlvbiAoY3VycmVudFN0YXRlKSB7XHJcbiAgICByZXR1cm4gQ2hlY2tUcmFuc2l0aW9uUnVsZS5pbmRldGVybWluYXRlVG9DaGVja2VkKHRydWUsIGN1cnJlbnRTdGF0ZSk7XHJcbiAgfTtcclxuXHJcbiAgQ2hlY2tUcmFuc2l0aW9uUnVsZS5pbmRldGVybWluYXRlVG9VbmNoZWNrZWRTaG9ydEN5Y2xlID0gZnVuY3Rpb24gKGN1cnJlbnRTdGF0ZSkge1xyXG4gICAgcmV0dXJuIENoZWNrVHJhbnNpdGlvblJ1bGUuaW5kZXRlcm1pbmF0ZVRvVW5jaGVja2VkKHRydWUsIGN1cnJlbnRTdGF0ZSk7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0QWxsQ2hlY2tTdGF0ZShjaGVja1N0YXRlQ291bnRlcnMsIGNvdW50KSB7XHJcbiAgICByZXR1cm4gXy5maW5kS2V5KGNoZWNrU3RhdGVDb3VudGVycywgZnVuY3Rpb24gKGMpIHtcclxuICAgICAgcmV0dXJuIGMgPT09IGNvdW50O1xyXG4gICAgfSkgfHwgJ3VuY2hlY2tlZCc7XHJcbiAgfVxyXG5cclxuICB2YXIgTW9kZWwgPSBCYXNlUHJvamVjdGlvbi5leHRlbmQoe1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgJ2NvbHVtbi5jaGVja2VkJzogJ2NoZWNrYm94JywgIC8vIHRoZSBjaGVja2JveCBjb2x1bW5cclxuICAgICAgJ3Jvdy5jaGVjay5pZCc6ICdJZCcsXHJcbiAgICAgICdyb3cuY2hlY2subWFwJzoge30sXHJcbiAgICAgICdyb3cuY2hlY2suYWxsJzogeyBzdGF0ZTogJ3VuY2hlY2tlZCcgfSwgICAgLy8gdXNlZCB0byBzdG9yZSB1c2VyJ3MgY2hlY2sgdmFsdWUgZm9yIHRoZSBzcGVjaWFsIGNhc2Ugbm8gcm93cyBvciBhbGwgcm93cyBpcyBkaXNhYmxlZFxyXG4gICAgICAncm93LmNoZWNrLmFsbG93JzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9LFxyXG4gICAgICAncm93LmNoZWNrLmNsaWNrLWFueXdoZXJlJzogZmFsc2UsXHJcbiAgICAgICdyb3cuY2hlY2sudHJhbnNpdGlvbic6IENoZWNrVHJhbnNpdGlvblJ1bGUuaW5kZXRlcm1pbmF0ZVRvQ2hlY2tlZFNob3J0Q3ljbGUsXHJcbiAgICAgICdyb3cuY2hlY2suYWxsLnRyYW5zaXRpb24nOiBDaGVja1RyYW5zaXRpb25SdWxlLmluZGV0ZXJtaW5hdGVUb0NoZWNrZWRTaG9ydEN5Y2xlLFxyXG4gICAgICAncm93LmNoZWNrLnRlbXBsYXRlJzogZGVmYXVsdFJvd0NoZWNrVGVtcCxcclxuICAgIH0sXHJcbiAgICBuYW1lOiAncm93LWNoZWNrJyxcclxuICAgIGV2ZW50czoge1xyXG4gICAgICAnbGF5b3V0OmNsaWNrOmNlbGwnOiAndGRDbGljaycsXHJcbiAgICAgICdsYXlvdXQ6Y2xpY2s6aGVhZGVyJzogJ3RoQ2xpY2snLFxyXG4gICAgfSxcclxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuc2V0KHtcclxuICAgICAgICAncm93LmNoZWNrLmNoZWNrZWQuYWxsJzogZmFsc2UsXHJcbiAgICAgICAgJ3Jvdy5jaGVjay5tYXAnOiB7fSxcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICBpZiAoIU1vZGVsLl9fc3VwZXJfXy51cGRhdGUuY2FsbCh0aGlzLCBvcHRpb25zKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNoZWNrSWQgPSB0aGlzLmdldCgncm93LmNoZWNrLmlkJyk7XHJcbiAgICAgIHZhciBpZHMgPSBfLnBsdWNrKHRoaXMuc3JjLmRhdGEuZ2V0KCd2YWx1ZScpLCBjaGVja0lkKTtcclxuICAgICAgdmFyIGNoZWNrTWFwID0gdGhpcy5nZXQoJ3Jvdy5jaGVjay5tYXAnKTtcclxuICAgICAgdmFyIGNvbCA9IHRoaXMuZ2V0KCdjb2x1bW4uY2hlY2tlZCcpO1xyXG4gICAgICB2YXIgY29sdW1ucyA9IF8uY2xvbmUodGhpcy5zcmMuZGF0YS5nZXQoJ2NvbHVtbnMnKSk7XHJcbiAgICAgIHZhciBjaGVja1N0YXRlQ291bnRlcnMgPSBfLm9iamVjdChcclxuICAgICAgICAgIFsndW5jaGVja2VkJywgJ2NoZWNrZWQnLCAnaW5kZXRlcm1pbmF0ZSddLFxyXG4gICAgICAgICAgWzAsIDAsIDBdXHJcbiAgICAgICAgKTtcclxuICAgICAgdmFyIGhhc0NoZWNrYm94YWJsZSA9IGZhbHNlO1xyXG4gICAgICB2YXIgY2hlY2tib3hBbGxvdyA9IHRoaXMuZ2V0KCdyb3cuY2hlY2suYWxsb3cnKTtcclxuICAgICAgdmFyIGNoZWNrYm94Q29sdW1uID0gXy5maW5kKGNvbHVtbnMsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0ucHJvcGVydHkgPT09IGNvbDtcclxuICAgICAgfSk7XHJcbiAgICAgIHZhciByb3dDaGVja1RlbXAgPSB0aGlzLmdldCgncm93LmNoZWNrLnRlbXBsYXRlJyk7XHJcblxyXG4gICAgICB2YXIgdmFsdWUgPSBfLm1hcCh0aGlzLnNyYy5kYXRhLmdldCgndmFsdWUnKSwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgcmV0ID0gXy5jbG9uZShpdGVtKTtcclxuICAgICAgICB2YXIgY2hlY2sgPSBjaGVja01hcFtyZXRbY2hlY2tJZF1dIHx8IHsgc3RhdGU6ICd1bmNoZWNrZWQnIH07XHJcbiAgICAgICAgdmFyIGRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICB2YXIgaXNBbGxvd2VkID0gXy5pc0Z1bmN0aW9uKGNoZWNrYm94QWxsb3cpID8gY2hlY2tib3hBbGxvdyhyZXQpIDogY2hlY2tib3hBbGxvdztcclxuXHJcbiAgICAgICAgY2hlY2tTdGF0ZUNvdW50ZXJzW2NoZWNrLnN0YXRlXSsrO1xyXG5cclxuICAgICAgICBpZiAoaXNBbGxvd2VkKSB7XHJcbiAgICAgICAgICBkaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgaGFzQ2hlY2tib3hhYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldFtjb2xdID0gXy5leHRlbmQoe30sIHJldFtjb2xdLCB7XHJcbiAgICAgICAgICAkaHRtbDogcm93Q2hlY2tUZW1wKHsgY2hlY2tTdGF0ZTogY2hlY2suc3RhdGUsIGRpc2FibGVkOiBkaXNhYmxlZCB9KSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBzZXQgdGhlIGNoZWNrYm94IGluIHRoXHJcbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChjaGVja2JveENvbHVtbikpIHtcclxuICAgICAgICB2YXIgZGlzYWJsZWRBbGxDaGVjayA9IF8uc2l6ZShpZHMpID09PSAwO1xyXG5cclxuICAgICAgICBpZiAoaGFzQ2hlY2tib3hhYmxlKSB7XHJcbiAgICAgICAgICB2YXIgY2hlY2tTdGF0ZSA9IGdldEFsbENoZWNrU3RhdGUoY2hlY2tTdGF0ZUNvdW50ZXJzLCBpZHMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICBjaGVja2JveENvbHVtbi4kaHRtbCA9IHJvd0NoZWNrVGVtcCh7IGNoZWNrU3RhdGU6IGNoZWNrU3RhdGUsIGRpc2FibGVkOiBkaXNhYmxlZEFsbENoZWNrIH0pO1xyXG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzWydyb3cuY2hlY2suYWxsJ10gPSBfLmV4dGVuZCh0aGlzLmF0dHJpYnV0ZXNbJ3Jvdy5jaGVjay5hbGwnXSwgeyBzdGF0ZTogY2hlY2tTdGF0ZSB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2hlY2tib3hDb2x1bW4uJGh0bWwgPSByb3dDaGVja1RlbXAoeyBjaGVja1N0YXRlOiB0aGlzLmdldCgncm93LmNoZWNrLmFsbCcpLnN0YXRlLCBkaXNhYmxlZDogZGlzYWJsZWRBbGxDaGVjayB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucGF0Y2goe1xyXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICBjb2x1bW5zOiBjb2x1bW5zLFxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICB0ZENsaWNrOiBmdW5jdGlvbiAoZSwgYXJnKSB7XHJcbiAgICAgIHZhciBjaGVja2JveFByb3BlcnR5ID0gdGhpcy5nZXQoJ2NvbHVtbi5jaGVja2VkJyk7XHJcbiAgICAgIHZhciBjbGlja0FueXdoZXJlID0gdGhpcy5nZXQoJ3Jvdy5jaGVjay5jbGljay1hbnl3aGVyZScpO1xyXG5cclxuICAgICAgaWYgKGFyZy5wcm9wZXJ0eSA9PT0gY2hlY2tib3hQcm9wZXJ0eSB8fCBjbGlja0FueXdoZXJlKSB7XHJcbiAgICAgICAgdmFyIGNoZWNrTWFwID0gXy5jbG9uZSh0aGlzLmdldCgncm93LmNoZWNrLm1hcCcpKTtcclxuICAgICAgICB2YXIgaWQgPSBhcmcubW9kZWxbdGhpcy5nZXQoJ3Jvdy5jaGVjay5pZCcpXTtcclxuICAgICAgICB2YXIgZGVmYXVsdFRyYW5zaXRpb24gPSB0aGlzLmdldCgncm93LmNoZWNrLnRyYW5zaXRpb24nKTtcclxuICAgICAgICB2YXIgY2hlY2sgPSBfLmV4dGVuZCh7XHJcbiAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICB0cmFuc2l0aW9uOiBkZWZhdWx0VHJhbnNpdGlvbixcclxuICAgICAgICAgIHN0YXRlOiAndW5jaGVja2VkJyxcclxuICAgICAgICB9LCBjaGVja01hcFtpZF0pO1xyXG5cclxuICAgICAgICBjaGVjay5zdGF0ZSA9IGNoZWNrLnRyYW5zaXRpb24oY2hlY2suc3RhdGUpO1xyXG4gICAgICAgIGNoZWNrTWFwW2lkXSA9IGNoZWNrO1xyXG5cclxuICAgICAgICB0aGlzLnNldCh7XHJcbiAgICAgICAgICAncm93LmNoZWNrLm1hcCc6IGNoZWNrTWFwLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgdGhDbGljazogZnVuY3Rpb24gKGUsIGFyZykge1xyXG4gICAgICB2YXIgY2hlY2tib3hQcm9wZXJ0eSA9IHRoaXMuZ2V0KCdjb2x1bW4uY2hlY2tlZCcpO1xyXG5cclxuICAgICAgaWYgKGFyZy5wcm9wZXJ0eSA9PT0gY2hlY2tib3hQcm9wZXJ0eSkge1xyXG4gICAgICAgIHZhciBjaGVja01hcCA9IF8uY2xvbmUodGhpcy5nZXQoJ3Jvdy5jaGVjay5tYXAnKSk7XHJcbiAgICAgICAgdmFyIGNoZWNrSWQgPSB0aGlzLmdldCgncm93LmNoZWNrLmlkJyk7XHJcbiAgICAgICAgdmFyIGFsbENoZWNrID0gdGhpcy5nZXQoJ3Jvdy5jaGVjay5hbGwnKTtcclxuICAgICAgICB2YXIgY2hlY2tTdGF0ZSA9IGFsbENoZWNrLnN0YXRlO1xyXG4gICAgICAgIHZhciBhbGxDaGVja1RyYW5zaXRpb25SdWxlID0gdGhpcy5nZXQoJ3Jvdy5jaGVjay5hbGwudHJhbnNpdGlvbicpO1xyXG4gICAgICAgIHZhciBDaGVja1RyYW5zaXRpb25SdWxlID0gdGhpcy5nZXQoJ3Jvdy5jaGVjay50cmFuc2l0aW9uJyk7XHJcblxyXG4gICAgICAgIGFsbENoZWNrLnN0YXRlID0gYWxsQ2hlY2tUcmFuc2l0aW9uUnVsZShjaGVja1N0YXRlKTtcclxuXHJcbiAgICAgICAgY2hlY2tNYXAgPSBfLm9iamVjdChcclxuICAgICAgICAgIHRoaXMuZGF0YS5nZXQoJ3ZhbHVlJylcclxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgdmFyIGlkID0gaXRlbVtjaGVja0lkXTtcclxuICAgICAgICAgICAgdmFyIGNoZWNrID0gXy5leHRlbmQoe1xyXG4gICAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBDaGVja1RyYW5zaXRpb25SdWxlLFxyXG4gICAgICAgICAgICB9LCBjaGVja01hcFtpZF0sIHsgc3RhdGU6IGFsbENoZWNrLnN0YXRlIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtpZCwgY2hlY2tdO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLnNldCh7XHJcbiAgICAgICAgICAncm93LmNoZWNrLm1hcCc6IGNoZWNrTWFwLFxyXG4gICAgICAgICAgJ3Jvdy5jaGVjay5hbGwnOiBhbGxDaGVjayxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgZnVuY3Rpb24gQ2hlY2tEaWZmKGFkZGVkLCBjaGFuZ2VkLCByZW1vdmVkLCB1bmNoYW5nZWQpIHtcclxuICAgIHRoaXMuYWRkZWQgPSBhZGRlZCB8fCB7fTtcclxuICAgIHRoaXMuY2hhbmdlZCA9IGNoYW5nZWQgfHwge307XHJcbiAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkIHx8IHt9O1xyXG4gICAgdGhpcy51bmNoYW5nZWQgPSB1bmNoYW5nZWQgfHwge307XHJcbiAgfVxyXG5cclxuICBDaGVja0RpZmYucHJvdG90eXBlLmhhc0NoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gXy5rZXlzKHRoaXMuY2hhbmdlZCkubGVuZ3RoICsgXy5rZXlzKHRoaXMuYWRkZWQpLmxlbmd0aCA+IDA7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZGlmZkNoZWNrTWFwKGJlZm9yZSwgYWZ0ZXIsIGRlZmF1bHRTdGF0ZSkge1xyXG4gICAgZGVmYXVsdFN0YXRlID0gZGVmYXVsdFN0YXRlIHx8IHsgc3RhdGU6ICd1bmNoZWNrZWQnIH07XHJcblxyXG4gICAgdmFyIGNoZWNrRGlmZiA9IG5ldyBDaGVja0RpZmYoKTtcclxuXHJcbiAgICBfLmtleXMoYmVmb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgdmFyIGJlZm9yZVN0YXRlID0gYmVmb3JlW2tleV07XHJcbiAgICAgIHZhciBhZnRlclN0YXRlID0gYWZ0ZXJba2V5XTtcclxuXHJcbiAgICAgIGlmICghYWZ0ZXJTdGF0ZSkge1xyXG4gICAgICAgIGNoZWNrRGlmZi5yZW1vdmVkW2tleV0gPSBiZWZvcmVTdGF0ZTtcclxuICAgICAgfSBlbHNlIGlmIChiZWZvcmVTdGF0ZS5zdGF0ZSA9PT0gYWZ0ZXJTdGF0ZS5zdGF0ZSkge1xyXG4gICAgICAgIGNoZWNrRGlmZi51bmNoYW5nZWRba2V5XSA9IGFmdGVyU3RhdGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hlY2tEaWZmLmNoYW5nZWRba2V5XSA9IHsgYmVmb3JlOiBiZWZvcmVTdGF0ZSwgYWZ0ZXI6IGFmdGVyU3RhdGUgfTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgXy5rZXlzKGFmdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgdmFyIGFmdGVyU3RhdGUgPSBhZnRlcltrZXldO1xyXG4gICAgICB2YXIgYmVmb3JlU3RhdGUgPSBiZWZvcmVba2V5XTtcclxuXHJcbiAgICAgIGlmICghYmVmb3JlU3RhdGUgJiYgZGVmYXVsdFN0YXRlLnN0YXRlICE9PSBhZnRlclN0YXRlLnN0YXRlKSB7XHJcbiAgICAgICAgY2hlY2tEaWZmLmFkZGVkW2tleV0gPSBhZnRlclN0YXRlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY2hlY2tEaWZmO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3RhdENoZWNrTWFwKGNoZWNrTWFwLCBkZWZhdWx0U3RhdGUpIHtcclxuICAgIGRlZmF1bHRTdGF0ZSA9IGRlZmF1bHRTdGF0ZSB8fCB7IHN0YXRlOiAndW5jaGVja2VkJyB9O1xyXG4gICAgdmFyIGNoZWNrZWQgPSBbXTtcclxuICAgIHZhciBpbmRldGVybWluYXRlID0gW107XHJcbiAgICB2YXIgdW5jaGVja2VkID0gW107XHJcblxyXG4gICAgXy5rZXlzKGNoZWNrTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgdmFyIGNoZWNrID0gY2hlY2tNYXBba2V5XTtcclxuXHJcbiAgICAgIGlmIChjaGVjay5zdGF0ZSA9PT0gJ2NoZWNrZWQnICYmIGNoZWNrLnN0YXRlICE9PSBkZWZhdWx0U3RhdGUuc3RhdGUpIHtcclxuICAgICAgICBjaGVja2VkLnB1c2goY2hlY2spO1xyXG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLnN0YXRlID09PSAndW5jaGVja2VkJyAmJiBjaGVjay5zdGF0ZSAhPT0gZGVmYXVsdFN0YXRlLnN0YXRlKSB7XHJcbiAgICAgICAgdW5jaGVja2VkLnB1c2goY2hlY2spO1xyXG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLnN0YXRlICE9PSBkZWZhdWx0U3RhdGUuc3RhdGUpIHtcclxuICAgICAgICBpbmRldGVybWluYXRlLnB1c2goY2hlY2spO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjaGVja2VkOiBjaGVja2VkLFxyXG4gICAgICB1bmNoZWNrZWQ6IHVuY2hlY2tlZCxcclxuICAgICAgaW5kZXRlcm1pbmF0ZTogaW5kZXRlcm1pbmF0ZSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmdWxsU3RhdENoZWNrTWFwKGJlZm9yZSwgYWZ0ZXIsIGRlZmF1bHRTdGF0ZSkge1xyXG4gICAgcmV0dXJuIF8uZXh0ZW5kKHN0YXRDaGVja01hcChhZnRlciwgZGVmYXVsdFN0YXRlKSwgZGlmZkNoZWNrTWFwKGJlZm9yZSwgYWZ0ZXIsIGRlZmF1bHRTdGF0ZSkpO1xyXG4gIH1cclxuXHJcbiAgTW9kZWwuQ2hlY2tUcmFuc2l0aW9uUnVsZSA9IENoZWNrVHJhbnNpdGlvblJ1bGU7XHJcbiAgTW9kZWwuZnVsbFN0YXRDaGVja01hcCA9IGZ1bGxTdGF0Q2hlY2tNYXA7XHJcbiAgTW9kZWwuc3RhdENoZWNrTWFwID0gc3RhdENoZWNrTWFwO1xyXG4gIE1vZGVsLmRpZmZDaGVja01hcCA9IGRpZmZDaGVja01hcDtcclxuXHJcbiAgcmV0dXJuIE1vZGVsO1xyXG59KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy9wcm9qZWN0aW9uL3Jvdy10cmktc3RhdGUtY2hlY2tib3guanNcbiAqKi8iLCJ2YXIgamFkZSA9IHJlcXVpcmUoXCJEOlxcXFx3b3Jrc3BhY2VcXFxcZm9ya1xcXFxwcm9qZWN0aW9uLWdyaWRcXFxcbm9kZV9tb2R1bGVzXFxcXGphZGVcXFxcbGliXFxcXHJ1bnRpbWUuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7XG52YXIgYnVmID0gW107XG52YXIgamFkZV9taXhpbnMgPSB7fTtcbnZhciBqYWRlX2ludGVycDtcbjt2YXIgbG9jYWxzX2Zvcl93aXRoID0gKGxvY2FscyB8fCB7fSk7KGZ1bmN0aW9uIChjaGVja1N0YXRlKSB7XG52YXIgY2xhc3NlcyA9IFtdLmNvbmNhdChjaGVja1N0YXRlID09PSAnaW5kZXRlcm1pbmF0ZScgPyBbJ2dseXBoaWNvbicsICdnbHlwaGljb24tbWludXMnXSA6IGNoZWNrU3RhdGUgPT09ICdjaGVja2VkJyA/IFsnZ2x5cGhpY29uJywgJ2dseXBoaWNvbi1vayddIDogW10pXG5idWYucHVzaChcIjxkaXYgY2xhc3M9XFxcImNvbHVtbi10cmktc3RhdGUtY2hlY2tib3hcXFwiPjxzcGFuXCIgKyAoamFkZS5jbHMoW2NsYXNzZXNdLCBbdHJ1ZV0pKSArIFwiPjwvc3Bhbj48L2Rpdj5cIik7fS5jYWxsKHRoaXMsXCJjaGVja1N0YXRlXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC5jaGVja1N0YXRlOnR5cGVvZiBjaGVja1N0YXRlIT09XCJ1bmRlZmluZWRcIj9jaGVja1N0YXRlOnVuZGVmaW5lZCkpOztyZXR1cm4gYnVmLmpvaW4oXCJcIik7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9qcy9sYXlvdXQvdGVtcGxhdGUvcm93LnRyaS1zdGF0ZS1jaGVja2VkLmphZGVcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL3VuZGVyc2NvcmUnLFxyXG4gICdsaWIvYmFja2JvbmUnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9wcm9qZWN0aW9uL2Jhc2UnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9zY2hlbWEvcHJvcGVydGllcycsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL21vZGVsL3Jlc3BvbnNlJyxcclxuXSwgZnVuY3Rpb24gKF8sIEJhY2tib25lLCBCYXNlUHJvamVjdGlvbiAvKiAsIHNjaGVtYVByb3BlcnRpZXMsIFJlc3BvbnNlICovKSB7XHJcbiAgdmFyIE1vZGVsID0gQmFzZVByb2plY3Rpb24uZXh0ZW5kKHtcclxuICAgIGRlZmF1bHRzOiB7fSxcclxuICAgIG5hbWU6ICdyb3ctaW5kZXgnLFxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICBpZiAoTW9kZWwuX19zdXBlcl9fLnVwZGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpKSB7XHJcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5zcmMuZGF0YTtcclxuICAgICAgICB2YXIgc2tpcCA9IHRoaXMuZ2V0KCdza2lwJyk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gXy5tYXAobW9kZWwuZ2V0KCd2YWx1ZScpLCBmdW5jdGlvbiAoaSwgaWR4KSB7XHJcbiAgICAgICAgICB2YXIgcmV0ID0gXy5jbG9uZShpKTtcclxuICAgICAgICAgIHJldC5yb3dJbmRleCA9IGlkeCArIChfLmlzRmluaXRlKHNraXApID8gc2tpcCA6IDApICsgMTtcclxuICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucGF0Y2goeyB2YWx1ZTogdmFsdWUgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gdG9kbyBbYWthbWVsXSB1bnNldCBvdXIgcHJvcGVydGllcyBvbmx5XHJcbiAgICAgICAgLy8gdGhpcy51bnNldCgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gTW9kZWw7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vcm93LWluZGV4LmpzXG4gKiovIiwiZGVmaW5lKFtcclxuICAnbGliL3VuZGVyc2NvcmUnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9wcm9qZWN0aW9uL2Jhc2UnLFxyXG4gICdjb21wb25lbnQvZ3JpZC9zY2hlbWEvcHJvcGVydGllcycsXHJcbl0sIGZ1bmN0aW9uIChfLCBCYXNlUHJvamVjdGlvbiwgc2NoZW1hUHJvcGVydGllcykge1xyXG4gIHZhciBNb2RlbCA9IEJhc2VQcm9qZWN0aW9uLmV4dGVuZCh7XHJcblxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgc2VlZDogbnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgbmFtZTogJ3NpbmsnLFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdmFsdWU7XHJcblxyXG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0KCdzZWVkJyk7XHJcblxyXG4gICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgc2VsZWN0ID0gc2NoZW1hUHJvcGVydGllcy5mcm9tKHZhbHVlKTtcclxuICAgICAgICB0aGlzLnBhdGNoKHtcclxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgIHNlbGVjdDogc2VsZWN0LFxyXG4gICAgICAgICAgY291bnQ6IF8uc2l6ZSh2YWx1ZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gTW9kZWw7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vc2luay5qc1xuICoqLyIsImRlZmluZShbXHJcbiAgJ2xpYi91bmRlcnNjb3JlJyxcclxuICAnbGliL2JhY2tib25lJyxcclxuICAnY29tcG9uZW50L2dyaWQvcHJvamVjdGlvbi9iYXNlJyxcclxuICAnY29tcG9uZW50L2dyaWQvbW9kZWwvcmVzcG9uc2UnLFxyXG5dLCBmdW5jdGlvbiAoXywgQmFja2JvbmUsIEJhc2VQcm9qZWN0aW9uKSB7XHJcbiAgdmFyIE1vZGVsID0gQmFzZVByb2plY3Rpb24uZXh0ZW5kKHtcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICdjb2x1bW4uZ3JvdXAnOiB7fSxcclxuICAgICAgJ2NvbHVtbi5ncm91cEV4cGFuc2lvbic6IFtdLFxyXG4gICAgICAnY29sdW1uLnNlbGVjdCc6IG51bGwsXHJcbiAgICB9LFxyXG4gICAgbmFtZTogJ2NvbHVtbi1ncm91cCcsXHJcblxyXG4gICAgZXZlbnRzOiB7XHJcbiAgICAgICdsYXlvdXQ6Y2xpY2s6aGVhZGVyJzogJ29uQ2xpY2tIZWFkZXInLFxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIGlmIChNb2RlbC5fX3N1cGVyX18udXBkYXRlLmNhbGwodGhpcywgb3B0aW9ucykpIHtcclxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLnNyYy5kYXRhO1xyXG4gICAgICAgIHZhciBjb2x1bW5Hcm91cCA9IHRoaXMuZ2V0KCdjb2x1bW4uZ3JvdXAnKSB8fCB7fTtcclxuICAgICAgICB2YXIgZ3JvdXBFeHBhbnNpb24gPSB7fTtcclxuICAgICAgICBfLmVhY2godGhpcy5nZXQoJ2NvbHVtbi5ncm91cEV4cGFuc2lvbicpIHx8IFtdLCBmdW5jdGlvbiAoY29sdW1uTmFtZSkge1xyXG4gICAgICAgICAgZ3JvdXBFeHBhbnNpb25bY29sdW1uTmFtZV0gPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBzZWxlY3QgPSB0aGlzLmdldCgnY29sdW1uLnNlbGVjdCcpIHx8IG1vZGVsLmdldCgnc2VsZWN0Jyk7XHJcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBtb2RlbC5nZXQoJ2NvbHVtbnMnKTtcclxuICAgICAgICB2YXIgZGF0ZSA9IG1vZGVsLmdldCgnanNkYXRhLnF1ZXJ5Jyk7XHJcbiAgICAgICAgdmFyIHN1YlNlbGVjdCA9IFtdO1xyXG4gICAgICAgIHZhciBpc0FwcGx5R3JvdXAgPSBkYXRlICYmIGRhdGUuc3RhcnREYXRlMiAmJiBkYXRlLmVuZERhdGUyO1xyXG5cclxuICAgICAgICBfLmNoYWluKGNvbHVtbnMpLmtleXMoKS5lYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgIGlmIChpc0FwcGx5R3JvdXAgJiYgXy5oYXMoY29sdW1uR3JvdXAsIGtleSkpIHtcclxuICAgICAgICAgICAgY29sdW1uc1trZXldLmdyb3VwID0gY29sdW1uR3JvdXBba2V5XTtcclxuICAgICAgICAgICAgY29sdW1uc1trZXldLmdyb3VwRXhwYW5zaW9uID0gXy5oYXMoZ3JvdXBFeHBhbnNpb24sIGtleSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb2x1bW5zW2tleV0uZ3JvdXAgPSBudWxsO1xyXG4gICAgICAgICAgICBjb2x1bW5zW2tleV0uZ3JvdXBFeHBhbnNpb24gPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIHNlbGVjdEV4cGFuZCA9IHNlbGVjdC5zbGljZSgwKTtcclxuXHJcbiAgICAgICAgXy5lYWNoKHNlbGVjdCwgZnVuY3Rpb24gKGNvbHVtbk5hbWUpIHtcclxuICAgICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5zW2NvbHVtbk5hbWVdO1xyXG4gICAgICAgICAgdmFyIHN1YkNvbHVtbnMgPSBjb2x1bW4uZ3JvdXA7XHJcbiAgICAgICAgICBpZiAoY29sdW1uLmdyb3VwRXhwYW5zaW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lSW5kZXggPSBzZWxlY3RFeHBhbmQuaW5kZXhPZihjb2x1bW5OYW1lKTtcclxuICAgICAgICAgICAgc2VsZWN0RXhwYW5kLnNwbGljZS5hcHBseShzZWxlY3RFeHBhbmQsIFtuYW1lSW5kZXgsIDFdLmNvbmNhdChzdWJDb2x1bW5zKSk7XHJcbiAgICAgICAgICAgIHN1YlNlbGVjdCA9IHN1YlNlbGVjdC5jb25jYXQoc3ViQ29sdW1ucyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMucGF0Y2goe1xyXG4gICAgICAgICAgY29sdW1uczogY29sdW1ucyxcclxuICAgICAgICAgIHNlbGVjdDogc2VsZWN0LFxyXG4gICAgICAgICAgc3ViU2VsZWN0OiBzdWJTZWxlY3QsXHJcbiAgICAgICAgICBzZWxlY3RFeHBhbmQ6IHNlbGVjdEV4cGFuZCxcclxuICAgICAgICAgIGlzQXBwbHlHcm91cDogaXNBcHBseUdyb3VwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHRvZG8gW2FrYW1lbF0gdW5zZXQgb3VyIHByb3BlcnRpZXMgb25seVxyXG4gICAgICAgIC8vIHRoaXMudW5zZXQoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNsaWNrSGVhZGVyOiBmdW5jdGlvbiAoZSwgYXJnKSB7XHJcbiAgICAgIGlmICghZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdnbHlwaGljb24nKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgY29sdW1uID0gYXJnLmNvbHVtbjtcclxuICAgICAgaWYgKF8uaXNBcnJheShjb2x1bW4uZ3JvdXApKSB7XHJcbiAgICAgICAgdmFyIGdyb3VwRXhwYW5zaW9uID0gdGhpcy5nZXQoJ2NvbHVtbi5ncm91cEV4cGFuc2lvbicpIHx8IFtdO1xyXG4gICAgICAgIGlmIChjb2x1bW4uZ3JvdXBFeHBhbnNpb24pIHtcclxuICAgICAgICAgIGdyb3VwRXhwYW5zaW9uID0gXy53aXRob3V0KGdyb3VwRXhwYW5zaW9uLCBjb2x1bW4ucHJvcGVydHkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBncm91cEV4cGFuc2lvbiA9IF8udW5pb24oZ3JvdXBFeHBhbnNpb24sIFtjb2x1bW4ucHJvcGVydHldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXQoeyAnY29sdW1uLmdyb3VwRXhwYW5zaW9uJzogZ3JvdXBFeHBhbnNpb24gfSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBNb2RlbDtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvcHJvamVjdGlvbi9jb2x1bW4tZ3JvdXAuanNcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2xpYi9iYWNrYm9uZScsXHJcbiAgJ2NvbXBvbmVudC9ncmlkL3Byb2plY3Rpb24vYmFzZScsXHJcbl0sIGZ1bmN0aW9uIChfLCBCYWNrYm9uZSwgQmFzZVByb2plY3Rpb24pIHtcclxuICB2YXIgTW9kZWwgPSBCYXNlUHJvamVjdGlvbi5leHRlbmQoe1xyXG4gICAgbmFtZTogJ2NvbHVtbi1ob3ZlcnRleHQnLFxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICBpZiAoTW9kZWwuX19zdXBlcl9fLnVwZGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpKSB7XHJcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5zcmMuZGF0YTtcclxuICAgICAgICB2YXIgY29sdW1ucyA9IG1vZGVsLmdldCgnY29sdW1ucycpO1xyXG5cclxuICAgICAgICBfLmVhY2goY29sdW1ucywgZnVuY3Rpb24oY29sdW1uKSB7XHJcbiAgICAgICAgICBjb2x1bW4uJG1ldGFkYXRhID0gXy5yZXN1bHQoY29sdW1uLCAnJG1ldGFkYXRhJywge30pO1xyXG4gICAgICAgICAgY29sdW1uLiRtZXRhZGF0YVsnYXR0ci5oZWFkJ10gPSBfLnJlc3VsdChjb2x1bW4uJG1ldGFkYXRhLCAnYXR0ci5oZWFkJywge30pO1xyXG4gICAgICAgICAgY29sdW1uLiRtZXRhZGF0YVsnYXR0ci5oZWFkJ10udGl0bGUgPSBfLnJlc3VsdChjb2x1bW4uY29uZmlnLCAnaG92ZXJUZXh0JykgfHwgXy5yZXN1bHQoY29sdW1uLmNvbmZpZywgJ3RpdGxlJykgfHwgJyc7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucGF0Y2goeyBjb2x1bW5zOiBjb2x1bW5zIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gTW9kZWw7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vY29sdW1uLWhvdmVydGV4dC5qc1xuICoqLyIsImltcG9ydCBCYXNlUHJvamVjdGlvbiBmcm9tICcuL2Jhc2UnO1xyXG5cclxuY29uc3QgQ29sdW1uc1Byb2plY3Rpb24gPSBCYXNlUHJvamVjdGlvbi5leHRlbmQoe1xyXG4gIGRlZmF1bHRzOiB7XHJcbiAgICBjb2x1bW5zOiB7fSxcclxuICB9LFxyXG5cclxuICBuYW1lOiAnY29sdW1ucycsXHJcblxyXG4gIHVwZGF0ZShvcHRpb25zKSB7XHJcbiAgICBpZiAoQmFzZVByb2plY3Rpb24ucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpKSB7XHJcbiAgICAgIHRoaXMucGF0Y2goe1xyXG4gICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0KCdjb2x1bW5zJyksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvbHVtbnNQcm9qZWN0aW9uO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3Byb2plY3Rpb24vY29sdW1ucy5qc1xuICoqLyIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlbGVnYXRlRXZlbnRzKHsgZnJvbSwgdG8sIGV2ZW50cyB9KSB7XHJcbiAgXy5lYWNoKFxyXG4gICAgZXZlbnRzLFxyXG4gICAgZXZlbnQgPT4gZnJvbS5vbihldmVudCwgKC4uLmFyZ3MpID0+IHRvLnRyaWdnZXIoZXZlbnQsIC4uLmFyZ3MpKVxyXG4gICk7XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy9mYWN0b3J5L3V0aWxpdHkuanNcbiAqKi8iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcclxuaW1wb3J0IEdyaWRWaWV3IGZyb20gJy4uL2dyaWQtdmlldyc7XHJcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi4vbGF5b3V0L2luZGV4JztcclxuaW1wb3J0IHsgZGVsZWdhdGVFdmVudHMgfSBmcm9tICcuL3V0aWxpdHknO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lUGx1Z2luID0+IGRlZmluZVBsdWdpbignZ3JpZFZpZXcnLCBbXHJcbiAgJ2NvbmZpZycsXHJcbiAgJ3Byb2plY3Rpb24nLFxyXG4gICdyZW5kZXJlcnMnLFxyXG5dLCBmdW5jdGlvbiAoY29uZmlnLCBwcm9qZWN0aW9uLCByZW5kZXJlcnMpIHtcclxuICBjb25zdCBncmlkVmlldyA9IG5ldyBHcmlkVmlldyh7XHJcbiAgICBwcm9qZWN0aW9uLFxyXG4gICAgZWw6IGNvbmZpZy5lbCxcclxuICAgIGNvbnRhaW5lcjogXy5jaGFpbihjb25maWcpXHJcbiAgICAgIC5yZXN1bHQoJ3Njcm9sbGFibGUnKVxyXG4gICAgICAucmVzdWx0KCdmaXhlZEhlYWRlcicpXHJcbiAgICAgIC5yZXN1bHQoJ2NvbnRhaW5lcicpXHJcbiAgICAgIC52YWx1ZSgpLFxyXG4gICAgc2NoZW1hOiBjb25maWcuZGF0YVNvdXJjZS5zY2hlbWEsXHJcbiAgICBMYXlvdXQ6IGxheW91dC5UYWJsZUxheW91dC5wYXJ0aWFsKHtcclxuICAgICAgcmVuZGVyZXJzLFxyXG4gICAgICB0ZW1wbGF0ZTogbGF5b3V0LnRlbXBsYXRlcy50YWJsZSxcclxuICAgICAgaGlkZUhlYWRlcnM6IGNvbmZpZy5oaWRlSGVhZGVycyxcclxuICAgICAgJG1ldGFkYXRhOiBjb25maWcubGF5b3V0T3B0aW9ucyB8fCB7fSxcclxuICAgIH0pLFxyXG4gIH0pO1xyXG5cclxuICBkZWxlZ2F0ZUV2ZW50cyh7XHJcbiAgICBmcm9tOiBwcm9qZWN0aW9uLFxyXG4gICAgdG86IGdyaWRWaWV3LFxyXG4gICAgZXZlbnRzOiBbXHJcbiAgICAgICd1cGRhdGU6YmVnaW5uaW5nJyxcclxuICAgICAgJ3VwZGF0ZTpmaW5pc2hlZCcsXHJcbiAgICBdLFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gZ3JpZFZpZXc7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL2ZhY3RvcnkvZ3JpZC12aWV3LXBsdWdpbi5qc1xuICoqLyIsImRlZmluZShbXHJcbiAgJ2xpYi91bmRlcnNjb3JlJyxcclxuICAnbGliL2JhY2tib25lJyxcclxuICAnY29tcG9uZW50L2dyaWQvbW9kZWwvaW5kZXgnLFxyXG4gICdjb21wb25lbnQvZ3JpZC93aW5kb3dDb250YWluZXInLFxyXG4gICdjb21wb25lbnQvZ3JpZC9lbGVtZW50Q29udGFpbmVyJyxcclxuXSwgZnVuY3Rpb24gKF8sIEJhY2tib25lLCBPcHRpb25zLCBXaW5kb3dDb250YWluZXIsIEVsZW1lbnRDb250YWluZXIpIHtcclxuICB2YXIgR3JpZFZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgICAvLyB0b2RvIFtha2FtZWxdIGRvY3VtZW50IGF2YWlsYWJsZSBvcHRpb25zXHJcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBPcHRpb25zKG9wdGlvbnMpO1xyXG5cclxuICAgICAgdmFyIGNvbnRhaW5lciA9IHNlbGVjdENvbnRhaW5lcihvcHRpb25zLmNvbnRhaW5lcik7XHJcblxyXG4gICAgICAvLyB0b2RvIFtha2FtZWxdIGFzc2VydCB0aGF0IGxheW91dCBpcyBhIGN0b3JcclxuICAgICAgdGhpcy5sYXlvdXQgPSBuZXcgb3B0aW9ucy5MYXlvdXQoe1xyXG4gICAgICAgIGVsOiB0aGlzLmVsLFxyXG4gICAgICAgIGdyaWQ6IHRoaXMsXHJcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5wcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uO1xyXG5cclxuICAgICAgdGhpcy5wcm9qZWN0aW9uLmRhdGEub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgWydjaGFuZ2U6ZGF0YSddLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSkpO1xyXG4gICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgdGhpcy5vcHRpb25zLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIFsnY2hhbmdlOm9wdGlvbnMnXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpKTtcclxuICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgIHRoaXMucHJvamVjdGlvbi5vbignYWxsJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBbJ2RhdGE6JyArIF8uZmlyc3QoYXJndW1lbnRzKV0uY29uY2F0KF8ucmVzdChhcmd1bWVudHMpKSk7XHJcbiAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICB0aGlzLmxheW91dC5vbignYWxsJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBrZXkgPSAnbGF5b3V0OicgKyBfLmZpcnN0KGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdmFyIGFyZyA9IFtrZXldLmNvbmNhdChfLnJlc3QoYXJndW1lbnRzKSk7XHJcblxyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbi5idWJibGUuYXBwbHkodGhpcy5wcm9qZWN0aW9uLCBhcmcpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBhcmcpO1xyXG4gICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgLy8gdG9kbyBbYWthbWVsXSB0aGlzIGlzIGEgdGVtcG9yYXJ5IGltcGxlbWVudGF0aW9uIG9mIG9yZGVyYnk7IHNob3VsZCBiZSBpbiBsYXlvdXQgbm90IGluIGdyaWRcclxuICAgICAgdGhpcy5vbignbGF5b3V0OmNsaWNrOmhlYWRlcicsIGZ1bmN0aW9uIChlLCBhcmcpIHtcclxuICAgICAgICB2YXIgY29sdW1uID0gYXJnLmNvbHVtbjtcclxuXHJcbiAgICAgICAgaWYgKGNvbHVtbi5zb3J0YWJsZSkge1xyXG4gICAgICAgICAgdmFyIG9yZGVyYnkgPSB0aGlzLnByb2plY3Rpb24uZ2V0KCdvcmRlcmJ5JykgfHwgW107XHJcbiAgICAgICAgICBvcmRlcmJ5ID0gXy5maWx0ZXIob3JkZXJieSwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uc2NvcGUgPT09ICdnbG9iYWwnO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdmFyIGtleSA9IF8uaXNTdHJpbmcoY29sdW1uLnNvcnRhYmxlKSA/IGNvbHVtbi5zb3J0YWJsZSA6IGNvbHVtbi5wcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgICB2YXIgb3JkZXJJdGVtID0ge307XHJcbiAgICAgICAgICBvcmRlckl0ZW1ba2V5XSA9IGNvbHVtbi4kb3JkZXJieSA/IGNvbHVtbi4kb3JkZXJieS5kaXIgKiAtMSA6IDE7XHJcbiAgICAgICAgICBvcmRlcmJ5LnB1c2gob3JkZXJJdGVtKTtcclxuXHJcbiAgICAgICAgICB0aGlzLnByb2plY3Rpb24uc2V0KHsgJ29yZGVyYnknOiBvcmRlcmJ5LCAncGFnZS5udW1iZXInOiAwIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgIHZhciBsb2NhbCA9IF8ub21pdChvcHRpb25zLCAncHJvamVjdGlvbicsICdsYXlvdXQnKTtcclxuICAgICAgdGhpcy5vcHRpb25zLnNldChsb2NhbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmxheW91dC5yZW1vdmUoKTtcclxuICAgICAgQmFja2JvbmUuVmlldy5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMuc2V0LmFwcGx5KHRoaXMub3B0aW9ucywgXy50b0FycmF5KGFyZ3VtZW50cykpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgdGhpcy5sYXlvdXQucmVuZGVyKCk7XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5mZXRjaCkge1xyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbi51cGRhdGUoeyBkZWVwOiB0cnVlIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb24uZ2V0KCdyb3cuY2hlY2subGlzdCcpIHx8IFtdO1xyXG4gICAgfSxcclxuXHJcbiAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIHNlbGVjdENvbnRhaW5lcih1c2VyQ29udGFpbmVyKSB7XHJcbiAgICBpZiAodXNlckNvbnRhaW5lciAmJiB3aW5kb3cgIT09IHVzZXJDb250YWluZXIgJiYgRWxlbWVudENvbnRhaW5lci5pc1ZhbGlkQ29udGFpbmVyKHVzZXJDb250YWluZXIpKSB7XHJcbiAgICAgIHJldHVybiBuZXcgRWxlbWVudENvbnRhaW5lcih7IGVsOiB1c2VyQ29udGFpbmVyIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgV2luZG93Q29udGFpbmVyKCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gR3JpZFZpZXc7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL2dyaWQtdmlldy5qc1xuICoqLyIsImRlZmluZShbXHJcbiAgJ2xpYi91bmRlcnNjb3JlJyxcclxuICAnbGliL2JhY2tib25lJyxcclxuXSwgZnVuY3Rpb24gKF8sIEJhY2tib25lKSB7XHJcbiAgcmV0dXJuIEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICBsYXlvdXQ6IHVuZGVmaW5lZCxcclxuICAgICAgcHJvamVjdGlvbjogdW5kZWZpbmVkLFxyXG4gICAgfSxcclxuICB9KTtcclxufSk7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvbW9kZWwvaW5kZXguanNcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2xpYi9qcXVlcnknLFxyXG4gICdjb21wb25lbnQvZ3JpZC9jb250YWluZXJCYXNlJyxcclxuXSwgZnVuY3Rpb24gKF8sICQsIENvbnRhaW5lckJhc2UpIHtcclxuICB2YXIgV2luZG93Q29udGFpbmVyID0gQ29udGFpbmVyQmFzZS5leHRlbmQoe1xyXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgb3B0aW9ucywgeyBlbDogd2luZG93IH0pO1xyXG4gICAgICBDb250YWluZXJCYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBbb3B0aW9uc10uY29uY2F0KF8ucmVzdChhcmd1bWVudHMpKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9mZnNldDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuICQoZWxlbWVudCkub2Zmc2V0KCk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gV2luZG93Q29udGFpbmVyO1xyXG59KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy93aW5kb3dDb250YWluZXIuanNcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2xpYi9qcXVlcnknLFxyXG4gICdsaWIvYmFja2JvbmUnLFxyXG5dLCBmdW5jdGlvbiAoXywgJCwgQmFja2JvbmUpIHtcclxuICB2YXIgQ29udGFpbmVyQmFzZSA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICAgIGV2ZW50czoge1xyXG4gICAgICBzY3JvbGw6ICdvblNjcm9sbCcsXHJcbiAgICAgIHJlc2l6ZTogJ29uUmVzaXplJyxcclxuICAgIH0sXHJcblxyXG4gICAgb25TY3JvbGw6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIHRoaXMudHJpZ2dlcignc2Nyb2xsOmNvbnRhaW5lcicsIGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblJlc2l6ZTogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdyZXNpemU6Y29udGFpbmVyJywgZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9mZnNldDogZnVuY3Rpb24gKC8qIGVsZW1lbnQsIHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCAqLykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPZmZzZXQgZnVuY3Rpb24gbm90IGltcGxlbWVudGVkXCIpO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIENvbnRhaW5lckJhc2U7XHJcbn0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL2NvbnRhaW5lckJhc2UuanNcbiAqKi8iLCJkZWZpbmUoW1xyXG4gICdsaWIvdW5kZXJzY29yZScsXHJcbiAgJ2xpYi9qcXVlcnknLFxyXG4gICdjb21wb25lbnQvZ3JpZC9jb250YWluZXJCYXNlJyxcclxuXSwgZnVuY3Rpb24gKF8sICQsIENvbnRhaW5lckJhc2UpIHtcclxuICB2YXIgRWxlbWVudENvbnRhaW5lciA9IENvbnRhaW5lckJhc2UuZXh0ZW5kKHtcclxuICAgIG9mZnNldDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgdmFyIHBvc2l0aW9uID0gJChlbGVtZW50KS5wb3NpdGlvbigpO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCArIHRoaXMuJGVsLnNjcm9sbFRvcCgpLFxyXG4gICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgKyB0aGlzLiRlbC5zY3JvbGxMZWZ0KCksXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICBFbGVtZW50Q29udGFpbmVyLmlzVmFsaWRDb250YWluZXIgPSBmdW5jdGlvbiAodXNlckNvbnRhaW5lcikge1xyXG4gICAgcmV0dXJuIFsnYWJzb2x1dGUnLCAncmVsYXRpdmUnLCAnZml4ZWQnXS5pbmRleE9mKCQodXNlckNvbnRhaW5lcikuY3NzKCdwb3NpdGlvbicpKSA+PSAwO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBFbGVtZW50Q29udGFpbmVyO1xyXG59KTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy9lbGVtZW50Q29udGFpbmVyLmpzXG4gKiovIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XHJcbmltcG9ydCB7XHJcbiAgRGF0YVNvdXJjZSxcclxuICBPRGF0YURhdGFTb3VyY2UsXHJcbiAgSlNEYXRhRGF0YVNvdXJjZSxcclxuICBNZW1vcnlEYXRhU291cmNlLFxyXG59IGZyb20gJy4uL2RhdGEtc291cmNlJztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiBEYXRhU291cmNlQ29uZmlnXHJcbiAqIEB0eXBlIHtEYXRhU291cmNlfEJ1aWx0aW5EYXRhU291cmNlQ29uZmlnfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiBCdWlsdGluRGF0YVNvdXJjZUNvbmZpZ1xyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxyXG4gKiAgICBUaGUgYnVpbHRpbiBkYXRhIHNvdXJjZSB0eXBlLCBhdmFpbGFibGUgdmFsdWVzIGFyZSAnb2RhdGEnLCAnanMtZGF0YSdcclxuICogICAgYW5kICdtZW1vcnknLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZz99IHByaW1hcnlLZXlcclxuICogICAgVGhlIHByaW1hcnlLZXkgZm9yIHRoZSBkYXRhIHNvdXJjZS4gUmVxdWlyZWQgYnkgJ29kYXRhJyBhbmQgJ21lbW9yeSdcclxuICogICAgZGF0YSBzb3VyY2VzLlxyXG4gKiBAcHJvcGVydHkge0pTRGF0YVJlc291cmNlP30gZW50aXR5XHJcbiAqICAgIFRoZSBKU0RhdGFSZXNvdXJjZSByZXByZXNlbnRpbmcgdGhlIGVudGl0eSBzZXQuIFJlcXVpcmVkIGJ5ICdqcy1kYXRhJ1xyXG4gKiAgICBkYXRhIHNvdXJjZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmc/fSB1cmxcclxuICogICAgVGhlIFVSTCBmb3IgdGhlIGVudGl0eSBzZXQuIFJlcXVpcmVkIGJ5ICdvZGF0YScgZGF0YSBzb3VyY2UuXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0W10/fSBkYXRhXHJcbiAqICAgIFRoZSBpbi1tZW1vcnkgZGF0YSBzZXQuIFJlcXVpcmVkIGJ5ICdtZW1vcnknIGRhdGEgc291cmNlLlxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGRlZmluZVBsdWdpbiA9PiBkZWZpbmVQbHVnaW4oJ2RhdGFTb3VyY2UnLCBbJ2NvbmZpZyddLCBjb25maWcgPT4ge1xyXG4gIGNvbnN0IGRhdGFTb3VyY2UgPSBfLnJlc3VsdChjb25maWcsICdkYXRhU291cmNlJywge30pO1xyXG5cclxuICBpZiAoZGF0YVNvdXJjZSBpbnN0YW5jZW9mIERhdGFTb3VyY2UpIHtcclxuICAgIHJldHVybiBkYXRhU291cmNlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgeyB0eXBlLCBwcmltYXJ5S2V5IH0gPSBkYXRhU291cmNlO1xyXG5cclxuICBpZiAodHlwZSA9PT0gJ21lbW9yeScpIHtcclxuICAgIHJldHVybiBuZXcgTWVtb3J5RGF0YVNvdXJjZShkYXRhU291cmNlLmRhdGEsIHByaW1hcnlLZXkpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGUgPT09ICdvZGF0YScpIHtcclxuICAgIHJldHVybiBuZXcgT0RhdGFEYXRhU291cmNlKGRhdGFTb3VyY2UudXJsLCBwcmltYXJ5S2V5KTtcclxuICB9XHJcblxyXG4gIGlmIChfLmNvbnRhaW5zKFsnanNkYXRhJywgJ2pzLWRhdGEnXSwgdHlwZSkpIHtcclxuICAgIHJldHVybiBuZXcgSlNEYXRhRGF0YVNvdXJjZShkYXRhU291cmNlLmVudGl0eSwgZGF0YVNvdXJjZS5vcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0YSBzb3VyY2UgdHlwZScpO1xyXG59KTtcclxuXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvdm5leHQvZmFjdG9yeS9kYXRhLXNvdXJjZS1wbHVnaW4uanNcbiAqKi8iLCJleHBvcnQgeyBEYXRhU291cmNlIH0gZnJvbSAnLi9iYXNlLmpzJztcclxuZXhwb3J0IHsgT0RhdGFEYXRhU291cmNlIH0gZnJvbSAnLi9vZGF0YS5qcyc7XHJcbmV4cG9ydCB7IEpTRGF0YURhdGFTb3VyY2UgfSBmcm9tICcuL2pzLWRhdGEuanMnO1xyXG5leHBvcnQgeyBNZW1vcnlEYXRhU291cmNlIH0gZnJvbSAnLi9tZW1vcnkuanMnO1xyXG5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy92bmV4dC9kYXRhLXNvdXJjZS9pbmRleC5qc1xuICoqLyIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xyXG5cclxuY29uc3QgZGVmYXVsdFByaW1hcnlLZXkgPSAnX19wcmltYXJ5X2tleV9fJztcclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIGRhdGEgc291cmNlcy5cclxuICogQGNsYXNzIERhdGFTb3VyY2VcclxuICogQHBhcmFtIHtzdHJpbmd9IFtwcmltYXJ5S2V5PSdfX3ByaW1hcnlfa2V5X18nXVxyXG4gKiAgICBUaGUgcHJpbWFyeSBrZXkgb2YgdGhlIGVudGl0eSBzZXQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRGF0YVNvdXJjZSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaW1hcnlLZXkgPSBkZWZhdWx0UHJpbWFyeUtleSkge1xyXG4gICAgdGhpcy5fcHJpbWFyeUtleSA9IHByaW1hcnlLZXk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgcHJpbWFyeSBrZXkgb2YgdGhlIGRhdGEgc291cmNlLlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IHByaW1hcnlLZXkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJpbWFyeUtleTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFF1ZXJ5IHRoZSBkYXRhIHNvdXJjZSB3aXRoIGdpdmVuIHBhcmFtZXRlcnNcclxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHF1ZXJ5IHBhcmFtZXRlcnNcclxuICAgKi9cclxuICBxdWVyeShwYXJhbXMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGl0ZW1zOiBbXSxcclxuICAgICAgdG90YWxDb3VudDogMCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgb3JkZXItYnkgY29uZmlndXJhdGlvbiBmb3IgdGhlIGRhdGEgc291cmNlLlxyXG4gICAqIEB0eXBlZGVmIE9yZGVyQnlDb25maWdcclxuICAgKiBAdHlwZSB7T3JkZXJCeUl0ZW18T3JkZXJCeUl0ZW1bXX1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQSBba2V5OiBzdHJpbmcsIGRpcmVjdGlvbjogbnVtYmVyXSBwYWlyLlxyXG4gICAqIEB0eXBlZGVmIE5vcm1hbGl6ZWRPcmRlckJ5UGFpclxyXG4gICAqIEB0eXBlIHthcnJheX1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplIHRoZSBvcmRlcmJ5IHBhcmFtZXRlciBmb3IgZGF0YSBzb3VyY2UuXHJcbiAgICogQHBhcmFtIHtPcmRlckJ5Q29uZmlnfSBvcmRlckJ5XHJcbiAgICogQHJldHVybiB7Tm9ybWFsaXplZE9yZGVyQnlQYWlyW119XHJcbiAgICovXHJcbiAgbm9ybWFsaXplT3JkZXJCeShvcmRlckJ5ID0gW10pIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc2luZ2xlIG9yZGVyLWJ5IGl0ZW0gd2l0aCBrZXkgYW5kIGRpcmVjdGlvbi5cclxuICAgICAqIEB0eXBlZGVmIE9yZGVyQnlJdGVtXHJcbiAgICAgKiBAdHlwZSB7T3JkZXJCeU9iamVjdHxPcmRlckJ5UGFpcn1cclxuICAgICAqL1xyXG4gICAgcmV0dXJuIF8ucmVkdWNlKF8uaXNBcnJheShvcmRlckJ5KSA/IG9yZGVyQnkgOiBbb3JkZXJCeV0sIChtZW1vLCBpdGVtKSA9PiB7XHJcbiAgICAgIGxldCBrZXkgPSBudWxsO1xyXG4gICAgICBsZXQgZGlyZWN0aW9uID0gbnVsbDtcclxuICAgICAgbGV0IGRpclN0cmluZyA9IG51bGw7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQSBba2V5OiBPcmRlckJ5S2V5LCBkaXJlY3Rpb246IG51bWJlcl0gcGFpci5cclxuICAgICAgICogQHR5cGVkZWYgT3JkZXJCeVBhaXJcclxuICAgICAgICogQHR5cGUge2FycmF5fVxyXG4gICAgICAgKi9cclxuICAgICAgaWYgKF8uaXNBcnJheShpdGVtKSkge1xyXG4gICAgICAgIGtleSA9IGl0ZW1bMF07XHJcbiAgICAgICAgZGlyZWN0aW9uID0gaXRlbVsxXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEB0eXBlZGVmIE9yZGVyQnlPYmplY3RcclxuICAgICAgICogQHR5cGUge29iamVjdH1cclxuICAgICAgICogQHByb3BlcnR5IHtPcmRlckJ5S2V5fSBrZXkgLSBUaGUga2V5IG9mZiB0aGUgb3JkZXIgYnkgaXRlbVxyXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiBvZiB0aGUgb3JkZXIgYnkgaXRlbSwgcG9zaXRpdmVcclxuICAgICAgICogZm9yIGFzY2VuZGluZywgbm9uLXBvc2l0aXZlIGZvciBkZXNjZW5kaW5nXHJcbiAgICAgICAqL1xyXG4gICAgICBpZiAoXy5pc09iamVjdChpdGVtKSkge1xyXG4gICAgICAgIGtleSA9IGl0ZW0ua2V5O1xyXG4gICAgICAgIGRpcmVjdGlvbiA9IGl0ZW0uZGlyZWN0aW9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIV8uaXNOdW1iZXIoZGlyZWN0aW9uKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkaXJlY3Rpb24gb3B0aW9uIGZvciBvcmRlckJ5Jyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lbW87XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXByZXNlbnRzIGFuIG9yZGVyIGJ5IGtleVxyXG4gICAgICAgKiAgKiBXaGVuIGl0J3MgYSBzdHJpbmcsIGl0J3MgdGhlIGtleSBwYXRoIG9mIHRoZSBzb3J0aW5nIHZhbHVlLlxyXG4gICAgICAgKiAgKiBXaGVuIGl0J3MgYSBjYWxsYmFjaywgaXQgdGFrZXMgYSBkaXJlY3Rpb24sIGFuZCByZXR1cm4gYSBub3JtYWxpemVkXHJcbiAgICAgICAqICAgIG9yZGVyIGNvbmZpZy5cclxuICAgICAgICogQHR5cGVkZWYgT3JkZXJCeUtleVxyXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfE9yZGVyQnlDYWxsYmFja31cclxuICAgICAgICovXHJcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oa2V5KSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjYWxsYmFjayBPcmRlckJ5Q2FsbGJhY2tcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiBvZiB0aGUgb3JkZXIgYnkgaXRlbVxyXG4gICAgICAgICAqIEByZXR1cm4ge09yZGVyQnlDb25maWd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmV0dXJuIG1lbW8uY29uY2F0KHRoaXMubm9ybWFsaXplT3JkZXJCeShrZXkoZGlyZWN0aW9uKSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoXy5pc1N0cmluZyhrZXkpKSB7XHJcbiAgICAgICAgbWVtby5wdXNoKFtrZXksIGRpcmVjdGlvbl0pO1xyXG4gICAgICAgIHJldHVybiBtZW1vO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IG9wdGlvbiBmb3Igb3JkZXJCeScpO1xyXG4gICAgfSwgW10pO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvdm5leHQvZGF0YS1zb3VyY2UvYmFzZS5qc1xuICoqLyIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xyXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xyXG5pbXBvcnQgUHJvbWlzZSBmcm9tICdibHVlYmlyZCc7XHJcbmltcG9ydCB7IERhdGFTb3VyY2UgfSBmcm9tICcuL2Jhc2UuanMnO1xyXG5cclxuZnVuY3Rpb24gdHJhbnNsYXRlT3JkZXJCeShkYXRhU291cmNlLCBvcmRlckJ5UGFyYW1zKSB7XHJcbiAgcmV0dXJuIF8uY2hhaW4oZGF0YVNvdXJjZS5ub3JtYWxpemVPcmRlckJ5KG9yZGVyQnlQYXJhbXMpKVxyXG4gICAgLm1hcCgoW2tleSwgZGlyZWN0aW9uXSkgPT4gYCR7a2V5fSAke2RpcmVjdGlvbiA+IDAgPyAnYXNjJyA6ICdkZXNjJ31gKVxyXG4gICAgLmpvaW4oJywnKVxyXG4gICAgLnZhbHVlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZVBhcmFtcyhkYXRhU291cmNlLCBwYXJhbXMpIHtcclxuICByZXR1cm4gXy5jaGFpbihwYXJhbXMpXHJcbiAgICAub21pdCgnc2tpcCcsICd0YWtlJywgJ2ZpbHRlcicsICdvcmRlcmJ5JylcclxuICAgIC5leHRlbmQoXy5waWNrKHtcclxuICAgICAgJHNraXA6IHBhcmFtcy5za2lwLFxyXG4gICAgICAkdG9wOiBwYXJhbXMudGFrZSxcclxuICAgICAgJGZpbHRlcjogcGFyYW1zLmZpbHRlcixcclxuICAgICAgJG9yZGVyYnk6IHRyYW5zbGF0ZU9yZGVyQnkoZGF0YVNvdXJjZSwgcGFyYW1zLm9yZGVyYnkpLFxyXG4gICAgICAkY291bnQ6IHRydWUsXHJcbiAgICB9LCBCb29sZWFuKSlcclxuICAgIC52YWx1ZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogRGF0YSBzb3VyY2UgZnJvbSBhbiBPRGF0YSBzZXJ2aWNlLlxyXG4gKiBAY2xhc3MgT0RhdGFEYXRhU291cmNlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcclxuICogICAgVGhlIHJvb3QgVVJMIG9mIHRoZSBPRGF0YSBlbnRpdHkgc2V0LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeUtleVxyXG4gKiAgICBUaGUgcHJpbWFyeSBrZXkgb2YgdGhlIGVudGl0eSBzZXQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgT0RhdGFEYXRhU291cmNlIGV4dGVuZHMgRGF0YVNvdXJjZSB7XHJcbiAgY29uc3RydWN0b3IodXJsLCBwcmltYXJ5S2V5KSB7XHJcbiAgICBzdXBlcihwcmltYXJ5S2V5KTtcclxuICAgIHRoaXMuX3VybCA9IHVybDtcclxuICB9XHJcblxyXG4gIHF1ZXJ5KHBhcmFtcykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgJC5nZXRKU09OKHRoaXMuX3VybCwgdHJhbnNsYXRlUGFyYW1zKHRoaXMsIHBhcmFtcykpXHJcbiAgICAgICAgLnN1Y2Nlc3MocmVzb2x2ZSlcclxuICAgICAgICAuZmFpbCgoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XHJcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yVGhyb3duKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KS50aGVuKGRhdGEgPT4gKHtcclxuICAgICAgaXRlbXM6IGRhdGEudmFsdWUgfHwgW10sXHJcbiAgICAgIHRvdGFsQ291bnQ6IGRhdGFbJ0BvZGF0YS5jb3VudCddIHx8IDAsXHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxuICBnZXQgdXJsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3VybDtcclxuICB9XHJcbn1cclxuXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvdm5leHQvZGF0YS1zb3VyY2Uvb2RhdGEuanNcbiAqKi8iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcclxuaW1wb3J0IHsgRGF0YVNvdXJjZSB9IGZyb20gJy4vYmFzZS5qcyc7XHJcblxyXG5mdW5jdGlvbiB0cmFuc2xhdGVPcmRlckJ5KGRhdGFTb3VyY2UsIG9yZGVyQnlQYXJhbXMpIHtcclxuICBjb25zdCBvcmRlckJ5ID0gXy5jaGFpbihkYXRhU291cmNlLm5vcm1hbGl6ZU9yZGVyQnkob3JkZXJCeVBhcmFtcykpXHJcbiAgICAubWFwKChba2V5LCBkaXJlY3Rpb25dKSA9PiBbXHJcbiAgICAgIGtleSxcclxuICAgICAgZGlyZWN0aW9uID4gMCA/ICdBU0MnIDogJ0RFU0MnLFxyXG4gICAgXSlcclxuICAgIC52YWx1ZSgpO1xyXG5cclxuICByZXR1cm4gXy5pc0VtcHR5KG9yZGVyQnkpID8gbnVsbCA6IG9yZGVyQnk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZVBhcmFtcyhkYXRhU291cmNlLCBwYXJhbXMpIHtcclxuICByZXR1cm4gXy5jaGFpbihwYXJhbXMpXHJcbiAgICAub21pdCgnc2tpcCcsICd0YWtlJywgJ2ZpbHRlcicsICdvcmRlcmJ5JylcclxuICAgIC5leHRlbmQoXy5waWNrKHtcclxuICAgICAgb2Zmc2V0OiBwYXJhbXMuc2tpcCxcclxuICAgICAgbGltaXQ6IHBhcmFtcy50YWtlLFxyXG4gICAgICB3aGVyZTogcGFyYW1zLmZpbHRlcixcclxuICAgICAgb3JkZXJCeTogdHJhbnNsYXRlT3JkZXJCeShkYXRhU291cmNlLCBwYXJhbXMub3JkZXJieSksXHJcbiAgICB9LCBCb29sZWFuKSlcclxuICAgIC52YWx1ZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogRGF0YSBzb3VyY2UgZnJvbSBhIEpTRGF0YSByZXNvdXJjZVxyXG4gKiBAY2xhc3MgSlNEYXRhRGF0YVNvdXJjZVxyXG4gKiBAcGFyYW0ge0pTRGF0YVJlc291cmNlfSByZXNvdXJjZVxyXG4gKiAgICBUaGUgSlNEYXRhIHJlc291cmNlIHJlcHJlc2VudGluZyB0aGUgZW50aXR5IHNldC5cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogICAgVGhlIHF1ZXJ5IG9wdGlvbnMuIFlvdSBjYW4gdXNlIGl0IGFkZCBKU0RhdGEgbGlmZSBjeWNsZSBob29rcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBKU0RhdGFEYXRhU291cmNlIGV4dGVuZHMgRGF0YVNvdXJjZSB7XHJcbiAgY29uc3RydWN0b3IocmVzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIocmVzb3VyY2UuaWRBdHRyaWJ1dGUpO1xyXG4gICAgdGhpcy5fcmVzb3VyY2UgPSByZXNvdXJjZTtcclxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgcXVlcnkocGFyYW1zKSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgcGFyYW1zLm9wdGlvbnMsIHRoaXMuX29wdGlvbnMpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9yZXNvdXJjZVxyXG4gICAgICAuZmluZEFsbCh0cmFuc2xhdGVQYXJhbXModGhpcywgXy5vbWl0KHBhcmFtcywgJ29wdGlvbnMnKSksIG9wdGlvbnMpXHJcbiAgICAgIC50aGVuKGRhdGEgPT4gKHtcclxuICAgICAgICBpdGVtczogZGF0YS5zbGljZSgpLFxyXG4gICAgICAgIHRvdGFsQ291bnQ6IGRhdGEudG90YWxDb3VudCB8fCAwLFxyXG4gICAgICB9KSk7XHJcbiAgfVxyXG5cclxuICBnZXQgcmVzb3VyY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2U7XHJcbiAgfVxyXG59XHJcblxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3ZuZXh0L2RhdGEtc291cmNlL2pzLWRhdGEuanNcbiAqKi8iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcclxuaW1wb3J0IHsgRGF0YVNvdXJjZSB9IGZyb20gJy4vYmFzZS5qcyc7XHJcblxyXG4vKipcclxuICogRGF0YSBzb3VyY2UgZnJvbSBhbiBpbi1tZW1vcnkgYXJyYXkuXHJcbiAqIEBjbGFzcyBNZW1vcnlEYXRhU291cmNlXHJcbiAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcclxuICogICAgVGhlIGluLW1lbW9yeSBhcnJheSBmb3IgdGhlIGRhdGEgc2V0LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeUtleVxyXG4gKiAgICBUaGUgcHJpbWFyeSBrZXkgb2YgdGhlIGRhdGEgc2V0LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE1lbW9yeURhdGFTb3VyY2UgZXh0ZW5kcyBEYXRhU291cmNlIHtcclxuICBjb25zdHJ1Y3RvcihkYXRhLCBwcmltYXJ5S2V5KSB7XHJcbiAgICBzdXBlcihwcmltYXJ5S2V5KTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgfVxyXG5cclxuICBxdWVyeShwYXJhbXMpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgc2tpcCA9IDAsXHJcbiAgICAgIHRha2UgPSB0aGlzLmRhdGEubGVuZ3RoIC0gc2tpcCxcclxuICAgICAgZmlsdGVyID0gKCkgPT4gdHJ1ZSxcclxuICAgICAgb3JkZXJieSA9IFtdLFxyXG4gICAgfSA9IHBhcmFtcyB8fCB7fTtcclxuXHJcbiAgICBjb25zdCB7IGtleSwgZGlyZWN0aW9uIH0gPSBfLmZpcnN0KG9yZGVyYnkpIHx8IHt9O1xyXG4gICAgbGV0IHNvcnRJdGVyYXRlZSA9IG51bGw7XHJcblxyXG4gICAgaWYgKF8uaXNGdW5jdGlvbihrZXkpKSB7XHJcbiAgICAgIHNvcnRJdGVyYXRlZSA9IGtleTtcclxuICAgIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhrZXkpKSB7XHJcbiAgICAgIGNvbnN0IHNlZ3MgPSBrZXkuc3BsaXQoL1tcXC5cXC9dLyk7XHJcbiAgICAgIHNvcnRJdGVyYXRlZSA9IGl0ZW0gPT4gXy5yZWR1Y2Uoc2VncywgKG1lbW8sIHNlZykgPT4gXy5yZXN1bHQobWVtbywgc2VnKSwgaXRlbSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGRhdGEgPSBfLmZpbHRlcih0aGlzLmRhdGEsIGZpbHRlcik7XHJcblxyXG4gICAgaWYgKHNvcnRJdGVyYXRlZSkge1xyXG4gICAgICBkYXRhID0gXy5zb3J0QnkoZGF0YSwgc29ydEl0ZXJhdGVlKTtcclxuXHJcbiAgICAgIGlmIChkaXJlY3Rpb24gPCAwKSB7XHJcbiAgICAgICAgZGF0YS5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbENvdW50OiBkYXRhLmxlbmd0aCxcclxuICAgICAgaXRlbXM6IGRhdGEuc2xpY2Uoc2tpcCwgc2tpcCArIHRha2UpLFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvdm5leHQvZGF0YS1zb3VyY2UvbWVtb3J5LmpzXG4gKiovIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XHJcbmltcG9ydCB7IEdyaWRWaWV3IH0gZnJvbSAnLi4vZ3JpZC12aWV3LmpzJztcclxuXHJcbmNvbnN0IENPTlNUUlVDVE9SX09QVElPTlMgPSBbJ2VsJywgJ3Njcm9sbGluZycsICd0YWJsZUNsYXNzZXMnXTtcclxuY29uc3QgTk9ORV9QUk9KRUNUSU9OX09QVElPTlMgPSBDT05TVFJVQ1RPUl9PUFRJT05TLmNvbmNhdChbJ3BsdWdpbnMnXSk7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgR3JpZFZpZXdDb25maWdcclxuICogQHR5cGUge09iamVjdH1cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcclxuICogICAgTmFtZSBvZiB0aGUgZ3JpZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudHxqUXVlcnl9IGVsXHJcbiAqICAgIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIGdyaWQgdmlldy5cclxuICogQHByb3BlcnR5IHtTY3JvbGxpbmdDb25maWd9IHNjcm9sbGluZ1xyXG4gKiAgICBUaGUgc2Nyb2xsaW5nIGJlaGF2aW9yIGNvbmZpZ3VyYXRvaW4uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nc1tdfSB0YWJsZUNsYXNzZXNcclxuICogICAgQW4gYXJyYXkgb2YgY2xhc3NlcyB0byBiZSBhcHBsaWVkIHRvIGBUQUJMRWAgZWxlbWVudHMuXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsT2JqZWN0Pn0gcGx1Z2luc1xyXG4gKiAgICBUaGUgcGx1Z2luIGNvbmZpZ3VyYXRpb25zLiBUaGUga2V5cyBhcmUgdGhlIHBsdWdpbiBuYW1lcywgYW5kIHRoZSB2YWx1ZXNcclxuICogICAgYXJlIHRoZSBjb25maWd1YXRpb24gb2JqZWN0cy5cclxuICogQHByb3BlcnR5IHtSb3dzQ29uZmlnfSByb3dzXHJcbiAqICAgIFRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGhlYWQvYm9keS9mb290IHJvd3MuXHJcbiAqIEBwcm9wZXJ0eSB7Q29sdW1uQ29uZmlnW119IGNvbHVtbnNcclxuICogICAgQXJyYXkgb2YgdGhlIGNvbHVtbnMgY29uZmlndXJhdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7RGF0YVNvdXJjZUNvbmZpZ30gZGF0YVNvdXJjZVxyXG4gKiAgICBUaGUgZGF0YSBzb3VyY2UgY29uZmlndXJhdGlvbnMuIFRlbGxzIHRoZSBncmlkIGhvdyB0byBmZXRjaCBkYXRhLlxyXG4gKiBAcHJvcGVydHkge1F1ZXJ5Q29uZmlnfSBxdWVyeVxyXG4gKiAgICBUaGUgcXVlcnkgcGFyYW1ldGVycyBmb3IgZGF0YSBmZXRjaC5cclxuICogQHByb3BlcnR5IHtTZWxlY3Rpb25Db25maWd9IHNlbGVjdGlvblxyXG4gKiAgICBDb25maWcgdGhlIGJlaGF2aW9yIGZvciByb3cgc2VsZWN0aW9uLlxyXG4gKiBAcHJvcGVydHkge1NvcnRhYmxlSGVhZGVyQ29uZmlnfSBzb3J0YWJsZUhlYWRlclxyXG4gKiAgICBDb25maWcgdGhlIHN0YXRlIGFuZCB2aXN1YWwgb2YgdGhlIGNsaWNrLXRvLXNvcnQgY29sdW1uIGhlYWRlcnMuXHJcbiAqIEBwcm9wZXJ0eSB7ZXh0ZXJuYWw6QmFja2JvbmVWaWV3RXZlbnRIYXNofSBldmVudHNcclxuICogICAgQ3VzdG9taXplZCBldmVudCBoYXNoIGluIGZvcm0gb2YgYEJhY2tib25lLlZpZXcjZXZlbnRzYC5cclxuICogICAgSXQgY2FuIGJlIHNldCB0byBoYW5kbGVcclxuICogICAgKiBUaGUgRE9NIGV2ZW50cyBpbnNpZGUgdGhlIGBHcmlkVmlld2AuXHJcbiAqICAgICogVGhlIGBHcmlkVmlld2AgZXZlbnRzLCBlLmcuIHtAbGluayBHcmlkVmlldyN3aWxsVXBkYXRlfSxcclxuICogICAgICB7QGxpbmsgR3JpZFZpZXcjZGlkVXBkYXRlfS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGRlZmluZVBsdWdpbiA9PiBkZWZpbmVQbHVnaW4oJ2dyaWRWaWV3JywgW1xyXG4gICdjb25maWcnLFxyXG4gICdkYXRhU291cmNlJyxcclxuXSwgKGNvbmZpZywgZGF0YVNvdXJjZSkgPT4ge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBfLmNoYWluKGNvbmZpZylcclxuICAgIC5waWNrKENPTlNUUlVDVE9SX09QVElPTlMpXHJcbiAgICAuZXh0ZW5kKHsgZGF0YVNvdXJjZSB9KVxyXG4gICAgLnZhbHVlKCk7XHJcbiAgY29uc3QgZ3JpZFZpZXcgPSBuZXcgR3JpZFZpZXcob3B0aW9ucyk7XHJcblxyXG4gIGdyaWRWaWV3LnNldChfLm9taXQoY29uZmlnLCBOT05FX1BST0pFQ1RJT05fT1BUSU9OUykpO1xyXG5cclxuICByZXR1cm4gZ3JpZFZpZXc7XHJcbn0pO1xyXG5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy92bmV4dC9mYWN0b3J5L2dyaWQtdmlldy1wbHVnaW4uanNcbiAqKi8iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcclxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcclxuaW1wb3J0IEJhY2tib25lIGZyb20gJ2JhY2tib25lJztcclxuaW1wb3J0IFByb21pc2UgZnJvbSAnYmx1ZWJpcmQnO1xyXG5pbXBvcnQge1xyXG4gIHF1ZXJ5LFxyXG4gIGJ1ZmZlcixcclxuICBzZWxlY3Rpb24sXHJcbiAgc2V0U2VsZWN0QWxsLFxyXG4gIHNldFNlbGVjdFJvdyxcclxuICBjb2x1bW5zLFxyXG4gIHJvd3MsXHJcbiAgY29sdW1uR3JvdXAsXHJcbiAgY2VsbHMsXHJcbiAgZWRpdGFibGUsXHJcbiAgc29ydGFibGVIZWFkZXIsXHJcbiAgZXZlbnRzLFxyXG59IGZyb20gJy4vcHJvamVjdGlvbic7XHJcblxyXG5pbXBvcnQgeyBUYWJsZVZpZXcgfSBmcm9tICcuL2xheW91dCc7XHJcbmltcG9ydCB7XHJcbiAgTWVtb3J5RGF0YVNvdXJjZSxcclxuICBKU0RhdGFEYXRhU291cmNlLFxyXG4gIE9EYXRhRGF0YVNvdXJjZSxcclxufSBmcm9tICcuL2RhdGEtc291cmNlJztcclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRzRGVlcChkZXN0LCBzcmMpIHtcclxuICBpZiAoXy5pc09iamVjdChkZXN0KSAmJiAhXy5pc0FycmF5KGRlc3QpKSB7XHJcbiAgICBfLmRlZmF1bHRzKGRlc3QsIHNyYyk7XHJcbiAgICBfLmVhY2goc3JjLCAodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICBpZiAoZGVzdFtrZXldICE9PSB2YWx1ZSkge1xyXG4gICAgICAgIGRlZmF1bHRzRGVlcChkZXN0W2tleV0sIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBkZXN0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBuZXh0VGljaygpIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gd2luZG93LnNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xyXG59XHJcblxyXG5jbGFzcyBQcm9qZWN0aW9uQ2hhaW4ge1xyXG4gIGNvbnN0cnVjdG9yKG1vZGVsKSB7XHJcbiAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICB0aGlzLnByb2plY3Rpb25zID0gW107XHJcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcclxuICAgIHRoaXMuaW5wdXQgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBXaGVuIHVwZGF0aW5nLCBleGVjdXRlIGVhY2ggZnVuY3Rpb24gaW4gcHJvamVjdGlvbnMgc3VjY2Vzc2l2ZWx5XHJcbiAgICovXHJcbiAgdXBkYXRlKGlucHV0LCBmb3JjZSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB1cGRhdGVkID0gZm9yY2UgfHwgaW5wdXQgIT09IHRoaXMuaW5wdXQ7XHJcblxyXG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xyXG5cclxuICAgIHJldHVybiBfLnJlZHVjZSh0aGlzLnByb2plY3Rpb25zLCAoe1xyXG4gICAgICB1cGRhdGVkLFxyXG4gICAgICBwJHN0YXRlLFxyXG4gICAgfSwgcHJvaikgPT4ge1xyXG4gICAgICBjb25zdCB7IG5hbWUsIGhhbmRsZXIsIHAkb3V0cHV0IH0gPSBwcm9qO1xyXG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuXHJcbiAgICAgIGlmICh1cGRhdGVkIHx8ICFwJG91dHB1dCB8fCBfLmhhcyh0aGlzLm1vZGVsLmNoYW5nZWQsIG5hbWUpKSB7XHJcbiAgICAgICAgcmVzdWx0LnVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHJlc3VsdC5wJHN0YXRlID0gcHJvai5wJG91dHB1dCA9IHAkc3RhdGUudGhlbihcclxuICAgICAgICAgIHN0YXRlID0+IGhhbmRsZXIoc3RhdGUsIHRoaXMubW9kZWwuZ2V0KG5hbWUpKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0LnVwZGF0ZWQgPSBmYWxzZTtcclxuICAgICAgICByZXN1bHQucCRzdGF0ZSA9IHAkb3V0cHV0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSwge1xyXG4gICAgICB1cGRhdGVkLFxyXG4gICAgICBwJHN0YXRlOiBQcm9taXNlLnJlc29sdmUoaW5wdXQpLFxyXG4gICAgfSkucCRzdGF0ZS50YXAoc3RhdGUgPT4ge1xyXG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogQWRkIHByb2plY3Rpb24gZnVuY3Rpb25zIHRvIG1vZGVsLnByb2plY3Rpb25zXHJcbiAgICovXHJcbiAgcGlwZSguLi5wcm9qcykge1xyXG4gICAgXy5jaGFpbihwcm9qcylcclxuICAgICAgLmZsYXR0ZW4oKVxyXG4gICAgICAuZWFjaChwcm9qID0+IHtcclxuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLm1vZGVsLmdldChwcm9qLm5hbWUpIHx8IHByb2ouZGVmYXVsdHM7XHJcblxyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbnMucHVzaChwcm9qKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChwcm9qLm5hbWUsIHByb2oubm9ybWFsaXplKGNvbmZpZykpO1xyXG4gICAgICB9KVxyXG4gICAgICAudmFsdWUoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENsYXNzIG9mIGEgcHJvamVjdGlvbiBncmlkIHZpZXdcclxuICogQGNsYXNzIEdyaWRWaWV3XHJcbiAqIEBleHRlbmRzIEJhY2tib25lLlZpZXdcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogICAgVGhlIGNvbnN0cnVjdG9yIG9wdGlvbnMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLnRhYmxlQ2xhc3Nlcz1bXV1cclxuICogICAgVGhlIGNsYXNzZXMgZm9yIHRoZSBUQUJMRSBlbGVtZW50cyAoY29udGVudCB0YWJsZSBhbmQgc3RpY2t5L2ZpeGVkIGhlYWRlcilcclxuICogQHBhcmFtIHtTY3JvbGxpbmdDb25maWd9IFtvcHRpb25zLnNjcm9sbGluZz17dmlydHVhbGl6ZWQ6IGZhbHNlLCBoZWFkZXI6ICdzdGF0aWMnfV1cclxuICogICAgVGhlIHNjcm9sbGluZyByZWxhdGVkIGNvbmZpZ3VyYXRpb25zXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR3JpZFZpZXcgZXh0ZW5kcyBCYWNrYm9uZS5WaWV3IHtcclxuICBpbml0aWFsaXplKHsgc2Nyb2xsaW5nLCB0YWJsZUNsYXNzZXMsIGRhdGFTb3VyY2UgfSkge1xyXG4gICAgdGhpcy5fdGFibGVWaWV3ID0gbmV3IFRhYmxlVmlldyh7XHJcbiAgICAgIGVsOiB0aGlzLiRlbCxcclxuICAgICAgc2Nyb2xsaW5nLFxyXG4gICAgICBjbGFzc2VzOiB0YWJsZUNsYXNzZXMsXHJcbiAgICB9KTtcclxuICAgIHRoaXMubW9kZWwgPSBuZXcgQmFja2JvbmUuTW9kZWwoKTtcclxuXHJcbiAgICB0aGlzLl9kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcclxuXHJcbiAgICBjb25zdCBwcm9qZWN0aW9ucyA9IHRoaXMuX3Byb2plY3Rpb25zID0ge307XHJcblxyXG4gICAgdGhpcy5fcmVnaXN0ZXJQcm9qZWN0aW9uID0gcHJvaiA9PiB7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBwcm9qLm5hbWU7XHJcblxyXG4gICAgICBpZiAoXy5oYXMocHJvamVjdGlvbnMsIFsnbmFtZSddKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRHVwbGljYXRpb24gcHJvamVjdG9ucycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQGNhbGxiYWNrIFByb2plY3Rpb25IYW5kbGVyXHJcbiAgICAgICAqIEBwYXJhbSB7RGF0YUNoYWluU3RhdGV8U3RydWN0dXJlQ2hhaW5TdGF0ZXxDb250ZW50Q2hhaW5TdGF0ZX0gc3RhdGVcclxuICAgICAgICogICAgVGhlIGlucHV0IHN0YXRlLlxyXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgICAqICAgIFRoZSBwcm9qZWN0aW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxyXG4gICAgICAgKiBAcmV0dXJuIHtEYXRhQ2hhaW5TdGF0ZXxTdHJ1Y3R1cmVDaGFpblN0YXRlfENvbnRlbnRDaGFpblN0YXRlfFByb21pc2V9XHJcbiAgICAgICAqICAgIFRoZSBvdXRwdXQgc3RhdGUgb3IgdGhlIGBQcm9taXNlYCBvZiB0aGUgb3V0cHV0IHN0YXRlLlxyXG4gICAgICAgKi9cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAdHlwZWRlZiBQcm9qZWN0aW9uRGVmaW5pdGlvblxyXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIHByb2plY3Rpb25cclxuICAgICAgICogQHByb3BlcnR5IHtQcm9qZWN0aW9uSGFuZGxlcn0gaGFuZGxlclxyXG4gICAgICAgKiAgICBUaGUgY2FsbGJhY2sgdG8gdHJhbnNmb3JtIHRoZSBzdGF0ZVxyXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdHNcclxuICAgICAgICogICAgVGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBvZiB0aGUgcHJvamVjdGlvblxyXG4gICAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBub3JtYWxpemVcclxuICAgICAgICogICAgVGhlIGNhbGxiYWNrIHRvIG5vcm1hbGl6ZSB0aGUgcHJvamVjdGlvbiBjb25maWd1cmF0aW9ucy5cclxuICAgICAgICovXHJcbiAgICAgIHByb2plY3Rpb25zW25hbWVdID0ge1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgaGFuZGxlcjogKF8uaXNGdW5jdGlvbihwcm9qKSA/IHByb2ogOiBwcm9qLmhhbmRsZXIpLmJpbmQodGhpcyksXHJcbiAgICAgICAgZGVmYXVsdHM6IHByb2ouZGVmYXVsdHMsXHJcbiAgICAgICAgbm9ybWFsaXplOiAocHJvai5ub3JtYWxpemUgfHwgXy5pZGVudGl0eSkuYmluZCh0aGlzKSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiBwcm9qZWN0aW9uc1tuYW1lXTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZWRlZiBEYXRhQ2hhaW5TdGF0ZVxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1bmlxdWVJZFxyXG4gICAgICogICAgVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIHNldCBvZiBkYXRhIGl0ZW1zLiBJdCBjaGFuZ2VzIGVhY2ggdGltZSBuZXdcclxuICAgICAqICAgIHF1ZXJ5IGlzIG1hZGUgdG8gdGhlIHNlcnZlci5cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcmltYXJ5S2V5XHJcbiAgICAgKiAgICBUaGUgcHJpbWFyeSBrZXkgb2YgdGhlIGRhdGEgaXRlbXMuXHJcbiAgICAgKiBAcHJvcGVydHkgeyhPYmplY3RbXXxGYWtlQXJyYXkpfSBpdGVtc1xyXG4gICAgICogICAgQW4gYXJyYXkgb3IgYSBmYWtlIGFycmF5IG9mIGRhdGEgaXRlbXMuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdG90YWxDb3VudFxyXG4gICAgICogICAgVGhlIHRvdGFsIGl0ZW0gY291bnQgb24gdGhlIHNlcnZlci5cclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59IGl0ZW1JbmRleFxyXG4gICAgICogICAgVGhlIGl0ZW1zIGluZGV4ZWQgYnkgcHJpbWFyeSBrZXkuXHJcbiAgICAgKiBAcHJvcGVydHkge2V4dGVybmFsOkJhY2tib25lVmlld0V2ZW50SGFzaH0gZXZlbnRzXHJcbiAgICAgKiAgICBUaGUgZXZlbnQgaGFzIGluIGZvcm0gb2YgYEJhY2tib25lLlZpZXcjZXZlbnRzYC4gQW55IHByb2plY3Rpb24gY2FuXHJcbiAgICAgKiAgICByZXNwb25zZSB0byB0aGUgRE9NIGV2ZW50cyBieSBhZGRpbmcgaXRzIG93biBldmVudCBoYW5kbGVycy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5fY2hhaW5EYXRhID0gbmV3IFByb2plY3Rpb25DaGFpbih0aGlzLm1vZGVsKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0IGV4dGVuZHMgdGhlIHtAbGluayBEYXRhQ2hhaW5TdGF0ZX0gd2l0aCBleHRyYSBwcm9wZXJ0aWVzLlxyXG4gICAgICogQHR5cGVkZWYgU3RydWN0dXJlQ2hhaW5TdGF0ZVxyXG4gICAgICogQHR5cGUge0RhdGFDaGFpblN0YXRlfVxyXG4gICAgICogQHByb3BlcnR5IHtDb2x1bW5Db25maWdbXX0gY29sdW1uc1xyXG4gICAgICogICAgVGhlIGFycmF5IG9mIGNvbHVtbiBjb25maWd1cmF0aW9ucy5cclxuICAgICAqIEBwcm9wZXJ0eSB7Um93Q29uZmlnW119IGhlYWRSb3dzXHJcbiAgICAgKiAgICBUaGUgcm93IGNvbmZpZ3VyYXRpb25zIGZvciBgVEhFQURgLlxyXG4gICAgICogQHByb3BlcnR5IHtSb3dDb25maWdbXX0gYm9keVJvd3NcclxuICAgICAqICAgIFRoZSByb3cgY29uZmlndXJhdGlvbnMgZm9yIGBUQk9EWWAuXHJcbiAgICAgKiBAcHJvcGVydHkge1Jvd0NvbmZpZ1tdfSBmb290Um93c1xyXG4gICAgICogICAgVGhlIHJvdyBjb25maWd1cmF0aW9ucyBmb3IgYFRGT09UYC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5fY2hhaW5TdHJ1Y3R1cmUgPSBuZXcgUHJvamVjdGlvbkNoYWluKHRoaXMubW9kZWwpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgZXh0ZW5kcyB0aGUge0BsaW5rIFN0cnVjdHVyZUNoYWluU3RhdGV9IHdpdGggZXh0cmEgcHJvcGVydGllcywgYW5kXHJcbiAgICAgKiBvdmVycmlkZXMgc29tZSBvZiB0aGUgcHJvcGVydGllcy5cclxuICAgICAqIEB0eXBlZGVmIENvbnRlbnRDaGFpblN0YXRlXHJcbiAgICAgKiBAdHlwZSB7U3RydWN0dXJlQ2hhaW5TdGF0ZX1cclxuICAgICAqIEBwcm9wZXJ0eSB7Q29sdW1uR3JvdXB9IGNvbHVtbkdyb3VwXHJcbiAgICAgKiAgICBUaGUgY29sdW1uIGdyb3VwIG9iamVjdCwgcmVwcmVzZW50cyB0aGUgY29tcGlsZWQgY29sdW1uIGhpZXJhcmNoeS5cclxuICAgICAqIEBwcm9wZXJ0eSB7Q29sQ29udGVudFtdfSBjb2xzXHJcbiAgICAgKiAgICBUaGUgY29udGVudCBmb3IgYENPTGAgZWxlbWVudHMgaW4gYENPTEdST1VQYC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Um93Q29udGVudH0gaGVhZFJvd3NcclxuICAgICAqICAgIFRoZSBjb250ZW50IGZvciByb3dzIGluIGBUSEVBRGAuXHJcbiAgICAgKiBAcHJvcGVydHkge1Jvd0NvbnRlbnR9IGJvZHlSb3dzXHJcbiAgICAgKiAgICBUaGUgY29udGVudCBmb3Igcm93cyBpbiBgVEJPRFlgLlxyXG4gICAgICogQHByb3BlcnR5IHtSb3dDb250ZW50fSBmb290Um93c1xyXG4gICAgICogICAgVGhlIGNvbnRlbnQgZm9yIHJvd3MgaW4gYFRGT09UYC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5fY2hhaW5Db250ZW50ID0gbmV3IFByb2plY3Rpb25DaGFpbih0aGlzLm1vZGVsKTtcclxuXHJcbiAgICB0aGlzLnBpcGVEYXRhUHJvamVjdGlvbnMocXVlcnksIGJ1ZmZlcik7XHJcbiAgICB0aGlzLnBpcGVTdHJ1Y3R1cmVQcm9qZWN0aW9ucyhbXHJcbiAgICAgIGNvbHVtbnMsXHJcbiAgICAgIHJvd3MsXHJcbiAgICAgIHNlbGVjdGlvbixcclxuICAgIF0pO1xyXG4gICAgdGhpcy5waXBlQ29udGVudFByb2plY3Rpb25zKFtcclxuICAgICAgY29sdW1uR3JvdXAsXHJcbiAgICAgIGNlbGxzLFxyXG4gICAgICBlZGl0YWJsZSxcclxuICAgICAgc29ydGFibGVIZWFkZXIsXHJcbiAgICAgIGV2ZW50cyxcclxuICAgIF0pO1xyXG5cclxuICAgIGNvbnN0IHBhdGNoRXZlbnRzID0gc3RhdGUgPT4gXy5leHRlbmQoc3RhdGUsIHtcclxuICAgICAgZXZlbnRzOiBfLm1hcE9iamVjdChzdGF0ZS5ldmVudHMsIGhhbmRsZXIgPT4gaGFuZGxlci5iaW5kKHRoaXMpKSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcmVmcmVzaFN0YXRlID0ge1xyXG4gICAgICBjaGFuZ2VzOiBudWxsLFxyXG4gICAgICBwcm9taXNlOiBudWxsLFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLl9pc1JlbmRlcmVkID0gZmFsc2U7XHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2ggdGhlIEdyaWRWaWV3XHJcbiAgICAgKiBAZnVuY3Rpb24gcmVmcmVzaFxyXG4gICAgICogQG1lbWJlcm9mIEdyaWRWaWV3XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXVxyXG4gICAgICogICAgVHJ1ZSBmb3IgZm9yY2UgcmVmcmVzaCBpZ25vcmluZyB0aGUgY2FjaGVkIHN0YXRlcy5cclxuICAgICAqL1xyXG4gICAgY29uc3QgcmVmcmVzaCA9IHRoaXMucmVmcmVzaCA9IGZvcmNlID0+IHtcclxuICAgICAgY29uc3QgY2hhbmdlcyA9IHJlZnJlc2hTdGF0ZS5jaGFuZ2VzO1xyXG5cclxuICAgICAgcmVmcmVzaFN0YXRlLmNoYW5nZXMgPSBudWxsO1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBgR3JpZFZpZXdgIHdpbGwgdXBkYXRlIGl0cyBjb25maWd1cmF0aW9uIGFuZCByZWRyYXcuXHJcbiAgICAgICAqIEBldmVudCBHcmlkVmlldyN3aWxsVXBkYXRlXHJcbiAgICAgICAqL1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ3dpbGxVcGRhdGUnLCBjaGFuZ2VzKTtcclxuXHJcbiAgICAgIC8vIERvbid0IHJlZnJlc2ggYmVmb3JlIHRoZSB2aWV3IGlzIHJlbmRlcmVkXHJcbiAgICAgIGlmICghdGhpcy5faXNSZW5kZXJlZCkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignZGlkVXBkYXRlJywgY2hhbmdlcyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfLnJlZHVjZShbXHJcbiAgICAgICAgdGhpcy5fY2hhaW5EYXRhLFxyXG4gICAgICAgIHRoaXMuX2NoYWluU3RydWN0dXJlLFxyXG4gICAgICAgIHRoaXMuX2NoYWluQ29udGVudCxcclxuICAgICAgXSwgKG1lbW8sIGNoYWluKSA9PiBjaGFpbi51cGRhdGUobWVtbywgZm9yY2UpLCBudWxsKVxyXG4gICAgICAgIC50aGVuKHBhdGNoRXZlbnRzKVxyXG4gICAgICAgIC50aGVuKHN0YXRlID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgIHRoaXMuX3RhYmxlVmlldy5zZXQoc3RhdGUsIHJlc29sdmUpO1xyXG4gICAgICAgIH0pKVxyXG4gICAgICAgIC50aGVuKG5leHRUaWNrKVxyXG4gICAgICAgIC5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogVGhlIGBHcmlkVmlld2AgZGlkIHVwZGF0ZSBpdHMgY29uZmlndXJhdGlvbiBhbmQgcmVkcmF3LlxyXG4gICAgICAgICAgICogQGV2ZW50IEdyaWRWaWV3I2RpZFVwZGF0ZVxyXG4gICAgICAgICAgICovXHJcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2RpZFVwZGF0ZScsIGNoYW5nZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBzY2hlZHVsZVVwZGF0ZSA9ICgpID0+IHtcclxuICAgICAgaWYgKHJlZnJlc2hTdGF0ZS5jaGFuZ2VzKSB7XHJcbiAgICAgICAgXy5leHRlbmQocmVmcmVzaFN0YXRlLmNoYW5nZXMsIHRoaXMubW9kZWwuY2hhbmdlZEF0dHJpYnV0ZXMoKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVmcmVzaFN0YXRlLmNoYW5nZXMgPSB0aGlzLm1vZGVsLmNoYW5nZWRBdHRyaWJ1dGVzKCk7XHJcblxyXG4gICAgICAgIGlmIChyZWZyZXNoU3RhdGUucHJvbWlzZSkge1xyXG4gICAgICAgICAgcmVmcmVzaFN0YXRlLnByb21pc2UgPSByZWZyZXNoU3RhdGUucHJvbWlzZS50aGVuKHJlZnJlc2gpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZWZyZXNoU3RhdGUucHJvbWlzZSA9IHJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5tb2RlbC5vbignY2hhbmdlJywgc2NoZWR1bGVVcGRhdGUpO1xyXG5cclxuICAgIF8uZWFjaChbXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgYEdyaWRWaWV3YCB3aWxsIHJlZHJhdyB0aGUgRE9NLiBUaGlzIGV2ZW50IG1heSB0cmlnZ2VyIGZyZXF1ZW50bHlcclxuICAgICAgICogd2hlbiB2aXJ0dWFsaXphdGlvbiBpcyBlbmFibGVkLlxyXG4gICAgICAgKiBAZXZlbnQgR3JpZFZpZXcjd2lsbFJlZHJhd1xyXG4gICAgICAgKi9cclxuICAgICAgJ3dpbGxSZWRyYXcnLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBgR3JpZFZpZXdgIGRpZCByZWRyYXcgdGhlIERPTS4gVGhpcyBldmVudCBtYXkgdHJpZ2dlciBmcmVxdWVudGx5XHJcbiAgICAgICAqIHdoZW4gdmlydHVhbGl6YXRpb24gaXMgZW5hYmxlZC5cclxuICAgICAgICogQGV2ZW50IEdyaWRWaWV3I2RpZFJlZHJhd1xyXG4gICAgICAgKi9cclxuICAgICAgJ2RpZFJlZHJhdycsXHJcbiAgICBdLCBldmVudCA9PiB7XHJcbiAgICAgIHRoaXMuX3RhYmxlVmlldy5vbihldmVudCwgKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnQsIC4uLmFyZ3MpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMub24oJ2FsbCcsIChldmVudCwgLi4uYXJncykgPT4ge1xyXG4gICAgICBjb25zdCBldmVudHMgPSBfLmNoYWluKHRoaXMuX2NoYWluQ29udGVudClcclxuICAgICAgICAucmVzdWx0KCdzdGF0ZScpLnJlc3VsdCgnZXZlbnRzJykudmFsdWUoKTtcclxuICAgICAgY29uc3QgaGFuZGxlciA9IGV2ZW50cyAmJiBldmVudHNbZXZlbnRdO1xyXG5cclxuICAgICAgaWYgKF8uaXNGdW5jdGlvbihoYW5kbGVyKSkge1xyXG4gICAgICAgIGhhbmRsZXIoLi4uYXJncyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGlwZSBhIHByb2plY3Rpb24gdG8gcHJvY2NlZWQgdGhlIGdyaWQgZGF0YVxyXG4gICAqIEBwYXJhbSB7Li4uUHJvamVjdGlvbkRlZmluaXRpb259IHByb2pzIC0gQSBsaXN0IG9mIHByb2plY3Rpb24gZGVmaW5pdGlvbnNcclxuICAgKiBAcmV0dXJuIHtHcmlkVmlld30gLSBUaGlzIGdyaWQgdmlld1xyXG4gICAqL1xyXG4gIHBpcGVEYXRhUHJvamVjdGlvbnMoLi4ucHJvanMpIHtcclxuICAgIHRoaXMuX2NoYWluRGF0YS5waXBlKF8ubWFwKF8uZmxhdHRlbihwcm9qcyksIHRoaXMuX3JlZ2lzdGVyUHJvamVjdGlvbikpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQaXBlIGEgcHJvamVjdGlvbiB0byBwcm9jY2VlZCB0aGUgZ3JpZCBzdHJ1Y3R1cmVcclxuICAgKiBAcGFyYW0gey4uLlByb2plY3Rpb25EZWZpbml0aW9ufSBwcm9qcyAtIEEgbGlzdCBvZiBwcm9qZWN0aW9uIGRlZmluaXRpb25zXHJcbiAgICogQHJldHVybiB7R3JpZFZpZXd9IC0gVGhpcyBncmlkIHZpZXdcclxuICAgKi9cclxuICBwaXBlU3RydWN0dXJlUHJvamVjdGlvbnMoLi4ucHJvanMpIHtcclxuICAgIHRoaXMuX2NoYWluU3RydWN0dXJlLnBpcGUoXy5tYXAoXy5mbGF0dGVuKHByb2pzKSwgdGhpcy5fcmVnaXN0ZXJQcm9qZWN0aW9uKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBpcGUgYSBwcm9qZWN0aW9uIHRvIHByb2NjZWVkIHRoZSBncmlkIHZpc3VhbCBjb250ZW50XHJcbiAgICogQHBhcmFtIHsuLi5Qcm9qZWN0aW9uRGVmaW5pdGlvbn0gcHJvanMgLSBBIGxpc3Qgb2YgcHJvamVjdGlvbiBkZWZpbml0aW9uc1xyXG4gICAqIEByZXR1cm4ge0dyaWRWaWV3fSAtIFRoaXMgZ3JpZCB2aWV3XHJcbiAgICovXHJcbiAgcGlwZUNvbnRlbnRQcm9qZWN0aW9ucyguLi5wcm9qcykge1xyXG4gICAgdGhpcy5fY2hhaW5Db250ZW50LnBpcGUoXy5tYXAoXy5mbGF0dGVuKHByb2pzKSwgdGhpcy5fcmVnaXN0ZXJQcm9qZWN0aW9uKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoYW5nZSB0aGUgZ3JpZChwcm9qZWN0aW9uKSBjb25maWd1cmF0b25zXHJcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgT2JqZWN0Pn0gY29uZmlnXHJcbiAgICogICAgQSBoYXNoIG9mIGNvbmZpZ3VyYXRpb25zIHRvIGNoYW5nZS4gVGhlIGtleXMgYXJlIHByb2plY3Rpb24gbmFtZXMgd2hpbGVcclxuICAgKiAgICB0aGUgdmFsdWVzIGFyZSB0aGUgcHJvamVjdGlvbiBjb25maWd1cmF0aW9uc1xyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja11cclxuICAgKiAgICBBIGNhbGxiYWNrIHRvIG5vdGlmeSB0aGUgdXBkYXRlIGlzIGNvbXBsZXRlZFxyXG4gICAqIEByZXR1cm4ge0dyaWRWaWV3fVxyXG4gICAqICAgIFRoaXMgZ3JpZCB2aWV3LlxyXG4gICAqL1xyXG4gIHNldChjb25maWcgPSB7fSwgY2FsbGJhY2sgPSBfLm5vb3ApIHtcclxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuICAgIGlmIChfLmhhcyhjb25maWcsICdkYXRhU291cmNlJykpIHtcclxuICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IGNvbmZpZy5kYXRhU291cmNlO1xyXG5cclxuICAgICAgY29uZmlnLnF1ZXJ5ID0gXy5kZWZhdWx0cyh7fSwgY29uZmlnLnF1ZXJ5LCBfLnBpY2soZGF0YVNvdXJjZSwgW1xyXG4gICAgICAgICdza2lwJyxcclxuICAgICAgICAndGFrZScsXHJcbiAgICAgICAgJ29yZGVyYnknLFxyXG4gICAgICAgICdmaWx0ZXInLFxyXG4gICAgICAgICdvcHRpb25zJyxcclxuICAgICAgICAncXVlcnknLFxyXG4gICAgICBdKSk7XHJcblxyXG4gICAgICBpZiAoZGF0YVNvdXJjZS50eXBlID09PSAnbWVtb3J5JyAmJiBkYXRhU291cmNlLmRhdGEgIT09IHRoaXMuX2RhdGFTb3VyY2UuZGF0YSkge1xyXG4gICAgICAgIHRoaXMuX2RhdGFTb3VyY2UuZGF0YSA9IGRhdGFTb3VyY2UuZGF0YTtcclxuICAgICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgZGVsZXRlIGNvbmZpZy5kYXRhU291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubW9kZWwuc2V0KF8ubWFwT2JqZWN0KGNvbmZpZywgKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMuX3Byb2plY3Rpb25zW2tleV07XHJcblxyXG4gICAgICByZXR1cm4gcHJvamVjdGlvbiA/IHByb2plY3Rpb24ubm9ybWFsaXplKHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgfSkpO1xyXG4gICAgdGhpcy5vbmNlKCdkaWRVcGRhdGUnLCBjYWxsYmFjayk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWQgdGhlIGdyaWQocHJvamVjdGlvbilfY29uZmlndXJhdGlvblxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgcHJvamVjdGlvblxyXG4gICAqIEByZXR1cm4ge29iamVjdH1cclxuICAgKi9cclxuICBnZXQobmFtZSkge1xyXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG4gICAgaWYgKG5hbWUgPT09ICdkYXRhU291cmNlJykge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBfLmRlZmF1bHRzKHt9LCB0aGlzLm1vZGVsLmdldCgnZGF0YVNvdXJjZScpLCB0aGlzLm1vZGVsLmdldCgncXVlcnknKSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5fZGF0YVNvdXJjZSBpbnN0YW5jZW9mIE1lbW9yeURhdGFTb3VyY2UpIHtcclxuICAgICAgICByZXN1bHQudHlwZSA9ICdtZW1vcnknO1xyXG4gICAgICAgIHJlc3VsdC5kYXRhID0gdGhpcy5fZGF0YVNvdXJjZS5kYXRhO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTb3VyY2UgaW5zdGFuY2VvZiBKU0RhdGFEYXRhU291cmNlKSB7XHJcbiAgICAgICAgcmVzdWx0LnR5cGUgPSAnanMtZGF0YSc7XHJcbiAgICAgICAgcmVzdWx0LmVudGl0eSA9IHRoaXMuX2RhdGFTb3VyY2UucmVzb3VyY2U7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNvdXJjZSBpbnN0YW5jZW9mIE9EYXRhRGF0YVNvdXJjZSkge1xyXG4gICAgICAgIHJlc3VsdC50eXBlID0gJ29kYXRhJztcclxuICAgICAgICByZXN1bHQudXJsID0gdGhpcy5fZGF0YVNvdXJjZS51cmw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXQobmFtZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRjaCB0aGUgZ3JpZChwcm9qZWN0aW9uKSBjb25maWd1cmF0aW9ucy5cclxuICAgKiBJdCdzIHNpbWlsYXIgdG8ge0BsaW5rIEdyaWRWaWV3I3NldH0sIGJ1dCBpbnN0ZWFkIG9mIHJlcGxhY2luZyB0aGVcclxuICAgKiBwcm9qZWN0aW9uIGNvbmZpZ3VyYXRpb25zLCBgcGF0Y2hgIGRvIGRlZXAgb2JqZWN0IG1lcmdlLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59IGNvbmZpZ1xyXG4gICAqICAgIEEgaGFzaCBvZiBjb25maWd1cmF0aW9ucyB0byBjaGFuZ2UuIFRoZSBrZXlzIGFyZSBwcm9qZWN0aW9uIG5hbWVzXHJcbiAgICogICAgd2hpbGUgdGhlIHZhbHVlcyBhcmUgdGhlIHByb2plY3Rpb24gY29uZmlndXJhdGlvbnNcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqICAgIEEgY2FsbGJhY2sgdG8gbm90aWZ5IHRoZSB1cGRhdGUgaXMgY29tcGxldGVkXHJcbiAgICogQHJldHVybiB7R3JpZFZpZXd9XHJcbiAgICogICAgVGhpcyBncmlkIHZpZXcuXHJcbiAgICovXHJcbiAgcGF0Y2goc3RhdGUgPSB7fSwgY2FsbGJhY2sgPSBfLm5vb3ApIHtcclxuICAgIHRoaXMuc2V0KF8ucmVkdWNlKF8ua2V5cyhzdGF0ZSksIChtZW1vLCBrZXkpID0+IHtcclxuICAgICAgY29uc3QgdmFsdWUgPSBzdGF0ZVtrZXldO1xyXG4gICAgICBjb25zdCB2YWx1ZUN1ciA9IHRoaXMuZ2V0KGtleSk7XHJcbiAgICAgIFxyXG4gICAgICBtZW1vW2tleV0gPSBkZWZhdWx0c0RlZXAodmFsdWUsIHZhbHVlQ3VyKTtcclxuICAgICAgcmV0dXJuIG1lbW87XHJcbiAgICB9LCB7fSksIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlciB0aGUgZ3JpZCB2aWV3LlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja11cclxuICAgKiAgICBBIGNhbGxiYWNrIHRvIG5vdGlmeSB0aGUgcmVuZGVyIGlzIGNvbXBsZXRlZC5cclxuICAgKiBAcmV0dXJuIHtHcmlkVmlld31cclxuICAgKiAgICBUaGlzIGdyaWQgdmlldy5cclxuICAgKi9cclxuICByZW5kZXIoY2FsbGJhY2spIHtcclxuICAgIHRoaXMuX3RhYmxlVmlldy5yZW5kZXIoKCkgPT4ge1xyXG4gICAgICB0aGlzLl9pc1JlbmRlcmVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5yZWZyZXNoKHRydWUpO1xyXG4gICAgICB0aGlzLm9uY2UoJ2RpZFJlZHJhdycsIGNhbGxiYWNrKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IGFuZCBkZXRhY2ggdGhlIHZpZXcgZnJvbSBET00uXHJcbiAgICovXHJcbiAgcmVtb3ZlKCkge1xyXG4gICAgdGhpcy5fdGFibGVWaWV3LnJlbW92ZSgpO1xyXG4gICAgc3VwZXIucmVtb3ZlKCk7XHJcbiAgfVxyXG5cclxuICAvKiBIZWxwZXIgZnVuY3Rpb25zICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEEgb2JqZWN0IGltcGxlbWVudHMgYSBtaW5pbWFsIGludGVyZmFjZSBvZiBhcnJheSB0byBsYXp5IGZldGNoIGl0ZW1zLlxyXG4gICAqIFdlIHVzZSB0aGlzIHN0cnVjdHVyZSBhIGxvdCBpbiBwcm9qZWN0aW9ucywgc28gdGhhdCB3ZSBkb24ndCBuZWVkIHRvXHJcbiAgICogcHJvY2NlZWQgYWxsIHRoZSByb3dzIHdoZW4gdmlydHVhbGl6YXRpb24gaXMgb24uXHJcbiAgICogQHR5cGVkZWYgRmFrZUFycmF5XHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBzbGljZVxyXG4gICAqICAgIGEgY2FsbGJhY2sgdG8gZ2V0IGEgc2xpY2Ugb2YgdGhlIGl0ZW1zLiBJdCBoYXMgdGhlIHNhbWUgc2lnbmF0dXJlIGFzXHJcbiAgICogICAgYEFycmF5LnNsaWNlKClgLlxyXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZW5ndGhcclxuICAgKiAgICBsZW5ndGggb2YgdGhlIGFycmF5XHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBkYXRhIGl0ZW1zLiBJdCdzIGEgZmFrZSBhcnJheSBvZiBvcmlnaW5hbCBtb2RlbC5cclxuICAgKiBAdHlwZSB7KE9iamVjdFtdfEZha2VBcnJheSl9XHJcbiAgICovXHJcbiAgZ2V0IGl0ZW1zKCkge1xyXG4gICAgcmV0dXJuIF8ucmVzdWx0KHRoaXMuX2NoYWluRGF0YS5zdGF0ZSwgJ2l0ZW1zJywgW10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWFrZSBxdWVyeSB0byB0aGUgZGF0YSBzb3VyY2VcclxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHF1ZXJ5IHBhcmFtZXRlcnNcclxuICAgKiBAcmV0dXJuIHtRdWVyeVJlc3VsdH1cclxuICAgKi9cclxuICBxdWVyeShwYXJhbXMpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU291cmNlLnF1ZXJ5KHBhcmFtcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgYXJyYXkgZGF0YSBpdGVtcy5cclxuICAgKiBAdHlwZSB7T2JqZWN0W119XHJcbiAgICovXHJcbiAgZ2V0IGl0ZW1BcnJheSgpIHtcclxuICAgIHJldHVybiB0aGlzLml0ZW1zLnNsaWNlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgY291bnQgb2YgZGF0YSByb3dzLlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGNvdW50Um93cygpIHtcclxuICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBwcmltYXJ5IGtleSBvZiBkYXRhIGl0ZW1zLlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IHByaW1hcnlLZXkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNvdXJjZS5wcmltYXJ5S2V5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRvdGFsIGNvdW50IG9mIGRhdGEgaXRlbXMuIFRoaXMgcmVwcmVzZW50cyB0aGUgc2VydmVyIHNpZGUgc3RhdGUuXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgdG90YWxDb3VudFJvd3MoKSB7XHJcbiAgICByZXR1cm4gXy5yZXN1bHQodGhpcy5fY2hhaW5EYXRhLnN0YXRlLCAndG90YWxDb3VudCcsIDApO1xyXG4gIH1cclxuXHJcbiAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG4gIGdldEl0ZW1Db3VudCgpIHtcclxuICAgIHJldHVybiB0aGlzLnRvdGFsQ291bnRSb3dzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUXVlcnkgdGhlIGRhdGEgaXRlbSB3aXRoIGl0cyBwcmltYXJ5IGtleS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gdGhlIHByaW1hcnkga2V5LlxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBpdGVtV2l0aEtleShrZXkpIHtcclxuICAgIHJldHVybiBfLmNoYWluKHRoaXMuX2NoYWluRGF0YS5zdGF0ZSlcclxuICAgICAgLnJlc3VsdCgnaXRlbUluZGV4JylcclxuICAgICAgLnJlc3VsdChrZXksIG51bGwpXHJcbiAgICAgIC52YWx1ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwcmltYXJ5IGtleSBmcm9tIGEgRE9NIGVsZW1lbnQgaW4gYSBjZXJ0YWluIHJvdy5cclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGpRdWVyeXxzdHJpbmd9IGVsXHJcbiAgICogICAgVGhlIERPTSBlbGVtZW50LiBJdCBjYW4gYmUgYW4gYEhUTUxFbGVtZW50YCwgYSBqUXVlcnkgb2JqZWN0IG9yIGFcclxuICAgKiAgICBqUXVlcnkgc2VsZWN0b3IuXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSBwcmltYXJ5IGtleSBmb3IgdGhlIHJvdy5cclxuICAgKi9cclxuICBrZXlPZkVsZW1lbnQoZWwpIHtcclxuICAgIGNvbnN0ICR0ciA9ICQoZWwpLmNsb3Nlc3QoJ3RyJywgdGhpcy4kZWwpO1xyXG5cclxuICAgIGlmICgkdHIubGVuZ3RoID4gMCkge1xyXG4gICAgICByZXR1cm4gJHRyLmF0dHIoJ2RhdGEta2V5JykgfHwgbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZGF0YSBpdGVtIHdpdGggaXRzIGluZGV4IGluIHRoZSBpdGVtcyBhcnJheS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGl0ZW0uXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGl0ZW1BdChpbmRleCkge1xyXG4gICAgcmV0dXJuIF8ucmVzdWx0KHRoaXMuX2NoYWluRGF0YS5zdGF0ZSwgJ2l0ZW1zJywgW10pLnNsaWNlKGluZGV4LCBpbmRleCArIDEpWzBdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2l2ZW4gYW4gZWxlbWVudCBpbiB0aGUgZGF0YSByb3dzLCBnZXQgdGhlIGluZGV4IG9mIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAgICogZGF0YSBpdGVtLlxyXG4gICAqXHJcbiAgICogX19OT1RFX186IEl0J3Mgbm90IHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIEFQSSB0byBmaW5kIHRoZSBkYXRhIGl0ZW0gZm9yXHJcbiAgICogYSBnaXZlbiBlbGVtZW50LiBJdCBjb3VsZCBiZSBpbmNvcnJlY3QgaWYgdGhlcmUncmUgY3VzdG9tIHByb2plY3Rpb25zXHJcbiAgICogY2hhbmdlcyB0aGUgVFIgc2VxdWVuY2Ugb2YgVEJPRFkuIEluc3RlYWRseSwgeW91IHNob3VsZCB1c2VcclxuICAgKiB7QGxpbmsgR3JpZFZpZXcja2V5T2ZFbGVtZW50fS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8alF1ZXJ5fHN0cmluZ30gZWxcclxuICAgKiAgICBUaGUgRE9NIGVsZW1lbnQuIEl0IGNhbiBiZSBhbiBgSFRNTEVsZW1lbnRgLCBhIGpRdWVyeSBvYmplY3Qgb3IgYVxyXG4gICAqICAgIGpRdWVyeSBzZWxlY3Rvci5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGluZGV4IG9mIHRoZSBkYXRhIHJvdy5cclxuICAgKi9cclxuICBpbmRleE9mRWxlbWVudChlbCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RhYmxlVmlldy5pbmRleE9mRWxlbWVudChlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHByaW1hcnkga2V5cyBvZiB0aGUgc2VsZWN0ZWQgaXRlbXMuXHJcbiAgICogQHJldHVybiB7c3RyaW5nW119IC0gQW4gYXJyYXkgb2YgdGhlIHNlbGVjdGVkIGtleXMuXHJcbiAgICovXHJcbiAgc2VsZWN0ZWRLZXlzKCkge1xyXG4gICAgcmV0dXJuIF8ucmVzdWx0KHRoaXMuZ2V0KCdzZWxlY3Rpb24nKSwgJ3NlbGVjdGVkJywgW10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzZWxlY3RlZCBpdGVtcy5cclxuICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gLSBBbiBhcnJheSBvZiB0aGUgc2VsZWN0ZWQgZGF0YSBpdGVtcy5cclxuICAgKi9cclxuICBzZWxlY3RlZEl0ZW1zKCkge1xyXG4gICAgY29uc3QgaXRlbUluZGV4ID0gXy5yZXN1bHQodGhpcy5fY2hhaW5EYXRhLnN0YXRlLCAnaXRlbUluZGV4Jywge30pO1xyXG5cclxuICAgIHJldHVybiBfLmNoYWluKHRoaXMuc2VsZWN0ZWRLZXlzKCkpXHJcbiAgICAgIC5tYXAoa2V5ID0+IF8ucmVzdWx0KGl0ZW1JbmRleCwga2V5KSlcclxuICAgICAgLmNvbXBhY3QoKVxyXG4gICAgICAudmFsdWUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdCBhIHJvdyB3aXRoIHRoZSBnaXZlbiBwcmltYXJ5IGtleS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIHByaW1hcnkga2V5IGZvciB0aGUgcm93LlxyXG4gICAqL1xyXG4gIHNlbGVjdFJvdyhrZXkpIHtcclxuICAgIHNldFNlbGVjdFJvdyh0aGlzLCBrZXksIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzZWxlY3QgYSByb3cgd2l0aCB0aGUgZ2l2ZW4gcHJpbWFyeSBrZXkuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBwcmltYXJ5IGtleSBmb3IgdGhlIHJvdy5cclxuICAgKi9cclxuICBkZXNlbGVjdFJvdyhrZXkpIHtcclxuICAgIHNldFNlbGVjdFJvdyh0aGlzLCBrZXksIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdCBhbGwgdGhlIHNlbGVjdGFibGUgaXRlbXMuXHJcbiAgICovXHJcbiAgc2VsZWN0QWxsKCkge1xyXG4gICAgc2V0U2VsZWN0QWxsKHRoaXMsIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzZWxlY3QgYWxsIHRoZSBzZWxlY3RhYmxlIGl0ZW1zLlxyXG4gICAqL1xyXG4gIGRlc2VsZWN0QWxsKCkge1xyXG4gICAgc2V0U2VsZWN0QWxsKHRoaXMsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZmluYWxpemVkIGNvbHVtbiBjb25maWd1cmF0aW9uIHdpdGggYSBnaXZlbiBjb2x1bW4gbmFtZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb2x1bW4uXHJcbiAgICogQHJldHVybiB7RXh0ZW5kZWRDb2x1bW5Db25maWd9XHJcbiAgICovXHJcbiAgY29sdW1uV2l0aE5hbWUobmFtZSkge1xyXG4gICAgY29uc3QgY29sdW1uR3JvdXAgPSBfLnJlc3VsdCh0aGlzLl9jaGFpbkNvbnRlbnQuc3RhdGUsICdjb2x1bW5Hcm91cCcpO1xyXG4gICAgcmV0dXJuIGNvbHVtbkdyb3VwID8gY29sdW1uR3JvdXAuY29sdW1uV2l0aE5hbWUobmFtZSkgOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSByb3cgY29uZmlndXJhdGlvbnMgZm9yIGBUSEVBRGBcclxuICAgKiBAcmV0dXJuIHtSb3dDb25maWdbXX1cclxuICAgKi9cclxuICBnZXRIZWFkUm93cygpIHtcclxuICAgIHJldHVybiBfLnJlc3VsdCh0aGlzLmdldCgncm93cycpLCAnaGVhZFJvd3MnLCBbJ2NvbHVtbi1oZWFkZXItcm93cyddKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBjYWxsYmFjayBTZXRSb3dzQ2FsbGJhY2tcclxuICAgKiBAcGFyYW0ge1Jvd0NvbmZpZ1tdfSByb3dzIC0gVGhlIGN1cnJlbnQgcm93IGNvbmZpZ3VyYXRpb25zLlxyXG4gICAqIEByZXR1cm4ge1Jvd0NvbmZpZ1tdfSAtIFRoZSBuZXcgcm93IGNvbmZpZ3VyYXRpb25zLlxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIHJvdyBjb25maWd1cmF0aW9ucyBmb3IgYFRIRUFEYFxyXG4gICAqIEBwYXJhbSB7Um93Q29uZmlnW118U2V0Um93c0NhbGxiYWNrfSB2YWx1ZVxyXG4gICAqICAgIFRoZSBuZXcgaGVhZGVyIHJvd3Mgb3IgYSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gdGhlIGhlYWRlciByb3dzLlxyXG4gICAqL1xyXG4gIHNldEhlYWRSb3dzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBoZWFkUm93cyA9IF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSh0aGlzLmdldEhlYWRSb3dzKCkpIDogdmFsdWU7XHJcbiAgICB0aGlzLnBhdGNoKHsgcm93czogeyBoZWFkUm93cyB9IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJlcGVuZCBhIHNldCBoZWFkZXIgcm93c1xyXG4gICAqIEBwYXJhbSB7Um93Q29uZmlnW119IHJvd3MgLSBUaGUgcm93cyB0byBwcmVwZW5kXHJcbiAgICovXHJcbiAgcHJlcGVuZEhlYWRSb3dzKHJvd3MpIHtcclxuICAgIHRoaXMuc2V0SGVhZFJvd3MoaGVhZFJvd3MgPT4gcm93cy5jb25jYXQoaGVhZFJvd3MpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGVuZCBhIHNldCBoZWFkZXIgcm93c1xyXG4gICAqIEBwYXJhbSB7Um93Q29uZmlnW119IHJvd3MgLSBUaGUgcm93cyB0byBhcHBlbmRcclxuICAgKi9cclxuICBhcHBlbmRIZWFkUm93cyhyb3dzKSB7XHJcbiAgICB0aGlzLnNldEhlYWRSb3dzKGhlYWRSb3dzID0+IGhlYWRSb3dzLmNvbmNhdChyb3dzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHJvdyBjb25maWd1cmF0aW9ucyBmb3IgYFRCT0RZYFxyXG4gICAqIEByZXR1cm4ge1Jvd0NvbmZpZ1tdfVxyXG4gICAqL1xyXG4gIGdldEJvZHlSb3dzKCkge1xyXG4gICAgcmV0dXJuIF8ucmVzdWx0KHRoaXMuZ2V0KCdyb3dzJyksICdib2R5Um93cycsIFsnZGF0YS1yb3dzJ10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSByb3cgY29uZmlndXJhdGlvbnMgZm9yIGBUQk9EWWBcclxuICAgKiBAcGFyYW0ge1Jvd0NvbmZpZ1tdfFNldFJvd3NDYWxsYmFja30gdmFsdWVcclxuICAgKiAgICBUaGUgbmV3IGJvZHkgcm93cyBvciBhIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgYm9keSByb3dzLlxyXG4gICAqL1xyXG4gIHNldEJvZHlSb3dzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBib2R5Um93cyA9IF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSh0aGlzLmdldEJvZHlSb3dzKCkpIDogdmFsdWU7XHJcbiAgICB0aGlzLnBhdGNoKHsgcm93czogeyBib2R5Um93cyB9IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJlcGVuZCBhIHNldCBib2R5IHJvd3NcclxuICAgKiBAcGFyYW0ge1Jvd0NvbmZpZ1tdfSByb3dzIC0gVGhlIHJvd3MgdG8gcHJlcGVuZFxyXG4gICAqL1xyXG4gIHByZXBlbmRCb2R5Um93cyhyb3dzKSB7XHJcbiAgICB0aGlzLnNldEJvZHlSb3dzKGJvZHlSb3dzID0+IHJvd3MuY29uY2F0KGJvZHlSb3dzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBlbmQgYSBzZXQgYm9keSByb3dzXHJcbiAgICogQHBhcmFtIHtSb3dDb25maWdbXX0gcm93cyAtIFRoZSByb3dzIHRvIGFwcGVuZFxyXG4gICAqL1xyXG4gIGFwcGVuZEJvZHlSb3dzKHJvd3MpIHtcclxuICAgIHRoaXMuc2V0Qm9keVJvd3MoYm9keVJvd3MgPT4gYm9keVJvd3MuY29uY2F0KHJvd3MpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcm93IGNvbmZpZ3VyYXRpb25zIGZvciBgVEZPT1RgXHJcbiAgICogQHJldHVybiB7Um93Q29uZmlnW119XHJcbiAgICovXHJcbiAgZ2V0Rm9vdFJvd3MoKSB7XHJcbiAgICByZXR1cm4gXy5yZXN1bHQodGhpcy5nZXQoJ3Jvd3MnKSwgJ2Zvb3RSb3dzJywgW10pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSByb3cgY29uZmlndXJhdGlvbnMgZm9yIGBURk9PVGBcclxuICAgKiBAcGFyYW0ge1Jvd0NvbmZpZ1tdfFNldFJvd3NDYWxsYmFja30gdmFsdWVcclxuICAgKiAgICBUaGUgbmV3IGZvb3RlciByb3dzIG9yIGEgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHRoZSBmb290ZXIgcm93cy5cclxuICAgKi9cclxuICBzZXRGb290Um93cyh2YWx1ZSkge1xyXG4gICAgY29uc3QgZm9vdFJvd3MgPSBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUodGhpcy5nZXRGb290Um93cygpKSA6IHZhbHVlO1xyXG4gICAgdGhpcy5wYXRjaCh7IHJvd3M6IHsgZm9vdFJvd3MgfSB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXBlbmQgYSBzZXQgZm9vdGVyIHJvd3NcclxuICAgKiBAcGFyYW0ge1Jvd0NvbmZpZ1tdfSByb3dzIC0gVGhlIHJvd3MgdG8gcHJlcGVuZFxyXG4gICAqL1xyXG4gIHByZXBlbmRGb290Um93cyhyb3dzKSB7XHJcbiAgICB0aGlzLnNldEZvb3RSb3dzKGZvb3RSb3dzID0+IHJvd3MuY29uY2F0KGZvb3RSb3dzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBlbmQgYSBzZXQgZm9vdGVyIHJvd3NcclxuICAgKiBAcGFyYW0ge1Jvd0NvbmZpZ1tdfSByb3dzIC0gVGhlIHJvd3MgdG8gYXBwZW5kXHJcbiAgICovXHJcbiAgYXBwZW5kRm9vdFJvd3Mocm93cykge1xyXG4gICAgdGhpcy5zZXRGb290Um93cyhmb290Um93cyA9PiBmb290Um93cy5jb25jYXQocm93cykpO1xyXG4gIH1cclxuXHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy92bmV4dC9ncmlkLXZpZXcuanNcbiAqKi8iLCJleHBvcnQgeyBxdWVyeSB9IGZyb20gJy4vcXVlcnkuanMnO1xyXG5leHBvcnQgeyBidWZmZXIgfSBmcm9tICcuL2J1ZmZlci5qcyc7XHJcbmV4cG9ydCB7IHNlbGVjdGlvbiwgc2V0U2VsZWN0QWxsLCBzZXRTZWxlY3RSb3cgfSBmcm9tICcuL3NlbGVjdGlvbi5qcyc7XHJcbmV4cG9ydCB7IGNvbHVtbnMgfSBmcm9tICcuL2NvbHVtbnMuanMnO1xyXG5leHBvcnQgeyByb3dzIH0gZnJvbSAnLi9yb3dzLmpzJztcclxuZXhwb3J0IHsgY29sdW1uR3JvdXAgfSBmcm9tICcuL2NvbHVtbi1ncm91cC5qcyc7XHJcbmV4cG9ydCB7IGNlbGxzIH0gZnJvbSAnLi9jZWxscy5qcyc7XHJcbmV4cG9ydCB7IHNvcnRhYmxlSGVhZGVyIH0gZnJvbSAnLi9zb3J0YWJsZS1oZWFkZXIuanMnO1xyXG5leHBvcnQgeyBlZGl0YWJsZSB9IGZyb20gJy4vZWRpdGFibGUuanMnO1xyXG5leHBvcnQgeyBldmVudHMgfSBmcm9tICcuL2V2ZW50cy5qcyc7XHJcblxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vaW5kZXguanNcbiAqKi8iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcclxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcclxuaW1wb3J0IFByb21pc2UgZnJvbSAnYmx1ZWJpcmQnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBkYXRhIHNvdXJjZSBjb25maWd1cmF0aW9ucy5cclxuICogQHR5cGVkZWYgUXVlcnlDb25maWdcclxuICogQHR5cGUge09iamVjdH1cclxuICogQHByb3BlcnR5IHtPcmRlckJ5Q29uZmlnfSBvcmRlcmJ5XHJcbiAqICAgIFRoZSBzb3J0aW5nIHBhcmFtZXRlci5cclxuICogQHByb3BlcnR5IHtPYmplY3R9IGZpbHRlclxyXG4gKiAgICBUaGUgZmlsdGVyIG9iamVjdCBpbiBNYW5nb0RCIGZvcm1hdC5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNraXBcclxuICogICAgVGhlIG51bWJlciBvZiBpdGVtIHRvIHNraXAgZnJvbSB0aGUgcXVlcnkgcmVzdWx0LlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGFrZVxyXG4gKiAgICBUaGUgbnVtYmVyIG9mIGl0ZW0gdG8gdGFrZSBmcm9tIHRoZSBxdWVyeSByZXN1bHQuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEZldGNoaW5nIGRhdGEgZnJvbSB0aGUgZGF0YSBzb3VyY2VcclxuICogQHBhcmFtIHtEYXRhQ2hhaW5TdGF0ZX0gc3RhdGVcclxuICogQHBhcmFtIHtRdWVyeUNvbmZpZ30gcGFyYW1zIFxyXG4gKiAgICBUaGUgZGF0YSBzb3VyY2UgY29uZmlndXJhdGlvbnMuXHJcbiAqIEByZXR1cm4ge0RhdGFDaGFpblN0YXRlfVxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlQcm9qZWN0aW9uSGFuZGxlcihzdGF0ZSwgcGFyYW1zKSB7XHJcbiAgY29uc3QgcHJpbWFyeUtleSA9IHRoaXMucHJpbWFyeUtleTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGBHcmlkVmlld2Agd2lsbCByZWxvYWQgZGF0YSBmcm9tIHRoZSBkYXRhIHNvdXJjZS5cclxuICAgKiBAZXZlbnQgR3JpZFZpZXcjd2lsbFJlbG9hZFxyXG4gICAqL1xyXG4gIHRoaXMudHJpZ2dlcignd2lsbFJlbG9hZCcpO1xyXG5cclxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucXVlcnkocGFyYW1zKSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgY29uc29sZS53YXJuKGVycm9yKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvdGFsQ291bnQ6IDAsXHJcbiAgICAgIGl0ZW1zOiBbXSxcclxuICAgICAgZXJyb3IsXHJcbiAgICB9O1xyXG4gIH0pLnRoZW4oKHsgdG90YWxDb3VudCwgaXRlbXMgfSkgPT4ge1xyXG4gICAgY29uc3QgaXRlbUluZGV4ID0ge307XHJcblxyXG4gICAgXy5lYWNoKGl0ZW1zLCBpdGVtID0+IHtcclxuICAgICAgaWYgKCFfLmhhcyhpdGVtLCBwcmltYXJ5S2V5KSkge1xyXG4gICAgICAgIGl0ZW1bcHJpbWFyeUtleV0gPSBfLnVuaXF1ZUlkKCdncmlkLWl0ZW0tJyk7XHJcbiAgICAgIH1cclxuICAgICAgaXRlbUluZGV4W2l0ZW1bcHJpbWFyeUtleV1dID0gaXRlbTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHVuaXF1ZUlkOiBfLnVuaXF1ZUlkKCdncmlkLWRhdGEtJyksXHJcbiAgICAgIGl0ZW1zLFxyXG4gICAgICBpdGVtSW5kZXgsXHJcbiAgICAgIHByaW1hcnlLZXksXHJcbiAgICAgIHRvdGFsQ291bnQsXHJcbiAgICB9O1xyXG5cclxuICB9KS5maW5hbGx5KCgpID0+IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBHcmlkVmlld2AgZGlkIHJlbG9hZCBkYXRhIGZyb20gdGhlIGRhdGEgc291cmNlLlxyXG4gICAgICogQGV2ZW50IEdyaWRWaWV3I2RpZFJlbG9hZFxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoJ2RpZFJlbG9hZCcpXHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBxdWVyeSA9IHtcclxuICBuYW1lOiAncXVlcnknLFxyXG4gIGhhbmRsZXI6IHF1ZXJ5UHJvamVjdGlvbkhhbmRsZXIsXHJcbiAgZGVmYXVsdHM6IHt9LFxyXG59O1xyXG5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy92bmV4dC9wcm9qZWN0aW9uL3F1ZXJ5LmpzXG4gKiovIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XHJcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XHJcbmltcG9ydCBQcm9taXNlIGZyb20gJ2JsdWViaXJkJztcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUl0ZW1TdGF0ZShncmlkVmlldywgaXRlbSwgc3RhdGUpIHtcclxuICBjb25zdCBidWZmZXIgPSBncmlkVmlldy5nZXQoJ2J1ZmZlcicpO1xyXG4gIGNvbnN0IGNoYW5nZWQgPSB7fTtcclxuICBjb25zdCBrZXkgPSBfLnJlc3VsdChpdGVtLCBncmlkVmlldy5wcmltYXJ5S2V5KTtcclxuXHJcbiAgY2hhbmdlZFtrZXldID0ge1xyXG4gICAgaXRlbSxcclxuICAgIHN0YXRlLFxyXG4gIH07XHJcbiAgXy5kZWZhdWx0cyhjaGFuZ2VkLCBidWZmZXIuY2hhbmdlZCk7XHJcblxyXG4gIGdyaWRWaWV3LnNldCh7XHJcbiAgICBidWZmZXI6IF8uZGVmYXVsdHMoeyBjaGFuZ2VkIH0sIGJ1ZmZlciksXHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBidWZmZXIgPSB7XHJcbiAgbmFtZTogJ2J1ZmZlcicsXHJcbiAgaGFuZGxlcihzdGF0ZSwgYnVmZmVyKSB7XHJcbiAgICBjb25zdCB7IHByaW1hcnlLZXksIHVuaXF1ZUlkLCB1cGRhdGUgfSA9IHN0YXRlO1xyXG5cclxuICAgIGlmIChidWZmZXIudW5pcXVlSWQgIT09IHVuaXF1ZUlkKSB7XHJcbiAgICAgIGJ1ZmZlci51bmlxdWVJZCA9IHVuaXF1ZUlkO1xyXG4gICAgICBidWZmZXIuY2hhbmdlZCA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGl0ZW1zID0ge1xyXG4gICAgICBsZW5ndGg6IHN0YXRlLml0ZW1zLmxlbmd0aCxcclxuICAgICAgc2xpY2U6IChiZWdpbiA9IDAsIGVuZCA9IHN0YXRlLml0ZW1zLmxlbmd0aCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBzdGF0ZS5pdGVtcy5zbGljZShiZWdpbiwgZW5kKS5tYXAoaXRlbSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBrZXkgPSBpdGVtW3ByaW1hcnlLZXldO1xyXG5cclxuICAgICAgICAgIGlmIChfLmhhcyhidWZmZXIuY2hhbmdlZCwga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLmNoYW5nZWRba2V5XS5pdGVtO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb25Db21taXQgPSBpdGVtID0+IHtcclxuICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICB1cGRhdGVJdGVtU3RhdGUodGhpcywgaXRlbSwgJ2NvbW1pdHRlZCcpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb25FZGl0ID0gaXRlbSA9PiB7XHJcbiAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgdXBkYXRlSXRlbVN0YXRlKHRoaXMsIGl0ZW0sICdjaGFuZ2VkJyk7XHJcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih1cGRhdGUpKSB7XHJcbiAgICAgICAgICB1cGRhdGUoaXRlbSkudGhlbihvbkNvbW1pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZXZlbnRzID0gXy5kZWZhdWx0cyh7IGRpZEVkaXQ6IG9uRWRpdCB9LCBzdGF0ZS5ldmVudHMpO1xyXG5cclxuICAgIHJldHVybiBfLmRlZmF1bHRzKHsgaXRlbXMsIGV2ZW50cyB9LCBzdGF0ZSk7XHJcbiAgfSxcclxuICBkZWZhdWx0czoge30sXHJcbn07XHJcblxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vYnVmZmVyLmpzXG4gKiovIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XHJcbmltcG9ydCB7IFNpbmdsZVNlbGVjdGlvblJlc29sdmVyIH0gZnJvbSAnLi9zaW5nbGUtc2VsZWN0aW9uLXJlc29sdmVyLmpzJztcclxuaW1wb3J0IHsgTXVsdGlwbGVTZWxlY3Rpb25SZXNvbHZlciB9IGZyb20gJy4vbXVsdGlwbGUtc2VsZWN0aW9uLXJlc29sdmVyLmpzJztcclxuaW1wb3J0IHNlbGVjdGlvbkhlYWRUZW1wbGF0ZSBmcm9tICcuL3NlbGVjdGlvbi1oZWFkLmphZGUnO1xyXG5pbXBvcnQgc2VsZWN0aW9uQm9keVRlbXBsYXRlIGZyb20gJy4vc2VsZWN0aW9uLWJvZHkuamFkZSc7XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24oZ3JpZFZpZXcsIHNlbGVjdGlvbikge1xyXG4gIGdyaWRWaWV3LnRyaWdnZXIoJ3dpbGxTZWxlY3QnLCBzZWxlY3Rpb24uc2VsZWN0ZWQpO1xyXG4gIGdyaWRWaWV3LnNldCh7IHNlbGVjdGlvbiB9LCAoKSA9PiB7XHJcbiAgICBncmlkVmlldy50cmlnZ2VyKCdkaWRTZWxlY3QnLCBzZWxlY3Rpb24uc2VsZWN0ZWQpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0U2VsZWN0QWxsKGdyaWRWaWV3LCBjaGVja2VkKSB7XHJcbiAgY29uc3QgeyByZXNvbHZlciB9ID0gZ3JpZFZpZXcuZ2V0KCdzZWxlY3Rpb24nKTtcclxuICBjb25zdCBzZWxlY3Rpb24gPSBjaGVja2VkID8gcmVzb2x2ZXIuc2VsZWN0QWxsKCkgOiByZXNvbHZlci5kZXNlbGVjdEFsbCgpO1xyXG5cclxuICB1cGRhdGVTZWxlY3Rpb24oZ3JpZFZpZXcsIHNlbGVjdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoYW5nZVNlbGVjdEFsbChlKSB7XHJcbiAgc2V0U2VsZWN0QWxsKHRoaXMsIGUudGFyZ2V0LmNoZWNrZWQpO1xyXG4gIGUucHJldmVudERlZmF1bHQoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFNlbGVjdFJvdyhncmlkVmlldywga2V5LCBjaGVja2VkKSB7XHJcbiAgY29uc3QgeyByZXNvbHZlciB9ID0gZ3JpZFZpZXcuZ2V0KCdzZWxlY3Rpb24nKTtcclxuICBjb25zdCBzZWxlY3Rpb24gPSBjaGVja2VkID8gcmVzb2x2ZXIuc2VsZWN0Um93KGtleSkgOiByZXNvbHZlci5kZXNlbGVjdFJvdyhrZXkpO1xyXG5cclxuICB1cGRhdGVTZWxlY3Rpb24oZ3JpZFZpZXcsIHNlbGVjdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoYW5nZVNlbGVjdFJvdyhlKSB7XHJcbiAgY29uc3Qga2V5ID0gdGhpcy5rZXlPZkVsZW1lbnQoZS50YXJnZXQpO1xyXG5cclxuICBzZXRTZWxlY3RSb3codGhpcywga2V5LCBlLnRhcmdldC5jaGVja2VkKTtcclxuICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGQgc2VsZWN0aW9uIGJveCB0byByb3dzXHJcbiAqIEBwYXJhbSB7U3RydWN0dXJlQ2hhaW5TdGF0ZX0gc3RhdGVcclxuICogICAgVGhlIGlucHV0IHN0YXRlLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW58U2VsZWN0aW9uQ29uZmlnfSBzZWxlY3Rpb25cclxuICogICAgVGhlIHNlbGVjdGlvbiBjb25maWd1cmF0aW9uLiBJdCBjYW4gYmVcclxuICogICAgKiBBIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgZ3JpZCBoYXMgdGhlIHNlbGVjdGlvbiBjb2x1bW4uXHJcbiAqICAgICogQSBkZXRhaWxlZCB7QGxpbmsgU2VsZWN0aW9uQ29uZmlnfSBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZWxlY3Rpb25Qcm9qZWN0aW9uSGFuZGxlcihzdGF0ZSwgeyBlbmFibGVkLCByZXNvbHZlciB9KSB7XHJcbiAgaWYgKCFlbmFibGVkKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG5cclxuICBjb25zdCB7XHJcbiAgICBzZWxlY3RlZCxcclxuICAgIHNpbmdsZSxcclxuICAgIGNvbENsYXNzZXMsXHJcbiAgICBoZWFkQ2xhc3NlcyxcclxuICAgIGJvZHlDbGFzc2VzLFxyXG4gICAgZm9vdENsYXNzZXMsXHJcbiAgICBzZWxlY3RhYmxlLFxyXG4gIH0gPSByZXNvbHZlci51cGRhdGVJdGVtcyhzdGF0ZS5pdGVtcyk7XHJcblxyXG4gIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBfLnJlZHVjZShzZWxlY3RlZCwgKG1lbW8sIGtleSkgPT4ge1xyXG4gICAgbWVtb1trZXldID0gdHJ1ZTtcclxuICAgIHJldHVybiBtZW1vO1xyXG4gIH0sIHt9KTtcclxuICBjb25zdCBwcmltYXJ5S2V5ID0gc3RhdGUucHJpbWFyeUtleTtcclxuICBsZXQgc2VsZWN0ZWRBbGwgPSBmYWxzZTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgdG8gZGVjaWRlIHdoZXRoZXIgYSByb3cgaXMgc2VsZWN0YWJsZS5cclxuICAgKiBAY2FsbGJhY2sgU2VsZWN0YWJsZUNhbGxiYWNrXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cclxuICAgKiAgICBUaGUgZGF0YSBpdGVtIG9mIHRoZSByb3cuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gXHJcbiAgICovXHJcbiAgaWYgKCFzaW5nbGUpIHtcclxuICAgIGNvbnN0IHNlbGVjdGFibGVDb3VudCA9IF8uZmlsdGVyKHN0YXRlLml0ZW1zLnNsaWNlKCksIHNlbGVjdGFibGUpLmxlbmd0aDtcclxuICAgIGNvbnN0IHNlbGVjdGVkQ291bnQgPSBfLmZpbHRlcihzZWxlY3RlZCwga2V5ID0+IHNlbGVjdGFibGUodGhpcy5pdGVtV2l0aEtleShrZXkpKSkubGVuZ3RoO1xyXG5cclxuICAgIHNlbGVjdGVkQWxsID0gc2VsZWN0ZWRDb3VudCA9PT0gc2VsZWN0YWJsZUNvdW50O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgY29sdW1ucyA9IFt7XHJcbiAgICBuYW1lOiAnc2VsZWN0aW9uJyxcclxuICAgIGh0bWw6IHNlbGVjdGlvbkhlYWRUZW1wbGF0ZSh7XHJcbiAgICAgIHNpbmdsZSxcclxuICAgICAgY2hlY2tlZDogc2VsZWN0ZWRBbGxcclxuICAgIH0pLFxyXG4gICAgdGVtcGxhdGU6IHNlbGVjdGlvbkJvZHlUZW1wbGF0ZSxcclxuICAgIHByb3BlcnR5OiBpdGVtID0+IHtcclxuICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgc2luZ2xlLFxyXG4gICAgICAgIHNlbGVjdGFibGU6IHNlbGVjdGFibGUoaXRlbSksXHJcbiAgICAgICAgY2hlY2tlZDogc2VsZWN0ZWRJbmRleFtpdGVtW3ByaW1hcnlLZXldXSxcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBzb3J0YWJsZTogZmFsc2UsXHJcbiAgICBjb2xDbGFzc2VzLFxyXG4gICAgaGVhZENsYXNzZXMsXHJcbiAgICBib2R5Q2xhc3NlcyxcclxuICAgIGZvb3RDbGFzc2VzLFxyXG4gIH1dLmNvbmNhdChzdGF0ZS5jb2x1bW5zKTtcclxuXHJcbiAgY29uc3QgZXZlbnRzID0gXy5kZWZhdWx0cyh7XHJcbiAgICAnY2hhbmdlIHRoIGlucHV0LnNlbGVjdC1hbGwnOiBjaGFuZ2VTZWxlY3RBbGwsXHJcbiAgICAnY2hhbmdlIHRkIGlucHV0LnNlbGVjdC1yb3cnOiBjaGFuZ2VTZWxlY3RSb3csXHJcbiAgfSwgc3RhdGUuZXZlbnRzKTtcclxuXHJcbiAgcmV0dXJuIF8uZGVmYXVsdHMoeyBjb2x1bW5zLCBldmVudHMgfSwgc3RhdGUpO1xyXG59XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplIHRoZSBzZWxlY3Rpb24gY29uZmlnXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbnxTZWxlY3Rpb25Db25maWd9IHNlbGVjdGlvblxyXG4gKiAgICBUaGUgc2VsZWN0aW9uIGNvbmZpZ3VyYXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVTZWxlY3Rpb25Db25maWcoc2VsZWN0aW9uKSB7XHJcbiAgaWYgKCFzZWxlY3Rpb24pIHtcclxuICAgIHJldHVybiB7IGVuYWJsZWQ6IGZhbHNlIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZWRlZiBTZWxlY3Rpb25Db25maWdcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5hYmxlZFxyXG4gICAqICAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBmZWF0dXJlIGlzIGVuYWJsZWQuXHJcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBzaW5nbGVcclxuICAgKiAgICBUcnVlIGlmIG9ubHkgMSByb3cgY2FuIGJlIHNlbGVjdGVkIGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmdbXX0gc2VsZWN0ZWRcclxuICAgKiAgICBUaGUgcHJpbWFyeSBrZXkgb2Ygcm93cyBiZWluZyBzZWxlY3RlZC5cclxuICAgKiBAcHJvcGVydHkge1NlbGVjdGFibGVDYWxsYmFja30gc2VsZWN0YWJsZVxyXG4gICAqICAgIEEgY2FsbGJhY2sgdG8gZGVjaWRlIHdoZXRoZXIgYSByb3cgaXMgc2VsZWN0YWJsZS5cclxuICAgKiBAcHJvcGVydHkge0NsYXNzZXNDb25maWd9IGNvbENsYXNzZXNcclxuICAgKiAgICBUaGUgY2xhc3NlcyBvZiB0aGUgJ0NPTCcgZWxlbWVudCBmb3IgdGhlIHNlbGVjdGlvbiBjb2x1bW4uXHJcbiAgICogQHByb3BlcnR5IHtDbGFzc2VzQ29uZmlnfSBoZWFkQ2xhc3Nlc1xyXG4gICAqICAgIFRoZSBjbGFzc2VzIG9mIHRoZSAnVEgnIGVsZW1lbnQgaW4gJ1RIRUFEJyBvZiB0aGUgc2VsZWN0aW9uIGNvbHVtbi5cclxuICAgKiBAcHJvcGVydHkge0NsYXNzZXNDb25maWd9IGJvZHlDbGFzc2VzXHJcbiAgICogICAgVGhlIGNsYXNzZXMgb2YgdGhlICdURCcgZWxlbWVudHMgaW4gJ1RCT0RZJyBvZiB0aGUgc2VsZWN0aW9uIGNvbHVtbi5cclxuICAgKiBAcHJvcGVydHkge0NsYXNzZXNDb25maWd9IGZvb3RDbGFzc2VzXHJcbiAgICogICAgVGhlIGNsYXNzZXMgb2YgdGhlICdURCcgZWxlbWVudHMgaW4gJ1RGT09UJyBvZiB0aGUgc2VsZWN0aW9uIGNvbHVtbi5cclxuICAgKi9cclxuICBjb25zdCBjb25maWcgPSBfLmRlZmF1bHRzKHt9LCBfLmlzT2JqZWN0KHNlbGVjdGlvbikgPyBzZWxlY3Rpb24gOiB7fSwge1xyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIHNpbmdsZTogZmFsc2UsXHJcbiAgICBzZWxlY3RlZDogW10sXHJcbiAgICBzZWxlY3RhYmxlOiAoaXRlbSkgPT4gXy5oYXMoaXRlbSwgdGhpcy5wcmltYXJ5S2V5KSxcclxuICAgIGNvbENsYXNzZXM6IFtdLFxyXG4gICAgaGVhZENsYXNzZXM6IFtdLFxyXG4gICAgYm9keUNsYXNzZXM6IFtdLFxyXG4gICAgZm9vdENsYXNzZXM6IFtdLFxyXG4gIH0pO1xyXG5cclxuICBpZiAoIV8uaXNGdW5jdGlvbihjb25maWcuUmVzb2x2ZXIpKSB7XHJcbiAgICBjb25maWcuUmVzb2x2ZXIgPSBjb25maWcuc2luZ2xlID8gU2luZ2xlU2VsZWN0aW9uUmVzb2x2ZXIgOiBNdWx0aXBsZVNlbGVjdGlvblJlc29sdmVyO1xyXG4gIH1cclxuXHJcbiAgaWYgKCEoY29uZmlnLnJlc29sdmVyIGluc3RhbmNlb2YgY29uZmlnLlJlc29sdmVyKSkge1xyXG4gICAgY29uZmlnLnJlc29sdmVyID0gbmV3IGNvbmZpZy5SZXNvbHZlcih0aGlzKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjb25maWc7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY29uc3Qgc2VsZWN0aW9uID0ge1xyXG4gIG5hbWU6ICdzZWxlY3Rpb24nLFxyXG4gIGhhbmRsZXI6IHNlbGVjdGlvblByb2plY3Rpb25IYW5kbGVyLFxyXG4gIG5vcm1hbGl6ZTogbm9ybWFsaXplU2VsZWN0aW9uQ29uZmlnLFxyXG4gIGRlZmF1bHRzOiBmYWxzZSxcclxufTtcclxuXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvdm5leHQvcHJvamVjdGlvbi9zZWxlY3Rpb24uanNcbiAqKi8iLCJpbXBvcnQgeyBTZWxlY3Rpb25SZXNvbHZlciB9IGZyb20gJy4vc2VsZWN0aW9uLXJlc29sdmVyLmpzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBTaW5nbGVTZWxlY3Rpb25SZXNvbHZlciBleHRlbmRzIFNlbGVjdGlvblJlc29sdmVyIHtcclxuICBzZWxlY3RSb3coa2V5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXRjaCh7IHNlbGVjdGVkOiBba2V5LnRvU3RyaW5nKCldIH0pO1xyXG4gIH1cclxufVxyXG5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy92bmV4dC9wcm9qZWN0aW9uL3NpbmdsZS1zZWxlY3Rpb24tcmVzb2x2ZXIuanNcbiAqKi8iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcclxuXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb25SZXNvbHZlciB7XHJcbiAgY29uc3RydWN0b3IoZ3JpZFZpZXcpIHtcclxuICAgIHRoaXMuZ3JpZFZpZXcgPSBncmlkVmlldztcclxuICB9XHJcblxyXG4gIHVwZGF0ZUl0ZW1zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGF0Y2goe30pO1xyXG4gIH1cclxuXHJcbiAgc2VsZWN0Um93KCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgU3VwcG9ydGVkJyk7XHJcbiAgfVxyXG5cclxuICBkZXNlbGVjdFJvdygpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm90IFN1cHBvcnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgc2VsZWN0QWxsKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgU3VwcG9ydGVkJyk7XHJcbiAgfVxyXG5cclxuICBkZXNlbGVjdEFsbCgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm90IFN1cHBvcnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgcGF0Y2gob3B0aW9ucykge1xyXG4gICAgY29uc3Qgc2VsZWN0aW9uQ3VyID0gdGhpcy5ncmlkVmlldy5nZXQoJ3NlbGVjdGlvbicpO1xyXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gXy5pc0Z1bmN0aW9uKG9wdGlvbnMpID8gb3B0aW9ucyhzZWxlY3Rpb25DdXIpIDogb3B0aW9ucztcclxuXHJcbiAgICByZXR1cm4gXy5kZWZhdWx0cyhzZWxlY3Rpb24sIHNlbGVjdGlvbkN1cik7XHJcbiAgfVxyXG59XHJcblxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vc2VsZWN0aW9uLXJlc29sdmVyLmpzXG4gKiovIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XHJcbmltcG9ydCB7IFNlbGVjdGlvblJlc29sdmVyIH0gZnJvbSAnLi9zZWxlY3Rpb24tcmVzb2x2ZXIuanMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIE11bHRpcGxlU2VsZWN0aW9uUmVzb2x2ZXIgZXh0ZW5kcyBTZWxlY3Rpb25SZXNvbHZlciB7XHJcblxyXG4gIHNlbGVjdFJvdyhrZXkpIHtcclxuICAgIHJldHVybiB0aGlzLnBhdGNoKCh7IHNlbGVjdGVkIH0pID0+ICh7XHJcbiAgICAgIHNlbGVjdGVkOiBfLnVuaW9uKHNlbGVjdGVkLCBba2V5LnRvU3RyaW5nKCldKSxcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIGRlc2VsZWN0Um93KGtleSkge1xyXG4gICAgcmV0dXJuIHRoaXMucGF0Y2goKHsgc2VsZWN0ZWQgfSkgPT4gKHtcclxuICAgICAgc2VsZWN0ZWQ6IF8ud2l0aG91dChzZWxlY3RlZCwga2V5LnRvU3RyaW5nKCkpLFxyXG4gICAgfSkpO1xyXG4gIH1cclxuXHJcbiAgLy8gU2VsZWN0IGFsbCBzZWxlY3RhbGJlIGl0ZW1zXHJcbiAgc2VsZWN0QWxsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGF0Y2goKHsgc2VsZWN0YWJsZSwgc2VsZWN0ZWQgfSkgPT4ge1xyXG4gICAgICBjb25zdCBwYXRjaCA9IHt9O1xyXG5cclxuICAgICAgcGF0Y2guc2VsZWN0ZWQgPSBfLmNoYWluKHRoaXMuZ3JpZFZpZXcuaXRlbXMuc2xpY2UoKSlcclxuICAgICAgICAuZmlsdGVyKHNlbGVjdGFibGUpXHJcbiAgICAgICAgLm1hcChfLnByb3BlcnR5KHRoaXMuZ3JpZFZpZXcucHJpbWFyeUtleSkpXHJcbiAgICAgICAgLm1hcChTdHJpbmcpXHJcbiAgICAgICAgLnVuaW9uKHNlbGVjdGVkKVxyXG4gICAgICAgIC52YWx1ZSgpO1xyXG5cclxuICAgICAgcmV0dXJuIHBhdGNoO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBEZXNlbGVjdCBhbGwgc2VsZWN0YWJsZSBpdGVtc1xyXG4gIGRlc2VsZWN0QWxsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGF0Y2goKHsgc2VsZWN0YWJsZSwgc2VsZWN0ZWQgfSkgPT4ge1xyXG4gICAgICBjb25zdCBwYXRjaCA9IHt9O1xyXG5cclxuICAgICAgcGF0Y2guc2VsZWN0ZWQgPSBfLmZpbHRlcihzZWxlY3RlZCwga2V5ID0+IHtcclxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5ncmlkVmlldy5pdGVtV2l0aEtleShrZXkpO1xyXG5cclxuICAgICAgICByZXR1cm4gIShpdGVtICYmIHNlbGVjdGFibGUoaXRlbSkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBwYXRjaDtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy92bmV4dC9wcm9qZWN0aW9uL211bHRpcGxlLXNlbGVjdGlvbi1yZXNvbHZlci5qc1xuICoqLyIsInZhciBqYWRlID0gcmVxdWlyZShcIkQ6XFxcXHdvcmtzcGFjZVxcXFxmb3JrXFxcXHByb2plY3Rpb24tZ3JpZFxcXFxub2RlX21vZHVsZXNcXFxcamFkZVxcXFxsaWJcXFxccnVudGltZS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZW1wbGF0ZShsb2NhbHMpIHtcbnZhciBidWYgPSBbXTtcbnZhciBqYWRlX21peGlucyA9IHt9O1xudmFyIGphZGVfaW50ZXJwO1xuO3ZhciBsb2NhbHNfZm9yX3dpdGggPSAobG9jYWxzIHx8IHt9KTsoZnVuY3Rpb24gKGNoZWNrZWQsIHNpbmdsZSkge1xuaWYgKCBzaW5nbGUpXG57XG5idWYucHVzaChcIjxzcGFuPjwvc3Bhbj5cIik7XG59XG5lbHNlXG57XG5idWYucHVzaChcIjxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCJcIiArIChqYWRlLmF0dHIoXCJjaGVja2VkXCIsIGNoZWNrZWQsIHRydWUsIHRydWUpKSArIFwiIGNsYXNzPVxcXCJzZWxlY3QtYWxsXFxcIj5cIik7XG59fS5jYWxsKHRoaXMsXCJjaGVja2VkXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC5jaGVja2VkOnR5cGVvZiBjaGVja2VkIT09XCJ1bmRlZmluZWRcIj9jaGVja2VkOnVuZGVmaW5lZCxcInNpbmdsZVwiIGluIGxvY2Fsc19mb3Jfd2l0aD9sb2NhbHNfZm9yX3dpdGguc2luZ2xlOnR5cGVvZiBzaW5nbGUhPT1cInVuZGVmaW5lZFwiP3NpbmdsZTp1bmRlZmluZWQpKTs7cmV0dXJuIGJ1Zi5qb2luKFwiXCIpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vanMvdm5leHQvcHJvamVjdGlvbi9zZWxlY3Rpb24taGVhZC5qYWRlXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBqYWRlID0gcmVxdWlyZShcIkQ6XFxcXHdvcmtzcGFjZVxcXFxmb3JrXFxcXHByb2plY3Rpb24tZ3JpZFxcXFxub2RlX21vZHVsZXNcXFxcamFkZVxcXFxsaWJcXFxccnVudGltZS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZW1wbGF0ZShsb2NhbHMpIHtcbnZhciBidWYgPSBbXTtcbnZhciBqYWRlX21peGlucyA9IHt9O1xudmFyIGphZGVfaW50ZXJwO1xuO3ZhciBsb2NhbHNfZm9yX3dpdGggPSAobG9jYWxzIHx8IHt9KTsoZnVuY3Rpb24gKHZhbHVlKSB7XG5pZiAoIHZhbHVlLnNlbGVjdGFibGUpXG57XG5pZiAoIHZhbHVlLnNpbmdsZSlcbntcbmJ1Zi5wdXNoKFwiPGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIlwiICsgKGphZGUuYXR0cihcImNoZWNrZWRcIiwgdmFsdWUuY2hlY2tlZCwgdHJ1ZSwgdHJ1ZSkpICsgXCIgY2xhc3M9XFxcInNlbGVjdC1yb3dcXFwiPlwiKTtcbn1cbmVsc2VcbntcbmJ1Zi5wdXNoKFwiPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIlwiICsgKGphZGUuYXR0cihcImNoZWNrZWRcIiwgdmFsdWUuY2hlY2tlZCwgdHJ1ZSwgdHJ1ZSkpICsgXCIgY2xhc3M9XFxcInNlbGVjdC1yb3dcXFwiPlwiKTtcbn1cbn1cbmVsc2VcbntcbmJ1Zi5wdXNoKFwiPHNwYW4gY2xhc3M9XFxcInVuc2VsZWN0YWJsZVxcXCI+PC9zcGFuPlwiKTtcbn19LmNhbGwodGhpcyxcInZhbHVlXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC52YWx1ZTp0eXBlb2YgdmFsdWUhPT1cInVuZGVmaW5lZFwiP3ZhbHVlOnVuZGVmaW5lZCkpOztyZXR1cm4gYnVmLmpvaW4oXCJcIik7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9qcy92bmV4dC9wcm9qZWN0aW9uL3NlbGVjdGlvbi1ib2R5LmphZGVcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgQ29sdW1uQ29uZmlnXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXHJcbiAqICAgIE5hbWUgb2YgdGhlIGNvbHVtbi5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpdGxlXHJcbiAqICAgIFRoZSBsb2NhbGl6ZWQgY29sdW1uIHRpdGxlLiBUaGUgYG5hbWVgIHdpbGwgYmUgdXNlZCBpZiBgdGl0bGVgIGlzIG9taXR0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBodG1sXHJcbiAqICAgIFRoZSBIVE1MIHN0cmluZyB0byBiZSByZW5kZXJlZCBpbiB0aGUgY29sdW1uIGhlYWRlci4gVGhlIGB0aXRsZWAgc3RyaW5nXHJcbiAqICAgIHdpbGwgYmUgcmVuZGVyZWQgaW4gdGhlIGNvbHVtbiBoZWFkZXIgaWYgYGh0bWxgIGlzIG9taXR0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7KHN0cmluZ3xQcm9wZXJ0eUNhbGxiYWNrfFByb3BlcnR5Q29uZmlnKX0gcHJvcGVydHlcclxuICogICAgVGhlIGRhdGEgcHJvcGVydHkgb2YgdGhlIGNvbHVtbi4gSXQgZGVmaW5lcyBob3cgdG8gZ2V0L3NldCB2YWx1ZXMgd2l0aFxyXG4gKiAgICBhIGRhdGEgaXRlbS4gSWYgaXQncyBvbWl0dGVkLCB3aWxsIHVzZSB0aGUgY29sdW1uIGBuYW1lYCBhcyB0aGUga2V5IHBhdGguXHJcbiAqICAgIEl0IGNvdWxkIGJlXHJcbiAqXHJcbiAqICAgICogQSBrZXkgcGF0aCBzdHJpbmcuIEUuZy4gJ0Zvby9CYXInLlxyXG4gKiAgICAqIEEge0BsaW5rIFByb3BlcnR5Q2FsbGJhY2t9IGZ1bmN0aW9uXHJcbiAqICAgICogQSB7QGxpbmsgUHJvcGVydHlDb25maWd9IG9iamVjdFxyXG4gKlxyXG4gKiBAcHJvcGVydHkge0NlbGxUZW1wbGF0ZX0gdGVtcGxhdGVcclxuICogICAgVGhlIHRlbXBsYXRlIHRvIHJlbmRlciBhIGNlbGwgZm9yIHRoZSBjb2x1bW4uXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7KGJvb2xlYW58bnVtYmVyfE9yZGVyQnlLZXkpfSBzb3J0YWJsZVxyXG4gKiAgICBUaGUgb3JkZXJpbmcgY29uZmlndXJhdGlvbi4gSWYgaXQncyBvbWl0dGVkLCB0aGUgY29sdW1uIGlzIHVuc29ydGFibGUuXHJcbiAqICAgIEl0IGNvdWxkIGJlXHJcbiAqXHJcbiAqICAgICogQSBib29sZWFuIHNpbXBseSBzYXkgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZSBvciBub3QuXHJcbiAqICAgICogQSBudW1iZXIsIHBvc2l0aXZlIGZvciBhc2NlbmRpbmcgZmlyc3QsIG90aGVyd2lzZSBkZXNjZW5kaW5nIGZpcnN0LlxyXG4gKiAgICAqIEEgc3RyaW5nLCB0aGUga2V5IHBhdGggb2YgdGhlIHNvcnRpbmcgdmFsdWVzLlxyXG4gKiAgICAqIEEge0BsaW5rIFByb3BlcnR5R2V0dGVyfSB0byBnZXQgdGhlIHNvcnRpbmcgdmFsdWVzIGZyb20gZGF0YSBpdGVtcy5cclxuICogICAgICBPbmx5IGF2YWlsYWJsZSBmb3IgbWVtb3J5IGRhdGEgc291cmNlLlxyXG4gKiAgICAqIEEgZGV0YWlsZWQge0BsaW5rIFNvcnRhYmxlQ29uZmlnfSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbH0gZWRpdGFibGVcclxuICogICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBlZGl0YWJsZS5cclxuICogQHByb3BlcnR5IHtDbGFzc2VzQ29uZmlnfSBjb2xDbGFzc2VzXHJcbiAqICAgIFRoZSBjbGFzc2VzIGZvciB0aGUgYENPTGAgZWxlbWVudCBpbiBgQ09MR1JPVVBgLlxyXG4gKiBAcHJvcGVydHkge0NsYXNzZXNDb25maWd9IGhlYWRDbGFzc2VzXHJcbiAqICAgIFRoZSBjbGFzc2VzIGZvciB0aGUgYFRIYCBlbGVtZW50IGluIGBUSEVBRGAuXHJcbiAqIEBwcm9wZXJ0eSB7Q2xhc3Nlc0NvbmZpZ30gYm9keUNsYXNzZXNcclxuICogICAgVGhlIGNsYXNzZXMgZm9yIHRoZSBgVERgIGVsZW1lbnRzIGluIGBUQk9EWWAuXHJcbiAqIEBwcm9wZXJ0eSB7Q2xhc3Nlc0NvbmZpZ30gZm9vdENsYXNzZXNcclxuICogICAgVGhlIGNsYXNzZXMgZm9yIHRoZSBgVERgIGVsZW1lbnRzIGluIGBURk9PVGAuXHJcbiAqIEBwcm9wZXJ0eSB7Q29sdW1uQ29uZmlnW119IGNvbHVtbnNcclxuICogICAgVGhlIGNoaWxkcmVuIGNvbHVtbnMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENvbHVtbnMgcHJvamVjdGlvbiBoYW5kbGluZyBjb2x1bW5zIGNvbmZpZ3VyYXRpb25cclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7KG9iamVjdFtdfEZha2VBcnJheSl9IFtzdGF0ZS5pdGVtc11cclxuICogICAgT3JpZ2luYWwgZGF0YSBpdGVtcyBmcm9tIGRhdGEgc291cmNlLlxyXG4gKiBAcGFyYW0ge0NvbHVtbkNvbmZpZ1tdfSBbY29sdW1uc11cclxuICogICAgQ29sdW1ucyBjb25maWd1cmF0aW9uIGRlZmluZWQgYnkgdXNlci4gSWYgb21pdHRlZCwgYWxsIGNvbHVtbnMgaW4gb3JpZ2luYWxcclxuICogICAgZGF0YSB3aWxsIGJlIHNob3duLlxyXG4gKi9cclxuZnVuY3Rpb24gY29sdW1uc1Byb2plY3Rpb25IYW5kbGVyKHN0YXRlLCBjb2x1bW5zKSB7XHJcbiAgcmV0dXJuIF8uZGVmYXVsdHMoe1xyXG4gICAgY29sdW1uczogY29sdW1ucyB8fCBfLmNoYWluKHN0YXRlLml0ZW1zLnNsaWNlKDAsIDEpKS5maXJzdCgpLmtleXMoKS5tYXAobmFtZSA9PiAoe1xyXG4gICAgICBuYW1lLFxyXG4gICAgICAgIHNvcnRhYmxlOiB0cnVlLFxyXG4gICAgfSkpLnZhbHVlKCksXHJcbiAgfSwgc3RhdGUpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY29sdW1ucyA9IHtcclxuICBuYW1lOiAnY29sdW1ucycsXHJcbiAgaGFuZGxlcjogY29sdW1uc1Byb2plY3Rpb25IYW5kbGVyLFxyXG4gIGRlZmF1bHRzOiBudWxsLFxyXG59O1xyXG5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy92bmV4dC9wcm9qZWN0aW9uL2NvbHVtbnMuanNcbiAqKi8iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcclxuaW1wb3J0IHsgbm9ybWFsaXplQ2xhc3NlcyB9IGZyb20gJy4vY29tbW9uLmpzJztcclxuXHJcbmNvbnN0IGJ1ZmZlclN0YXRlQ2xhc3NlcyA9IHtcclxuICAnY2hhbmdlZCc6IFsncm93LWJ1ZmZlci1jaGFuZ2VkJ10sXHJcbiAgJ2NvbW1pdHRlZCc6IFsncm93LWJ1ZmZlci1jb21taXR0ZWQnXSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb25maWd1cmF0aW9uIGZvciBhIHJvdy4gSXQgY2FuIGJlIGFuIG9iamVjdCBvciBhIHNwZWNpYWxcclxuICogQHR5cGVkZWYgUm93Q29uZmlnXHJcbiAqIEB0eXBlIHsoc3RyaW5nfE9iamVjdCl9XHJcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdHlwZVxyXG4gKiAgICBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gZGVmaW5lIHRoZSB0eXBlIG9mIHRoZSByb3cuIFNwZWNpYWwgdmFsdWVzIGFyZVxyXG4gKiAgICAqIGAnZGF0YS1yb3dzJ2AuIEEgcm93IGNvbmZpZ3VyYXRpb24gd2hpY2ggd2lsbCBiZSBleHBhbmRlZCBpbnRvXHJcbiAqICAgICAgbXVsdGlwbGUgcm93cyByZXByZXNlbnRpbmcgZWFjaCBvZiB0aGUgZGF0YSBpdGVtcy5cclxuICogICAgKiBgJ2RhdGEnYC4gSW5kaWNhdGluZyB0aGUgcm93IGlzIGV4cGFuZGVkIGZyb20gdGhlIGAnZGF0YS1yb3dzJ2AuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7P0NsYXNzZXNDb25maWd9IGNsYXNzZXNcclxuICogICAgQ2xhc3NlcyBvZiB0aGUgYFRSYCBlbGVtZW50LlxyXG4gKiBAcHJvcGVydHkgez9PYmplY3R9IGl0ZW1cclxuICogICAgVGhlIGRhdGEgaXRlbSBmb3IgdGhlIHJvdy5cclxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBodG1sXHJcbiAqICAgIFRoZSBIVE1MIHN0cmluZyByZW5kZXJlZCBpbiBhIGNlbGwgdGFraW5nIHRoZSBlbnRpcmUgcm93LlxyXG4gKiBAcHJvcGVydHkgez9CYWNrYm9uZS5WaWV3fSB2aWV3XHJcbiAqICAgIFRoZSBCYWNrYm9uZSBWaWV3IHRha2UgdGhlIHBsYWNlIG9mIHRoZSBlbnRpcmUgcm93LiBUaGlzIGlzIGlzIG9ubHkgZm9yXHJcbiAqICAgIHRoZSBoZWFkZXIgYW5kIGZvb3RlciByb3dzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGUgY29uZmlndXJhdGlvbiBmb3Igcm93cyBwcm9qZWN0aW9uLiBXaGVuIGRlZmluaW5nIGhlYWRlciByb3dzLCBpdCBjYW4gYmVcclxuICogYSBzcGVjaWFsIHN0cmluZyBgJ2NvbHVtbi1oZWFkZXItcm93cydgLCByZXByZXNlbnRpbmcgYWxsIHRoZSBjb2x1bW4gaGVhZGVyXHJcbiAqIHJvd3MuXHJcbiAqIEB0eXBlZGVmIFJvd3NDb25maWdcclxuICogQHR5cGUgeyhzdHJpbmd8T2JqZWN0KX1cclxuICogQHByb3BlcnR5IHtSb3dDb25maWdbXX0gaGVhZFJvd3NcclxuICogICAgUm93IGNvbmZpZ3VyYXRpb25zIGZvciBgVEhFQURgLiBJdCBjYW4gdGFrZSBhIHNwZWNpYWwgc3RyaW5nIHZhbHVlXHJcbiAqICAgIGBjb2x1bW4taGVhZGVyLXJvd3NgLCB3aGljaCB3aWxsIGJlIGV4cGFuZGVkIGludG8gdGhlIGNvbHVtbiBoZWFkZXJzLlxyXG4gKiBAcHJvcGVydHkge1Jvd0NvbmZpZ1tdfSBib2R5Um93c1xyXG4gKiAgICBSb3cgY29uZmlndXJhdGlvbnMgZm9yIGBUQk9EWWAuIEl0IGNhbiB0YWtlIGEgc3BlY2lhbCByb3cgd2l0aCB0eXBlXHJcbiAqICAgIGBkYXRhLXJvd3NgLiBUaGlzIHJvdyB3aWxsIGJlIGV4cGFuZGVkLCBvbmUgZm9yIGVhY2ggZGF0YSBpdGVtLlxyXG4gKiBAcHJvcGVydHkge1Jvd0NvbmZpZ1tdfSBmb290Um93cyAtIFJvdyBjb25maWd1cmF0aW9ucyBmb3IgYFRGT09UYC5cclxuICovXHJcblxyXG4vKipcclxuICogSGFuZGxpbmcgYm9keVJvd3MgYW5kIGFkZGluZyBoZWFkUm93cywgYm9keVJvd3MsIGZvb3RSb3dzIHRvIHN0YXRlXHJcbiAqIEBwYXJhbSB7U3RydWN0dXJlQ2hhaW5TdGF0ZX0gc3RhdGUgLSBUaGUgaW5wdXQgc3RhdGUuXHJcbiAqIEBwYXJhbSB7Um93c0NvbmZpZ30gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIGZvciByb3dzIHByb2plY3Rpb24uXHJcbiAqIEByZXR1cm4ge1N0cnVjdHVyZUNoYWluU3RhdGV9XHJcbiAqL1xyXG5mdW5jdGlvbiByb3dzUHJvamVjdGlvbkhhbmRsZXIoc3RhdGUsIHtcclxuICBoZWFkUm93cyA9IFsnY29sdW1uLWhlYWRlci1yb3dzJ10sXHJcbiAgZm9vdFJvd3MgPSBbXSxcclxuICBib2R5Um93cyA9IFsnZGF0YS1yb3dzJ10sXHJcbn0gPSB7fSkge1xyXG4gIGNvbnN0IHBhdGNoID0geyBoZWFkUm93cywgZm9vdFJvd3MgfTtcclxuXHJcbiAgY29uc3QgcHJpbWFyeUtleSA9IHN0YXRlLnByaW1hcnlLZXk7XHJcbiAgY29uc3QgY2hhbmdlZCA9IHRoaXMuZ2V0KCdidWZmZXInKS5jaGFuZ2VkIHx8IHt9O1xyXG5cclxuICAvLyBUT0RPIFt3ZXdlaV0sIHVzZSBGYWtlIGl0ZW1zIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXHJcbiAgY29uc3QgaXRlbXMgPSBzdGF0ZS5pdGVtcy5zbGljZSgwLCBzdGF0ZS5pdGVtcy5sZW5ndGgpO1xyXG5cclxuICBwYXRjaC5ib2R5Um93cyA9IF8ucmVkdWNlKGJvZHlSb3dzLCAobWVtbywgcm93KSA9PiB7XHJcbiAgICBpZiAocm93ID09PSAnZGF0YS1yb3dzJyB8fCByb3cudHlwZSA9PT0gJ2RhdGEtcm93cycpIHtcclxuICAgICAgXy5lYWNoKGl0ZW1zLCBpdGVtID0+IHtcclxuICAgICAgICBjb25zdCBrZXkgPSBpdGVtW3ByaW1hcnlLZXldO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlclN0YXRlID0gXy5jaGFpbihjaGFuZ2VkKS5yZXN1bHQoa2V5KS5yZXN1bHQoJ3N0YXRlJykudmFsdWUoKTtcclxuICAgICAgICBjb25zdCBjbGFzc2VzID0gXy51bmlvbihcclxuICAgICAgICAgIG5vcm1hbGl6ZUNsYXNzZXMocm93LmNsYXNzZXMsIGl0ZW0pLFxyXG4gICAgICAgICAgXy5yZXN1bHQoYnVmZmVyU3RhdGVDbGFzc2VzLCBidWZmZXJTdGF0ZSwgW10pXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgbWVtby5wdXNoKHsgaXRlbSwgY2xhc3NlcywgdHlwZTogJ2RhdGEnIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAocm93LnZpZXcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb2R5IHJvdyBjYW5ub3QgaGF2ZSBzdWJ2aWV3cycpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWVtby5wdXNoKHJvdyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1lbW87XHJcbiAgfSwgW10pO1xyXG5cclxuICByZXR1cm4gXy5kZWZhdWx0cyhwYXRjaCwgc3RhdGUpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgcm93cyA9IHtcclxuICBuYW1lOiAncm93cycsXHJcbiAgaGFuZGxlcjogcm93c1Byb2plY3Rpb25IYW5kbGVyLFxyXG4gIGRlZmFsdXRzOiB7fSxcclxufTtcclxuXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvdm5leHQvcHJvamVjdGlvbi9yb3dzLmpzXG4gKiovIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XHJcblxyXG4vKipcclxuICogVGhlIGNsYXNzZXMgY29uZmlndXJhdGlvbi4gSXQgY291bGQgYmVcclxuICogICAgKiBBIGFycmF5IG9mIGNsYXNzIHN0cmluZ3NcclxuICogICAgKiBBIHNwYWNlIHNlcGFyYXRlZCBjbGFzc2VzIHN0cmluZ1xyXG4gKiAgICAqIEEgaGFzaCBmcm9tIGNsYXNzIG5hbWVzIHRvIHtAbGluayBDbGFzc1ByZWRpY2F0ZX1cclxuICogQHR5cGVkZWYgQ2xhc3Nlc0NvbmZpZ1xyXG4gKiBAdHlwZSB7KHN0cmluZ1tdfHN0cmluZ3xPYmplY3QuPHN0cmluZywgQ2xhc3NQcmVkaWNhdGU+KX1cclxuICovXHJcblxyXG4vKipcclxuICogTm9ybWFsaXplIHRoZSBjbGFzc2VzIGNvbmZpZ3VyYXRpb25cclxuICogQHBhcmFtIHtDbGFzc2VzQ29uZmlnfSBjbGFzc2VzXHJcbiAqICAgIFRoZSBjbGFzc2VzIGNvbmZpZ3VyYXRpb24uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XHJcbiAqICAgIFRoZSBjb250ZXh0IGZvciB0aGUgY2xhc3Nlcy4gSXQgY291bGQgYmVcclxuICogICAgKiBBIHtAbGluayBDb2x1bW5Db25maWd9IGZvciBhIGNvbHVtbidzIGhlYWRDbGFzc2VzL2NvbENsYXNzZXNcclxuICogICAgKiBBIHtAbGluayBSb3dDb25maWd9IGZvciBhIGNvbHVtbiBvciByb3cncyBib2R5Q2xhc3Nlcy9mb290Q2xhc3Nlc1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX1cclxuICogICAgVGhlIG5vcm1hbGl6ZWQgY2xhc3NlcyBjb25maWd1cmF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzZXMoY2xhc3NlcywgY29udGV4dCkge1xyXG4gIGlmKF8uaXNBcnJheShjbGFzc2VzKSkge1xyXG4gICAgcmV0dXJuIGNsYXNzZXM7XHJcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGNsYXNzZXMpKSB7XHJcbiAgICByZXR1cm4gY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xyXG4gIH0gZWxzZSBpZiAoXy5pc0Z1bmN0aW9uKGNsYXNzZXMpKSB7XHJcbiAgICByZXR1cm4gY2xhc3Nlcyhjb250ZXh0KTtcclxuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoY2xhc3NlcykpIHtcclxuICAgIHJldHVybiBfLmNoYWluKGNsYXNzZXMpXHJcbiAgICAgIC5wYWlycygpXHJcbiAgICAgIC5maWx0ZXIoKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgYm9vbGVhbiBvciBhIGNhbGxiYWNrIHRvIGRlY2lkZSB3aGV0aGVyIG9yIG5vdCBhIGNsYXNzIGlzIGFwcGxpZWQuXHJcbiAgICAgICAgICogV2hlbiBpdCdzIGEgZnVuY3Rpb24sIGl0IHRha2VzIHRoZSBjb250ZXh0IGFuZCByZXR1cm4gYSBib29sZWFuLlxyXG4gICAgICAgICAqIEB0eXBlZGVmIENsYXNzUHJlZGljYXRlXHJcbiAgICAgICAgICogQHR5cGUgeyhib29sZWFufENsYXNzUHJlZGljYXRlQ2FsbGJhY2spfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IGlzRnVuYyA9IF8uaXNGdW5jdGlvbih2YWx1ZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjYWxsYmFjayBDbGFzc1ByZWRpY2F0ZUNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcclxuICAgICAgICAgKiAgICBSZWZlciB0byB0aGUgYGNvbnRleHRgIG9mIHtAbGluayBub3JtYWxpemVDbGFzc2VzfS5cclxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICAgICAqICAgIFdoZXRoZXIgb3Igbm90IHRoZSBjbGFzcyBpcyBhcHBsaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJldHVybiAoaXNGdW5jICYmIHZhbHVlKGNvbnRleHQpKSB8fCAoIWlzRnVuYyAmJiBCb29sZWFuKHZhbHVlKSk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ga2V5KVxyXG4gICAgICAudmFsdWUoKTtcclxuICB9XHJcbiAgcmV0dXJuIFtdO1xyXG59XHJcblxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vY29tbW9uLmpzXG4gKiovIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XHJcbmltcG9ydCB7IG5vcm1hbGl6ZUNsYXNzZXMgfSBmcm9tICcuL2NvbW1vbi5qcyc7XHJcbmltcG9ydCBkZWZhdWx0Q2VsbFRlbXBsYXRlIGZyb20gJy4vZGVmYXVsdC1jZWxsLmphZGUnO1xyXG5cclxuZnVuY3Rpb24gc3RyaW5nUHJvcGVydHkocHJvcGVydHkpIHtcclxuICBjb25zdCBzZWdzID0gcHJvcGVydHkuc3BsaXQoJy8nKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGtleTogcHJvcGVydHksXHJcbiAgICBnZXQoaXRlbSkge1xyXG4gICAgICByZXR1cm4gXy5yZWR1Y2Uoc2VncywgKG1lbW8sIGtleSkgPT4gKG1lbW8gfHwge30pW2tleV0sIGl0ZW0pO1xyXG4gICAgfSxcclxuICAgIHNldChpdGVtLCB2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gXy5yZWR1Y2Uoc2VncywgKG1lbW8sIHNlZywgaW5kZXgpID0+IHtcclxuICAgICAgICBpZiAoaW5kZXggPCBzZWdzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgIGlmICghXy5pc09iamVjdChtZW1vW3NlZ10pKSB7XHJcbiAgICAgICAgICAgIG1lbW9bc2VnXSA9IHt9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtZW1vW3NlZ10gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIGl0ZW0pO1xyXG4gICAgfSxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgUHJvcGVydHlDb25maWdcclxuICogQHR5cGUge09iamVjdH1cclxuICogQHByb3BlcnR5IHtQcm9wZXJ0eUdldHRlcn0gZ2V0IC0gVGhlIGdldHRlciBmdW5jdGlvbi5cclxuICogQHByb3BlcnR5IHtQcm9wZXJ0eVNldHRlcn0gc2V0IC0gVGhlIHNldHRlciBmdW5jdGlvbi5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIFByb3BlcnR5R2V0dGVyXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIC0gVGhlIGRhdGEgaXRlbS5cclxuICogQHJldHVybiB7fSAtIFRoZSB2YWx1ZSBmb3IgdGhlIHByb3BlcnR5LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgUHJvcGVydHlTZXR0ZXJcclxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gLSBUaGUgZGF0YSBpdGVtLlxyXG4gKiBAcGFyYW0ge30gdmFsdWUgLSBUaGUgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eS5cclxuICovXHJcblxyXG4vKipcclxuICogSXQgYmVoYXZlcyBhcyBhIHtAbGluayBQcm9wZXJ0eUdldHRlcn0gd2hlbiBwYXNzZWQgMSBhcmd1bWVudCwgYW5kIGJlaGF2ZXNcclxuICogYXMgYSB7QGxpbmsgUHJvcGVydHlTZXR0ZXJ9IHdoZW4gcGFzc2VkIDIgYXJndW1lbnRzLlxyXG4gKiBAY2FsbGJhY2sgUHJvcGVydHlDYWxsYmFja1xyXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSAtIFRoZSBkYXRhIGl0ZW0uXHJcbiAqIEBwYXJhbSB7fSBbdmFsdWVdIC0gVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHByb3BlcnR5LlxyXG4gKiBAcmV0dXJuIHt9IC0gVGhlIHZhbHVlIGZvciB0aGUgcHJvcGVydHkuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcGVydHkocHJvcGVydHksIGNvbHVtbikge1xyXG4gIGlmICghcHJvcGVydHkpIHtcclxuICAgIHJldHVybiBzdHJpbmdQcm9wZXJ0eShjb2x1bW4ubmFtZSk7XHJcbiAgfVxyXG5cclxuICBpZiAoXy5pc1N0cmluZyhwcm9wZXJ0eSkpIHtcclxuICAgIHJldHVybiBzdHJpbmdQcm9wZXJ0eShwcm9wZXJ0eSk7XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChfLmlzRnVuY3Rpb24ocHJvcGVydHkpKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBnZXQ6IHByb3BlcnR5LFxyXG4gICAgICBzZXQ6IHByb3BlcnR5LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiBwcm9wZXJ0eTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIFNvcnRhYmxlQ29uZmlnXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfFByb3BlcnR5R2V0dGVyfSBrZXlcclxuICogICAgVGhlIHNvcnQga2V5LiBJdCBjb3VsZCBiZVxyXG4gKiAgICAqIEEgc3RyaW5nLCB0aGUga2V5IHBhdGggb2YgdGhlIHNvcnRpbmcgdmFsdWVzLlxyXG4gKiAgICAqIEEge0BsaW5rIFByb3BlcnR5R2V0dGVyfSB0byBnZXQgdGhlIHNvcnRpbmcgdmFsdWVzIGZyb20gZGF0YSBpdGVtcy5cclxuICogICAgICBPbmx5IGF2YWlsYWJsZSBmb3IgbWVtb3J5IGRhdGEgc291cmNlLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGlyZWN0aW9uXHJcbiAqICAgIEEgbnVtYmVyIGluZGljYXRpbmcgdGhlIG9yZGVyIG9uIGZpcnN0IGNsaWNrLiBQb3NpdGl2ZSBmb3IgYXNjZW5kaW5nLFxyXG4gKiAgICBvdGhlcndpc2UgZGVzY2VuZGluZy5cclxuICogQHByb3BlcnR5IHtTb3J0YWJsZUhlYWRlclRlbXBsYXRlfSB0ZW1wbGF0ZVxyXG4gKiAgICBBIGN1c3RvbWl6ZWQgdGVtcGxhdGUgdG8gcmVuZGVyIHRoZSBzb3J0YWJsZSBjb2x1bW4gaGVhZGVyLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNvcnRhYmxlKHNvcnRhYmxlLCBjb2x1bW4pIHtcclxuICBjb25zdCBjb2x1bW5LZXkgPSBjb2x1bW4ucHJvcGVydHkua2V5IHx8IGNvbHVtbi5wcm9wZXJ0eS5nZXQ7XHJcblxyXG4gIGlmIChzb3J0YWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2V5OiBjb2x1bW5LZXksXHJcbiAgICAgIGRpcmVjdGlvbjogMSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpZiAoXy5pc1N0cmluZyhzb3J0YWJsZSkgfHwgXy5pc0Z1bmN0aW9uKHNvcnRhYmxlKSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2V5OiBzb3J0YWJsZSxcclxuICAgICAgZGlyZWN0aW9uOiAxLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGlmIChfLmlzTnVtYmVyKHNvcnRhYmxlKSAmJiBzb3J0YWJsZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2V5OiBjb2x1bW5LZXksXHJcbiAgICAgIGRpcmVjdGlvbjogc29ydGFibGUgPiAwID8gMSA6IC0xLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGlmIChfLmlzT2JqZWN0KHNvcnRhYmxlKSkge1xyXG4gICAgcmV0dXJuIF8uZXh0ZW5kKHtcclxuICAgICAga2V5OiBjb2x1bW5LZXksXHJcbiAgICAgIGRpcmVjdGlvbjogMSxcclxuICAgIH0sIHNvcnRhYmxlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGNvbHVtbiBncm91cCBjbGFzcy5cclxuICpcclxuICogSXQgdGFrZXMgY29sdW1ucyBjb25maWd1cmF0aW9uIGFzIGlucHV0IGFuZCBnZW5lcmF0ZXMgaGVhZGVyUm93cywgbGVhZkNvbHVtbnMsXHJcbiAqIGNvbHVtbkluZGV4IGFuZCByb290KGEgdHJlZS1saWtlIGNvbHVtbiBzdHJ1Y3R1cmUpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NvbHVtbkNvbmZpZ1tdfSBjb2x1bW5zXHJcbiAqICAgIFRoZSBjb2x1bW5zIGNvbmZpZ3VyYXRpb25cclxuICovXHJcbmNsYXNzIENvbHVtbkdyb3VwIHtcclxuICBjb25zdHJ1Y3Rvcihjb2x1bW5zKSB7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbHVtbiBoZWFkZXIgcm93c1xyXG4gICAgICogQHR5cGUge1Jvd0NvbnRlbnRbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5oZWFkZXJSb3dzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGVhZiBjb2x1bW5zXHJcbiAgICAgKiBAdHlwZSB7RXh0ZW5kZWRDb2x1bW5Db25maWdbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sZWFmQ29sdW1ucyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbHVtbnMgaW5kZXhlZCBieSBuYW1lXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsRXh0ZW5kZWRDb2x1bW5Db25maWc+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbHVtbkluZGV4ID0ge307XHJcblxyXG4gICAgLypcclxuICAgICAqIEJ1aWxkIHRyZWUtbGlrZSBjb2x1bW5zIHN0cnVjdHVyZSB1c2luZyBERlNcclxuICAgICAqL1xyXG4gICAgY29uc3QgYnVpbGRDb2x1bW4gPSBjb2wgPT4ge1xyXG4gICAgICAvKipcclxuICAgICAgICogQW4gZXh0ZW5kZWQgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgY29sdW1ucy4gSXQgZXh0ZW5kc1xyXG4gICAgICAgKiB7QGxpbmsgQ29sdW1uQ29uZmlnfSB3aXRoIHNldmVyYWwgZXh0cmEgcHJvcGVydGllcy5cclxuICAgICAgICogQHR5cGVkZWYgRXh0ZW5kZWRDb2x1bW5Db25maWdcclxuICAgICAgICogQHR5cGUgQ29sdW1uQ29uZmlnXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7RXh0ZW5kZWRDb2x1bW5Db25maWd9IHBhcmVudFxyXG4gICAgICAgKiAgICBUaGUgcGFyZW50IGNvbHVtbiBpZiB0aGVyZSdzIGEgY29sdW1uIGhpZXJhcmNoeS5cclxuICAgICAgICogQHByb3BlcnR5IHtFeHRlbmRlZENvbHVtbkNvbmZpZ1tdfSBjb2x1bW5zXHJcbiAgICAgICAqICAgIFRoZSBjaGlsZHJlbiBjb2x1bW5zLlxyXG4gICAgICAgKiBAcHJvcGVydHkge0NlbGxDb250ZW50fSBjZWxsXHJcbiAgICAgICAqICAgIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBoZWFkZXIgY2VsbC5cclxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodFxyXG4gICAgICAgKiAgICBUaGUgcm93c3BhbiBvZiB0aGUgaGVhZGVyIGNlbGwuXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0cmVlV2lkdGhcclxuICAgICAgICogICAgVGhlIGNvbHNwYW4gb2YgdGhlIGhlYWRlciBjZWxsLiBUaGUgdHJlZSB3aWR0aCBvZiB0aGUgY29sdW1uXHJcbiAgICAgICAqICAgIHN1YnRyZWUgaW4gbnVtYmVyIG9mIGNvbHVtbnMuXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0cmVlSGVpZ2h0XHJcbiAgICAgICAqICAgIFRoZSBoZWlnaHQgb2YgdGhlIGNvbHVtbiBzdWJ0cmVlIGluIG51bWJlciBvZiByb3dzLlxyXG4gICAgICAgKi9cclxuICAgICAgY29uc3QgeyBwYXJlbnQsIGNvbHVtbnMsIGhlaWdodCwgbmFtZSwgcHJvcGVydHksIHNvcnRhYmxlIH0gPSBjb2w7XHJcblxyXG4gICAgICB0aGlzLmNvbHVtbkluZGV4W25hbWVdID0gY29sO1xyXG4gICAgICBcclxuICAgICAgY29sLnByb3BlcnR5ID0gbm9ybWFsaXplUHJvcGVydHkocHJvcGVydHksIGNvbCk7XHJcbiAgICAgIGNvbC5zb3J0YWJsZSA9IG5vcm1hbGl6ZVNvcnRhYmxlKHNvcnRhYmxlLCBjb2wpO1xyXG5cclxuICAgICAgaWYgKCFfLmlzRnVuY3Rpb24oY29sLnRlbXBsYXRlKSkge1xyXG4gICAgICAgIGNvbC50ZW1wbGF0ZSA9IGRlZmF1bHRDZWxsVGVtcGxhdGU7XHJcbiAgICAgIH1cclxuICAgICAgY29sLmhlaWdodCAgPSBfLmlzTnVtYmVyKGhlaWdodCkgPyBoZWlnaHQgOiAxO1xyXG4gICAgICBjb2wucm93SW5kZXggPSBwYXJlbnQgPyBwYXJlbnQucm93SW5kZXggKyBwYXJlbnQuaGVpZ2h0IDogMDtcclxuICAgICAgY29sLmNvbHVtbnMgPSBfLm1hcChjb2x1bW5zLCBjID0+IGJ1aWxkQ29sdW1uKF8uZXh0ZW5kKHsgcGFyZW50OiBjb2wgfSwgYykpKTtcclxuICAgICAgY29sLnRyZWVIZWlnaHQgPSBjb2wuaGVpZ2h0O1xyXG4gICAgICBjb2wudHJlZVdpZHRoID0gMTtcclxuICAgICAgaWYgKCFfLmlzRW1wdHkoY29sLmNvbHVtbnMpKSB7XHJcbiAgICAgICAgY29sLnRyZWVIZWlnaHQgKz0gXy5jaGFpbihjb2wuY29sdW1ucylcclxuICAgICAgICAgIC5tYXAoXy5wcm9wZXJ0eSgndHJlZUhlaWdodCcpKS5tYXgoKS52YWx1ZSgpO1xyXG4gICAgICAgIGNvbC50cmVlV2lkdGggPSBfLmNoYWluKGNvbC5jb2x1bW5zKVxyXG4gICAgICAgICAgLm1hcChfLnByb3BlcnR5KCd0cmVlV2lkdGgnKSkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkudmFsdWUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmxlYWZDb2x1bW5zLnB1c2goY29sKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNvbDtcclxuICAgIH07XHJcblxyXG4gICAgLypcclxuICAgICAqIEJ1aWxkIGNvbHVtbiBoZWFkZXIgd2l0aCBERlNcclxuICAgICAqL1xyXG4gICAgY29uc3QgYnVpbGRDb2x1bW5IZWFkZXIgPSBjb2wgPT4ge1xyXG4gICAgICBpZiAoY29sLnBhcmVudCkge1xyXG4gICAgICAgIGNvbnN0IGNvbHNwYW4gPSBjb2wudHJlZVdpZHRoO1xyXG4gICAgICAgIGNvbnN0IHJvd3NwYW4gPSBfLmlzRW1wdHkoY29sLmNvbHVtbnMpID8gdGhpcy5yb290LnRyZWVIZWlnaHQgLSBjb2wucm93SW5kZXggOiBjb2wuaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBjb2wubmFtZTtcclxuICAgICAgICBjb25zdCBodG1sID0gY29sLmh0bWwgfHwgY29sLnRpdGxlIHx8IGNvbC5uYW1lO1xyXG5cclxuICAgICAgICB3aGlsZSAodGhpcy5oZWFkZXJSb3dzLmxlbmd0aCA8PSBjb2wucm93SW5kZXgpIHtcclxuICAgICAgICAgIHRoaXMuaGVhZGVyUm93cy5wdXNoKHsgY2VsbHM6IFtdLCBhdHRyaWJ1dGVzOiB7fSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBfLnVuaW9uKG5vcm1hbGl6ZUNsYXNzZXMoY29sLmhlYWRDbGFzc2VzLCBjb2wpLCBbJ2NvbHVtbi1oZWFkZXInXSk7XHJcbiAgICAgICAgaWYgKF8uaXNFbXB0eShjb2wuY29sdW1ucykpIHtcclxuICAgICAgICAgIGNsYXNzZXMucHVzaCgnY29sdW1uLWhlYWRlci1sZWFmJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XHJcbiAgICAgICAgICBjb2xzcGFuLFxyXG4gICAgICAgICAgcm93c3BhbixcclxuICAgICAgICAgICdkYXRhLW5hbWUnOiBuYW1lLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29sLmNlbGwgPSB7IGh0bWwsIG5hbWUsIGNsYXNzZXMsIGF0dHJpYnV0ZXMgfTtcclxuICAgICAgICB0aGlzLmhlYWRlclJvd3NbY29sLnJvd0luZGV4XS5jZWxscy5wdXNoKGNvbC5jZWxsKTtcclxuICAgICAgfVxyXG4gICAgICBfLmVhY2goY29sLmNvbHVtbnMsIGJ1aWxkQ29sdW1uSGVhZGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcm9vdCBjb2x1bW5cclxuICAgICAqIEB0eXBlIHtFeHRlbmRlZENvbHVtbkNvbmZpZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5yb290ID0gYnVpbGRDb2x1bW4oe1xyXG4gICAgICBuYW1lOiAnX19yb290X18nLFxyXG4gICAgICBoZWlnaHQ6IDAsXHJcbiAgICAgIGNvbHVtbnMsXHJcbiAgICB9KTtcclxuXHJcbiAgICBidWlsZENvbHVtbkhlYWRlcih0aGlzLnJvb3QpO1xyXG4gIH1cclxuXHJcbiAgY29sdW1uV2l0aE5hbWUobmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uSW5kZXhbbmFtZV07XHJcbiAgfVxyXG5cclxuICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC50cmVlSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgZ2V0IHdpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC50cmVlV2lkdGg7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2xhdGVDb2x1bW5Hcm91cChjb2x1bW5Hcm91cCkge1xyXG4gIHJldHVybiBfLm1hcChjb2x1bW5Hcm91cC5sZWFmQ29sdW1ucywgY29sID0+IHtcclxuICAgIGNvbnN0IGNvbENsYXNzZXMgPSBfLnVuaW9uKG5vcm1hbGl6ZUNsYXNzZXMoY29sLmNvbENsYXNzZXMsIGNvbCksIFtgY29sLSR7Y29sLm5hbWV9YF0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29udGVudCBvZiBhIGBDT0xgIGVsZW1lbnQgaW4gYENPTEdST1VQYC5cclxuICAgICAqIEB0eXBlZGVmIENvbENvbnRlbnRcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBjbGFzc2VzXHJcbiAgICAgKiAgICBUaGUgY2xhc3NlcyBvZiB0aGUgYENPTGAgZWxlbWVudC5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfHN0cmluZ30gd2lkdGhcclxuICAgICAqICAgIFRoZSBDU1Mgd2lkdGggZm9yIHRoZSBjb2x1bW4uXHJcbiAgICAgKi9cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsYXNzZXM6IGNvbENsYXNzZXMsXHJcbiAgICAgIHdpZHRoOiBfLmlzTnVtYmVyKGNvbC53aWR0aCkgPyBgJHtjb2wud2lkdGh9cHhgIDogY29sLndpZHRoLFxyXG4gICAgfTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc29sdmUgZ3JpZCBzdHJ1Y3R1cmUgZnJvbSBjb2x1bW5zIGNvbmZpZ3VyYXRpb24gYW5kIGJ1aWxkIHRoZVxyXG4gKiB7QGxpbmsgQ29sdW1uR3JvdXB9IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtDb250ZW50Q2hhaW5TdGF0ZX0gc3RhdGVcclxuICogICAgVGhlIGlucHV0IGNvbnRlbnQgY2hhaW4gc3RhdGUuXHJcbiAqIEByZXR1cm4ge0NvbnRlbnRDaGFpblN0YXRlfVxyXG4gKi9cclxuZnVuY3Rpb24gY29sdW1uR3JvdXBQcm9qZWN0aW9uSGFuZGxlcihzdGF0ZSkge1xyXG4gIGNvbnN0IGNvbHVtbkdyb3VwID0gbmV3IENvbHVtbkdyb3VwKHN0YXRlLmNvbHVtbnMgfHwgW10pO1xyXG4gIHJldHVybiBfLmRlZmF1bHRzKHtcclxuICAgIGNvbHVtbkdyb3VwLFxyXG4gICAgY29sczogdHJhbnNsYXRlQ29sdW1uR3JvdXAoY29sdW1uR3JvdXApLFxyXG4gIH0sIHN0YXRlKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGNvbHVtbkdyb3VwID0ge1xyXG4gIG5hbWU6ICdjb2x1bW5Hcm91cCcsXHJcbiAgaGFuZGxlcjogY29sdW1uR3JvdXBQcm9qZWN0aW9uSGFuZGxlcixcclxuICBkZWZhdWx0czoge30sXHJcbn07XHJcblxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vY29sdW1uLWdyb3VwLmpzXG4gKiovIiwidmFyIGphZGUgPSByZXF1aXJlKFwiRDpcXFxcd29ya3NwYWNlXFxcXGZvcmtcXFxccHJvamVjdGlvbi1ncmlkXFxcXG5vZGVfbW9kdWxlc1xcXFxqYWRlXFxcXGxpYlxcXFxydW50aW1lLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRlbXBsYXRlKGxvY2Fscykge1xudmFyIGJ1ZiA9IFtdO1xudmFyIGphZGVfbWl4aW5zID0ge307XG52YXIgamFkZV9pbnRlcnA7XG47dmFyIGxvY2Fsc19mb3Jfd2l0aCA9IChsb2NhbHMgfHwge30pOyhmdW5jdGlvbiAodmFsdWUpIHtcbmJ1Zi5wdXNoKFwiPHNwYW4+XCIgKyAoamFkZS5lc2NhcGUobnVsbCA9PSAoamFkZV9pbnRlcnAgPSB2YWx1ZSkgPyBcIlwiIDogamFkZV9pbnRlcnApKSArIFwiPC9zcGFuPlwiKTt9LmNhbGwodGhpcyxcInZhbHVlXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC52YWx1ZTp0eXBlb2YgdmFsdWUhPT1cInVuZGVmaW5lZFwiP3ZhbHVlOnVuZGVmaW5lZCkpOztyZXR1cm4gYnVmLmpvaW4oXCJcIik7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9qcy92bmV4dC9wcm9qZWN0aW9uL2RlZmF1bHQtY2VsbC5qYWRlXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xyXG5pbXBvcnQgeyBub3JtYWxpemVDbGFzc2VzIH0gZnJvbSAnLi9jb21tb24uanMnO1xyXG5cclxuLyoqXHJcbiAqIFRyYW5zbGF0ZSB0aGUge0BsaW5rIFJvd0NvbmZpZ30gaW50byB7QGxpbmsgUm93Q29udGVudH1cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtDb2x1bW5Hcm91cH0gb3B0aW9ucy5jb2x1bW5Hcm91cFxyXG4gKiAgICBUaGUgY29sdW1uIGdyb3VwLlxyXG4gKiBAcGFyYW0ge1Jvd0NvbmZpZ30gb3B0aW9ucy5yb3dcclxuICogICAgVGhlIHtAbGluayBSb3dDb25maWd9IHRvIHRyYW5zbGF0ZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHJvd1R5cGVcclxuICogICAgV2hpY2ggZ3JvdXAgdGhlIHJvdyBiZWxvbmdzIHRvLiBJdCBjb3VsZCBiZSAnaGVhZCcsICdib2R5JyBvciAnZm9vdCcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5S2V5XHJcbiAqICAgIFRoZSBwcmltYXJ5IGtleSBvZiB0aGUgZGF0YSBpdGVtcy5cclxuICogQHJldHVybiB7Um93Q29udGVudH1cclxuICovXHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZVJvdyh7XHJcbiAgY29sdW1uR3JvdXAsXHJcbiAgcm93LFxyXG4gIHJvd1R5cGUsXHJcbiAgcHJpbWFyeUtleSxcclxufSkge1xyXG4gIGNvbnN0IHBhdGNoID0ge307XHJcblxyXG4gIGlmIChfLmhhcyhyb3csICdodG1sJykpIHtcclxuICAgIHBhdGNoLmNlbGxzID0gW3tcclxuICAgICAgYXR0cmlidXRlczoge1xyXG4gICAgICAgIHJvd3NwYW46IDEsXHJcbiAgICAgICAgY29sc3BhbjogY29sdW1uR3JvdXAud2lkdGgsXHJcbiAgICAgIH0sXHJcbiAgICAgIGh0bWw6IHJvdy5odG1sLFxyXG4gICAgfV07XHJcbiAgfVxyXG4gIGlmIChfLmhhcyhyb3csICd2aWV3JykpIHtcclxuICAgIHBhdGNoLmNlbGxzID0gW3tcclxuICAgICAgYXR0cmlidXRlczoge1xyXG4gICAgICAgIHJvd3NwYW46IDEsXHJcbiAgICAgICAgY29sc3BhbjogY29sdW1uR3JvdXAud2lkdGgsXHJcbiAgICAgIH0sXHJcbiAgICAgIHZpZXc6IHJvdy52aWV3LFxyXG4gICAgfV07XHJcbiAgfVxyXG4gIGlmIChfLmhhcyhyb3csICdpdGVtJykpIHtcclxuICAgIHBhdGNoLmNlbGxzID0gXy5tYXAoY29sdW1uR3JvdXAubGVhZkNvbHVtbnMsIGNvbCA9PiB7XHJcbiAgICAgIGxldCBjZWxsQ2xhc3NlcztcclxuICAgICAgaWYgKHJvd1R5cGUgPT09ICdmb290Jykge1xyXG4gICAgICAgIGNlbGxDbGFzc2VzID0gbm9ybWFsaXplQ2xhc3Nlcyhjb2wuZm9vdENsYXNzZXMsIHJvdyk7XHJcbiAgICAgIH0gZWxzZSBpZiAocm93VHlwZSA9PT0gJ2JvZHknKSB7XHJcbiAgICAgICAgY2VsbENsYXNzZXMgPSBub3JtYWxpemVDbGFzc2VzKGNvbC5ib2R5Q2xhc3Nlcywgcm93KTtcclxuICAgICAgfSBlbHNlIGlmIChyb3dUeXBlID09PSAnaGVhZCcpIHtcclxuICAgICAgICBjZWxsQ2xhc3NlcyA9IG5vcm1hbGl6ZUNsYXNzZXMoY29sLmhlYWRDbGFzc2VzLCByb3cpO1xyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgb2JqZWN0IHJlcHJlc2VudHMgYSBjZWxsLlxyXG4gICAgICAgKiBAdHlwZWRlZiBDZWxsQ29udGVudFxyXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBjbGFzc2VzXHJcbiAgICAgICAqICAgIFRoZSBjbGFzc2VzIGZvciB0aGUgYFREYC9gVEhgIGVsZW1lbnRcclxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBhdHRyaWJ1dGVzXHJcbiAgICAgICAqICAgIFRoZSBIVE1MIGF0dHJpYnV0ZXMgZm9yIHRoZSBgVERgL2BUSGAgZWxlbWVudC5cclxuICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGh0bWxcclxuICAgICAgICogICAgVGhlIEhUTUwgc3RyaW5nIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgY2VsbC5cclxuICAgICAgICogQHByb3BlcnR5IHtCYWNrYm9uZS5WaWV3fSB2aWV3XHJcbiAgICAgICAqICAgIFRoZSBCYWNrYm9uZSBWaWV3IHRvIGJlIGZpbGxlZCBpbnRvIHRoZSBjZWxsLiBVbnN1cHBvcnRlZCBmb3JcclxuICAgICAgICogICAgdGhlIGJvZHkgY2VsbHMuXHJcbiAgICAgICAqL1xyXG4gICAgICBjb25zdCBjZWxsID0geyBjbGFzc2VzOiBjZWxsQ2xhc3NlcywgYXR0cmlidXRlczoge30gfTtcclxuICAgICAgY2VsbC52YWx1ZSA9IGNvbC5wcm9wZXJ0eS5nZXQocm93Lml0ZW0pO1xyXG4gICAgICBjZWxsLmh0bWwgPSBjb2wudGVtcGxhdGUoXy5waWNrKGNlbGwsICd2YWx1ZScpKTtcclxuXHJcbiAgICAgIHJldHVybiBjZWxsO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcGF0Y2guYXR0cmlidXRlcyA9IF8uZGVmYXVsdHMoe1xyXG4gICAgICAnZGF0YS1rZXknOiByb3cuaXRlbVtwcmltYXJ5S2V5XSxcclxuICAgIH0sIHJvdy5hdHRyaWJ1dGVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dGVuZHMgdGhlIHtAbGluayBSb3dDb25maWd9IHdpdGggZXh0cmEgcHJvcGVydGllc1xyXG4gICAqIEB0eXBlZGVmIFJvd0NvbnRlbnRcclxuICAgKiBAdHlwZSB7Um93Q29uZmlnfVxyXG4gICAqIEBwcm9wZXJ0eSB7Q2VsbENvbnRlbnRbXX0gY2VsbHNcclxuICAgKiAgICBUaGUgY2VsbHMgaW4gdGhlIHJvdy5cclxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLHN0cmluZz59IGF0dHJpYnV0ZXNcclxuICAgKiAgICBUaGUgSFRNTCBhdHRyaWJ1dGVzIGZvciB0aGUgYFRSYCBlbGVtZW50LlxyXG4gICAqL1xyXG4gIHJldHVybiBfLmRlZmF1bHRzKHBhdGNoLCByb3csIHsgYXR0cmlidXRlczoge30gfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaWxsIHRoZSBoZWFkUm93cywgYm9keVJvd3MgYW5kIGZvb3RSb3dzIHdpdGggY2VsbHMuXHJcbiAqIEBwYXJhbSB7Q29udGVudENoYWluU3RhdGV9IHN0YXRlXHJcbiAqICAgIEFsbCBkYXRhLCBjb25maWd1cmF0aW9ucyBhbmQgZXZlbnRzIG5lZWRlZCBpbiBncmlkIGNlbGxzLlxyXG4gKiBAcmV0dXJuIHtDb250ZW50Q2hhaW5TdGF0ZX1cclxuICovXHJcbmZ1bmN0aW9uIGNlbGxzUHJvamVjdGlvbkhhbmRsZXIoc3RhdGUpIHtcclxuICBjb25zdCBjb2x1bW5Hcm91cCA9IHN0YXRlLmNvbHVtbkdyb3VwO1xyXG4gIGNvbnN0IHByaW1hcnlLZXkgPSB0aGlzLnByaW1hcnlLZXk7XHJcblxyXG4gIGNvbnN0IGhlYWRSb3dzID0gXy5yZWR1Y2Uoc3RhdGUuaGVhZFJvd3MsIChtZW1vLCByb3cpID0+IHtcclxuICAgIGlmIChyb3cgPT09ICdjb2x1bW4taGVhZGVyLXJvd3MnKSB7XHJcbiAgICAgIHJldHVybiBtZW1vLmNvbmNhdChjb2x1bW5Hcm91cC5oZWFkZXJSb3dzKTtcclxuICAgIH1cclxuICAgIG1lbW8ucHVzaCh0cmFuc2xhdGVSb3coe1xyXG4gICAgICBjb2x1bW5Hcm91cCxcclxuICAgICAgcm93LFxyXG4gICAgICByb3dUeXBlOiAnaGVhZCcsXHJcbiAgICAgIHByaW1hcnlLZXksXHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gbWVtbztcclxuICB9LCBbXSk7XHJcblxyXG4gIGNvbnN0IGJvZHlSb3dzID0ge1xyXG4gICAgbGVuZ3RoOiBzdGF0ZS5ib2R5Um93cy5sZW5ndGgsXHJcbiAgICBzbGljZTogKGJlZ2luID0gMCwgZW5kID0gc3RhdGUuYm9keVJvd3MubGVuZ3RoKSA9PiB7XHJcbiAgICAgIHJldHVybiBzdGF0ZS5ib2R5Um93cy5zbGljZShiZWdpbiwgZW5kKVxyXG4gICAgICAgIC5tYXAocm93ID0+IHRyYW5zbGF0ZVJvdyh7XHJcbiAgICAgICAgICBjb2x1bW5Hcm91cCxcclxuICAgICAgICAgIHJvdyxcclxuICAgICAgICAgIHJvd1R5cGU6ICdib2R5JyxcclxuICAgICAgICAgIHByaW1hcnlLZXksXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICBjb25zdCBmb290Um93cyA9IF8ubWFwKHN0YXRlLmZvb3RSb3dzLCByb3cgPT4gdHJhbnNsYXRlUm93KHtcclxuICAgIGNvbHVtbkdyb3VwLFxyXG4gICAgcm93LFxyXG4gICAgcm93VHlwZTogJ2Zvb3QnLFxyXG4gICAgcHJpbWFyeUtleSxcclxuICB9KSk7XHJcblxyXG4gIHJldHVybiBfLmRlZmF1bHRzKHtcclxuICAgIGhlYWRSb3dzLFxyXG4gICAgYm9keVJvd3MsXHJcbiAgICBmb290Um93cyxcclxuICB9LCBzdGF0ZSk7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY29uc3QgY2VsbHMgPSB7XHJcbiAgbmFtZTogJ2NlbGxzJyxcclxuICBoYW5kbGVyOiBjZWxsc1Byb2plY3Rpb25IYW5kbGVyLFxyXG4gIGRlZmF1bHRzOiB7fSxcclxufTtcclxuXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvdm5leHQvcHJvamVjdGlvbi9jZWxscy5qc1xuICoqLyIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xyXG5pbXBvcnQgc29ydGFibGVIZWFkZXJUZW1wbGF0ZSBmcm9tICcuL3NvcnRhYmxlLWhlYWRlci5qYWRlJztcclxuXHJcbmNvbnN0IHJlZ2V4S2V5ID0gL1xccyooLSk/XFxzKihcXHcrKS87XHJcblxyXG4vLyBSZW9yZGVyIGNvbHVtbiBkYXRhIHJlZmVycmluZyB0byAnY29sdW1uLnNvcnRhYmxlJy5cclxuLy8gJ2NvbHVtbi5zb3J0YWJsZScgdGFrZXMgZm91ciB0eXBlcyBvZiB2YWx1ZXM6IGJvb2xlYW4sIG51bWJlciwgc3RyaW5nIGFuZCBmdW5jdGlvbi5cclxuZnVuY3Rpb24gcmVvcmRlcihlKSB7XHJcbiAgY29uc3QgbmFtZSA9IHRoaXMuJChlLnRhcmdldCkuY2xvc2VzdCgndGgnKS5hdHRyKCdkYXRhLW5hbWUnKTtcclxuICBjb25zdCBzb3J0YWJsZSA9IHRoaXMuY29sdW1uV2l0aE5hbWUobmFtZSkuc29ydGFibGU7XHJcblxyXG4gIGlmIChzb3J0YWJsZSkge1xyXG4gICAgY29uc3Qgc29ydGFibGVIZWFkZXJDdXIgPSB0aGlzLmdldCgnc29ydGFibGVIZWFkZXInKSB8fCB7fTtcclxuICAgIGxldCBkaXJlY3Rpb24gPSBzb3J0YWJsZS5kaXJlY3Rpb247XHJcblxyXG4gICAgaWYgKHNvcnRhYmxlSGVhZGVyQ3VyLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgZGlyZWN0aW9uID0gLXNvcnRhYmxlSGVhZGVyQ3VyLmRpcmVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBhdGNoKHtcclxuICAgICAgcXVlcnk6IHtcclxuICAgICAgICBvcmRlcmJ5OiBbe1xyXG4gICAgICAgICAga2V5OiBzb3J0YWJsZS5rZXksXHJcbiAgICAgICAgICBkaXJlY3Rpb24sXHJcbiAgICAgICAgfV0sXHJcbiAgICAgIH0sXHJcbiAgICAgIHNvcnRhYmxlSGVhZGVyOiB7IG5hbWUsIGRpcmVjdGlvbiB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQWRkIGNsaWNrIGV2ZW50IHRvIHNvcnRhYmxlIGNvbHVtbiBhbmQgd3JhcCBzb3J0YWJsZSBjb2x1bW4ncyBoZWFkIHdpdGggYSB0ZW1wbGF0ZVxyXG4gKiBAcGFyYW0ge0NvbnRlbnRDaGFpblN0YXRlfSBzdGF0ZVxyXG4gKiAgICBUaGUgaW5wdXQgc3RhdGUuXHJcbiAqIEBwYXJhbSB7U29ydGFibGVIZWFkZXJDb25maWd9IG9wdGlvbnNcclxuICogICAgVGhlIHNvcnRhYmxlIGhlYWRlciBjb25maWd1cmF0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIHNvcnRhYmxlSGVhZGVyUHJvamVjdGlvbkhhbmRsZXIoc3RhdGUsIHtcclxuICBuYW1lLFxyXG4gIGRpcmVjdGlvbixcclxuICB0ZW1wbGF0ZSA9IHNvcnRhYmxlSGVhZGVyVGVtcGxhdGUsXHJcbn0gPSB7fSkge1xyXG4gIC8qKlxyXG4gICAqIEB0eXBlZGVmIFNvcnRhYmxlSGVhZGVyQ29uZmlnXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxyXG4gICAqICAgIFRoZSBuYW1lIG9mIHRoZSBvcmRlcmVkIGNvbHVtbi5cclxuICAgKiBAcHJvcGVydHkge251bWJlcn0gZGlyZWN0aW9uXHJcbiAgICogICAgVGhlIG9yZGVyIGRpcmVjdGlvbi4gUG9zaXRpdmUgZm9yIGFzY2VuZGluZywgb3RoZXJ3aXNlIGRlc2NlbmRpbmcuXHJcbiAgICogQHByb3BlcnR5IHs/U29ydGFibGVIZWFkZXJUZW1wbGF0ZX0gdGVtcGxhdGVcclxuICAgKiAgICBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyIHRoZSBzb3J0YWJsZSBjb2x1bW4gaGVhZGVycy5cclxuICAgKi9cclxuICBjb25zdCBwYXRjaCA9IHt9O1xyXG4gIGNvbnN0IGxlYWZDb2x1bW5zID0gc3RhdGUuY29sdW1uR3JvdXAubGVhZkNvbHVtbnM7XHJcbiAgY29uc3QgbGVhZkNvbHVtbkluZGV4ID0gXy5yZWR1Y2UobGVhZkNvbHVtbnMsIChtZW1vLCBjb2wpID0+IHtcclxuICAgIG1lbW9bY29sLm5hbWVdID0gY29sO1xyXG4gICAgcmV0dXJuIG1lbW87XHJcbiAgfSwge30pO1xyXG5cclxuICBwYXRjaC5oZWFkUm93cyA9IF8ubWFwKHN0YXRlLmhlYWRSb3dzLCByb3cgPT4ge1xyXG4gICAgY29uc3QgY2VsbHMgPSBfLm1hcChyb3cuY2VsbHMsIGNlbGwgPT4ge1xyXG4gICAgICBjb25zdCBwYXRjaENlbGwgPSB7fTtcclxuICAgICAgY29uc3QgY29sdW1uID0gbGVhZkNvbHVtbkluZGV4W2NlbGwubmFtZV07XHJcblxyXG4gICAgICBpZiAoY29sdW1uICYmIGNvbHVtbi5zb3J0YWJsZSkge1xyXG4gICAgICAgIHBhdGNoQ2VsbC5jbGFzc2VzID0gY2VsbC5jbGFzc2VzLmNvbmNhdCgnY29sdW1uLWhlYWRlci1zb3J0YWJsZScpO1xyXG5cclxuICAgICAgICBjb25zdCBkZWNvcmF0aW9uVGVtcGxhdGUgPSBjb2x1bW4uc29ydGFibGUudGVtcGxhdGUgfHwgdGVtcGxhdGU7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjYWxsYmFjayBTb3J0YWJsZUhlYWRlclRlbXBsYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGxvY2Fsc1xyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbHMuaHRtbFxyXG4gICAgICAgICAqICAgIFRoZSBvcmlnaW5hbCBIVE1MIHN0cmluZyBmb3IgdGhlIGNvbHVtbiBoZWFkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxvY2Fscy5kaXJlY3Rpb25cclxuICAgICAgICAgKiAgICBUaGUgc29ydCBzdGF0ZS5cclxuICAgICAgICAgKiAgICAqIFBvc2l0aXZlIHZhbHVlIGZvciBhc2NlbmRpbmcuXHJcbiAgICAgICAgICogICAgKiBOZWdhdGl2ZSB2YWx1ZSBmb3IgZGVzY2VuZGluZy5cclxuICAgICAgICAgKiAgICAqIDAgZm9yIG5vdCBzb3J0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGF0Y2hDZWxsLmh0bWwgPSBkZWNvcmF0aW9uVGVtcGxhdGUoe1xyXG4gICAgICAgICAgaHRtbDogY2VsbC5odG1sLFxyXG4gICAgICAgICAgZGlyZWN0aW9uOiBjb2x1bW4ubmFtZSA9PT0gbmFtZSA/IGRpcmVjdGlvbiA6IDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBfLmRlZmF1bHRzKHBhdGNoQ2VsbCwgY2VsbCk7XHJcbiAgICB9KTsgXHJcblxyXG4gICAgcmV0dXJuIF8uZGVmYXVsdHMoeyBjZWxscyB9LCByb3cpO1xyXG4gIH0pO1xyXG5cclxuICBwYXRjaC5ldmVudHMgPSBfLmRlZmF1bHRzKHtcclxuICAgICdjbGljayB0aC5jb2x1bW4taGVhZGVyLXNvcnRhYmxlJzogcmVvcmRlcixcclxuICB9LCBzdGF0ZS5ldmVudHMpO1xyXG5cclxuICByZXR1cm4gXy5kZWZhdWx0cyhwYXRjaCwgc3RhdGUpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgc29ydGFibGVIZWFkZXIgPSB7XHJcbiAgbmFtZTogJ3NvcnRhYmxlSGVhZGVyJyxcclxuICBoYW5kbGVyOiBzb3J0YWJsZUhlYWRlclByb2plY3Rpb25IYW5kbGVyLFxyXG4gIGRlZmF1bHRzOiB7fSxcclxufTtcclxuXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvdm5leHQvcHJvamVjdGlvbi9zb3J0YWJsZS1oZWFkZXIuanNcbiAqKi8iLCJ2YXIgamFkZSA9IHJlcXVpcmUoXCJEOlxcXFx3b3Jrc3BhY2VcXFxcZm9ya1xcXFxwcm9qZWN0aW9uLWdyaWRcXFxcbm9kZV9tb2R1bGVzXFxcXGphZGVcXFxcbGliXFxcXHJ1bnRpbWUuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7XG52YXIgYnVmID0gW107XG52YXIgamFkZV9taXhpbnMgPSB7fTtcbnZhciBqYWRlX2ludGVycDtcbjt2YXIgbG9jYWxzX2Zvcl93aXRoID0gKGxvY2FscyB8fCB7fSk7KGZ1bmN0aW9uIChkaXJlY3Rpb24sIGh0bWwpIHtcbmlmICggZGlyZWN0aW9uIDwgMClcbntcbmJ1Zi5wdXNoKFwiPHNwYW4gY2xhc3M9XFxcInNvcnQtaW5kaWNhdG9yIGdseXBoaWNvbiBnbHlwaGljb24tYXJyb3ctZG93blxcXCI+PC9zcGFuPlwiKTtcbn1cbmVsc2UgaWYgKCBkaXJlY3Rpb24gPiAwKVxue1xuYnVmLnB1c2goXCI8c3BhbiBjbGFzcz1cXFwic29ydC1pbmRpY2F0b3IgZ2x5cGhpY29uIGdseXBoaWNvbi1hcnJvdy11cFxcXCI+PC9zcGFuPlwiKTtcbn1cbmJ1Zi5wdXNoKG51bGwgPT0gKGphZGVfaW50ZXJwID0gaHRtbCkgPyBcIlwiIDogamFkZV9pbnRlcnApO30uY2FsbCh0aGlzLFwiZGlyZWN0aW9uXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC5kaXJlY3Rpb246dHlwZW9mIGRpcmVjdGlvbiE9PVwidW5kZWZpbmVkXCI/ZGlyZWN0aW9uOnVuZGVmaW5lZCxcImh0bWxcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLmh0bWw6dHlwZW9mIGh0bWwhPT1cInVuZGVmaW5lZFwiP2h0bWw6dW5kZWZpbmVkKSk7O3JldHVybiBidWYuam9pbihcIlwiKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2pzL3ZuZXh0L3Byb2plY3Rpb24vc29ydGFibGUtaGVhZGVyLmphZGVcbiAqKiBtb2R1bGUgaWQgPSA5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XHJcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XHJcbmltcG9ydCBlZGl0VGVtcGxhdGUgZnJvbSAnLi4vbGF5b3V0L2VkaXRhYmxlLmphZGUnO1xyXG5pbXBvcnQgcHJvbXB0IGZyb20gJy4uLy4uL3BvcHVwLWVkaXRvci9pbmRleC5qcyc7XHJcblxyXG5mdW5jdGlvbiBkZWVwQ2xvbmUob2JqKSB7XHJcbiAgaWYgKF8uaXNBcnJheShvYmopKSB7XHJcbiAgICByZXR1cm4gXy5tYXAob2JqLCBkZWVwQ2xvbmUpO1xyXG4gIH0gZWxzZSBpZiAoXy5pc09iamVjdChvYmopKSB7XHJcbiAgICByZXR1cm4gXy5tYXBPYmplY3Qob2JqLCBkZWVwQ2xvbmUpO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlZGl0SW5Db2x1bW4oY29sdW1uKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICBjb25zdCAkdGQgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCd0ZCcpO1xyXG4gICAgY29uc3Qga2V5ID0gdGhpcy5rZXlPZkVsZW1lbnQoZS50YXJnZXQpO1xyXG4gICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbVdpdGhLZXkoa2V5KTtcclxuXHJcbiAgICBpZigkdGQuaGFzQ2xhc3MoJ2dyaWQtZWRpdGFibGUtY2VsbCcpKSB7XHJcbiAgICAgIHRoaXMudHJpZ2dlcignd2lsbEVkaXQnLCBpdGVtKTtcclxuXHJcbiAgICAgIGNvbnN0IHByb21wdFBvcyA9IHt9O1xyXG4gICAgICBjb25zdCBvZmZzZXQgPSAkdGQub2Zmc2V0KCk7XHJcbiAgICAgIGlmIChvZmZzZXQubGVmdCA+IHdpbmRvdy5pbm5lcldpZHRoICogMC45KSB7XHJcbiAgICAgICAgcHJvbXB0UG9zLnJpZ2h0ID0gZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCAtIG9mZnNldC5sZWZ0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHByb21wdFBvcy5sZWZ0ID0gb2Zmc2V0LmxlZnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByb21wdFBvcy50b3AgPSBvZmZzZXQudG9wO1xyXG5cclxuICAgICAgcHJvbXB0KHtcclxuICAgICAgICBtb2RlbDogZGVlcENsb25lKGl0ZW0pLFxyXG4gICAgICAgIHBvc2l0aW9uOiBwcm9tcHRQb3MsXHJcbiAgICAgICAgcHJvcGVydHk6IGNvbHVtbi5uYW1lLFxyXG4gICAgICAgIG9uU3VibWl0OiBtb2RlbCA9PiB7XHJcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2RpZEVkaXQnLCBfLmlzRXF1YWwobW9kZWwsIGl0ZW0pID8gbnVsbCA6IG1vZGVsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2FuY2VsOiBtb2RlbCA9PiB7XHJcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2RpZEVkaXQnLCBudWxsKTtcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY29uc3QgZWRpdGFibGUgPSB7XHJcbiAgbmFtZTogJ2VkaXRhYmxlJyxcclxuXHJcbiAgLyoqXHJcbiAgICogRW5hYmxlIGVkaXRpbmcgYW5kIHdyYXAgZWFjaCBlZGl0YWJsZSBjZWxsIHdpdGggYSB0ZW1wbGF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAgICogQHBhcmFtIHtDb2x1bW5Hcm91cH0gW3N0YXRlLmNvbHVtbkdyb3VwXSBDb2x1bW4gZ3JvdXAgaW5mb3JtYXRpb25cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YXRlLmJvZHlSb3dzXVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhdGUuYm9keVJvd3MubGVuZ3RoXSBib2R5Um93cycgbGVuZ3RoXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N0YXRlLmJvZHlSb3dzLnNsaWNlXSBHZXQgYm9keVJvd3MgZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhdGUuZXZlbnRzXSBCYWNrYm9uZSB2aWV3IGV2ZW50cyBoYW5kbGVyXHJcbiAgICogXHJcbiAgICovXHJcbiAgaGFuZGxlcihzdGF0ZSkge1xyXG4gICAgY29uc3QgbGVhZkNvbHVtbnMgPSBzdGF0ZS5jb2x1bW5Hcm91cC5sZWFmQ29sdW1ucztcclxuICAgIGNvbnN0IGljb25DbGFzc2VzID0gWydnbHlwaGljb24nLCAnZ2x5cGhpY29uLXBlbmNpbCddO1xyXG4gICAgY29uc3QgZXZlbnRzID0gXy5yZWR1Y2UobGVhZkNvbHVtbnMsIChtZW1vLCBjb2wpID0+IHtcclxuICAgICAgbWVtb1tgY2xpY2sgdGQuZ3JpZC1lZGl0YWJsZS1jZWxsLmdyaWQtY29sdW1uLSR7Y29sLm5hbWV9YF0gPSBlZGl0SW5Db2x1bW4oY29sKTtcclxuICAgICAgcmV0dXJuIG1lbW87XHJcbiAgICB9LCB7fSk7XHJcbiAgICBjb25zdCBib2R5Um93cyA9IHtcclxuICAgICAgbGVuZ3RoOiBzdGF0ZS5ib2R5Um93cy5sZW5ndGgsXHJcbiAgICAgIHNsaWNlOiAoLi4uYXJncykgPT4gc3RhdGUuYm9keVJvd3Muc2xpY2UoLi4uYXJncykubWFwKHJvdyA9PiB7XHJcbiAgICAgICAgaWYgKHJvdy50eXBlICE9PSAnZGF0YScpIHtcclxuICAgICAgICAgIHJldHVybiByb3c7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjZWxscyA9IF8ubWFwKHJvdy5jZWxscywgKGNlbGwsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBjb2wgPSBsZWFmQ29sdW1uc1tpbmRleF07XHJcblxyXG4gICAgICAgICAgaWYgKGNvbC5lZGl0YWJsZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gXy51bmlvbihjZWxsLmNsYXNzZXMsIFsnZ3JpZC1lZGl0YWJsZS1jZWxsJywgYGdyaWQtY29sdW1uLSR7Y29sLm5hbWV9YF0pO1xyXG4gICAgICAgICAgICBjb25zdCBodG1sID0gZWRpdFRlbXBsYXRlKHsgJGh0bWw6IGNlbGwuaHRtbCwgY2xhc3NlczogaWNvbkNsYXNzZXMgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfLmRlZmF1bHRzKHsgY2xhc3NlcywgaHRtbCB9LCBjZWxsKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBjZWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfLmRlZmF1bHRzKHsgY2VsbHMgfSwgcm93KTtcclxuICAgICAgfSksXHJcbiAgICB9O1xyXG5cclxuICAgIF8uZGVmYXVsdHMoZXZlbnRzLCBzdGF0ZS5ldmVudHMpO1xyXG5cclxuICAgIHJldHVybiBfLmRlZmF1bHRzKHsgZXZlbnRzLCBib2R5Um93cyB9LCBzdGF0ZSk7XHJcbiAgfSxcclxuICBkZWZhdWx0czoge30sXHJcbn07XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvdm5leHQvcHJvamVjdGlvbi9lZGl0YWJsZS5qc1xuICoqLyIsInZhciBqYWRlID0gcmVxdWlyZShcIkQ6XFxcXHdvcmtzcGFjZVxcXFxmb3JrXFxcXHByb2plY3Rpb24tZ3JpZFxcXFxub2RlX21vZHVsZXNcXFxcamFkZVxcXFxsaWJcXFxccnVudGltZS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZW1wbGF0ZShsb2NhbHMpIHtcbnZhciBidWYgPSBbXTtcbnZhciBqYWRlX21peGlucyA9IHt9O1xudmFyIGphZGVfaW50ZXJwO1xuO3ZhciBsb2NhbHNfZm9yX3dpdGggPSAobG9jYWxzIHx8IHt9KTsoZnVuY3Rpb24gKCRodG1sLCBjbGFzc2VzLCB0ZXh0KSB7XG5idWYucHVzaChcIjxkaXYgdGl0bGU9XFxcIkVkaXRcXFwiXCIgKyAoamFkZS5jbHMoWydncmlkLWVkaXQtaWNvbicsY2xhc3Nlc10sIFtudWxsLHRydWVdKSkgKyBcIj48L2Rpdj5cIiArIChudWxsID09IChqYWRlX2ludGVycCA9ICRodG1sKSA/IFwiXCIgOiBqYWRlX2ludGVycCkgKyAoamFkZS5lc2NhcGUobnVsbCA9PSAoamFkZV9pbnRlcnAgPSB0ZXh0KSA/IFwiXCIgOiBqYWRlX2ludGVycCkpKTt9LmNhbGwodGhpcyxcIiRodG1sXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC4kaHRtbDp0eXBlb2YgJGh0bWwhPT1cInVuZGVmaW5lZFwiPyRodG1sOnVuZGVmaW5lZCxcImNsYXNzZXNcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLmNsYXNzZXM6dHlwZW9mIGNsYXNzZXMhPT1cInVuZGVmaW5lZFwiP2NsYXNzZXM6dW5kZWZpbmVkLFwidGV4dFwiIGluIGxvY2Fsc19mb3Jfd2l0aD9sb2NhbHNfZm9yX3dpdGgudGV4dDp0eXBlb2YgdGV4dCE9PVwidW5kZWZpbmVkXCI/dGV4dDp1bmRlZmluZWQpKTs7cmV0dXJuIGJ1Zi5qb2luKFwiXCIpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vanMvdm5leHQvbGF5b3V0L2VkaXRhYmxlLmphZGVcbiAqKiBtb2R1bGUgaWQgPSA5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XHJcblxyXG5mdW5jdGlvbiBzZXF1ZW5jZSguLi5hcmdzKSB7XHJcbiAgY29uc3QgY2FsbGJhY2tzID0gXy5maWx0ZXIoYXJncywgXy5pc0Z1bmN0aW9uKTtcclxuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3NJbm5lcikge1xyXG4gICAgXy5lYWNoKGNhbGxiYWNrcywgY2IgPT4gY2IuYXBwbHkodGhpcywgYXJnc0lubmVyKSk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBleHRlcm5hbCBCYWNrYm9uZVZpZXdFdmVudEhhc2hcclxuICogQHNlZSB7QGxpbmsgaHR0cDovL2JhY2tib25lanMub3JnLyNWaWV3LWV2ZW50c31cclxuICovXHJcblxyXG4vKipcclxuICogTWVyZ2UgdGhlIGN1c3RvbWl6ZWQgZXZlbnRzIHdpdGggdGhlIHByb2plY3Rpb24gaW5qZWN0ZWQgZXZlbnRzLlxyXG4gKiBAcGFyYW0ge0NvbnRlbnRDaGFpblN0YXRlfSBzdGF0ZVxyXG4gKiAgICBUaGUgaW5wdXQgc3RhdGUuXHJcbiAqIEBwYXJhbSB7ZXh0ZXJuYWw6QmFja2JvbmVWaWV3RXZlbnRIYXNofSBldmVudHNPcHRpb25zIFxyXG4gKiAgICBUaGUgY3VzdG9taXplZCBldmVudHMgaW4gZm9ybSBvZiBgQmFja2JvbmUuVmlldyNldmVudHNgLlxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRzUHJvamVjdGlvbkhhbmRsZXIoc3RhdGUsIGV2ZW50c09wdGlvbnMpIHtcclxuICBjb25zdCBwYWlycyA9IF8ucGFpcnMoc3RhdGUuZXZlbnRzKS5jb25jYXQoXy5wYWlycyhldmVudHNPcHRpb25zKSk7XHJcbiAgY29uc3QgZXZlbnRzID0gXy5yZWR1Y2UocGFpcnMsIChtZW1vLCBba2V5LCBoYW5kbGVyXSkgPT4ge1xyXG4gICAgcmV0dXJuIF8uZXh0ZW5kKG1lbW8sIHtcclxuICAgICAgW2tleV06IHNlcXVlbmNlKG1lbW9ba2V5XSwgaGFuZGxlcilcclxuICAgIH0pO1xyXG4gIH0sIHt9KTtcclxuXHJcbiAgcmV0dXJuIF8uZGVmYXVsdHMoeyBldmVudHMgfSwgc3RhdGUpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZXZlbnRzID0ge1xyXG4gIG5hbWU6ICdldmVudHMnLFxyXG4gIGhhbmRsZXI6IGV2ZW50c1Byb2plY3Rpb25IYW5kbGVyLFxyXG4gIGRlZmF1bHRzOiB7fSxcclxufTtcclxuXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vLi4vanMvdm5leHQvcHJvamVjdGlvbi9ldmVudHMuanNcbiAqKi8iLCJleHBvcnQgeyBUYWJsZVZpZXcgfSBmcm9tICcuL3RhYmxlLXZpZXcnO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLy4uL2pzL3ZuZXh0L2xheW91dC9pbmRleC5qc1xuICoqLyIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xyXG5pbXBvcnQgQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnO1xyXG5pbXBvcnQgTGlzdFZpZXcgZnJvbSAnYmFja2JvbmUtdmlydHVhbGl6ZWQtbGlzdHZpZXcnO1xyXG5cclxuaW1wb3J0IHsgSGVhZGVyVmlldywgRm9vdGVyVmlldyB9IGZyb20gJy4vaGVhZGVyLWZvb3Rlci12aWV3LmpzJztcclxuXHJcbmltcG9ydCByb3dUZW1wbGF0ZSBmcm9tICcuL3Jvdy5qYWRlJztcclxuaW1wb3J0IHRhYmxlRml4ZWRUZW1wbGF0ZSBmcm9tICcuL3RhYmxlLWZpeGVkLmphZGUnO1xyXG5pbXBvcnQgdGFibGVTdGF0aWNUZW1wbGF0ZSBmcm9tICcuL3RhYmxlLXN0YXRpYy5qYWRlJztcclxuaW1wb3J0IHRhYmxlU3RpY2t5VGVtcGxhdGUgZnJvbSAnLi90YWJsZS1zdGlja3kuamFkZSc7XHJcblxyXG5pbXBvcnQgY29sdW1uR3JvdXBUZW1wbGF0ZSBmcm9tICcuL2NvbHVtbi1ncm91cC5qYWRlJztcclxuXHJcbmNvbnN0IFNUQVRFX09QVElPTlMgPSBbJ2NvbHMnLCAnaGVhZFJvd3MnLCAnYm9keVJvd3MnLCAnZm9vdFJvd3MnLCAnZXZlbnRzJ107XHJcbmNvbnN0IEhFQURFUl9UWVBFUyA9IFsnc3RhdGljJywgJ2ZpeGVkJywgJ3N0aWNreSddO1xyXG5cclxuLyoqXHJcbiAqIFRhYmxlIHZpZXcgd2l0aCB2aXJ0dWFsaXphdGlvbiBzdXBwb3J0XHJcbiAqIEBjbGFzcyBUYWJsZVZpZXdcclxuICogQGV4dGVuZHMgQmFja2JvbmUuVmlld1xyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gKiAgdGhlIGNvbnN0cnVjdG9yIG9wdGlvbnNcclxuICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMuY2xhc3Nlcz1bXV1cclxuICogIHRoZSBjbGFzc2VzIGZvciB0aGUgVEFCTEUgZWxlbWVudHMgKGNvbnRlbnQgdGFibGUgYW5kIHN0aWNreS9maXhlZCBoZWFkZXIpXHJcbiAqIEBwYXJhbSB7U2Nyb2xsaW5nQ29uZmlnfSBbb3B0aW9ucy5zY3JvbGxpbmc9e3ZpcnR1YWxpemVkOiBmYWxzZSwgaGVhZGVyOiAnc3RhdGljJ31dXHJcbiAqICB0aGUgc2Nyb2xsaW5nIHJlbGF0ZWQgY29uZmlndXJhdGlvbnNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBUYWJsZVZpZXcgZXh0ZW5kcyBCYWNrYm9uZS5WaWV3IHtcclxuICBpbml0aWFsaXplKHsgc2Nyb2xsaW5nID0ge30sIGNsYXNzZXMgPSBbXSB9KSB7XHJcbiAgICB0aGlzLl9wcm9wcyA9IHtcclxuICAgICAgc2Nyb2xsaW5nOiB0aGlzLl9ub3JtYWxpemVTY3JvbGxpbmdDb25maWcoc2Nyb2xsaW5nKSxcclxuICAgICAgY2xhc3NlcyxcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5fc3RhdGUgPSB7XHJcbiAgICAgIGNvbHM6IFtdLFxyXG4gICAgICBoZWFkUm93czogW10sXHJcbiAgICAgIGJvZHlSb3dzOiBbXSxcclxuICAgICAgZm9vdFJvd3M6IFtdLFxyXG4gICAgICBldmVudHM6IHt9LFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLl9saXN0VmlldyA9IG5ldyBMaXN0Vmlldyh7XHJcbiAgICAgIGVsOiB0aGlzLiRlbCxcclxuICAgICAgdmlydHVhbGl6ZWQ6IHRoaXMuX3Byb3BzLnNjcm9sbGluZy52aXJ0dWFsaXplZCxcclxuICAgICAgdmlld3BvcnQ6IHRoaXMuX3Byb3BzLnNjcm9sbGluZy52aWV3cG9ydCxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2hlYWRlclZpZXcgPSBuZXcgSGVhZGVyVmlldyh7IHRhYmxlVmlldzogdGhpcyB9KTtcclxuICAgIHRoaXMuX2Zvb3RlclZpZXcgPSBuZXcgRm9vdGVyVmlldyh7IHRhYmxlVmlldzogdGhpcyB9KTtcclxuXHJcbiAgICBfLmVhY2goWyd3aWxsUmVkcmF3JywgJ2RpZFJlZHJhdyddLCBldmVudCA9PiB7XHJcbiAgICAgIHRoaXMuX2xpc3RWaWV3Lm9uKGV2ZW50LCAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcihldmVudCwgLi4uYXJncyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfbm9ybWFsaXplSGVhZGVyQ29uZmlnKGNvbmZpZykge1xyXG4gICAgY29uc3QgaGVhZGVyID0ge307XHJcblxyXG4gICAgaWYgKF8uaXNTdHJpbmcoY29uZmlnKSkge1xyXG4gICAgICBoZWFkZXIudHlwZSA9IGNvbmZpZztcclxuICAgIH0gZWxzZSBpZiAoXy5pc0Z1bmN0aW9uKGNvbmZpZykgfHwgXy5pc0Zpbml0ZShjb25maWcpKSB7XHJcbiAgICAgIGhlYWRlci50eXBlID0gJ3N0aWNreSc7XHJcbiAgICAgIGhlYWRlci5vZmZzZXQgPSBjb25maWc7XHJcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoY29uZmlnKSAmJiBfLmlzU3RyaW5nKGNvbmZpZy50eXBlKSkge1xyXG4gICAgICBfLmV4dGVuZChoZWFkZXIsIF8ucGljayhjb25maWcsICd0eXBlJywgJ29mZnNldCcpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIV8uY29udGFpbnMoSEVBREVSX1RZUEVTLCBoZWFkZXIudHlwZSkpIHtcclxuICAgICAgaGVhZGVyLnR5cGUgPSAnc3RhdGljJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGVhZGVyLnR5cGUgPT09ICdzdGlja3knICYmICFfLmlzRmluaXRlKF8ucmVzdWx0KGhlYWRlciwgJ29mZnNldCcpKSkge1xyXG4gICAgICBoZWFkZXIub2Zmc2V0ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaGVhZGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGVkZWYgU2Nyb2xsaW5nQ29uZmlnXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKlxyXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdmlydHVhbGl6ZWRcclxuICAgKiAgZmxhZyBmb3IgdmlydHVhbGl6YXRpb24uXHJcbiAgICpcclxuICAgKiBAcHJvcGVydHkgeyhzdHJpbmd8SFRNTEVsZW1lbnR8alF1ZXJ5fHdpbmRvdyl9IHZpZXdwb3J0XHJcbiAgICogIHRoZSBzY3JvbGxpbmcgdmlld3BvcnQuIElmIG9taXQsIHRoZSB0YWJsZSB2aWV3IHdpbGwgYXV0byBkZXRlY3QgdGhlXHJcbiAgICogIGNsb3Nlc3QgYW5jZXN0b3Igb2YgdGhlICRlbCB3aXRoICdvdmVyZmxvd1knIHN0eWxlIGJlaW5nICdhdXRvJyBvclxyXG4gICAqICAnc2Nyb2xsJy4gVXNlIHRoZSB3aW5kb3cgdmlld3BvcnQgaWYgZm91bmQgbm9uZS5cclxuICAgKlxyXG4gICAqICBOT1RFOiB0aGUgdmlld3BvcnQgdGFrZXMgbm8gZWZmZWN0IHdoZW4gdXNpbmcgZml4ZWQgaGVhZGVyLiBUYWJsZXMgd2l0aFxyXG4gICAqICBmaXhlZCBoZWFkZXIgcmVuZGVyIGl0cyB2aWV3cG9ydCBpbnNpZGUsIGFzIHRoZSBjb250YWluZXIgb2YgdGhlIGJvZHlcclxuICAgKiAgYW5kIGZvb3Rlci5cclxuICAgKlxyXG4gICAqIEBwcm9wZXJ0eSB7KHN0cmluZ3xIZWFkZXJDb25maWcpfSBoZWFkZXJcclxuICAgKiAgdGhlIGhlYWRlciBzY3JvbGxpbmcgYmVoYXZpb3IgY29uZmlndXJhdGlvbnMuIEl0IGNhbiBiZSBhIHN0cmluZyB0b1xyXG4gICAqICBpbmRpY2F0ZSB0aGUgaGVhZGVyIHR5cGUgKGAnc3RhdGljJ2AsIGAnc3RpY2t5J2Agb3IgYCdmaXhlZCdgKS4gT3IgYW5cclxuICAgKiAgZGV0YWlsZWQgY29uZmlndXJhdGlvbiBvYmplY3QuXHJcbiAgICpcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGVkZWYgSGVhZGVyQ29uZmlnXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxyXG4gICAqIHRoZSBoZWFkZXIgdHlwZS4gSXQgY2FuIGhhdmUgdGhlIGZvbGxvd2luZyB2YWx1ZXNcclxuICAgKlxyXG4gICAqICAqIGAnc3RhdGljJ2A6IHN0YXRpYyBoZWFkZXIsIHRoZSBub3JtYWwgY2FzZSwgdGhlIGhlYWRlciBpcyByZW5kZXJlZCB0b1xyXG4gICAqICAgIHRoZSB0b3Agb2YgdGhlIGdyaWQuXHJcbiAgICogICogYCdzdGlja3knYDogc3RpY2t5IGhlYWRlciwgdGhlIGhlYWRlciB3aWxsIHN0aWNrIHRvIHRoZSB2aWV3cG9ydCB3aXRoXHJcbiAgICogICAgYSBnaXZlbiBvZmZzZXQuXHJcbiAgICogICogYCdmaXhlZCdgOiBmaXhlZCBoZWFkZXIsIHRoZSBoZWFkZXIgd2lsbCBiZSBvdXRzaWRlIHRoZSB2aWV3cG9ydC4gT25seVxyXG4gICAqICAgIHRoZSBib2R5IGFuZCBmb290ZXIgYXJlIHNjcm9sbGFibGUuXHJcbiAgICpcclxuICAgKiBAcHJvcGVydHkge251bWJlcnxmdW5jdGlvbn0gb2Zmc2V0XHJcbiAgICogc3BlY2lhbCBjb25maWd1cmF0aW9uIGZvciBzdGlja3kgaGVhZGVyIGluZGljYXRpbmcgaXRzIHBvc2l0aW9uLiBJdCdzIGNhblxyXG4gICAqIGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgbnVtYmVyLCByZXByZXNlbnRzIG51bWJlciBvZiBwaXhlbHNcclxuICAgKiBiZWxvdyB0aGUgdmlld3BvcnQgdG9wLlxyXG4gICAqL1xyXG4gIF9ub3JtYWxpemVTY3JvbGxpbmdDb25maWcoe1xyXG4gICAgdmlld3BvcnQsXHJcbiAgICB2aXJ0dWFsaXplZCA9IGZhbHNlLFxyXG4gICAgaGVhZGVyID0gJ3N0YXRpYycsXHJcbiAgfSkge1xyXG4gICAgY29uc3Qgc2Nyb2xsaW5nID0geyB2aWV3cG9ydCwgdmlydHVhbGl6ZWQgfTtcclxuXHJcbiAgICBzY3JvbGxpbmcuaGVhZGVyID0gdGhpcy5fbm9ybWFsaXplSGVhZGVyQ29uZmlnKGhlYWRlcik7XHJcblxyXG4gICAgaWYgKHNjcm9sbGluZy5oZWFkZXIudHlwZSA9PT0gJ2ZpeGVkJykge1xyXG4gICAgICBzY3JvbGxpbmcudmlld3BvcnQgPSAnLnZpZXdwb3J0JztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2Nyb2xsaW5nO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGhlYWRlclR5cGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvcHMuc2Nyb2xsaW5nLmhlYWRlci50eXBlO1xyXG4gIH1cclxuXHJcbiAgc2V0KHN0YXRlID0ge30sIGNhbGxiYWNrID0gXy5ub29wKSB7XHJcbiAgICBjb25zdCBpc1NldCA9IGtleSA9PiAhXy5pc1VuZGVmaW5lZChzdGF0ZVtrZXldKTtcclxuICAgIGNvbnN0IGxpc3RTdGF0ZSA9IHt9O1xyXG5cclxuICAgIF8uZXh0ZW5kKHRoaXMuX3N0YXRlLCBfLnBpY2soc3RhdGUsIFNUQVRFX09QVElPTlMpKTtcclxuXHJcbiAgICBpZiAoaXNTZXQoJ2JvZHlSb3dzJykpIHtcclxuICAgICAgY29uc3QgYm9keVJvd3MgPSB0aGlzLl9zdGF0ZS5ib2R5Um93cztcclxuXHJcbiAgICAgIGxpc3RTdGF0ZS5pdGVtcyA9IHtcclxuICAgICAgICBsZW5ndGg6IGJvZHlSb3dzLmxlbmd0aCxcclxuICAgICAgICBzbGljZShzdGFydCwgc3RvcCkge1xyXG4gICAgICAgICAgcmV0dXJuIF8ubWFwKGJvZHlSb3dzLnNsaWNlKHN0YXJ0LCBzdG9wKSwgcm93ID0+ICh7IHJvdyB9KSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNTZXQoJ2V2ZW50cycpKSB7XHJcbiAgICAgIGxpc3RTdGF0ZS5ldmVudHMgPSBzdGF0ZS5ldmVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcmVuZGVyQ29sdW1uR3JvdXAoKTtcclxuXHJcbiAgICBpZiAodGhpcy5faGVhZGVyVmlldykge1xyXG4gICAgICB0aGlzLl9oZWFkZXJWaWV3LnJlZHJhdygpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9mb290ZXJWaWV3KSB7XHJcbiAgICAgIHRoaXMuX2Zvb3RlclZpZXcucmVkcmF3KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fbGlzdFZpZXcuc2V0KGxpc3RTdGF0ZSwgY2FsbGJhY2spO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgX3JlbmRlckNvbHVtbkdyb3VwKCkge1xyXG4gICAgdGhpcy4kY29sZ3JvdXAgPSB0aGlzLiQoJ2NvbGdyb3VwLmNvbHVtbi1ncm91cCcpO1xyXG4gICAgdGhpcy4kY29sZ3JvdXAuaHRtbChjb2x1bW5Hcm91cFRlbXBsYXRlKHRoaXMuX3N0YXRlKSk7XHJcbiAgfVxyXG5cclxuICBfcmVuZGVySGVhZGVyKCkge1xyXG4gICAgdGhpcy5faGVhZGVyVmlldy5zZXRFbGVtZW50KHRoaXMuJCgndGhlYWQuaGVhZGVyJykpO1xyXG4gICAgdGhpcy5faGVhZGVyVmlldy5yZW5kZXIoKTtcclxuICB9XHJcblxyXG4gIF9yZW5kZXJGb290ZXIoKSB7XHJcbiAgICB0aGlzLl9mb290ZXJWaWV3LnNldEVsZW1lbnQodGhpcy4kKCd0Zm9vdC5mb290ZXInKSk7XHJcbiAgICB0aGlzLl9mb290ZXJWaWV3LnJlbmRlcigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBpcyBzaW11bGF0aW5nIGB7IHBvc2l0aW9uOiBzdGlja3kgfWAsIGJ1dCBpdCdzIHN0aWxsIGZhciBmcm9tIHBlcmZlY3QuXHJcbiAgICpcclxuICAgKiAxLiBGb3Igd2luZG93IHZpZXdwb3J0XHJcbiAgICogICAgKiBVc2UgYHsgcG9zdGlvbjogZml4ZWQgfWBcclxuICAgKiAgICAqIEFkanVzdCB0aGUgd2lkdGggYW5kIHRoZSBob3Jpem9udGFsIGxvY2F0aW9uIG9uIHRoZSBmbHlcclxuICAgKiAgICAqIFB1dCBhbiBkdW1teSBmaWxsZXIgaW50byB0aGUgY29udGVudCBmbG93IHRvIHRha2UgdGhlIHBsYWNlIG9mIGhlYWRlclxyXG4gICAqXHJcbiAgICogVGhlIGlzc3VlcyBhcmVcclxuICAgKiAgICAqIElmIHRoZSBzdWJ2aWV3cyBpbiBoZWFkZXIgY2hhbmdlcywgdGhleSBoYXZlIHRvIG5vdGlmeSB0aGUgZ3JpZFxyXG4gICAqICAgIG1hbnVhbGx5IHRvIHVwZGF0ZSB0aGUgZmlsbGVyJ3Mgc2l6ZVxyXG4gICAqICAgICogVGhlIGhlYWRlciBkb2Vzbid0IGZvbGxvdyB0aGUgdGFibGUgdGlnaHRseSBvbiBob3Jpem9udGFsIHNjcm9sbCwgYXNcclxuICAgKiAgICB0aGUgYHNjcm9sbGAgZXZlbnQgaXMgdHJpZ2dlcmVkIGFmdGVyIHJlcGFpbnQgZm9yIG1vc3QgYnJvd3NlcnNcclxuICAgKlxyXG4gICAqIDIuIEZvciBlbGVtZW50IHZpZXdwb3J0XHJcbiAgICogICAgKiBVc2UgYHsgcG9zaXRpb246IHJlbGF0aXZlIH1gXHJcbiAgICogICAgKiBBZGp1c3QgdGhlIHZlcnRpY2FsIGxvY2F0aW9uIG9uIHRoZSBmbHlcclxuICAgKlxyXG4gICAqIFRoZSBpc3N1ZXMgYXJlXHJcbiAgICogICAgKiBUaGUgaGVhZGVyIGRvZXNuJ3QgZm9sbG93IHRoZSB0YWJsZSB0aWdodGx5IG9uIHZlcnRpY2FsIHNjcm9sbCwgYXNcclxuICAgKiAgICB0aGUgYHNjcm9sbGAgZXZlbnQgaXMgdHJpZ2dlcmVkIGFmdGVyIHJlcGFpbnQgZm9yIG1vc3QgYnJvd3NlcnMuIFRoZVxyXG4gICAqICAgIHN0aWNreSBoZWFkZXIgY291bGQgYmUgdmVyeSBqdW1weSBvbiBJRSBhbmQgRWRnZS5cclxuICAgKlxyXG4gICAqIFdlIHdpc2ggYWxsIGJyb3dzZXJzIHN1cHBvcnQgYHsgcG9zaXRpb246IHN0aWNreSB9YCBpbiBhIG5vdCB0b28gZmFyXHJcbiAgICogZnV0dXJlLiBTbyB0aGF0IHdlIGNhbiBoYXZlIGEgcGVyZmVjdCBzb2x1dGlvbiB3aXRoIG5hdGl2ZSBzdXBwb3J0LlxyXG4gICAqXHJcbiAgICovXHJcbiAgX2hvb2tVcFN0aWNreUhlYWRlcihsaXN0Vmlldykge1xyXG4gICAgY29uc3Qgdmlld3BvcnQgPSBsaXN0Vmlldy52aWV3cG9ydDtcclxuICAgIGNvbnN0IGlzV2luZG93ID0gdmlld3BvcnQuJGVsLmdldCgwKSA9PT0gd2luZG93O1xyXG4gICAgY29uc3QgJHRhYmxlQ29udGFpbmVyID0gdGhpcy4kKCcudGFibGUtY29udGFpbmVyJyk7XHJcbiAgICBjb25zdCAkc3RpY2t5SGVhZGVyID0gdGhpcy4kKCcuc3RpY2t5LWhlYWRlcicpO1xyXG4gICAgY29uc3QgJHN0aWNreUhlYWRlckZpbGxlciA9IHRoaXMuJCgnLnN0aWNreS1oZWFkZXItZmlsbGVyJyk7XHJcbiAgICBjb25zdCAkdGFibGUgPSB0aGlzLiQoJy5zdGlja3ktaGVhZGVyLWZpbGxlciArIHRhYmxlJyk7XHJcbiAgICBjb25zdCB2aWV3cG9ydFNpemUgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcclxuXHJcbiAgICBjb25zdCBhZGp1c3RTdGlja3lIZWFkZXIgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy4kZWwuaXMoJzp2aXNpYmxlJykpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG1ldHJpY3NWUCA9IGxpc3RWaWV3LnZpZXdwb3J0LmdldE1ldHJpY3MoKTtcclxuICAgICAgY29uc3QgdG9wVlAgPSBtZXRyaWNzVlAub3V0ZXIudG9wO1xyXG4gICAgICBjb25zdCBvZmZzZXQgPSBfLnJlc3VsdCh0aGlzLl9wcm9wcy5zY3JvbGxpbmcuaGVhZGVyLCAnb2Zmc2V0JywgMCk7XHJcbiAgICAgIGNvbnN0IHJlY3RDb250YWluZXIgPSAgJHRhYmxlQ29udGFpbmVyLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgY29uc3QgdG9wQ3VyID0gcmVjdENvbnRhaW5lci50b3A7XHJcblxyXG4gICAgICBpZiAoaXNXaW5kb3cpIHtcclxuICAgICAgICBjb25zdCBzdGlja3kgPSB0b3BDdXIgPCB0b3BWUCArIG9mZnNldDtcclxuICAgICAgICAkc3RpY2t5SGVhZGVyRmlsbGVyLmNzcyh7XHJcbiAgICAgICAgICBkaXNwbGF5OiBzdGlja3kgPyAnYmxvY2snIDogJ25vbmUnLFxyXG4gICAgICAgICAgaGVpZ2h0OiBzdGlja3kgPyAkc3RpY2t5SGVhZGVyLmhlaWdodCgpIDogJycsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0eWxlID0ge1xyXG4gICAgICAgICAgcG9zaXRpb246IHN0aWNreSA/ICdmaXhlZCcgOiAnc3RhdGljJyxcclxuICAgICAgICAgIHRvcDogc3RpY2t5ID8gdG9wVlAgKyBvZmZzZXQgOiAnJyxcclxuICAgICAgICAgIGxlZnQ6IHN0aWNreSA/IHJlY3RDb250YWluZXIubGVmdCA6ICcnLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGRlbHRhV2lkdGggPSBNYXRoLmFicyhtZXRyaWNzVlAub3V0ZXIud2lkdGggLSB2aWV3cG9ydFNpemUud2lkdGgpO1xyXG4gICAgICAgIGNvbnN0IGRlbHRhSGVpZ2h0ID0gTWF0aC5hYnMobWV0cmljc1ZQLm91dGVyLmhlaWdodCAtIHZpZXdwb3J0U2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgIGNvbnN0IHJlc2l6ZSA9IGRlbHRhV2lkdGggPj0gMSB8fCBkZWx0YUhlaWdodCA+PSAxO1xyXG5cclxuICAgICAgICBpZiAocmVzaXplKSB7XHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHZpZXdwb3J0U2l6ZVxyXG4gICAgICAgICAgdmlld3BvcnRTaXplLndpZHRoID0gbWV0cmljc1ZQLm91dGVyLndpZHRoO1xyXG4gICAgICAgICAgdmlld3BvcnRTaXplLmhlaWdodCA9IG1ldHJpY3NWUC5vdXRlci5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgLy8gTGV0IHRoZSBjb250ZW50IHRhYmxlIGxheW91dCBmcmVlbHksIHRoZW4gc3luYyB0aGUgd2lkdGggdG8gc3RpY2t5IGhlYWRlclxyXG4gICAgICAgICAgJHN0aWNreUhlYWRlci5jc3MoeyB3aWR0aDogJ2F1dG8nIH0pO1xyXG4gICAgICAgICAgJHRhYmxlLmNzcyh7IHdpZHRoOiAnYXV0bycgfSk7XHJcbiAgICAgICAgICBjb25zdCB3aWR0aCA9ICR0YWJsZUNvbnRhaW5lci53aWR0aCgpO1xyXG4gICAgICAgICAgc3R5bGUud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICR0YWJsZS5jc3MoeyB3aWR0aCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICRzdGlja3lIZWFkZXIuY3NzKHN0eWxlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAkc3RpY2t5SGVhZGVyRmlsbGVyLmNzcyh7XHJcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZScsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJHN0aWNreUhlYWRlci5jc3Moe1xyXG4gICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICB0b3A6IE1hdGgubWluKE1hdGgubWF4KHRvcFZQICsgb2Zmc2V0IC0gdG9wQ3VyLCAwKSwgJHRhYmxlLmhlaWdodCgpKSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsaXN0Vmlldy52aWV3cG9ydC5vbigncmVzaXplJywgXy5wYXJ0aWFsKGFkanVzdFN0aWNreUhlYWRlciwgdHJ1ZSkpO1xyXG4gICAgbGlzdFZpZXcudmlld3BvcnQub24oJ3Njcm9sbCcsIF8ucGFydGlhbChhZGp1c3RTdGlja3lIZWFkZXIsIGZhbHNlKSk7XHJcbiAgICBsaXN0Vmlldy5vbignZGlkUmVkcmF3JywgXy5wYXJ0aWFsKGFkanVzdFN0aWNreUhlYWRlciwgdHJ1ZSkpO1xyXG4gIH1cclxuXHJcbiAgX3JlbmRlclN0YXRpYyhjYWxsYmFjaykge1xyXG4gICAgdGhpcy5fbGlzdFZpZXcuc2V0KHtcclxuICAgICAgbW9kZWw6IHtcclxuICAgICAgICBjbGFzc2VzOiB0aGlzLl9wcm9wcy5jbGFzc2VzLFxyXG4gICAgICB9LFxyXG4gICAgICBsaXN0VGVtcGxhdGU6IHRhYmxlU3RhdGljVGVtcGxhdGUsXHJcbiAgICAgIGl0ZW1UZW1wbGF0ZTogcm93VGVtcGxhdGUsXHJcbiAgICB9KS5yZW5kZXIoKCkgPT4ge1xyXG4gICAgICB0aGlzLl9yZW5kZXJDb2x1bW5Hcm91cCgpO1xyXG4gICAgICB0aGlzLl9yZW5kZXJIZWFkZXIoKTtcclxuICAgICAgdGhpcy5fcmVuZGVyRm9vdGVyKCk7XHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9yZW5kZXJGaXhlZChjYWxsYmFjaykge1xyXG4gICAgdGhpcy5fbGlzdFZpZXcuc2V0KHtcclxuICAgICAgbW9kZWw6IHtcclxuICAgICAgICBjbGFzc2VzOiB0aGlzLl9wcm9wcy5jbGFzc2VzLFxyXG4gICAgICB9LFxyXG4gICAgICBsaXN0VGVtcGxhdGU6IHRhYmxlRml4ZWRUZW1wbGF0ZSxcclxuICAgICAgaXRlbVRlbXBsYXRlOiByb3dUZW1wbGF0ZSxcclxuICAgIH0pLnJlbmRlcigoKSA9PiB7XHJcbiAgICAgIHRoaXMuX3JlbmRlckNvbHVtbkdyb3VwKCk7XHJcbiAgICAgIHRoaXMuX3JlbmRlckhlYWRlcigpO1xyXG4gICAgICB0aGlzLl9yZW5kZXJGb290ZXIoKTtcclxuICAgICAgY2FsbGJhY2soKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2xpc3RWaWV3Lm9uKCdkaWRSZWRyYXcnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHdpZHRoVmlld3BvcnQgPSB0aGlzLiQoJy52aWV3cG9ydCcpLmdldCgwKS5jbGllbnRXaWR0aDtcclxuICAgICAgY29uc3Qgd2lkdGhDb250YWluZXIgPSB0aGlzLmVsLmNsaWVudFdpZHRoO1xyXG4gICAgICBjb25zdCB3aWR0aFNjcm9sbGJhciA9IHdpZHRoQ29udGFpbmVyIC0gd2lkdGhWaWV3cG9ydDtcclxuICAgICAgY29uc3Qgd2lkdGhUYWJsZSA9IHRoaXMuJCgnLnZpZXdwb3J0ID4gdGFibGUnKS5nZXQoMCkub2Zmc2V0V2lkdGg7XHJcblxyXG4gICAgICB0aGlzLiRlbC53aWR0aCh3aWR0aFRhYmxlICsgd2lkdGhTY3JvbGxiYXIpO1xyXG4gICAgICB0aGlzLiQoJy5maXhlZC1oZWFkZXInKS53aWR0aCh3aWR0aFRhYmxlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX3JlbmRlclN0aWNreShjYWxsYmFjaykge1xyXG4gICAgdGhpcy5fbGlzdFZpZXcuc2V0KHtcclxuICAgICAgbW9kZWw6IHtcclxuICAgICAgICBjbGFzc2VzOiB0aGlzLl9wcm9wcy5jbGFzc2VzLFxyXG4gICAgICB9LFxyXG4gICAgICBsaXN0VGVtcGxhdGU6IHRhYmxlU3RpY2t5VGVtcGxhdGUsXHJcbiAgICAgIGl0ZW1UZW1wbGF0ZTogcm93VGVtcGxhdGUsXHJcbiAgICB9KS5yZW5kZXIoKCkgPT4ge1xyXG4gICAgICB0aGlzLl9yZW5kZXJDb2x1bW5Hcm91cCgpO1xyXG4gICAgICB0aGlzLl9yZW5kZXJIZWFkZXIoKTtcclxuICAgICAgdGhpcy5faG9va1VwU3RpY2t5SGVhZGVyKHRoaXMuX2xpc3RWaWV3KTtcclxuICAgICAgdGhpcy5fcmVuZGVyRm9vdGVyKCk7XHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJlbmRlcihjYWxsYmFjayA9IF8ubm9vcCkge1xyXG4gICAgY29uc3QgaGVhZGVyID0gdGhpcy5fcHJvcHMuc2Nyb2xsaW5nLmhlYWRlcjtcclxuXHJcbiAgICBzd2l0Y2ggKGhlYWRlci50eXBlKSB7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgIGNhc2UgJ3N0YXRpYyc6XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGljKGNhbGxiYWNrKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnZml4ZWQnOlxyXG4gICAgICAgIHRoaXMuX3JlbmRlckZpeGVkKGNhbGxiYWNrKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnc3RpY2t5JzpcclxuICAgICAgICB0aGlzLl9yZW5kZXJTdGlja3koY2FsbGJhY2spO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlKCkge1xyXG4gICAgaWYgKHRoaXMuX2hlYWRlclZpZXcpIHtcclxuICAgICAgdGhpcy5faGVhZGVyVmlldy5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbGlzdFZpZXcpIHtcclxuICAgICAgdGhpcy5fbGlzdFZpZXcucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2Zvb3RlclZpZXcpIHtcclxuICAgICAgdGhpcy5fZm9vdGVyVmlldy5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBzdXBlci5yZW1vdmUoKTtcclxuICB9XHJcblxyXG4gIHNjcm9sbFRvSXRlbSguLi5hcmdzKSB7XHJcbiAgICB0aGlzLl9saXN0Vmlldy5zY3JvbGxUb0l0ZW0oLi4uYXJncyk7XHJcbiAgfVxyXG5cclxuICBpbmRleE9mRWxlbWVudChlbCkge1xyXG4gICAgY29uc3QgJGVsVHIgPSB0aGlzLl9saXN0Vmlldy4kKGVsKS5jbG9zZXN0KCd0cicsIHRoaXMuX2xpc3RWaWV3LiRjb250YWluZXIpO1xyXG4gICAgaWYgKCRlbFRyLmxlbmd0aCA+IDApIHtcclxuICAgICAgcmV0dXJuICRlbFRyLmluZGV4KCkgKyB0aGlzLl9saXN0Vmlldy5pbmRleEZpcnN0IC0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy92bmV4dC9sYXlvdXQvdGFibGUtdmlldy5qc1xuICoqLyIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInVuZGVyc2NvcmVcIiksIHJlcXVpcmUoXCJqcXVlcnlcIiksIHJlcXVpcmUoXCJiYWNrYm9uZVwiKSwgcmVxdWlyZShcImZhc3QtYmluYXJ5LWluZGV4ZWQtdHJlZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJ1bmRlcnNjb3JlXCIsIFwianF1ZXJ5XCIsIFwiYmFja2JvbmVcIiwgXCJmYXN0LWJpbmFyeS1pbmRleGVkLXRyZWVcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiYmFja2JvbmUtdmlydHVhbGl6ZWQtbGlzdHZpZXdcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpLCByZXF1aXJlKFwianF1ZXJ5XCIpLCByZXF1aXJlKFwiYmFja2JvbmVcIiksIHJlcXVpcmUoXCJmYXN0LWJpbmFyeS1pbmRleGVkLXRyZWVcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImJhY2tib25lLXZpcnR1YWxpemVkLWxpc3R2aWV3XCJdID0gZmFjdG9yeShyb290W1widW5kZXJzY29yZVwiXSwgcm9vdFtcImpxdWVyeVwiXSwgcm9vdFtcImJhY2tib25lXCJdLCByb290W1wiZmFzdC1iaW5hcnktaW5kZXhlZC10cmVlXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNF9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHR2YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cdFxuXHR2YXIgX3VuZGVyc2NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcblx0dmFyIF91bmRlcnNjb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VuZGVyc2NvcmUpO1xuXHRcblx0dmFyIF9qcXVlcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0dmFyIF9qcXVlcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanF1ZXJ5KTtcblx0XG5cdHZhciBfYmFja2JvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcblx0dmFyIF9iYWNrYm9uZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYWNrYm9uZSk7XG5cdFxuXHR2YXIgX2Zhc3RCaW5hcnlJbmRleGVkVHJlZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHR2YXIgX2Zhc3RCaW5hcnlJbmRleGVkVHJlZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mYXN0QmluYXJ5SW5kZXhlZFRyZWUpO1xuXHRcblx0dmFyIF9kZWZhdWx0TGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFxuXHR2YXIgX2RlZmF1bHRMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmF1bHRMaXN0KTtcblx0XG5cdHZhciBfZGVmYXVsdEl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHRcblx0dmFyIF9kZWZhdWx0SXRlbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZhdWx0SXRlbSk7XG5cdFxuXHR2YXIgX3ZpZXdwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cdFxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblx0XG5cdC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGVkIGEgc2NvcGVkIHdoaWxlIGxvb3Bcblx0dmFyIHdoaWxlVHJ1ZSA9IGZ1bmN0aW9uIHdoaWxlVHJ1ZShmdW5jKSB7XG5cdCAgd2hpbGUgKGZ1bmMoKSkge31cblx0fTtcblx0XG5cdHZhciBJTlZBTElEQVRJT05fTk9ORSA9IDA7XG5cdHZhciBJTlZBTElEQVRJT05fSVRFTVMgPSAweDE7XG5cdHZhciBJTlZBTElEQVRJT05fRVZFTlRTID0gMHgyO1xuXHR2YXIgSU5WQUxJREFUSU9OX0xJU1QgPSAweDQ7XG5cdHZhciBJTlZBTElEQVRJT05fQUxMID0gMHg3O1xuXHRcblx0dmFyIExJU1RfVklFV19FVkVOVFMgPSBbJ3dpbGxSZWRyYXcnLCAnZGlkUmVkcmF3J107XG5cdFxuXHQvKipcclxuXHQgKiBUaGUgdmlydHVhbGl6ZWQgbGlzdCB2aWV3IGNsYXNzLlxyXG5cdCAqXHJcblx0ICogSW4gYWRkaXRpb24gdG8gb3JkaW5hcnkgQmFja2JvbmUgVmlldyBvcHRpb25zLCB0aGUgY29uc3RydWN0b3IgYWxzbyB0YWtlc1xyXG5cdCAqXHJcblx0ICogX192aXJ0dWFsaXplZF9fOiB3aGV0aGVyIG9yIG5vdCB0aGUgdmlydHVhbGl6YXRpb24gaXMgZW5hYmxlZC5cclxuXHQgKlxyXG5cdCAqIF9fdmlld3BvcnRfXzogdGhlIG9wdGlvbiBsb2NhdGUgdGhlIHNjcm9sbGFibGUgdmlld3BvcnQuIEl0IGNhbiBiZVxyXG5cdCAqXHJcblx0ICogICogT21pdHRlZCwgYXV0byBkZXRlY3QgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgdGhlIGAkZWxgIHdpdGggJ292ZXJmbG93WSdcclxuXHQgKiAgICBzdHlsZSBiZWluZyAnYXV0bycgb3IgJ3Njcm9sbCcuIFVzZSB0aGUgd2luZG93IHZpZXdwb3J0IGlmIGZvdW5kIG5vbmUuXHJcblx0ICogICogQSBgc3RyaW5nYCwgdXNlIGl0IGFzIGEgc2VsZWN0b3IgdG8gc2VsZWN0IGFuIF9faW50ZXJuYWxfXyBlbGVtZW50IGFzXHJcblx0ICogICAgdGhlIHZpZXdwb3J0LlxyXG5cdCAqICAqIEFuIGBIVE1MRWxlbWVudGAgb3IgYGpRdWVyeWAsIHVzZSBpdCBhcyB0aGUgdmlld3BvcnQgZWxlbWVudC5cclxuXHQgKiAgKiBUaGUgYHdpbmRvd2AsIHVzZSB0aGUgd2luZG93IHZpZXdwb3J0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIGNvbnN0cnVjdG9yIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy52aXJ0dWFsaXplZD10cnVlXVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgSFRNTEVsZW1lbnQgfCBqUXVlcnkgfCB3aW5kb3d9IFtvcHRpb25zLnZpZXdwb3J0XVxyXG5cdCAqXHJcblx0ICovXG5cdFxuXHR2YXIgTGlzdFZpZXcgPSBmdW5jdGlvbiAoX0JhY2tib25lJFZpZXcpIHtcblx0ICBfaW5oZXJpdHMoTGlzdFZpZXcsIF9CYWNrYm9uZSRWaWV3KTtcblx0XG5cdCAgZnVuY3Rpb24gTGlzdFZpZXcoKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGlzdFZpZXcpO1xuXHRcblx0ICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdFZpZXcpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKExpc3RWaWV3LCBbe1xuXHQgICAga2V5OiAnaW5pdGlhbGl6ZScsXG5cdFxuXHRcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBCYWNrYm9uZSB2aWV3IGluaXRpYWxpemVyXHJcblx0ICAgICAqIEBzZWUgTGlzdFZpZXdcclxuXHQgICAgICovXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcblx0ICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblx0XG5cdCAgICAgIHZhciBfcmVmJHZpcnR1YWxpemVkID0gX3JlZi52aXJ0dWFsaXplZDtcblx0ICAgICAgdmFyIHZpcnR1YWxpemVkID0gX3JlZiR2aXJ0dWFsaXplZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkdmlydHVhbGl6ZWQ7XG5cdCAgICAgIHZhciBfcmVmJHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydDtcblx0ICAgICAgdmFyIHZpZXdwb3J0ID0gX3JlZiR2aWV3cG9ydCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IF9yZWYkdmlld3BvcnQ7XG5cdFxuXHQgICAgICB0aGlzLl9wcm9wcyA9IHsgdmlydHVhbGl6ZWQ6IHZpcnR1YWxpemVkLCB2aWV3cG9ydDogdmlld3BvcnQgfTtcblx0ICAgICAgdGhpcy5vcHRpb25zID0ge1xuXHQgICAgICAgIG1vZGVsOiB7fSxcblx0ICAgICAgICBsaXN0VGVtcGxhdGU6IF9kZWZhdWx0TGlzdDIuZGVmYXVsdCxcblx0ICAgICAgICBldmVudHM6IHt9LFxuXHQgICAgICAgIGl0ZW1zOiBbXSxcblx0ICAgICAgICBpdGVtVGVtcGxhdGU6IF9kZWZhdWx0SXRlbTIuZGVmYXVsdCxcblx0ICAgICAgICBkZWZhdWx0SXRlbUhlaWdodDogMjBcblx0ICAgICAgfTtcblx0XG5cdCAgICAgIC8vIFN0YXRlc1xuXHQgICAgICB0aGlzLl9zdGF0ZSA9IHtcblx0ICAgICAgICBpbmRleEZpcnN0OiAwLFxuXHQgICAgICAgIGluZGV4TGFzdDogMCxcblx0ICAgICAgICBhbmNob3I6IG51bGwsXG5cdCAgICAgICAgaW52YWxpZGF0aW9uOiBJTlZBTElEQVRJT05fTk9ORSxcblx0ICAgICAgICByZW1vdmVkOiBmYWxzZSxcblx0ICAgICAgICBldmVudHNMaXN0Vmlldzoge31cblx0ICAgICAgfTtcblx0XG5cdCAgICAgIHRoaXMuX3NjaGVkdWxlUmVkcmF3ID0gX3VuZGVyc2NvcmUyLmRlZmF1bHQubm9vcDtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfaW5pdFZpZXdwb3J0Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdFZpZXdwb3J0KCkge1xuXHQgICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLl9wcm9wcy52aWV3cG9ydDtcblx0XG5cdCAgICAgIGlmIChfdW5kZXJzY29yZTIuZGVmYXVsdC5pc1N0cmluZyh2aWV3cG9ydCkpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IF92aWV3cG9ydC5FbGVtZW50Vmlld3BvcnQodGhpcy4kKHZpZXdwb3J0KSk7XG5cdCAgICAgIH0gZWxzZSBpZiAodmlld3BvcnQgaW5zdGFuY2VvZiBfanF1ZXJ5Mi5kZWZhdWx0KSB7XG5cdCAgICAgICAgaWYgKHZpZXdwb3J0LmdldCgwKSA9PT0gd2luZG93KSB7XG5cdCAgICAgICAgICByZXR1cm4gbmV3IF92aWV3cG9ydC5XaW5kb3dWaWV3cG9ydCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IF92aWV3cG9ydC5FbGVtZW50Vmlld3BvcnQodmlld3BvcnQpO1xuXHQgICAgICB9IGVsc2UgaWYgKHZpZXdwb3J0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IF92aWV3cG9ydC5FbGVtZW50Vmlld3BvcnQodmlld3BvcnQpO1xuXHQgICAgICB9IGVsc2UgaWYgKHZpZXdwb3J0ID09PSB3aW5kb3cpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IF92aWV3cG9ydC5XaW5kb3dWaWV3cG9ydCgpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgJGVsID0gdGhpcy4kZWw7XG5cdCAgICAgIHdoaWxlICgkZWwubGVuZ3RoID4gMCAmJiAhJGVsLmlzKGRvY3VtZW50KSkge1xuXHQgICAgICAgIGlmIChfdW5kZXJzY29yZTIuZGVmYXVsdC5jb250YWlucyhbJ2F1dG8nLCAnc2Nyb2xsJ10sICRlbC5jc3MoJ292ZXJmbG93WScpKSkge1xuXHQgICAgICAgICAgcmV0dXJuIG5ldyBfdmlld3BvcnQuRWxlbWVudFZpZXdwb3J0KCRlbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgICRlbCA9ICRlbC5wYXJlbnQoKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbmV3IF92aWV3cG9ydC5XaW5kb3dWaWV3cG9ydCgpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19ob29rVXBWaWV3cG9ydCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2hvb2tVcFZpZXdwb3J0KCkge1xuXHQgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblx0XG5cdCAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLl9pbml0Vmlld3BvcnQoKTtcblx0XG5cdCAgICAgIGlmICh0aGlzLnZpcnR1YWxpemVkKSB7XG5cdCAgICAgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHZhciBibG9ja1VudGlsID0gMDtcblx0XG5cdCAgICAgICAgICB2YXIgb25WaWV3cG9ydENoYW5nZSA9IGZ1bmN0aW9uIG9uVmlld3BvcnRDaGFuZ2UoKSB7XG5cdCAgICAgICAgICAgIGlmIChwZXJmb3JtYW5jZS5ub3coKSA+IGJsb2NrVW50aWwpIHtcblx0ICAgICAgICAgICAgICBfdGhpczIuX3NjaGVkdWxlUmVkcmF3KCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoIV90aGlzMi5fc3RhdGUucmVtb3ZlZCkge1xuXHQgICAgICAgICAgICAgIC8vIElmIHRoZSBzY3JvbGwgZXZlbnRzIGFyZSBibG9ja2VkLCB3ZSBzaG91bGRuJ3QganVzdCBzd2FsbG93IHRoZW0uXG5cdCAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgMC4xIHNlY29uZCBhbmQgZ2l2ZSBhbm90aGVyIHRyeS5cblx0ICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChvblZpZXdwb3J0Q2hhbmdlLCAxMDApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9O1xuXHRcblx0ICAgICAgICAgIF90aGlzMi52aWV3cG9ydC5vbignY2hhbmdlJywgb25WaWV3cG9ydENoYW5nZSk7XG5cdFxuXHQgICAgICAgICAgLy9cblx0ICAgICAgICAgIC8vIE9uIGtleXByZXNzLCB3ZSB3YW50IHRvIGJsb2NrIHRoZSBzY3JvbGwgZXZlbnRzIGZvciAwLjIgc2Vjb25kIHRvIHdhaXRcblx0ICAgICAgICAgIC8vIGZvciB0aGUgYW5pbWF0aW9uIHRvIGNvbXBsZXRlLiBPdGhlcndpc2UsIHRoZSBzY3JvbGwgd291bGQgY2hhbmdlIHRoZVxuXHQgICAgICAgICAgLy8gZ2VvbWV0cnkgbWV0cmljcyBhbmQgYnJlYWsgdGhlIGFuaW1hdGlvbi4gVGhlIHdvcnN0IHRoaW5nIHdlIG1heSBnZXQgaXMsXG5cdCAgICAgICAgICAvLyBmb3IgJ0hPTUUnIGFuZCAnRU5EJyBrZXlzLCB0aGUgdmlldyBkb2Vzbid0IHNjcm9sbCB0byB0aGUgcmlnaHQgcG9zaXRpb24uXG5cdCAgICAgICAgICAvL1xuXHQgICAgICAgICAgX3RoaXMyLnZpZXdwb3J0Lm9uKCdrZXlwcmVzcycsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgYmxvY2tVbnRpbCA9IHBlcmZvcm1hbmNlLm5vdygpICsgMjAwO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSkoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbGlzdCB2aWV3IGlzIHZpcnR1YWxpemVkXHJcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdyZW1vdmUnLFxuXHRcblx0XG5cdCAgICAvKipcclxuXHQgICAgICogUmVtb3ZlIHRoZSB2aWV3IGFuZCB1bnJlZ2lzdGVyIHRoZSBldmVudCBsaXN0ZW5lcnMuXHJcblx0ICAgICAqL1xuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0ICAgICAgdGhpcy5fc3RhdGUucmVtb3ZlZCA9IHRydWU7XG5cdCAgICAgIGlmICh0aGlzLnZpZXdwb3J0KSB7XG5cdCAgICAgICAgdGhpcy52aWV3cG9ydC5yZW1vdmUoKTtcblx0ICAgICAgfVxuXHQgICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0Vmlldy5wcm90b3R5cGUpLCAncmVtb3ZlJywgdGhpcykuY2FsbCh0aGlzKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfYXBwbHlQYWRkaW5ncycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5UGFkZGluZ3MoX3JlZjIpIHtcblx0ICAgICAgdmFyIHBhZGRpbmdUb3AgPSBfcmVmMi5wYWRkaW5nVG9wO1xuXHQgICAgICB2YXIgcGFkZGluZ0JvdHRvbSA9IF9yZWYyLnBhZGRpbmdCb3R0b207XG5cdFxuXHQgICAgICBpZiAodGhpcy4kdG9wRmlsbGVyICYmIHRoaXMuJGJvdHRvbUZpbGxlcikge1xuXHQgICAgICAgIHRoaXMuJHRvcEZpbGxlci5oZWlnaHQocGFkZGluZ1RvcCk7XG5cdCAgICAgICAgdGhpcy4kYm90dG9tRmlsbGVyLmhlaWdodChwYWRkaW5nQm90dG9tKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19wcm9jZXNzSW52YWxpZGF0aW9uJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc0ludmFsaWRhdGlvbigpIHtcblx0ICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cdFxuXHQgICAgICB2YXIgX29wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdCAgICAgIHZhciBpdGVtcyA9IF9vcHRpb25zLml0ZW1zO1xuXHQgICAgICB2YXIgZXZlbnRzID0gX29wdGlvbnMuZXZlbnRzO1xuXHQgICAgICB2YXIgbGlzdFRlbXBsYXRlID0gX29wdGlvbnMubGlzdFRlbXBsYXRlO1xuXHQgICAgICB2YXIgbW9kZWwgPSBfb3B0aW9ucy5tb2RlbDtcblx0ICAgICAgdmFyIGludmFsaWRhdGlvbiA9IHRoaXMuX3N0YXRlLmludmFsaWRhdGlvbjtcblx0XG5cdCAgICAgIHZhciBldmVudHNET00gPSBfdW5kZXJzY29yZTIuZGVmYXVsdC5vbWl0KGV2ZW50cywgTElTVF9WSUVXX0VWRU5UUyk7XG5cdCAgICAgIHZhciBldmVudHNMaXN0VmlldyA9IF91bmRlcnNjb3JlMi5kZWZhdWx0LnBpY2soZXZlbnRzLCBMSVNUX1ZJRVdfRVZFTlRTKTtcblx0XG5cdCAgICAgIGlmIChpbnZhbGlkYXRpb24gJiBJTlZBTElEQVRJT05fRVZFTlRTKSB7XG5cdCAgICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG5cdCAgICAgICAgX3VuZGVyc2NvcmUyLmRlZmF1bHQuZWFjaCh0aGlzLl9zdGF0ZS5ldmVudHNMaXN0VmlldyB8fCB7fSwgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50KSB7XG5cdCAgICAgICAgICBfdGhpczMub2ZmKGV2ZW50LCBoYW5kbGVyKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoaW52YWxpZGF0aW9uICYgSU5WQUxJREFUSU9OX0xJU1QpIHtcblx0ICAgICAgICB2YXIgaXNJbnRlcm5hbFZpZXdwb3J0ID0gX3VuZGVyc2NvcmUyLmRlZmF1bHQuaXNTdHJpbmcodGhpcy5fcHJvcHMudmlld3BvcnQpO1xuXHQgICAgICAgIGlmIChpc0ludGVybmFsVmlld3BvcnQgJiYgdGhpcy52aWV3cG9ydCkge1xuXHQgICAgICAgICAgdGhpcy52aWV3cG9ydC5yZW1vdmUoKTtcblx0ICAgICAgICAgIHRoaXMudmlld3BvcnQgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLiRlbC5odG1sKGxpc3RUZW1wbGF0ZShtb2RlbCkpO1xuXHQgICAgICAgIGlmICghdGhpcy52aWV3cG9ydCkge1xuXHQgICAgICAgICAgdGhpcy5faG9va1VwVmlld3BvcnQoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy4kdG9wRmlsbGVyID0gdGhpcy4kKCcudG9wLWZpbGxlcicpO1xuXHQgICAgICAgIHRoaXMuJGJvdHRvbUZpbGxlciA9IHRoaXMuJCgnLmJvdHRvbS1maWxsZXInKTtcblx0ICAgICAgICB0aGlzLl9hcHBseVBhZGRpbmdzKHtcblx0ICAgICAgICAgIHBhZGRpbmdUb3A6IDAsXG5cdCAgICAgICAgICBwYWRkaW5nQm90dG9tOiB0aGlzLml0ZW1IZWlnaHRzLnJlYWQoaXRlbXMubGVuZ3RoKVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIF91bmRlcnNjb3JlMi5kZWZhdWx0LmV4dGVuZCh0aGlzLl9zdGF0ZSwgeyBpbmRleEZpcnN0OiAwLCBpbmRleExhc3Q6IDAgfSk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGludmFsaWRhdGlvbiAmIElOVkFMSURBVElPTl9FVkVOVFMpIHtcblx0ICAgICAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKGV2ZW50c0RPTSk7XG5cdCAgICAgICAgX3VuZGVyc2NvcmUyLmRlZmF1bHQuZWFjaChldmVudHNMaXN0VmlldywgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50KSB7XG5cdCAgICAgICAgICBfdGhpczMub24oZXZlbnQsIGhhbmRsZXIpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmV2ZW50c0xpc3RWaWV3ID0gZXZlbnRzTGlzdFZpZXc7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGludmFsaWRhdGVJdGVtcyA9IGludmFsaWRhdGlvbiAmIElOVkFMSURBVElPTl9JVEVNUztcblx0XG5cdCAgICAgIF91bmRlcnNjb3JlMi5kZWZhdWx0LmV4dGVuZCh0aGlzLl9zdGF0ZSwgeyBpbnZhbGlkYXRpb246IElOVkFMSURBVElPTl9OT05FIH0pO1xuXHQgICAgICByZXR1cm4gaW52YWxpZGF0ZUl0ZW1zO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIFByaXZhdGUgQVBJLCByZWRyYXcgaW1tZWRpYXRlbHlcblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3JlZHJhdycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZHJhdygpIHtcblx0ICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cdFxuXHQgICAgICB2YXIgaW52YWxpZGF0ZUl0ZW1zID0gdGhpcy5fcHJvY2Vzc0ludmFsaWRhdGlvbigpO1xuXHQgICAgICB2YXIgX29wdGlvbnMyID0gdGhpcy5vcHRpb25zO1xuXHQgICAgICB2YXIgaXRlbXMgPSBfb3B0aW9uczIuaXRlbXM7XG5cdCAgICAgIHZhciBpdGVtVGVtcGxhdGUgPSBfb3B0aW9uczIuaXRlbVRlbXBsYXRlO1xuXHQgICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0O1xuXHQgICAgICB2YXIgaXRlbUhlaWdodHMgPSB0aGlzLml0ZW1IZWlnaHRzO1xuXHQgICAgICB2YXIgJHRvcEZpbGxlciA9IHRoaXMuJHRvcEZpbGxlcjtcblx0ICAgICAgdmFyICRib3R0b21GaWxsZXIgPSB0aGlzLiRib3R0b21GaWxsZXI7XG5cdCAgICAgIHZhciB2aXJ0dWFsaXplZCA9IHRoaXMudmlydHVhbGl6ZWQ7XG5cdCAgICAgIHZhciBfc3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0ICAgICAgdmFyIGluZGV4Rmlyc3QgPSBfc3RhdGUuaW5kZXhGaXJzdDtcblx0ICAgICAgdmFyIGluZGV4TGFzdCA9IF9zdGF0ZS5pbmRleExhc3Q7XG5cdCAgICAgIHZhciBhbmNob3IgPSBfc3RhdGUuYW5jaG9yO1xuXHRcblx0XG5cdCAgICAgIGlmICghaW52YWxpZGF0ZUl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgLyoqXHJcblx0ICAgICAgICogVGhlIGV2ZW50IGluZGljYXRlcyB0aGUgbGlzdCB3aWxsIHN0YXJ0IHJlZHJhdy5cclxuXHQgICAgICAgKiBAZXZlbnQgTGlzdFZpZXcjd2lsbFJlZHJhd1xyXG5cdCAgICAgICAqL1xuXHQgICAgICB0aGlzLnRyaWdnZXIoJ3dpbGxSZWRyYXcnKTtcblx0XG5cdCAgICAgIHdoaWxlVHJ1ZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGlzQ29tcGxldGVkID0gdHJ1ZTtcblx0XG5cdCAgICAgICAgdmFyIG1ldHJpY3NWaWV3cG9ydCA9IHZpZXdwb3J0LmdldE1ldHJpY3MoKTtcblx0ICAgICAgICB2YXIgdmlzaWJsZVRvcCA9IG1ldHJpY3NWaWV3cG9ydC5vdXRlci50b3A7XG5cdCAgICAgICAgdmFyIHZpc2libGVCb3QgPSBtZXRyaWNzVmlld3BvcnQub3V0ZXIuYm90dG9tO1xuXHQgICAgICAgIHZhciBsaXN0VG9wQ3VyID0gX3RoaXM0LiR0b3BGaWxsZXIuZ2V0KDApLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcblx0ICAgICAgICB2YXIgc2Nyb2xsUmF0aW8gPSBtZXRyaWNzVmlld3BvcnQuc2Nyb2xsLnJhdGlvWTtcblx0XG5cdCAgICAgICAgdmFyIHJlbmRlclRvcCA9IGZhbHNlO1xuXHQgICAgICAgIHZhciByZW5kZXJCb3QgPSBmYWxzZTtcblx0XG5cdCAgICAgICAgd2hpbGVUcnVlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHZhciBsaXN0VG9wID0gYW5jaG9yID8gYW5jaG9yLnRvcCAtIGl0ZW1IZWlnaHRzLnJlYWQoYW5jaG9yLmluZGV4KSA6IGxpc3RUb3BDdXI7XG5cdCAgICAgICAgICB2YXIgdGFyZ2V0Rmlyc3QgPSB2aXJ0dWFsaXplZCA/IGl0ZW1IZWlnaHRzLmxvd2VyQm91bmQodmlzaWJsZVRvcCAtIGxpc3RUb3ApIDogMDtcblx0ICAgICAgICAgIHZhciB0YXJnZXRMYXN0ID0gdmlydHVhbGl6ZWQgPyBNYXRoLm1pbihpdGVtSGVpZ2h0cy51cHBlckJvdW5kKHZpc2libGVCb3QgLSBsaXN0VG9wKSArIDEsIGl0ZW1zLmxlbmd0aCkgOiBpdGVtcy5sZW5ndGg7XG5cdCAgICAgICAgICB2YXIgcmVuZGVyRmlyc3QgPSBNYXRoLm1heCh0YXJnZXRGaXJzdCAtIDEwLCAwKTtcblx0ICAgICAgICAgIHZhciByZW5kZXJMYXN0ID0gTWF0aC5taW4odGFyZ2V0TGFzdCArIDEwLCBpdGVtcy5sZW5ndGgpO1xuXHRcblx0ICAgICAgICAgIHZhciByZW5kZXJNb3JlID0gZmFsc2U7XG5cdFxuXHQgICAgICAgICAgLy8gQ2xlYW4gdXBcblx0ICAgICAgICAgIGlmICh0YXJnZXRGaXJzdCA+PSBpbmRleExhc3QgfHwgdGFyZ2V0TGFzdCA8PSBpbmRleEZpcnN0IHx8IGludmFsaWRhdGVJdGVtcykge1xuXHQgICAgICAgICAgICAkdG9wRmlsbGVyLm5leHRVbnRpbCgkYm90dG9tRmlsbGVyKS5yZW1vdmUoKTtcblx0ICAgICAgICAgICAgaW5kZXhGaXJzdCA9IGluZGV4TGFzdCA9IHRhcmdldEZpcnN0O1xuXHQgICAgICAgICAgICBpZiAodGFyZ2V0Rmlyc3QgIT09IHRhcmdldExhc3QgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgIHJlbmRlck1vcmUgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghYW5jaG9yKSB7XG5cdCAgICAgICAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5yb3VuZCh0YXJnZXRGaXJzdCAqICgxIC0gc2Nyb2xsUmF0aW8pICsgdGFyZ2V0TGFzdCAqIHNjcm9sbFJhdGlvKTtcblx0ICAgICAgICAgICAgICB2YXIgdG9wID0gbGlzdFRvcEN1ciArIGl0ZW1IZWlnaHRzLnJlYWQoaW5kZXgpO1xuXHQgICAgICAgICAgICAgIGFuY2hvciA9IHsgaW5kZXg6IGluZGV4LCB0b3A6IHRvcCB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGludmFsaWRhdGVJdGVtcyA9IGZhbHNlO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICghYW5jaG9yKSB7XG5cdCAgICAgICAgICAgIHZhciBfaW5kZXggPSBNYXRoLnJvdW5kKGluZGV4Rmlyc3QgKiAoMSAtIHNjcm9sbFJhdGlvKSArIGluZGV4TGFzdCAqIHNjcm9sbFJhdGlvKTtcblx0ICAgICAgICAgICAgdmFyIF90b3AgPSBsaXN0VG9wQ3VyICsgaXRlbUhlaWdodHMucmVhZChfaW5kZXgpO1xuXHQgICAgICAgICAgICBhbmNob3IgPSB7IGluZGV4OiBfaW5kZXgsIHRvcDogX3RvcCB9O1xuXHQgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgIC8vIFJlbmRlciB0b3Bcblx0ICAgICAgICAgIGlmICh0YXJnZXRGaXJzdCA8IGluZGV4Rmlyc3QpIHtcblx0ICAgICAgICAgICAgJHRvcEZpbGxlci5hZnRlcihpdGVtcy5zbGljZShyZW5kZXJGaXJzdCwgaW5kZXhGaXJzdCkubWFwKGl0ZW1UZW1wbGF0ZSkpO1xuXHQgICAgICAgICAgICAkdG9wRmlsbGVyLm5leHRVbnRpbCgkYm90dG9tRmlsbGVyKS5zbGljZSgwLCBpbmRleEZpcnN0IC0gcmVuZGVyRmlyc3QpLmVhY2goZnVuY3Rpb24gKG9mZnNldCwgZWwpIHtcblx0ICAgICAgICAgICAgICBpdGVtSGVpZ2h0cy53cml0ZVNpbmdsZShyZW5kZXJGaXJzdCArIG9mZnNldCwgZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGluZGV4Rmlyc3QgPSByZW5kZXJGaXJzdDtcblx0ICAgICAgICAgICAgcmVuZGVyTW9yZSA9IHJlbmRlclRvcCA9IHRydWU7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKHJlbmRlckJvdCAmJiAhcmVuZGVyVG9wICYmIHJlbmRlckZpcnN0ID4gaW5kZXhGaXJzdCkge1xuXHQgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgIHZhciByZW1vdmFsID0gW107XG5cdCAgICAgICAgICAgICAgJHRvcEZpbGxlci5uZXh0VW50aWwoJGJvdHRvbUZpbGxlcikuc2xpY2UoMCwgcmVuZGVyRmlyc3QgLSBpbmRleEZpcnN0KS5lYWNoKGZ1bmN0aW9uIChvZmZzZXQsIGVsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZhbC5wdXNoKGVsKTtcblx0ICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkocmVtb3ZhbCkucmVtb3ZlKCk7XG5cdCAgICAgICAgICAgICAgaW5kZXhGaXJzdCA9IHJlbmRlckZpcnN0O1xuXHQgICAgICAgICAgICAgIHJlbmRlck1vcmUgPSB0cnVlO1xuXHQgICAgICAgICAgICB9KSgpO1xuXHQgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgIC8vIFJlbmRlciBib3R0b21cblx0ICAgICAgICAgIGlmICh0YXJnZXRMYXN0ID4gaW5kZXhMYXN0KSB7XG5cdCAgICAgICAgICAgICRib3R0b21GaWxsZXIuYmVmb3JlKGl0ZW1zLnNsaWNlKGluZGV4TGFzdCwgcmVuZGVyTGFzdCkubWFwKGl0ZW1UZW1wbGF0ZSkpO1xuXHQgICAgICAgICAgICAkdG9wRmlsbGVyLm5leHRVbnRpbCgkYm90dG9tRmlsbGVyKS5zbGljZShpbmRleExhc3QgLSBpbmRleEZpcnN0KS5lYWNoKGZ1bmN0aW9uIChvZmZzZXQsIGVsKSB7XG5cdCAgICAgICAgICAgICAgaXRlbUhlaWdodHMud3JpdGVTaW5nbGUoaW5kZXhMYXN0ICsgb2Zmc2V0LCBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgaW5kZXhMYXN0ID0gcmVuZGVyTGFzdDtcblx0ICAgICAgICAgICAgcmVuZGVyTW9yZSA9IHJlbmRlckJvdCA9IHRydWU7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKHJlbmRlclRvcCAmJiAhcmVuZGVyQm90ICYmIHJlbmRlckxhc3QgPCBpbmRleExhc3QpIHtcblx0ICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICB2YXIgcmVtb3ZhbCA9IFtdO1xuXHQgICAgICAgICAgICAgICR0b3BGaWxsZXIubmV4dFVudGlsKCRib3R0b21GaWxsZXIpLnNsaWNlKHJlbmRlckxhc3QgLSBpbmRleEZpcnN0KS5lYWNoKGZ1bmN0aW9uIChvZmZzZXQsIGVsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZhbC5wdXNoKGVsKTtcblx0ICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkocmVtb3ZhbCkucmVtb3ZlKCk7XG5cdCAgICAgICAgICAgICAgaW5kZXhMYXN0ID0gcmVuZGVyTGFzdDtcblx0ICAgICAgICAgICAgICByZW5kZXJNb3JlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfSkoKTtcblx0ICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICByZXR1cm4gcmVuZGVyTW9yZTtcblx0ICAgICAgICB9KTtcblx0XG5cdCAgICAgICAgLy8gVXBkYXRlIHRoZSBwYWRkaW5nXG5cdCAgICAgICAgaWYgKGluZGV4Rmlyc3QgIT09IF90aGlzNC5pbmRleEZpcnN0IHx8IGluZGV4TGFzdCAhPT0gX3RoaXM0LmluZGV4TGFzdCkge1xuXHQgICAgICAgICAgX3RoaXM0Ll9hcHBseVBhZGRpbmdzKHtcblx0ICAgICAgICAgICAgcGFkZGluZ1RvcDogaXRlbUhlaWdodHMucmVhZChpbmRleEZpcnN0KSxcblx0ICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogaXRlbUhlaWdodHMucmVhZChpdGVtcy5sZW5ndGgpIC0gaXRlbUhlaWdodHMucmVhZChpbmRleExhc3QpXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8vIEFkanVzdCB0aGUgc2Nyb2xsIGlmIGl0J3MgY2hhbmdlZCBzaWduaWZpY2FudGx5XG5cdCAgICAgICAgdmFyIGxpc3RUb3AgPSBhbmNob3IudG9wIC0gaXRlbUhlaWdodHMucmVhZChhbmNob3IuaW5kZXgpO1xuXHQgICAgICAgIHZhciBpbm5lclRvcCA9IGxpc3RUb3AgLSAobGlzdFRvcEN1ciAtIG1ldHJpY3NWaWV3cG9ydC5pbm5lci50b3ApO1xuXHQgICAgICAgIHZhciBzY3JvbGxUb3AgPSBNYXRoLnJvdW5kKHZpc2libGVUb3AgLSBpbm5lclRvcCk7XG5cdCAgICAgICAgdmFyIGFuY2hvck5ldyA9IG51bGw7XG5cdFxuXHQgICAgICAgIC8vIERvIGEgc2Vjb25kIHNjcm9sbCBmb3IgYSBtaWRkbGUgYW5jaG9yIGFmdGVyIHRoZSBpdGVtIGlzIHJlbmRlcmVkXG5cdCAgICAgICAgaWYgKGFuY2hvci5pc01pZGRsZSkge1xuXHQgICAgICAgICAgdmFyIGluZGV4ID0gYW5jaG9yLmluZGV4O1xuXHQgICAgICAgICAgdmFyIGl0ZW1Ub3AgPSBsaXN0VG9wQ3VyICsgX3RoaXM0Lml0ZW1IZWlnaHRzLnJlYWQoaW5kZXgpO1xuXHQgICAgICAgICAgdmFyIGl0ZW1Cb3QgPSBsaXN0VG9wQ3VyICsgX3RoaXM0Lml0ZW1IZWlnaHRzLnJlYWQoaW5kZXggKyAxKTtcblx0XG5cdCAgICAgICAgICBhbmNob3JOZXcgPSB7XG5cdCAgICAgICAgICAgIGluZGV4OiBpbmRleCxcblx0ICAgICAgICAgICAgdG9wOiAodmlzaWJsZVRvcCArIHZpc2libGVCb3QgKyBpdGVtVG9wIC0gaXRlbUJvdCkgLyAyXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgICAgaXNDb21wbGV0ZWQgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChNYXRoLmFicyhzY3JvbGxUb3AgLSB2aWV3cG9ydC5nZXRNZXRyaWNzKCkuc2Nyb2xsLnkpID49IDEpIHtcblx0ICAgICAgICAgIF90aGlzNC52aWV3cG9ydC5zY3JvbGxUbyh7IHk6IHNjcm9sbFRvcCB9KTtcblx0ICAgICAgICAgIGlzQ29tcGxldGVkID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBhbmNob3IgPSBhbmNob3JOZXc7XG5cdFxuXHQgICAgICAgIHJldHVybiAhaXNDb21wbGV0ZWQ7XG5cdCAgICAgIH0pO1xuXHRcblx0ICAgICAgLy8gV3JpdGUgYmFjayB0aGUgcmVuZGVyIHN0YXRlXG5cdCAgICAgIF91bmRlcnNjb3JlMi5kZWZhdWx0LmV4dGVuZCh0aGlzLl9zdGF0ZSwgeyBpbmRleEZpcnN0OiBpbmRleEZpcnN0LCBpbmRleExhc3Q6IGluZGV4TGFzdCwgYW5jaG9yOiBudWxsIH0pO1xuXHRcblx0ICAgICAgLyoqXHJcblx0ICAgICAgICogVGhlIGV2ZW50IGluZGljYXRlcyB0aGUgbGlzdCB2aWV3IGhhdmUgY29tcGxldGVkIHJlZHJhdy5cclxuXHQgICAgICAgKiBAZXZlbnQgTGlzdFZpZXcjZGlkUmVkcmF3XHJcblx0ICAgICAgICovXG5cdCAgICAgIHRoaXMudHJpZ2dlcignZGlkUmVkcmF3Jyk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXHJcblx0ICAgICAqIEdldCB0aGUgaXRlbSBhdCBjZXJ0YWluIGluZGV4LlxyXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBpdGVtLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdpdGVtQXQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGl0ZW1BdChpbmRleCkge1xuXHQgICAgICByZXR1cm4gX3VuZGVyc2NvcmUyLmRlZmF1bHQuZmlyc3QodGhpcy5vcHRpb25zLml0ZW1zLnNsaWNlKGluZGV4LCBpbmRleCArIDEpKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcclxuXHQgICAgICogR2V0IHRoZSByZW5kZXJlZCBET00gZWxlbWVudCBhdCBjZXJ0YWluIGluZGV4LlxyXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBpdGVtLlxyXG5cdCAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2VsZW1lbnRBdCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZWxlbWVudEF0KGluZGV4KSB7XG5cdCAgICAgIHZhciBfc3RhdGUyID0gdGhpcy5fc3RhdGU7XG5cdCAgICAgIHZhciBpbmRleEZpcnN0ID0gX3N0YXRlMi5pbmRleEZpcnN0O1xuXHQgICAgICB2YXIgaW5kZXhMYXN0ID0gX3N0YXRlMi5pbmRleExhc3Q7XG5cdFxuXHRcblx0ICAgICAgaWYgKGluZGV4IDwgaW5kZXhGaXJzdCB8fCBpbmRleCA+PSBpbmRleExhc3QgfHwgIXRoaXMuJHRvcEZpbGxlciB8fCAhdGhpcy4kYm90dG9tRmlsbGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRoaXMuJHRvcEZpbGxlci5uZXh0VW50aWwodGhpcy4kYm90dG9tRmlsbGVyKS5nZXQoaW5kZXggLSBpbmRleEZpcnN0KTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcclxuXHQgICAgICogVGhlIGluZGV4IG9mIHRoZSBmaXJzdCByZW5kZXJlZCBpdGVtLlxyXG5cdCAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnc2V0Jyxcblx0XG5cdFxuXHQgICAgLyoqXHJcblx0ICAgICAqIFNldCB0aGUgbGlzdCB2aWV3IG9wdGlvbnMuIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBjYW4gYmUgc2V0XHJcblx0ICAgICAqXHJcblx0ICAgICAqIF9fbW9kZWxfXzogVGhlIG1vZGVsIG9iamVjdCB0byByZW5kZXIgdGhlIHNrZWxldG9uIG9mIHRoZSBsaXN0IHZpZXcuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIF9fbGlzdFRlbXBsYXRlX186IFRoZSB0ZW1wbGF0ZSB0byByZW5kZXIgdGhlIHNrZWxldG9uIG9mIHRoZSBsaXN0IHZpZXcuXHJcblx0ICAgICAqXHJcblx0ICAgICAqICAqIEJ5IGRlZmF1bHQsIGl0IHdvdWxkIHJlbmRlciBhIHNpbmdsZSBgVUxgLlxyXG5cdCAgICAgKiAgKiBfX05vdGVfXzogSXQgbXVzdCBjb250YWluIHRoZSBmb2xsb3dpbmcgZWxlbWVudHMgd2l0aCBzcGVjaWZpZWQgY2xhc3NcclxuXHQgICAgICogICAgbmFtZXMgYXMgdGhlIGZpcnN0IGFuZCBsYXN0IHNpYmxpbmdzIG9mIHRoZSBsaXN0IGl0ZW1zLiBBbGwgbGlzdCBpdGVtc1xyXG5cdCAgICAgKiAgICB3aWxsIGJlIHJlbmRlcmVkIGluIGJldHdlZW4uXHJcblx0ICAgICAqICAgICogYCd0b3AtZmlsbGVyJ2A6IFRoZSBmaWxsZXIgYmxvY2sgb24gdG9wLlxyXG5cdCAgICAgKiAgICAqIGAnYm90dG9tLWZpbGxlcidgOiBUaGUgZmlsbGVyIGJsb2NrIGF0IGJvdHRvbS5cclxuXHQgICAgICpcclxuXHQgICAgICogX19ldmVudHNfXzogVGhlIGV2ZW50cyBoYXNoIGluIGZvcm0gb2YgYHsgXCJldmVudCBzZWxlY3RvclwiOiBjYWxsYmFjayB9YC5cclxuXHQgICAgICpcclxuXHQgICAgICogICogUmVmZXIgdG8ge0BsaW5rIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZy8jVmlldy1ldmVudHN8QmFja2JvbmUuVmlld35ldmVudHN9XHJcblx0ICAgICAqICAqIEluIGFkZGl0aW9uIHRvIHRoZSBET00gZXZlbnRzLCBpdCBjYW4gYWxzbyBoYW5kbGUgdGhlIGAnd2lsbFJlZHJhdydgIGFuZFxyXG5cdCAgICAgKiAgICBgJ2RpZFJlZHJhdydgIGV2ZW50cyBvZiB0aGUgbGlzdCB2aWV3LlxyXG5cdCAgICAgKiAgKiBfX05vdGVfXzogVGhlIGNhbGxiYWNrIF9fTVVTVF9fIGJlIGEgZnVuY3Rpb24uIE1lbWJlciBmdW5jdGlvbiBuYW1lcyBhcmVcclxuXHQgICAgICogICAgbm90IHN1cHBvcnRlZC5cclxuXHQgICAgICpcclxuXHQgICAgICogX19pdGVtc19fOiBUaGUgbW9kZWwgb2JqZWN0cyBvZiB0aGUgbGlzdCBpdGVtcy5cclxuXHQgICAgICpcclxuXHQgICAgICogX19pdGVtVGVtcGxhdGVfXzogVGhlIHRlbXBsYXRlIHRvIHJlbmRlciBhIGxpc3QgaXRlbS5cclxuXHQgICAgICpcclxuXHQgICAgICogICogQnkgZGVmYXVsdCwgaXQgd291bGQgcmVuZGVyIGEgc2luZ2xlIGBMSWAgZmlsbGVkIHdpdGggYGl0ZW0udGV4dGAuXHJcblx0ICAgICAqICAqIF9fTm90ZV9fOiBsaXN0IGl0ZW1zIF9fTVVTVCBOT1RfXyBoYXZlIG91dGVyIG1hcmdpbnMsIG90aGVyd2lzZSB0aGUgbGF5b3V0XHJcblx0ICAgICAqICAgIGNhbGN1bGF0aW9uIHdpbGwgYmUgaW5hY2N1cmF0ZS5cclxuXHQgICAgICpcclxuXHQgICAgICogX19kZWZhdWx0SXRlbUhlaWdodF9fOiBUaGUgZXN0aW1hdGVkIGhlaWdodCBvZiBhIHNpbmdsZSBpdGVtLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiAgKiBJdCdzIG5vdCBuZWNlc3NhcnkgdG8gYmUgYWNjdXJhdGUuIEJ1dCB0aGUgYWNjdXJhdGVyIGl0IGlzLCB0aGUgbGVzcyB0aGVcclxuXHQgICAgICogICAgc2Nyb2xsIGJhciBpcyBhZGp1c3RlZCBvdmVydGltZS5cclxuXHQgICAgICpcclxuXHQgICAgICogUmVmZXIgdG8ge0BsaW5rIExpc3RWaWV3fSBmb3IgZGV0YWlsLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgbmV3IG9wdGlvbnMuXHJcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLm1vZGVsXHJcblx0ICAgICAqIEBwYXJhbSB7TGlzdFZpZXd+Y2JMaXN0VGVtcGxhdGV9IFtvcHRpb25zLmxpc3RUZW1wbGF0ZV1cclxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZXZlbnRzXHJcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0W119IFtvcHRpb25zLml0ZW1zPVtdXVxyXG5cdCAgICAgKiBAcGFyYW0ge0xpc3RWaWV3fmNiSXRlbVRlbXBsYXRlfSBbb3B0aW9ucy5pdGVtVGVtcGxhdGVdXHJcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kZWZhdWx0SXRlbUhlaWdodD0yMF1cclxuXHQgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgdG8gbm90aWZ5IGNvbXBsZXRpb24uXHJcblx0ICAgICAqIEByZXR1cm4ge0xpc3RWaWV3fSBUaGUgbGlzdCB2aWV3IGl0c2VsZi5cclxuXHQgICAgICovXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KCkge1xuXHQgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBfdW5kZXJzY29yZTIuZGVmYXVsdC5ub29wIDogYXJndW1lbnRzWzFdO1xuXHRcblx0ICAgICAgdmFyIGlzU2V0ID0gZnVuY3Rpb24gaXNTZXQoa2V5KSB7XG5cdCAgICAgICAgcmV0dXJuICFfdW5kZXJzY29yZTIuZGVmYXVsdC5pc1VuZGVmaW5lZChvcHRpb25zW2tleV0pO1xuXHQgICAgICB9O1xuXHQgICAgICB2YXIgaXRlbUhlaWdodHNDdXIgPSB0aGlzLl9pdGVtSGVpZ2h0cztcblx0ICAgICAgdmFyIGludmFsaWRhdGlvbiA9IDA7XG5cdFxuXHQgICAgICBfdW5kZXJzY29yZTIuZGVmYXVsdC5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblx0XG5cdCAgICAgIGlmIChfdW5kZXJzY29yZTIuZGVmYXVsdC5zb21lKFsnbW9kZWwnLCAnbGlzdFRlbXBsYXRlJ10sIGlzU2V0KSkge1xuXHQgICAgICAgIGludmFsaWRhdGlvbiB8PSBJTlZBTElEQVRJT05fQUxMO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChfdW5kZXJzY29yZTIuZGVmYXVsdC5zb21lKFsnaXRlbXMnLCAnaXRlbVRlbXBsYXRlJywgJ2RlZmF1bHRJdGVtSGVpZ2h0J10sIGlzU2V0KSkge1xuXHQgICAgICAgICAgaWYgKGlzU2V0KCdkZWZhdWx0SXRlbUhlaWdodCcpIHx8IHRoaXMuaXRlbUhlaWdodHMubWF4VmFsICE9PSB0aGlzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0aGlzLl9pdGVtSGVpZ2h0cyA9IG51bGw7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpbnZhbGlkYXRpb24gfD0gSU5WQUxJREFUSU9OX0lURU1TO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaXNTZXQoJ2V2ZW50cycpKSB7XG5cdCAgICAgICAgICBpbnZhbGlkYXRpb24gfD0gSU5WQUxJREFUSU9OX0VWRU5UUztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGlmIChpbnZhbGlkYXRpb24pIHtcblx0ICAgICAgICBpZiAodGhpcy52aWV3cG9ydCAmJiB0aGlzLiR0b3BGaWxsZXIgJiYgaXRlbUhlaWdodHNDdXIpIHtcblx0ICAgICAgICAgIHZhciB2aXNpYmxlVG9wID0gdGhpcy52aWV3cG9ydC5nZXRNZXRyaWNzKCkub3V0ZXIudG9wO1xuXHQgICAgICAgICAgdmFyIGxpc3RUb3BDdXIgPSB0aGlzLiR0b3BGaWxsZXIuZ2V0KDApLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcblx0ICAgICAgICAgIHZhciB2aXNpYmxlRmlyc3QgPSBpdGVtSGVpZ2h0c0N1ci5sb3dlckJvdW5kKHZpc2libGVUb3AgLSBsaXN0VG9wQ3VyKTtcblx0XG5cdCAgICAgICAgICBpZiAodmlzaWJsZUZpcnN0IDwgdGhpcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbGVtZW50QXQodmlzaWJsZUZpcnN0KTtcblx0ICAgICAgICAgICAgaWYgKGVsKSB7XG5cdCAgICAgICAgICAgICAgdmFyIGVsVG9wID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuXHQgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLmFuY2hvciA9IHtcblx0ICAgICAgICAgICAgICAgIGluZGV4OiB2aXNpYmxlRmlyc3QsXG5cdCAgICAgICAgICAgICAgICB0b3A6IGVsVG9wXG5cdCAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdGhpcy5faW52YWxpZGF0ZShpbnZhbGlkYXRpb24sIGNhbGxiYWNrKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBjYWxsYmFjaygpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfaW52YWxpZGF0ZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2ludmFsaWRhdGUoaW52YWxpZGF0aW9uLCBjYWxsYmFjaykge1xuXHQgICAgICB0aGlzLl9zdGF0ZS5pbnZhbGlkYXRpb24gfD0gaW52YWxpZGF0aW9uO1xuXHQgICAgICB0aGlzLl9zY2hlZHVsZVJlZHJhdygpO1xuXHQgICAgICB0aGlzLm9uY2UoJ2RpZFJlZHJhdycsIGNhbGxiYWNrKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcclxuXHQgICAgICogSW52YWxpZGF0ZSB0aGUgYWxyZWFkeSByZW5kZXJlZCBpdGVtcyBhbmQgc2NoZWR1bGUgYW5vdGhlciByZWRyYXcuXHJcblx0ICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIHRvIG5vdGlmeSBjb21wbGV0aW9uLlxyXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnaW52YWxpZGF0ZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gX3VuZGVyc2NvcmUyLmRlZmF1bHQubm9vcCA6IGFyZ3VtZW50c1swXTtcblx0XG5cdCAgICAgIHRoaXMuX2ludmFsaWRhdGUoSU5WQUxJREFUSU9OX0lURU1TLCBjYWxsYmFjayk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXHJcblx0ICAgICAqIFNjcm9sbCB0byBhIGNlcnRhaW4gaXRlbS5cclxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaXRlbS5cclxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbcG9zaXRpb249J2RlZmF1bHQnXSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXHJcblx0ICAgICAqXHJcblx0ICAgICAqIFRoZSB2YWxpZCBwb3NpdGlvbnMgYXJlXHJcblx0ICAgICAqICAgKiBgJ2RlZmF1bHQnYCwgaWYgdGhlIGl0ZW0gaXMgYWJvdmUgdGhlIHZpZXdwb3J0IHRvcCwgc2Nyb2xsIGl0IHRvIHRoZVxyXG5cdCAgICAgKiAgICAgdG9wLCBpZiB0aGUgaXRlbSBpcyBiZWxvdyB0aGUgdmlld3BvcnQgYm90dG9tLCBzY3JvbGwgaXQgdG8gdGhlIGJvdHRvbSxcclxuXHQgICAgICogICAgIG90aGVyd2lzZSwga2VlcCB0aGUgdmlld3BvcnQgdW5jaGFuZ2VkLlxyXG5cdCAgICAgKiAgICogYCd0b3AnYCwgc2Nyb2xsIHRoZSBpdGVtIHRvIHRvcCBvZiB0aGUgdmlld3BvcnQuXHJcblx0ICAgICAqICAgKiBgJ21pZGRsZSdgLCBzY3JvbGwgdGhlIGl0ZW0gdG8gdGhlIHZlcnRpY2FsIGNlbnRlciBvZiB0aGUgdmlld3BvcnQuXHJcblx0ICAgICAqICAgKiBgJ2JvdHRvbSdgLCBzY3JvbGwgdGhlIGl0ZW0gdG8gdGhlIGJvdHRvbSBvZiB0aGUgdmlld3BvcnQuXHJcblx0ICAgICAqICAgKiBge251bWJlcn1gLCBzY3JvbGwgdGhlIGl0ZW0gdG8gdGhlIGdpdmVuIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCB0b3AuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIHRvIG5vdGlmeSBjb21wbGV0aW9uLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnc2Nyb2xsVG9JdGVtJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxUb0l0ZW0oKSB7XG5cdCAgICAgIGlmICghdGhpcy4kdG9wRmlsbGVyIHx8ICF0aGlzLiRib3R0b21GaWxsZXIpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzY3JvbGwgYmVmb3JlIHRoZSB2aWV3IGlzIHJlbmRlcmVkJyk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgICAgdmFyIHBvc2l0aW9uID0gJ2RlZmF1bHQnO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBfdW5kZXJzY29yZTIuZGVmYXVsdC5ub29wO1xuXHRcblx0ICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAoYXJncy5sZW5ndGggPj0gMykge1xuXHQgICAgICAgIGluZGV4ID0gYXJnc1swXTtcblx0ICAgICAgICBwb3NpdGlvbiA9IGFyZ3NbMV07XG5cdCAgICAgICAgY2FsbGJhY2sgPSBhcmdzWzJdO1xuXHQgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG5cdCAgICAgICAgaWYgKF91bmRlcnNjb3JlMi5kZWZhdWx0LmlzRnVuY3Rpb24oYXJnc1sxXSkpIHtcblx0ICAgICAgICAgIGluZGV4ID0gYXJnc1swXTtcblx0ICAgICAgICAgIGNhbGxiYWNrID0gYXJnc1sxXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaW5kZXggPSBhcmdzWzBdO1xuXHQgICAgICAgICAgcG9zaXRpb24gPSBhcmdzWzFdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgIGluZGV4ID0gYXJnc1swXTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLl9zY3JvbGxUb0l0ZW0oaW5kZXgsIHBvc2l0aW9uLCBjYWxsYmFjayk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3Njcm9sbFRvSXRlbScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3Njcm9sbFRvSXRlbShpbmRleCwgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBtZXRyaWNzVmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0LmdldE1ldHJpY3MoKTtcblx0ICAgICAgdmFyIHZpc2libGVUb3AgPSBtZXRyaWNzVmlld3BvcnQub3V0ZXIudG9wO1xuXHQgICAgICB2YXIgdmlzaWJsZUJvdCA9IG1ldHJpY3NWaWV3cG9ydC5vdXRlci5ib3R0b207XG5cdCAgICAgIHZhciBsaXN0VG9wQ3VyID0gdGhpcy4kdG9wRmlsbGVyLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG5cdCAgICAgIHZhciBpdGVtVG9wID0gbGlzdFRvcEN1ciArIHRoaXMuaXRlbUhlaWdodHMucmVhZChpbmRleCk7XG5cdCAgICAgIHZhciBpdGVtQm90ID0gbGlzdFRvcEN1ciArIHRoaXMuaXRlbUhlaWdodHMucmVhZChpbmRleCArIDEpO1xuXHQgICAgICB2YXIgcG9zID0gcG9zaXRpb247XG5cdFxuXHQgICAgICBpZiAocG9zID09PSAnZGVmYXVsdCcpIHtcblx0ICAgICAgICBpZiAoaXRlbVRvcCA8IHZpc2libGVUb3ApIHtcblx0ICAgICAgICAgIHBvcyA9ICd0b3AnO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoaXRlbUJvdCA+IHZpc2libGVCb3QpIHtcblx0ICAgICAgICAgIHBvcyA9ICdib3R0b20nO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBpZiAoX3VuZGVyc2NvcmUyLmRlZmF1bHQuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcblx0ICAgICAgICAgICAgY2FsbGJhY2soKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGlmIChwb3MgPT09ICd0b3AnKSB7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuYW5jaG9yID0ge1xuXHQgICAgICAgICAgaW5kZXg6IGluZGV4LFxuXHQgICAgICAgICAgdG9wOiB2aXNpYmxlVG9wXG5cdCAgICAgICAgfTtcblx0ICAgICAgfSBlbHNlIGlmIChwb3MgPT09ICdib3R0b20nKSB7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuYW5jaG9yID0ge1xuXHQgICAgICAgICAgaW5kZXg6IGluZGV4ICsgMSxcblx0ICAgICAgICAgIHRvcDogdmlzaWJsZUJvdFxuXHQgICAgICAgIH07XG5cdCAgICAgIH0gZWxzZSBpZiAocG9zID09PSAnbWlkZGxlJykge1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmFuY2hvciA9IHtcblx0ICAgICAgICAgIGluZGV4OiBpbmRleCxcblx0ICAgICAgICAgIHRvcDogKHZpc2libGVUb3AgKyB2aXNpYmxlQm90ICsgaXRlbVRvcCAtIGl0ZW1Cb3QpIC8gMixcblx0ICAgICAgICAgIGlzTWlkZGxlOiB0cnVlXG5cdCAgICAgICAgfTtcblx0ICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcG9zID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmFuY2hvciA9IHtcblx0ICAgICAgICAgIGluZGV4OiBpbmRleCxcblx0ICAgICAgICAgIHRvcDogdmlzaWJsZVRvcCArIHBvc1xuXHQgICAgICAgIH07XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBvc2l0aW9uJyk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHRoaXMub25jZSgnZGlkUmVkcmF3JywgY2FsbGJhY2spO1xuXHRcblx0ICAgICAgdGhpcy5fc2NoZWR1bGVSZWRyYXcoKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcclxuXHQgICAgICogUmVuZGVyIHRoZSBsaXN0IHZpZXcuXHJcblx0ICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIHRvIG5vdGlmeSBjb21wbGV0aW9uLlxyXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAncmVuZGVyJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG5cdCAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXHRcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gX3VuZGVyc2NvcmUyLmRlZmF1bHQubm9vcCA6IGFyZ3VtZW50c1swXTtcblx0XG5cdCAgICAgIHZhciByZXF1ZXN0SWQgPSBudWxsO1xuXHRcblx0ICAgICAgdGhpcy5fc2NoZWR1bGVSZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKCFyZXF1ZXN0SWQpIHtcblx0ICAgICAgICAgIHJlcXVlc3RJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXF1ZXN0SWQgPSBudWxsO1xuXHQgICAgICAgICAgICBpZiAoIV90aGlzNS5fc3RhdGUucmVtb3ZlZCkge1xuXHQgICAgICAgICAgICAgIF90aGlzNS5fcmVkcmF3KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgICAgLy8gdGhpcy5faG9va1VwVmlld3BvcnQoKTtcblx0ICAgICAgdGhpcy5faW52YWxpZGF0ZShJTlZBTElEQVRJT05fQUxMLCBjYWxsYmFjayk7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3ZpcnR1YWxpemVkJyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fcHJvcHMudmlydHVhbGl6ZWQ7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnaW5kZXhGaXJzdCcsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmluZGV4Rmlyc3Q7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXHJcblx0ICAgICAqIFRoZSBpbmRleCBhZnRlciB0aGUgbGFzdCByZW5kZXJlZCBpdGVtLlxyXG5cdCAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnaW5kZXhMYXN0Jyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuaW5kZXhMYXN0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBUaGUgdG90YWwgY291bnQgb2YgdGhlIGl0ZW1zLlxyXG5cdCAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnbGVuZ3RoJyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLml0ZW1zLmxlbmd0aDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcclxuXHQgICAgICogVGhlIG1vZGVsIG9iamVjdCB0byByZW5kZXIgdGhlIHNrZWxldG9uIG9mIHRoZSBsaXN0IHZpZXcuXHJcblx0ICAgICAqIEB0eXBlIHtPYmplY3R9XHJcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdtb2RlbCcsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tb2RlbDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcclxuXHQgICAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlciB0aGUgc2tlbGV0b24gb2YgdGhlIGxpc3Qgdmlldy5cclxuXHQgICAgICogQGNhbGxiYWNrIExpc3RWaWV3fmNiTGlzdFRlbXBsYXRlXHJcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBUaGUgbW9kZWwgb2JqZWN0IG9mIHRoZSBsaXN0IHZpZXcuXHJcblx0ICAgICAqL1xuXHRcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyIHRoZSBza2VsZXRvbiBvZiB0aGUgbGlzdCB2aWV3LlxyXG5cdCAgICAgKiBAdHlwZSB7TGlzdFZpZXd+Y2JMaXN0VGVtcGxhdGV9XHJcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdsaXN0VGVtcGxhdGUnLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGlzdFRlbXBsYXRlO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyIGEgbGlzdCBpdGVtLlxyXG5cdCAgICAgKiBAY2FsbGJhY2sgTGlzdFZpZXd+Y2JJdGVtVGVtcGxhdGVcclxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIG1vZGVsIG9iamVjdCBvZiB0aGUgaXRlbVxyXG5cdCAgICAgKi9cblx0XG5cdCAgICAvKipcclxuXHQgICAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlciBhIGxpc3QgaXRlbS5cclxuXHQgICAgICogQHR5cGUge0xpc3RWaWV3fmNiSXRlbVRlbXBsYXRlfVxyXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnaXRlbVRlbXBsYXRlJyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLml0ZW1UZW1wbGF0ZTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcclxuXHQgICAgICogVGhlIGRlZmF1bHQgbGlzdCBpdGVtIGhlaWdodC5cclxuXHQgICAgICogQHR5cGUge251bWJlcn1cclxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2RlZmF1bHRJdGVtSGVpZ2h0Jyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRlZmF1bHRJdGVtSGVpZ2h0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBAZXh0ZXJuYWwgQmluYXJ5SW5kZXhlZFRyZWVcclxuXHQgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9taWNyb3NvZnQuZ2l0aHViLmlvL2Zhc3QtYmluYXJ5LWluZGV4ZWQtdHJlZS1qcy9CaW5hcnlJbmRleGVkVHJlZS5odG1sfVxyXG5cdCAgICAgKi9cblx0XG5cdCAgICAvKipcclxuXHQgICAgICogVGhlIEJpbmFyeUluZGV4ZWRUcmVlIHRvIGdldCB0aGUgaGVpZ2h0cyBhbmQgYWNjdW11bGF0ZWQgaGVpZ2h0cyBvZiBpdGVtcy5cclxuXHQgICAgICogQHR5cGUge2V4dGVybmFsOkJpbmFyeUluZGV4ZWRUcmVlfVxyXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnaXRlbUhlaWdodHMnLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIGlmICghdGhpcy5faXRlbUhlaWdodHMpIHtcblx0ICAgICAgICB2YXIgX29wdGlvbnMzID0gdGhpcy5vcHRpb25zO1xuXHQgICAgICAgIHZhciBkZWZhdWx0SXRlbUhlaWdodCA9IF9vcHRpb25zMy5kZWZhdWx0SXRlbUhlaWdodDtcblx0ICAgICAgICB2YXIgaXRlbXMgPSBfb3B0aW9uczMuaXRlbXM7XG5cdFxuXHQgICAgICAgIHRoaXMuX2l0ZW1IZWlnaHRzID0gbmV3IF9mYXN0QmluYXJ5SW5kZXhlZFRyZWUyLmRlZmF1bHQoe1xuXHQgICAgICAgICAgZGVmYXVsdEZyZXF1ZW5jeTogTWF0aC5tYXgoZGVmYXVsdEl0ZW1IZWlnaHQsIDEpLFxuXHQgICAgICAgICAgbWF4VmFsOiBpdGVtcy5sZW5ndGhcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdGhpcy5faXRlbUhlaWdodHM7XG5cdCAgICB9XG5cdCAgfV0pO1xuXHRcblx0ICByZXR1cm4gTGlzdFZpZXc7XG5cdH0oX2JhY2tib25lMi5kZWZhdWx0LlZpZXcpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gTGlzdFZpZXc7XG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNF9fO1xuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGphZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZW1wbGF0ZShsb2NhbHMpIHtcblx0dmFyIGJ1ZiA9IFtdO1xuXHR2YXIgamFkZV9taXhpbnMgPSB7fTtcblx0dmFyIGphZGVfaW50ZXJwO1xuXHRcblx0YnVmLnB1c2goXCI8dWwgY2xhc3M9XFxcImxpc3QtY29udGFpbmVyXFxcIj48ZGl2IGNsYXNzPVxcXCJ0b3AtZmlsbGVyXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJib3R0b20tZmlsbGVyXFxcIj48L2Rpdj48L3VsPlwiKTs7cmV0dXJuIGJ1Zi5qb2luKFwiXCIpO1xuXHR9XG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogTWVyZ2UgdHdvIGF0dHJpYnV0ZSBvYmplY3RzIGdpdmluZyBwcmVjZWRlbmNlXG5cdCAqIHRvIHZhbHVlcyBpbiBvYmplY3QgYGJgLiBDbGFzc2VzIGFyZSBzcGVjaWFsLWNhc2VkXG5cdCAqIGFsbG93aW5nIGZvciBhcnJheXMgYW5kIG1lcmdpbmcvam9pbmluZyBhcHByb3ByaWF0ZWx5XG5cdCAqIHJlc3VsdGluZyBpbiBhIHN0cmluZy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGFcblx0ICogQHBhcmFtIHtPYmplY3R9IGJcblx0ICogQHJldHVybiB7T2JqZWN0fSBhXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdGV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZShhLCBiKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0ICAgIHZhciBhdHRycyA9IGFbMF07XG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgYXR0cnMgPSBtZXJnZShhdHRycywgYVtpXSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYXR0cnM7XG5cdCAgfVxuXHQgIHZhciBhYyA9IGFbJ2NsYXNzJ107XG5cdCAgdmFyIGJjID0gYlsnY2xhc3MnXTtcblx0XG5cdCAgaWYgKGFjIHx8IGJjKSB7XG5cdCAgICBhYyA9IGFjIHx8IFtdO1xuXHQgICAgYmMgPSBiYyB8fCBbXTtcblx0ICAgIGlmICghQXJyYXkuaXNBcnJheShhYykpIGFjID0gW2FjXTtcblx0ICAgIGlmICghQXJyYXkuaXNBcnJheShiYykpIGJjID0gW2JjXTtcblx0ICAgIGFbJ2NsYXNzJ10gPSBhYy5jb25jYXQoYmMpLmZpbHRlcihudWxscyk7XG5cdCAgfVxuXHRcblx0ICBmb3IgKHZhciBrZXkgaW4gYikge1xuXHQgICAgaWYgKGtleSAhPSAnY2xhc3MnKSB7XG5cdCAgICAgIGFba2V5XSA9IGJba2V5XTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIHJldHVybiBhO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEZpbHRlciBudWxsIGB2YWxgcy5cblx0ICpcblx0ICogQHBhcmFtIHsqfSB2YWxcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gbnVsbHModmFsKSB7XG5cdCAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHZhbCAhPT0gJyc7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBqb2luIGFycmF5IGFzIGNsYXNzZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gdmFsXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGV4cG9ydHMuam9pbkNsYXNzZXMgPSBqb2luQ2xhc3Nlcztcblx0ZnVuY3Rpb24gam9pbkNsYXNzZXModmFsKSB7XG5cdCAgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwubWFwKGpvaW5DbGFzc2VzKSA6XG5cdCAgICAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSA/IE9iamVjdC5rZXlzKHZhbCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHZhbFtrZXldOyB9KSA6XG5cdCAgICBbdmFsXSkuZmlsdGVyKG51bGxzKS5qb2luKCcgJyk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZW5kZXIgdGhlIGdpdmVuIGNsYXNzZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNsYXNzZXNcblx0ICogQHBhcmFtIHtBcnJheS48Qm9vbGVhbj59IGVzY2FwZWRcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0ZXhwb3J0cy5jbHMgPSBmdW5jdGlvbiBjbHMoY2xhc3NlcywgZXNjYXBlZCkge1xuXHQgIHZhciBidWYgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChlc2NhcGVkICYmIGVzY2FwZWRbaV0pIHtcblx0ICAgICAgYnVmLnB1c2goZXhwb3J0cy5lc2NhcGUoam9pbkNsYXNzZXMoW2NsYXNzZXNbaV1dKSkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYnVmLnB1c2goam9pbkNsYXNzZXMoY2xhc3Nlc1tpXSkpO1xuXHQgICAgfVxuXHQgIH1cblx0ICB2YXIgdGV4dCA9IGpvaW5DbGFzc2VzKGJ1Zik7XG5cdCAgaWYgKHRleHQubGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gJyBjbGFzcz1cIicgKyB0ZXh0ICsgJ1wiJztcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuICcnO1xuXHQgIH1cblx0fTtcblx0XG5cdFxuXHRleHBvcnRzLnN0eWxlID0gZnVuY3Rpb24gKHZhbCkge1xuXHQgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcblx0ICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWwpLm1hcChmdW5jdGlvbiAoc3R5bGUpIHtcblx0ICAgICAgcmV0dXJuIHN0eWxlICsgJzonICsgdmFsW3N0eWxlXTtcblx0ICAgIH0pLmpvaW4oJzsnKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIHZhbDtcblx0ICB9XG5cdH07XG5cdC8qKlxuXHQgKiBSZW5kZXIgdGhlIGdpdmVuIGF0dHJpYnV0ZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGtleVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZXNjYXBlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHRlcnNlXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGV4cG9ydHMuYXR0ciA9IGZ1bmN0aW9uIGF0dHIoa2V5LCB2YWwsIGVzY2FwZWQsIHRlcnNlKSB7XG5cdCAgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuXHQgICAgdmFsID0gZXhwb3J0cy5zdHlsZSh2YWwpO1xuXHQgIH1cblx0ICBpZiAoJ2Jvb2xlYW4nID09IHR5cGVvZiB2YWwgfHwgbnVsbCA9PSB2YWwpIHtcblx0ICAgIGlmICh2YWwpIHtcblx0ICAgICAgcmV0dXJuICcgJyArICh0ZXJzZSA/IGtleSA6IGtleSArICc9XCInICsga2V5ICsgJ1wiJyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gJyc7XG5cdCAgICB9XG5cdCAgfSBlbHNlIGlmICgwID09IGtleS5pbmRleE9mKCdkYXRhJykgJiYgJ3N0cmluZycgIT0gdHlwZW9mIHZhbCkge1xuXHQgICAgaWYgKEpTT04uc3RyaW5naWZ5KHZhbCkuaW5kZXhPZignJicpICE9PSAtMSkge1xuXHQgICAgICBjb25zb2xlLndhcm4oJ1NpbmNlIEphZGUgMi4wLjAsIGFtcGVyc2FuZHMgKGAmYCkgaW4gZGF0YSBhdHRyaWJ1dGVzICcgK1xuXHQgICAgICAgICAgICAgICAgICAgJ3dpbGwgYmUgZXNjYXBlZCB0byBgJmFtcDtgJyk7XG5cdCAgICB9O1xuXHQgICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsLnRvSVNPU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGNvbnNvbGUud2FybignSmFkZSB3aWxsIGVsaW1pbmF0ZSB0aGUgZG91YmxlIHF1b3RlcyBhcm91bmQgZGF0ZXMgaW4gJyArXG5cdCAgICAgICAgICAgICAgICAgICAnSVNPIGZvcm0gYWZ0ZXIgMi4wLjAnKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiAnICcgKyBrZXkgKyBcIj0nXCIgKyBKU09OLnN0cmluZ2lmeSh2YWwpLnJlcGxhY2UoLycvZywgJyZhcG9zOycpICsgXCInXCI7XG5cdCAgfSBlbHNlIGlmIChlc2NhcGVkKSB7XG5cdCAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwudG9JU09TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgY29uc29sZS53YXJuKCdKYWRlIHdpbGwgc3RyaW5naWZ5IGRhdGVzIGluIElTTyBmb3JtIGFmdGVyIDIuMC4wJyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gJyAnICsga2V5ICsgJz1cIicgKyBleHBvcnRzLmVzY2FwZSh2YWwpICsgJ1wiJztcblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsLnRvSVNPU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGNvbnNvbGUud2FybignSmFkZSB3aWxsIHN0cmluZ2lmeSBkYXRlcyBpbiBJU08gZm9ybSBhZnRlciAyLjAuMCcpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuICcgJyArIGtleSArICc9XCInICsgdmFsICsgJ1wiJztcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmVuZGVyIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXNjYXBlZFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRleHBvcnRzLmF0dHJzID0gZnVuY3Rpb24gYXR0cnMob2JqLCB0ZXJzZSl7XG5cdCAgdmFyIGJ1ZiA9IFtdO1xuXHRcblx0ICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFxuXHQgIGlmIChrZXlzLmxlbmd0aCkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG5cdCAgICAgICAgLCB2YWwgPSBvYmpba2V5XTtcblx0XG5cdCAgICAgIGlmICgnY2xhc3MnID09IGtleSkge1xuXHQgICAgICAgIGlmICh2YWwgPSBqb2luQ2xhc3Nlcyh2YWwpKSB7XG5cdCAgICAgICAgICBidWYucHVzaCgnICcgKyBrZXkgKyAnPVwiJyArIHZhbCArICdcIicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBidWYucHVzaChleHBvcnRzLmF0dHIoa2V5LCB2YWwsIGZhbHNlLCB0ZXJzZSkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gYnVmLmpvaW4oJycpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEVzY2FwZSB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGBodG1sYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHR2YXIgamFkZV9lbmNvZGVfaHRtbF9ydWxlcyA9IHtcblx0ICAnJic6ICcmYW1wOycsXG5cdCAgJzwnOiAnJmx0OycsXG5cdCAgJz4nOiAnJmd0OycsXG5cdCAgJ1wiJzogJyZxdW90Oydcblx0fTtcblx0dmFyIGphZGVfbWF0Y2hfaHRtbCA9IC9bJjw+XCJdL2c7XG5cdFxuXHRmdW5jdGlvbiBqYWRlX2VuY29kZV9jaGFyKGMpIHtcblx0ICByZXR1cm4gamFkZV9lbmNvZGVfaHRtbF9ydWxlc1tjXSB8fCBjO1xuXHR9XG5cdFxuXHRleHBvcnRzLmVzY2FwZSA9IGphZGVfZXNjYXBlO1xuXHRmdW5jdGlvbiBqYWRlX2VzY2FwZShodG1sKXtcblx0ICB2YXIgcmVzdWx0ID0gU3RyaW5nKGh0bWwpLnJlcGxhY2UoamFkZV9tYXRjaF9odG1sLCBqYWRlX2VuY29kZV9jaGFyKTtcblx0ICBpZiAocmVzdWx0ID09PSAnJyArIGh0bWwpIHJldHVybiBodG1sO1xuXHQgIGVsc2UgcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZS10aHJvdyB0aGUgZ2l2ZW4gYGVycmAgaW4gY29udGV4dCB0byB0aGVcblx0ICogdGhlIGphZGUgaW4gYGZpbGVuYW1lYCBhdCB0aGUgZ2l2ZW4gYGxpbmVub2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXJyb3J9IGVyclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxpbmVub1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRleHBvcnRzLnJldGhyb3cgPSBmdW5jdGlvbiByZXRocm93KGVyciwgZmlsZW5hbWUsIGxpbmVubywgc3RyKXtcblx0ICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHRocm93IGVycjtcblx0ICBpZiAoKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgfHwgIWZpbGVuYW1lKSAmJiAhc3RyKSB7XG5cdCAgICBlcnIubWVzc2FnZSArPSAnIG9uIGxpbmUgJyArIGxpbmVubztcblx0ICAgIHRocm93IGVycjtcblx0ICB9XG5cdCAgdHJ5IHtcblx0ICAgIHN0ciA9IHN0ciB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgJ3V0ZjgnKVxuXHQgIH0gY2F0Y2ggKGV4KSB7XG5cdCAgICByZXRocm93KGVyciwgbnVsbCwgbGluZW5vKVxuXHQgIH1cblx0ICB2YXIgY29udGV4dCA9IDNcblx0ICAgICwgbGluZXMgPSBzdHIuc3BsaXQoJ1xcbicpXG5cdCAgICAsIHN0YXJ0ID0gTWF0aC5tYXgobGluZW5vIC0gY29udGV4dCwgMClcblx0ICAgICwgZW5kID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBsaW5lbm8gKyBjb250ZXh0KTtcblx0XG5cdCAgLy8gRXJyb3IgY29udGV4dFxuXHQgIHZhciBjb250ZXh0ID0gbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKGZ1bmN0aW9uKGxpbmUsIGkpe1xuXHQgICAgdmFyIGN1cnIgPSBpICsgc3RhcnQgKyAxO1xuXHQgICAgcmV0dXJuIChjdXJyID09IGxpbmVubyA/ICcgID4gJyA6ICcgICAgJylcblx0ICAgICAgKyBjdXJyXG5cdCAgICAgICsgJ3wgJ1xuXHQgICAgICArIGxpbmU7XG5cdCAgfSkuam9pbignXFxuJyk7XG5cdFxuXHQgIC8vIEFsdGVyIGV4Y2VwdGlvbiBtZXNzYWdlXG5cdCAgZXJyLnBhdGggPSBmaWxlbmFtZTtcblx0ICBlcnIubWVzc2FnZSA9IChmaWxlbmFtZSB8fCAnSmFkZScpICsgJzonICsgbGluZW5vXG5cdCAgICArICdcXG4nICsgY29udGV4dCArICdcXG5cXG4nICsgZXJyLm1lc3NhZ2U7XG5cdCAgdGhyb3cgZXJyO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5EZWJ1Z0l0ZW0gPSBmdW5jdGlvbiBEZWJ1Z0l0ZW0obGluZW5vLCBmaWxlbmFtZSkge1xuXHQgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcblx0fVxuXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKiAoaWdub3JlZCkgKi9cblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBqYWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7XG5cdHZhciBidWYgPSBbXTtcblx0dmFyIGphZGVfbWl4aW5zID0ge307XG5cdHZhciBqYWRlX2ludGVycDtcblx0O3ZhciBsb2NhbHNfZm9yX3dpdGggPSAobG9jYWxzIHx8IHt9KTsoZnVuY3Rpb24gKHRleHQpIHtcblx0YnVmLnB1c2goXCI8bGk+XCIgKyAoamFkZS5lc2NhcGUobnVsbCA9PSAoamFkZV9pbnRlcnAgPSB0ZXh0KSA/IFwiXCIgOiBqYWRlX2ludGVycCkpICsgXCI8L2xpPlwiKTt9LmNhbGwodGhpcyxcInRleHRcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLnRleHQ6dHlwZW9mIHRleHQhPT1cInVuZGVmaW5lZFwiP3RleHQ6dW5kZWZpbmVkKSk7O3JldHVybiBidWYuam9pbihcIlwiKTtcblx0fVxuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuRWxlbWVudFZpZXdwb3J0ID0gZXhwb3J0cy5XaW5kb3dWaWV3cG9ydCA9IGV4cG9ydHMuVmlld3BvcnQgPSB1bmRlZmluZWQ7XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXHRcblx0dmFyIF9iYWNrYm9uZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFxuXHR2YXIgX2JhY2tib25lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JhY2tib25lKTtcblx0XG5cdHZhciBfanF1ZXJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XG5cdHZhciBfanF1ZXJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pxdWVyeSk7XG5cdFxuXHR2YXIgX3VuZGVyc2NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcblx0dmFyIF91bmRlcnNjb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VuZGVyc2NvcmUpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXHRcblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0ZnVuY3Rpb24gZ2V0RWxlbWVudE1ldHJpY3MoZWwpIHtcblx0ICByZXR1cm4gX3VuZGVyc2NvcmUyLmRlZmF1bHQucGljayhlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0J10pO1xuXHR9XG5cdFxuXHR2YXIgVmlld3BvcnQgPSBleHBvcnRzLlZpZXdwb3J0ID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIFZpZXdwb3J0KCRlbCkge1xuXHQgICAgdmFyIF90aGlzID0gdGhpcztcblx0XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlld3BvcnQpO1xuXHRcblx0ICAgIF91bmRlcnNjb3JlMi5kZWZhdWx0LmV4dGVuZCh0aGlzLCBfYmFja2JvbmUyLmRlZmF1bHQuRXZlbnRzKTtcblx0XG5cdCAgICB0aGlzLiRlbCA9ICRlbDtcblx0XG5cdCAgICB0aGlzLm9uU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBfdGhpcy50cmlnZ2VyKCdzY3JvbGwnKTtcblx0ICAgICAgX3RoaXMudHJpZ2dlcignY2hhbmdlJyk7XG5cdCAgICB9O1xuXHRcblx0ICAgIHRoaXMub25SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF90aGlzLnRyaWdnZXIoJ3Jlc2l6ZScpO1xuXHQgICAgICBfdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcblx0ICAgIH07XG5cdFxuXHQgICAgdmFyIGtleUNvZGUgPSBudWxsO1xuXHQgICAgdmFyIHRpbWVzdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHQgICAgdGhpcy5vbktleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgLy8gQ29uc29saWRhdGUgdGhlIGtleWRvd24gZXZlbnRzIGZvciB0aGUgc2FtZSBrZXkgaW4gMC4yIHNlY29uZHNcblx0ICAgICAgaWYgKGtleUNvZGUgIT09IGV2ZW50LmtleUNvZGUgfHwgcGVyZm9ybWFuY2Uubm93KCkgPiB0aW1lc3RhbXAgKyAyMDApIHtcblx0ICAgICAgICBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcblx0ICAgICAgICB0aW1lc3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0ICAgICAgICBfdGhpcy50cmlnZ2VyKCdrZXlwcmVzcycsIGtleUNvZGUpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHRcblx0ICAgIHRoaXMub25LZXl1cCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAga2V5Q29kZSA9IG51bGw7XG5cdCAgICB9O1xuXHRcblx0ICAgIHRoaXMuJGVsLm9uKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplKTtcblx0ICAgIHRoaXMuJGVsLm9uKCdzY3JvbGwnLCB0aGlzLm9uU2Nyb2xsKTtcblx0ICAgICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShkb2N1bWVudCkub24oJ2tleWRvd24nLCB0aGlzLm9uS2V5ZG93bik7XG5cdCAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoZG9jdW1lbnQpLm9uKCdrZXl1cCcsIHRoaXMub25LZXl1cCk7XG5cdFxuXHQgICAgdGhpcy5zY3JvbGxUbyA9IGZ1bmN0aW9uIChzY3JvbGxOZXcpIHtcblx0ICAgICAgaWYgKF91bmRlcnNjb3JlMi5kZWZhdWx0LmlzTnVtYmVyKHNjcm9sbE5ldy54KSkge1xuXHQgICAgICAgIF90aGlzLiRlbC5zY3JvbGxMZWZ0KHNjcm9sbE5ldy54KTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoX3VuZGVyc2NvcmUyLmRlZmF1bHQuaXNOdW1iZXIoc2Nyb2xsTmV3LnkpKSB7XG5cdCAgICAgICAgX3RoaXMuJGVsLnNjcm9sbFRvcChzY3JvbGxOZXcueSk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfVxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoVmlld3BvcnQsIFt7XG5cdCAgICBrZXk6ICdyZW1vdmUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0ICAgICAgdGhpcy4kZWwub2ZmKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplKTtcblx0ICAgICAgdGhpcy4kZWwub2ZmKCdzY3JvbGwnLCB0aGlzLm9uU2Nyb2xsKTtcblx0ICAgICAgKDAsIF9qcXVlcnkyLmRlZmF1bHQpKGRvY3VtZW50KS5vZmYoJ2tleWRvd24nLCB0aGlzLm9uS2V5ZG93bik7XG5cdCAgICAgICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShkb2N1bWVudCkub2ZmKCdrZXl1cCcsIHRoaXMub25LZXl1cCk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnZ2V0TWV0cmljcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWV0cmljcygpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBWaWV3cG9ydDtcblx0fSgpO1xuXHRcblx0dmFyIFdpbmRvd1ZpZXdwb3J0ID0gZXhwb3J0cy5XaW5kb3dWaWV3cG9ydCA9IGZ1bmN0aW9uIChfVmlld3BvcnQpIHtcblx0ICBfaW5oZXJpdHMoV2luZG93Vmlld3BvcnQsIF9WaWV3cG9ydCk7XG5cdFxuXHQgIGZ1bmN0aW9uIFdpbmRvd1ZpZXdwb3J0KCkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdpbmRvd1ZpZXdwb3J0KTtcblx0XG5cdCAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFdpbmRvd1ZpZXdwb3J0KS5jYWxsKHRoaXMsICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSh3aW5kb3cpKSk7XG5cdCAgfVxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoV2luZG93Vmlld3BvcnQsIFt7XG5cdCAgICBrZXk6ICdnZXRNZXRyaWNzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZXRyaWNzKCkge1xuXHQgICAgICB2YXIgaW5uZXIgPSBnZXRFbGVtZW50TWV0cmljcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXHRcblx0ICAgICAgaW5uZXIud2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XG5cdCAgICAgIGlubmVyLmhlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG5cdCAgICAgIGlubmVyLnJpZ2h0ID0gaW5uZXIubGVmdCArIGlubmVyLndpZHRoO1xuXHQgICAgICBpbm5lci5ib3R0b20gPSBpbm5lci50b3AgKyBpbm5lci5oZWlnaHQ7XG5cdFxuXHQgICAgICB2YXIgb3V0ZXIgPSB7XG5cdCAgICAgICAgdG9wOiAwLFxuXHQgICAgICAgIGJvdHRvbTogd2luZG93LmlubmVySGVpZ2h0LFxuXHQgICAgICAgIGxlZnQ6IDAsXG5cdCAgICAgICAgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoLFxuXHQgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcblx0ICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuXHQgICAgICB9O1xuXHRcblx0ICAgICAgdmFyIHNjcm9sbCA9IHtcblx0ICAgICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcblx0ICAgICAgICB5OiB3aW5kb3cuc2Nyb2xsWVxuXHQgICAgICB9O1xuXHRcblx0ICAgICAgc2Nyb2xsLnJhdGlvWCA9IHNjcm9sbC54ID4gMCA/IHNjcm9sbC54IC8gKGlubmVyLndpZHRoIC0gb3V0ZXIud2lkdGgpIDogMDtcblx0ICAgICAgc2Nyb2xsLnJhdGlvWSA9IHNjcm9sbC55ID4gMCA/IHNjcm9sbC55IC8gKGlubmVyLmhlaWdodCAtIG91dGVyLmhlaWdodCkgOiAwO1xuXHRcblx0ICAgICAgcmV0dXJuIHsgaW5uZXI6IGlubmVyLCBvdXRlcjogb3V0ZXIsIHNjcm9sbDogc2Nyb2xsIH07XG5cdCAgICB9XG5cdCAgfV0pO1xuXHRcblx0ICByZXR1cm4gV2luZG93Vmlld3BvcnQ7XG5cdH0oVmlld3BvcnQpO1xuXHRcblx0dmFyIFNDUk9MTEFCTEUgPSBbJ2F1dG8nLCAnc2Nyb2xsJ107XG5cdFxuXHR2YXIgRWxlbWVudFZpZXdwb3J0ID0gZXhwb3J0cy5FbGVtZW50Vmlld3BvcnQgPSBmdW5jdGlvbiAoX1ZpZXdwb3J0Mikge1xuXHQgIF9pbmhlcml0cyhFbGVtZW50Vmlld3BvcnQsIF9WaWV3cG9ydDIpO1xuXHRcblx0ICBmdW5jdGlvbiBFbGVtZW50Vmlld3BvcnQoZWwpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGVtZW50Vmlld3BvcnQpO1xuXHRcblx0ICAgIHZhciBfdGhpczMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRWxlbWVudFZpZXdwb3J0KS5jYWxsKHRoaXMsICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShlbCkpKTtcblx0XG5cdCAgICBfdGhpczMuZWwgPSBfdGhpczMuJGVsLmdldCgwKTtcblx0ICAgIF90aGlzMy4kZWwuY3NzKCdvdmVyZmxvd1gnLCBmdW5jdGlvbiAocykge1xuXHQgICAgICByZXR1cm4gX3VuZGVyc2NvcmUyLmRlZmF1bHQuY29udGFpbnMoU0NST0xMQUJMRSwgcykgPyBzIDogJ2F1dG8nO1xuXHQgICAgfSk7XG5cdCAgICBfdGhpczMuJGVsLmNzcygnb3ZlcmZsb3dZJywgZnVuY3Rpb24gKHMpIHtcblx0ICAgICAgcmV0dXJuIF91bmRlcnNjb3JlMi5kZWZhdWx0LmNvbnRhaW5zKFNDUk9MTEFCTEUsIHMpID8gcyA6ICdhdXRvJztcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIF90aGlzMztcblx0ICB9XG5cdFxuXHQgIF9jcmVhdGVDbGFzcyhFbGVtZW50Vmlld3BvcnQsIFt7XG5cdCAgICBrZXk6ICdnZXRNZXRyaWNzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZXRyaWNzKCkge1xuXHQgICAgICB2YXIgb3V0ZXIgPSBnZXRFbGVtZW50TWV0cmljcyh0aGlzLmVsKTtcblx0ICAgICAgdmFyIHNjcm9sbCA9IHtcblx0ICAgICAgICB4OiB0aGlzLmVsLnNjcm9sbExlZnQsXG5cdCAgICAgICAgeTogdGhpcy5lbC5zY3JvbGxUb3Bcblx0ICAgICAgfTtcblx0ICAgICAgdmFyIGlubmVyID0ge1xuXHQgICAgICAgIGxlZnQ6IG91dGVyLmxlZnQgLSBzY3JvbGwueCxcblx0ICAgICAgICB0b3A6IG91dGVyLnRvcCAtIHNjcm9sbC55LFxuXHQgICAgICAgIHdpZHRoOiB0aGlzLmVsLnNjcm9sbFdpZHRoLFxuXHQgICAgICAgIGhlaWdodDogdGhpcy5lbC5zY3JvbGxIZWlnaHRcblx0ICAgICAgfTtcblx0ICAgICAgaW5uZXIucmlnaHQgPSBpbm5lci5sZWZ0ICsgaW5uZXIud2lkdGg7XG5cdCAgICAgIGlubmVyLmJvdHRvbSA9IGlubmVyLnRvcCArIGlubmVyLmhlaWdodDtcblx0XG5cdCAgICAgIHNjcm9sbC5yYXRpb1ggPSBzY3JvbGwueCA+IDAgPyBzY3JvbGwueCAvIChpbm5lci53aWR0aCAtIG91dGVyLndpZHRoKSA6IDA7XG5cdCAgICAgIHNjcm9sbC5yYXRpb1kgPSBzY3JvbGwueSA+IDAgPyBzY3JvbGwueSAvIChpbm5lci5oZWlnaHQgLSBvdXRlci5oZWlnaHQpIDogMDtcblx0XG5cdCAgICAgIHJldHVybiB7IG91dGVyOiBvdXRlciwgaW5uZXI6IGlubmVyLCBzY3JvbGw6IHNjcm9sbCB9O1xuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIEVsZW1lbnRWaWV3cG9ydDtcblx0fShWaWV3cG9ydCk7XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tib25lLXZpcnR1YWxpemVkLWxpc3R2aWV3LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9iYWNrYm9uZS12aXJ0dWFsaXplZC1saXN0dmlldy9kaXN0L2JhY2tib25lLXZpcnR1YWxpemVkLWxpc3R2aWV3LmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtb2QgPSB7XG4gICAgICBleHBvcnRzOiB7fVxuICAgIH07XG4gICAgZmFjdG9yeShtb2QuZXhwb3J0cyk7XG4gICAgZ2xvYmFsLmluZGV4ID0gbW9kLmV4cG9ydHM7XG4gIH1cbn0pKHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodikgJiYgTWF0aC5mbG9vcih2KSA9PT0gdjtcbiAgfTtcblxuICBmdW5jdGlvbiBtb3N0U2lnbmlmaWNhbnRCaXQodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG5cbiAgICByZXN1bHQgfD0gcmVzdWx0ID4+IDE7XG4gICAgcmVzdWx0IHw9IHJlc3VsdCA+PiAyO1xuICAgIHJlc3VsdCB8PSByZXN1bHQgPj4gNDtcbiAgICByZXN1bHQgfD0gcmVzdWx0ID4+IDg7XG4gICAgcmVzdWx0IHw9IHJlc3VsdCA+PiAxNjtcbiAgICByZXN1bHQgfD0gcmVzdWx0ID4+IDMyO1xuICAgIHJlc3VsdCAtPSByZXN1bHQgPj4gMTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ2xhc3MgQmluYXJ5SW5kZXhlZFRyZWVcbiAgICovXG5cbiAgdmFyIEJpbmFyeUluZGV4ZWRUcmVlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tYXhWYWwgLSBUaGUgbWF4aW11bSB2YWx1ZSB3aGljaCB3aWxsIGhhdmUgbm9uLXplcm8gZnJlcXVlbmN5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRlZmF1bHRGcmVxdWVuY3k9MF0gLSBUaGUgZGVmYXVsdCBpbml0aWFsIGZyZXF1ZW5jeVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQmluYXJ5SW5kZXhlZFRyZWUoKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICB2YXIgX3JlZiRkZWZhdWx0RnJlcXVlbmN5ID0gX3JlZi5kZWZhdWx0RnJlcXVlbmN5O1xuICAgICAgdmFyIGRlZmF1bHRGcmVxdWVuY3kgPSBfcmVmJGRlZmF1bHRGcmVxdWVuY3kgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGRlZmF1bHRGcmVxdWVuY3k7XG4gICAgICB2YXIgbWF4VmFsID0gX3JlZi5tYXhWYWw7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCaW5hcnlJbmRleGVkVHJlZSk7XG5cbiAgICAgIHRoaXMuX2RlZmF1bHRGcmVxdWVuY3kgPSBkZWZhdWx0RnJlcXVlbmN5O1xuICAgICAgdGhpcy5fbWF4VmFsID0gbWF4VmFsO1xuICAgICAgdGhpcy5fdHJlZSA9IHsgMDogMCB9O1xuICAgICAgdGhpcy5fbXNiID0gbW9zdFNpZ25pZmljYW50Qml0KG1heFZhbCk7XG4gICAgICB0aGlzLl9jb3VudE5lZyA9IGRlZmF1bHRGcmVxdWVuY3kgPCAwID8gbWF4VmFsIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpbml0aWFsIGZyZXF1ZW5jeVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhCaW5hcnlJbmRleGVkVHJlZSwgW3tcbiAgICAgIGtleTogJ19nZXRUcmVlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJlZShpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggaW4gdGhpcy5fdHJlZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmVlW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0RnJlcXVlbmN5ICogKGluZGV4ICYgLWluZGV4KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRkVHJlZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZFRyZWUoaW5kZXgsIGRlbHRhKSB7XG4gICAgICAgIHRoaXMuX3RyZWVbaW5kZXhdID0gdGhpcy5fZ2V0VHJlZShpbmRleCkgKyBkZWx0YTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2hlY2tJbmRleCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCFpc0ludGVnZXIoaW5kZXgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9tYXhWYWwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlYWRTaW5nbGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkU2luZ2xlKGlkeCkge1xuICAgICAgICB2YXIgaW5kZXggPSBpZHggKyAxO1xuICAgICAgICB2YXIgc3VtID0gdGhpcy5fZ2V0VHJlZShpbmRleCk7XG4gICAgICAgIHZhciB6ID0gaW5kZXggLSAoaW5kZXggJiAtaW5kZXgpO1xuXG4gICAgICAgIGluZGV4LS07XG5cbiAgICAgICAgd2hpbGUgKGluZGV4ICE9PSB6KSB7XG4gICAgICAgICAgc3VtIC09IHRoaXMuX2dldFRyZWUoaW5kZXgpO1xuICAgICAgICAgIGluZGV4IC09IGluZGV4ICYgLWluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2hhbmdlZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NoYW5nZWQoZnJlcUN1ciwgZnJlcU5ldykge1xuICAgICAgICBpZiAoZnJlcUN1ciA8IDAgJiYgZnJlcU5ldyA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5fY291bnROZWctLTtcbiAgICAgICAgfSBlbHNlIGlmIChmcmVxQ3VyID49IDAgJiYgZnJlcU5ldyA8IDApIHtcbiAgICAgICAgICB0aGlzLl9jb3VudE5lZysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3VwZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZShpZHgsIGRlbHRhKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGlkeCArIDE7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDw9IHRoaXMuX21heFZhbCkge1xuICAgICAgICAgIHRoaXMuX2FkZFRyZWUoaW5kZXgsIGRlbHRhKTtcbiAgICAgICAgICBpbmRleCArPSBpbmRleCAmIC1pbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ193cml0ZVNpbmdsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3dyaXRlU2luZ2xlKGlkeCwgZnJlcSkge1xuICAgICAgICB2YXIgZnJlcUN1ciA9IHRoaXMuX3JlYWRTaW5nbGUoaWR4KTtcblxuICAgICAgICB0aGlzLl91cGRhdGUoaWR4LCBmcmVxIC0gZnJlcUN1cik7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoZnJlcUN1ciwgZnJlcSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlYWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkKGNvdW50KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50O1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgd2hpbGUgKGluZGV4KSB7XG4gICAgICAgICAgc3VtICs9IHRoaXMuX2dldFRyZWUoaW5kZXgpO1xuICAgICAgICAgIGluZGV4IC09IGluZGV4ICYgLWluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZmluZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmQoc3VtLCBiZWZvcmUpIHtcbiAgICAgICAgdmFyIGxlZnQgPSAwO1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLl9tc2IgPDwgMTtcbiAgICAgICAgdmFyIHN1bVQgPSBzdW07XG5cbiAgICAgICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCArIDEpIHtcbiAgICAgICAgICB2YXIgbWlkZGxlID0gbGVmdCArIHJpZ2h0ID4+IDE7XG4gICAgICAgICAgdmFyIHN1bU0gPSB0aGlzLl9nZXRUcmVlKG1pZGRsZSk7XG5cbiAgICAgICAgICBpZiAobWlkZGxlIDw9IHRoaXMuX21heFZhbCAmJiBiZWZvcmUoc3VtTSwgc3VtVCkpIHtcbiAgICAgICAgICAgIHN1bVQgLT0gc3VtTTtcbiAgICAgICAgICAgIGxlZnQgPSBtaWRkbGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gbWlkZGxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWFkU2luZ2xlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkU2luZ2xlKGlkeCkge1xuICAgICAgICB0aGlzLl9jaGVja0luZGV4KGlkeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkU2luZ2xlKGlkeCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoaWR4LCBkZWx0YSkge1xuICAgICAgICB0aGlzLl9jaGVja0luZGV4KGlkeCk7XG4gICAgICAgIHZhciBmcmVxQ3VyID0gdGhpcy5fcmVhZFNpbmdsZShpZHgpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZShpZHgsIGRlbHRhKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlZChmcmVxQ3VyLCBmcmVxQ3VyICsgZGVsdGEpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3dyaXRlU2luZ2xlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZVNpbmdsZShpZHgsIGZyZXEpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tJbmRleChpZHgpO1xuICAgICAgICB0aGlzLl93cml0ZVNpbmdsZShpZHgsIGZyZXEpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlYWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWQoY291bnQpIHtcbiAgICAgICAgaWYgKCFpc0ludGVnZXIoY291bnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvdW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoTWF0aC5tYXgoTWF0aC5taW4oY291bnQsIHRoaXMuX21heFZhbCksIDApKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdsb3dlckJvdW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb3dlckJvdW5kKHN1bSkge1xuICAgICAgICBpZiAodGhpcy5fY291bnROZWcgPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXF1ZW5jZSBpcyBub3Qgbm9uLWRlc2NlbmRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmluZChzdW0sIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgcmV0dXJuIHggPCB5O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cHBlckJvdW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cHBlckJvdW5kKHN1bSkge1xuICAgICAgICBpZiAodGhpcy5fY291bnROZWcgPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXF1ZW5jZSBpcyBub3Qgbm9uLWRlc2NlbmRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmluZChzdW0sIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgcmV0dXJuIHggPD0geTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVmYXVsdEZyZXF1ZW5jeScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRGcmVxdWVuY3k7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbWF4VmFsJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4VmFsO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCaW5hcnlJbmRleGVkVHJlZTtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEJpbmFyeUluZGV4ZWRUcmVlO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2Zhc3QtYmluYXJ5LWluZGV4ZWQtdHJlZS9kaXN0L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xyXG5pbXBvcnQgQmFja2JvbmUgZnJvbSAnYmFja2JvbmUnO1xyXG5pbXBvcnQgaGVhZGVyRm9vdGVyVGVtcGxhdGUgZnJvbSAnLi9oZWFkZXItZm9vdGVyLmphZGUnO1xyXG5cclxuY29uc3Qgc3Vidmlld0NsYXNzID0gaSA9PiBgaGVhZGVyLXN1YnZpZXctJHtpfWA7XHJcbmNvbnN0IHN1YnZpZXdTZWxlY3RvciA9IGkgPT4gYC4ke3N1YnZpZXdDbGFzcyhpKX1gO1xyXG5cclxuY2xhc3MgSGVhZGVyRm9vdGVyVmlldyBleHRlbmRzIEJhY2tib25lLlZpZXcge1xyXG4gIGluaXRpYWxpemUoeyB0YWJsZVZpZXcsIGdyb3VwIH0pIHtcclxuICAgIHRoaXMudGFibGVWaWV3ID0gdGFibGVWaWV3O1xyXG4gICAgdGhpcy5ncm91cCA9IGdyb3VwO1xyXG4gICAgdGhpcy5zdWJ2aWV3cyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgcmVkcmF3KCkge1xyXG4gICAgXy5lYWNoKHRoaXMuc3Vidmlld3MsIHN1YnZpZXcgPT4gc3Vidmlldy4kZWwuZGV0YWNoKCkpO1xyXG4gICAgdGhpcy5zdWJ2aWV3cyA9IFtdO1xyXG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHtcclxuICAgICAgcm93czogXy5tYXAodGhpcy5yb3dzLCByb3cgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNlbGxzID0gXy5tYXAocm93LmNlbGxzLCBjZWxsID0+IHtcclxuICAgICAgICAgIGlmIChjZWxsLnZpZXcpIHtcclxuICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IF8udW5pb24oY2VsbC5jbGFzc2VzLCBbXHJcbiAgICAgICAgICAgICAgc3Vidmlld0NsYXNzKHRoaXMuc3Vidmlld3MubGVuZ3RoKSxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3Vidmlld3MucHVzaChjZWxsLnZpZXcpO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5kZWZhdWx0cyh7IGNsYXNzZXMgfSwgY2VsbCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gY2VsbDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF8uZGVmYXVsdHMoeyBjZWxscyB9LCByb3cpO1xyXG4gICAgICB9KSxcclxuXHJcbiAgICAgIGdyb3VwOiB0aGlzLmdyb3VwLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIF8uZWFjaCh0aGlzLnN1YnZpZXdzLCAoc3VidmlldywgaSkgPT4ge1xyXG4gICAgICBzdWJ2aWV3LiRlbC5hcHBlbmRUbyh0aGlzLiQoc3Vidmlld1NlbGVjdG9yKGkpKSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJlbmRlcigpIHtcclxuICAgIHRoaXMucmVkcmF3KCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBIZWFkZXJWaWV3IGV4dGVuZHMgSGVhZGVyRm9vdGVyVmlldyB7XHJcbiAgZ2V0IHJvd3MoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50YWJsZVZpZXcuX3N0YXRlLmhlYWRSb3dzO1xyXG4gIH1cclxuXHJcbiAgdGVtcGxhdGUobW9kZWwpIHtcclxuICAgIHJldHVybiBoZWFkZXJGb290ZXJUZW1wbGF0ZShfLmRlZmF1bHRzKHsgZ3JvdXA6ICdoZWFkJyB9LCBtb2RlbCkpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBGb290ZXJWaWV3IGV4dGVuZHMgSGVhZGVyRm9vdGVyVmlldyB7XHJcbiAgZ2V0IHJvd3MoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50YWJsZVZpZXcuX3N0YXRlLmZvb3RSb3dzO1xyXG4gIH1cclxuXHJcbiAgdGVtcGxhdGUobW9kZWwpIHtcclxuICAgIHJldHVybiBoZWFkZXJGb290ZXJUZW1wbGF0ZShfLmRlZmF1bHRzKHsgZ3JvdXA6ICdmb290JyB9LCBtb2RlbCkpO1xyXG4gIH1cclxufVxyXG5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi8uLi9qcy92bmV4dC9sYXlvdXQvaGVhZGVyLWZvb3Rlci12aWV3LmpzXG4gKiovIiwidmFyIGphZGUgPSByZXF1aXJlKFwiRDpcXFxcd29ya3NwYWNlXFxcXGZvcmtcXFxccHJvamVjdGlvbi1ncmlkXFxcXG5vZGVfbW9kdWxlc1xcXFxqYWRlXFxcXGxpYlxcXFxydW50aW1lLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRlbXBsYXRlKGxvY2Fscykge1xudmFyIGJ1ZiA9IFtdO1xudmFyIGphZGVfbWl4aW5zID0ge307XG52YXIgamFkZV9pbnRlcnA7XG47dmFyIGxvY2Fsc19mb3Jfd2l0aCA9IChsb2NhbHMgfHwge30pOyhmdW5jdGlvbiAoZ3JvdXAsIHJvd3MpIHtcbmphZGVfbWl4aW5zW1wibWl4aW5IZWFkQ2VsbFwiXSA9IGphZGVfaW50ZXJwID0gZnVuY3Rpb24oY2VsbCl7XG52YXIgYmxvY2sgPSAodGhpcyAmJiB0aGlzLmJsb2NrKSwgYXR0cmlidXRlcyA9ICh0aGlzICYmIHRoaXMuYXR0cmlidXRlcykgfHwge307XG5idWYucHVzaChcIjx0aFwiICsgKGphZGUuYXR0cnMoamFkZS5tZXJnZShbe1wiY2xhc3NcIjogKGphZGVfaW50ZXJwID0gW3RydWVdLCBqYWRlLmpvaW5DbGFzc2VzKFtjZWxsLmNsYXNzZXNdLm1hcChqYWRlLmpvaW5DbGFzc2VzKS5tYXAoZnVuY3Rpb24gKGNscywgaSkgeyAgIHJldHVybiBqYWRlX2ludGVycFtpXSA/IGphZGUuZXNjYXBlKGNscykgOiBjbHMgfSkpKX0sY2VsbC5hdHRyaWJ1dGVzXSksIHRydWUpKSArIFwiPlwiKTtcbmlmICggKGNlbGwuaHRtbCkpXG57XG5idWYucHVzaChudWxsID09IChqYWRlX2ludGVycCA9IGNlbGwuaHRtbCkgPyBcIlwiIDogamFkZV9pbnRlcnApO1xufVxuZWxzZVxue1xuYnVmLnB1c2goamFkZS5lc2NhcGUobnVsbCA9PSAoamFkZV9pbnRlcnAgPSBjZWxsLnZhbHVlKSA/IFwiXCIgOiBqYWRlX2ludGVycCkpO1xufVxuYnVmLnB1c2goXCI8L3RoPlwiKTtcbn07XG5qYWRlX21peGluc1tcIm1peGluQ2VsbFwiXSA9IGphZGVfaW50ZXJwID0gZnVuY3Rpb24oY2VsbCl7XG52YXIgYmxvY2sgPSAodGhpcyAmJiB0aGlzLmJsb2NrKSwgYXR0cmlidXRlcyA9ICh0aGlzICYmIHRoaXMuYXR0cmlidXRlcykgfHwge307XG5idWYucHVzaChcIjx0ZFwiICsgKGphZGUuYXR0cnMoamFkZS5tZXJnZShbe1wiY2xhc3NcIjogKGphZGVfaW50ZXJwID0gW3RydWVdLCBqYWRlLmpvaW5DbGFzc2VzKFtjZWxsLmNsYXNzZXNdLm1hcChqYWRlLmpvaW5DbGFzc2VzKS5tYXAoZnVuY3Rpb24gKGNscywgaSkgeyAgIHJldHVybiBqYWRlX2ludGVycFtpXSA/IGphZGUuZXNjYXBlKGNscykgOiBjbHMgfSkpKX0sY2VsbC5hdHRyaWJ1dGVzXSksIHRydWUpKSArIFwiPlwiKTtcbmlmICggKGNlbGwuaHRtbCkpXG57XG5idWYucHVzaChudWxsID09IChqYWRlX2ludGVycCA9IGNlbGwuaHRtbCkgPyBcIlwiIDogamFkZV9pbnRlcnApO1xufVxuZWxzZVxue1xuYnVmLnB1c2goamFkZS5lc2NhcGUobnVsbCA9PSAoamFkZV9pbnRlcnAgPSBjZWxsLnZhbHVlKSA/IFwiXCIgOiBqYWRlX2ludGVycCkpO1xufVxuYnVmLnB1c2goXCI8L3RkPlwiKTtcbn07XG5qYWRlX21peGluc1tcIm1peGluUm93XCJdID0gamFkZV9pbnRlcnAgPSBmdW5jdGlvbihyb3csIGdyb3VwKXtcbnZhciBibG9jayA9ICh0aGlzICYmIHRoaXMuYmxvY2spLCBhdHRyaWJ1dGVzID0gKHRoaXMgJiYgdGhpcy5hdHRyaWJ1dGVzKSB8fCB7fTtcbmJ1Zi5wdXNoKFwiPHRyXCIgKyAoamFkZS5hdHRycyhqYWRlLm1lcmdlKFt7XCJjbGFzc1wiOiAoamFkZV9pbnRlcnAgPSBbdHJ1ZV0sIGphZGUuam9pbkNsYXNzZXMoW3Jvdy5jbGFzc2VzXS5tYXAoamFkZS5qb2luQ2xhc3NlcykubWFwKGZ1bmN0aW9uIChjbHMsIGkpIHsgICByZXR1cm4gamFkZV9pbnRlcnBbaV0gPyBqYWRlLmVzY2FwZShjbHMpIDogY2xzIH0pKSl9LHJvdy5hdHRyaWJ1dGVzXSksIHRydWUpKSArIFwiPlwiKTtcbi8vIGl0ZXJhdGUgcm93LmNlbGxzIHx8IFtdXG47KGZ1bmN0aW9uKCl7XG4gIHZhciAkJG9iaiA9IHJvdy5jZWxscyB8fCBbXTtcbiAgaWYgKCdudW1iZXInID09IHR5cGVvZiAkJG9iai5sZW5ndGgpIHtcblxuICAgIGZvciAodmFyICRpbmRleCA9IDAsICQkbCA9ICQkb2JqLmxlbmd0aDsgJGluZGV4IDwgJCRsOyAkaW5kZXgrKykge1xuICAgICAgdmFyIGNlbGwgPSAkJG9ialskaW5kZXhdO1xuXG5zd2l0Y2ggKGdyb3VwKXtcbmNhc2UgJ2hlYWQnOlxuamFkZV9taXhpbnNbXCJtaXhpbkhlYWRDZWxsXCJdKGNlbGwpO1xuICBicmVhaztcbmNhc2UgJ2JvZHknOlxuY2FzZSAnZm9vdCc6XG5qYWRlX21peGluc1tcIm1peGluQ2VsbFwiXShjZWxsKTtcbiAgYnJlYWs7XG59XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdmFyICQkbCA9IDA7XG4gICAgZm9yICh2YXIgJGluZGV4IGluICQkb2JqKSB7XG4gICAgICAkJGwrKzsgICAgICB2YXIgY2VsbCA9ICQkb2JqWyRpbmRleF07XG5cbnN3aXRjaCAoZ3JvdXApe1xuY2FzZSAnaGVhZCc6XG5qYWRlX21peGluc1tcIm1peGluSGVhZENlbGxcIl0oY2VsbCk7XG4gIGJyZWFrO1xuY2FzZSAnYm9keSc6XG5jYXNlICdmb290JzpcbmphZGVfbWl4aW5zW1wibWl4aW5DZWxsXCJdKGNlbGwpO1xuICBicmVhaztcbn1cbiAgICB9XG5cbiAgfVxufSkuY2FsbCh0aGlzKTtcblxuYnVmLnB1c2goXCI8L3RyPlwiKTtcbn07XG5qYWRlX21peGluc1tcIm1peGluUm93c1wiXSA9IGphZGVfaW50ZXJwID0gZnVuY3Rpb24ocm93cywgZ3JvdXApe1xudmFyIGJsb2NrID0gKHRoaXMgJiYgdGhpcy5ibG9jayksIGF0dHJpYnV0ZXMgPSAodGhpcyAmJiB0aGlzLmF0dHJpYnV0ZXMpIHx8IHt9O1xuLy8gaXRlcmF0ZSByb3dzIHx8IFtdXG47KGZ1bmN0aW9uKCl7XG4gIHZhciAkJG9iaiA9IHJvd3MgfHwgW107XG4gIGlmICgnbnVtYmVyJyA9PSB0eXBlb2YgJCRvYmoubGVuZ3RoKSB7XG5cbiAgICBmb3IgKHZhciAkaW5kZXggPSAwLCAkJGwgPSAkJG9iai5sZW5ndGg7ICRpbmRleCA8ICQkbDsgJGluZGV4KyspIHtcbiAgICAgIHZhciByb3cgPSAkJG9ialskaW5kZXhdO1xuXG5qYWRlX21peGluc1tcIm1peGluUm93XCJdKHJvdywgZ3JvdXApO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHZhciAkJGwgPSAwO1xuICAgIGZvciAodmFyICRpbmRleCBpbiAkJG9iaikge1xuICAgICAgJCRsKys7ICAgICAgdmFyIHJvdyA9ICQkb2JqWyRpbmRleF07XG5cbmphZGVfbWl4aW5zW1wibWl4aW5Sb3dcIl0ocm93LCBncm91cCk7XG4gICAgfVxuXG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbn07XG5qYWRlX21peGluc1tcIm1peGluUm93c1wiXShyb3dzLCBncm91cCk7fS5jYWxsKHRoaXMsXCJncm91cFwiIGluIGxvY2Fsc19mb3Jfd2l0aD9sb2NhbHNfZm9yX3dpdGguZ3JvdXA6dHlwZW9mIGdyb3VwIT09XCJ1bmRlZmluZWRcIj9ncm91cDp1bmRlZmluZWQsXCJyb3dzXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC5yb3dzOnR5cGVvZiByb3dzIT09XCJ1bmRlZmluZWRcIj9yb3dzOnVuZGVmaW5lZCkpOztyZXR1cm4gYnVmLmpvaW4oXCJcIik7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9qcy92bmV4dC9sYXlvdXQvaGVhZGVyLWZvb3Rlci5qYWRlXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgamFkZSA9IHJlcXVpcmUoXCJEOlxcXFx3b3Jrc3BhY2VcXFxcZm9ya1xcXFxwcm9qZWN0aW9uLWdyaWRcXFxcbm9kZV9tb2R1bGVzXFxcXGphZGVcXFxcbGliXFxcXHJ1bnRpbWUuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7XG52YXIgYnVmID0gW107XG52YXIgamFkZV9taXhpbnMgPSB7fTtcbnZhciBqYWRlX2ludGVycDtcbjt2YXIgbG9jYWxzX2Zvcl93aXRoID0gKGxvY2FscyB8fCB7fSk7KGZ1bmN0aW9uIChyb3cpIHtcbmphZGVfbWl4aW5zW1wibWl4aW5IZWFkQ2VsbFwiXSA9IGphZGVfaW50ZXJwID0gZnVuY3Rpb24oY2VsbCl7XG52YXIgYmxvY2sgPSAodGhpcyAmJiB0aGlzLmJsb2NrKSwgYXR0cmlidXRlcyA9ICh0aGlzICYmIHRoaXMuYXR0cmlidXRlcykgfHwge307XG5idWYucHVzaChcIjx0aFwiICsgKGphZGUuYXR0cnMoamFkZS5tZXJnZShbe1wiY2xhc3NcIjogKGphZGVfaW50ZXJwID0gW3RydWVdLCBqYWRlLmpvaW5DbGFzc2VzKFtjZWxsLmNsYXNzZXNdLm1hcChqYWRlLmpvaW5DbGFzc2VzKS5tYXAoZnVuY3Rpb24gKGNscywgaSkgeyAgIHJldHVybiBqYWRlX2ludGVycFtpXSA/IGphZGUuZXNjYXBlKGNscykgOiBjbHMgfSkpKX0sY2VsbC5hdHRyaWJ1dGVzXSksIHRydWUpKSArIFwiPlwiKTtcbmlmICggKGNlbGwuaHRtbCkpXG57XG5idWYucHVzaChudWxsID09IChqYWRlX2ludGVycCA9IGNlbGwuaHRtbCkgPyBcIlwiIDogamFkZV9pbnRlcnApO1xufVxuZWxzZVxue1xuYnVmLnB1c2goamFkZS5lc2NhcGUobnVsbCA9PSAoamFkZV9pbnRlcnAgPSBjZWxsLnZhbHVlKSA/IFwiXCIgOiBqYWRlX2ludGVycCkpO1xufVxuYnVmLnB1c2goXCI8L3RoPlwiKTtcbn07XG5qYWRlX21peGluc1tcIm1peGluQ2VsbFwiXSA9IGphZGVfaW50ZXJwID0gZnVuY3Rpb24oY2VsbCl7XG52YXIgYmxvY2sgPSAodGhpcyAmJiB0aGlzLmJsb2NrKSwgYXR0cmlidXRlcyA9ICh0aGlzICYmIHRoaXMuYXR0cmlidXRlcykgfHwge307XG5idWYucHVzaChcIjx0ZFwiICsgKGphZGUuYXR0cnMoamFkZS5tZXJnZShbe1wiY2xhc3NcIjogKGphZGVfaW50ZXJwID0gW3RydWVdLCBqYWRlLmpvaW5DbGFzc2VzKFtjZWxsLmNsYXNzZXNdLm1hcChqYWRlLmpvaW5DbGFzc2VzKS5tYXAoZnVuY3Rpb24gKGNscywgaSkgeyAgIHJldHVybiBqYWRlX2ludGVycFtpXSA/IGphZGUuZXNjYXBlKGNscykgOiBjbHMgfSkpKX0sY2VsbC5hdHRyaWJ1dGVzXSksIHRydWUpKSArIFwiPlwiKTtcbmlmICggKGNlbGwuaHRtbCkpXG57XG5idWYucHVzaChudWxsID09IChqYWRlX2ludGVycCA9IGNlbGwuaHRtbCkgPyBcIlwiIDogamFkZV9pbnRlcnApO1xufVxuZWxzZVxue1xuYnVmLnB1c2goamFkZS5lc2NhcGUobnVsbCA9PSAoamFkZV9pbnRlcnAgPSBjZWxsLnZhbHVlKSA/IFwiXCIgOiBqYWRlX2ludGVycCkpO1xufVxuYnVmLnB1c2goXCI8L3RkPlwiKTtcbn07XG5qYWRlX21peGluc1tcIm1peGluUm93XCJdID0gamFkZV9pbnRlcnAgPSBmdW5jdGlvbihyb3csIGdyb3VwKXtcbnZhciBibG9jayA9ICh0aGlzICYmIHRoaXMuYmxvY2spLCBhdHRyaWJ1dGVzID0gKHRoaXMgJiYgdGhpcy5hdHRyaWJ1dGVzKSB8fCB7fTtcbmJ1Zi5wdXNoKFwiPHRyXCIgKyAoamFkZS5hdHRycyhqYWRlLm1lcmdlKFt7XCJjbGFzc1wiOiAoamFkZV9pbnRlcnAgPSBbdHJ1ZV0sIGphZGUuam9pbkNsYXNzZXMoW3Jvdy5jbGFzc2VzXS5tYXAoamFkZS5qb2luQ2xhc3NlcykubWFwKGZ1bmN0aW9uIChjbHMsIGkpIHsgICByZXR1cm4gamFkZV9pbnRlcnBbaV0gPyBqYWRlLmVzY2FwZShjbHMpIDogY2xzIH0pKSl9LHJvdy5hdHRyaWJ1dGVzXSksIHRydWUpKSArIFwiPlwiKTtcbi8vIGl0ZXJhdGUgcm93LmNlbGxzIHx8IFtdXG47KGZ1bmN0aW9uKCl7XG4gIHZhciAkJG9iaiA9IHJvdy5jZWxscyB8fCBbXTtcbiAgaWYgKCdudW1iZXInID09IHR5cGVvZiAkJG9iai5sZW5ndGgpIHtcblxuICAgIGZvciAodmFyICRpbmRleCA9IDAsICQkbCA9ICQkb2JqLmxlbmd0aDsgJGluZGV4IDwgJCRsOyAkaW5kZXgrKykge1xuICAgICAgdmFyIGNlbGwgPSAkJG9ialskaW5kZXhdO1xuXG5zd2l0Y2ggKGdyb3VwKXtcbmNhc2UgJ2hlYWQnOlxuamFkZV9taXhpbnNbXCJtaXhpbkhlYWRDZWxsXCJdKGNlbGwpO1xuICBicmVhaztcbmNhc2UgJ2JvZHknOlxuY2FzZSAnZm9vdCc6XG5qYWRlX21peGluc1tcIm1peGluQ2VsbFwiXShjZWxsKTtcbiAgYnJlYWs7XG59XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdmFyICQkbCA9IDA7XG4gICAgZm9yICh2YXIgJGluZGV4IGluICQkb2JqKSB7XG4gICAgICAkJGwrKzsgICAgICB2YXIgY2VsbCA9ICQkb2JqWyRpbmRleF07XG5cbnN3aXRjaCAoZ3JvdXApe1xuY2FzZSAnaGVhZCc6XG5qYWRlX21peGluc1tcIm1peGluSGVhZENlbGxcIl0oY2VsbCk7XG4gIGJyZWFrO1xuY2FzZSAnYm9keSc6XG5jYXNlICdmb290JzpcbmphZGVfbWl4aW5zW1wibWl4aW5DZWxsXCJdKGNlbGwpO1xuICBicmVhaztcbn1cbiAgICB9XG5cbiAgfVxufSkuY2FsbCh0aGlzKTtcblxuYnVmLnB1c2goXCI8L3RyPlwiKTtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxuamFkZV9taXhpbnNbXCJtaXhpblJvd1wiXShyb3csICdib2R5Jyk7fS5jYWxsKHRoaXMsXCJyb3dcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLnJvdzp0eXBlb2Ygcm93IT09XCJ1bmRlZmluZWRcIj9yb3c6dW5kZWZpbmVkKSk7O3JldHVybiBidWYuam9pbihcIlwiKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2pzL3ZuZXh0L2xheW91dC9yb3cuamFkZVxuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGphZGUgPSByZXF1aXJlKFwiRDpcXFxcd29ya3NwYWNlXFxcXGZvcmtcXFxccHJvamVjdGlvbi1ncmlkXFxcXG5vZGVfbW9kdWxlc1xcXFxqYWRlXFxcXGxpYlxcXFxydW50aW1lLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRlbXBsYXRlKGxvY2Fscykge1xudmFyIGJ1ZiA9IFtdO1xudmFyIGphZGVfbWl4aW5zID0ge307XG52YXIgamFkZV9pbnRlcnA7XG47dmFyIGxvY2Fsc19mb3Jfd2l0aCA9IChsb2NhbHMgfHwge30pOyhmdW5jdGlvbiAoY2xhc3Nlcykge1xudmFyIHRhYmxlU3R5bGUgPSB7XG4gICdib3JkZXItY29sbGFwc2UnOiAnY29sbGFwc2UnLFxuICAnbWFyZ2luJzogMCxcbiAgJ3RhYmxlLWxheW91dCc6ICdmaXhlZCcsXG59O1xuXG5idWYucHVzaChcIjxkaXYgY2xhc3M9XFxcInRhYmxlLWNvbnRhaW5lclxcXCI+PGRpdiBjbGFzcz1cXFwiZml4ZWQtaGVhZGVyXFxcIj48dGFibGVcIiArIChqYWRlLmF0dHIoXCJzdHlsZVwiLCB0YWJsZVN0eWxlLCB0cnVlLCB0cnVlKSkgKyAoamFkZS5jbHMoW2NsYXNzZXNdLCBbdHJ1ZV0pKSArIFwiPjxjb2xncm91cCBjbGFzcz1cXFwiY29sdW1uLWdyb3VwXFxcIj48L2NvbGdyb3VwPjx0aGVhZCBjbGFzcz1cXFwiaGVhZGVyXFxcIj48L3RoZWFkPjwvdGFibGU+PC9kaXY+PGRpdiBjbGFzcz1cXFwidmlld3BvcnRcXFwiPjx0YWJsZVwiICsgKGphZGUuYXR0cihcInN0eWxlXCIsIHRhYmxlU3R5bGUsIHRydWUsIHRydWUpKSArIChqYWRlLmNscyhbY2xhc3Nlc10sIFt0cnVlXSkpICsgXCI+PGNvbGdyb3VwIGNsYXNzPVxcXCJjb2x1bW4tZ3JvdXBcXFwiPjwvY29sZ3JvdXA+PHRib2R5Pjx0ciBjbGFzcz1cXFwidG9wLWZpbGxlclxcXCI+PC90cj48dHIgY2xhc3M9XFxcImJvdHRvbS1maWxsZXJcXFwiPjwvdHI+PC90Ym9keT48dGZvb3QgY2xhc3M9XFxcImZvb3RlclxcXCI+PC90Zm9vdD48L3RhYmxlPjwvZGl2PjwvZGl2PlwiKTt9LmNhbGwodGhpcyxcImNsYXNzZXNcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLmNsYXNzZXM6dHlwZW9mIGNsYXNzZXMhPT1cInVuZGVmaW5lZFwiP2NsYXNzZXM6dW5kZWZpbmVkKSk7O3JldHVybiBidWYuam9pbihcIlwiKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2pzL3ZuZXh0L2xheW91dC90YWJsZS1maXhlZC5qYWRlXG4gKiogbW9kdWxlIGlkID0gMTAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgamFkZSA9IHJlcXVpcmUoXCJEOlxcXFx3b3Jrc3BhY2VcXFxcZm9ya1xcXFxwcm9qZWN0aW9uLWdyaWRcXFxcbm9kZV9tb2R1bGVzXFxcXGphZGVcXFxcbGliXFxcXHJ1bnRpbWUuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7XG52YXIgYnVmID0gW107XG52YXIgamFkZV9taXhpbnMgPSB7fTtcbnZhciBqYWRlX2ludGVycDtcbjt2YXIgbG9jYWxzX2Zvcl93aXRoID0gKGxvY2FscyB8fCB7fSk7KGZ1bmN0aW9uIChjbGFzc2VzKSB7XG52YXIgdGFibGVTdHlsZSA9IHtcbiAgJ2JvcmRlci1jb2xsYXBzZSc6ICdjb2xsYXBzZScsXG4gICdtYXJnaW4nOiAwLFxufTtcblxuYnVmLnB1c2goXCI8ZGl2IGNsYXNzPVxcXCJ0YWJsZS1jb250YWluZXJcXFwiPjx0YWJsZVwiICsgKGphZGUuYXR0cihcInN0eWxlXCIsIHRhYmxlU3R5bGUsIHRydWUsIHRydWUpKSArIChqYWRlLmNscyhbY2xhc3Nlc10sIFt0cnVlXSkpICsgXCI+PGNvbGdyb3VwIGNsYXNzPVxcXCJjb2x1bW4tZ3JvdXBcXFwiPjwvY29sZ3JvdXA+PHRoZWFkIGNsYXNzPVxcXCJoZWFkZXJcXFwiPjwvdGhlYWQ+PHRib2R5PiA8dHIgY2xhc3M9XFxcInRvcC1maWxsZXJcXFwiPjwvdHI+PHRyIGNsYXNzPVxcXCJib3R0b20tZmlsbGVyXFxcIj48L3RyPjwvdGJvZHk+PHRmb290IGNsYXNzPVxcXCJmb290ZXJcXFwiPjwvdGZvb3Q+PC90YWJsZT48L2Rpdj5cIik7fS5jYWxsKHRoaXMsXCJjbGFzc2VzXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC5jbGFzc2VzOnR5cGVvZiBjbGFzc2VzIT09XCJ1bmRlZmluZWRcIj9jbGFzc2VzOnVuZGVmaW5lZCkpOztyZXR1cm4gYnVmLmpvaW4oXCJcIik7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9qcy92bmV4dC9sYXlvdXQvdGFibGUtc3RhdGljLmphZGVcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBqYWRlID0gcmVxdWlyZShcIkQ6XFxcXHdvcmtzcGFjZVxcXFxmb3JrXFxcXHByb2plY3Rpb24tZ3JpZFxcXFxub2RlX21vZHVsZXNcXFxcamFkZVxcXFxsaWJcXFxccnVudGltZS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZW1wbGF0ZShsb2NhbHMpIHtcbnZhciBidWYgPSBbXTtcbnZhciBqYWRlX21peGlucyA9IHt9O1xudmFyIGphZGVfaW50ZXJwO1xuO3ZhciBsb2NhbHNfZm9yX3dpdGggPSAobG9jYWxzIHx8IHt9KTsoZnVuY3Rpb24gKGNsYXNzZXMpIHtcbnZhciB0YWJsZVN0eWxlID0ge1xuICAnYm9yZGVyLWNvbGxhcHNlJzogJ2NvbGxhcHNlJyxcbiAgJ21hcmdpbic6IDAsXG4gICd0YWJsZS1sYXlvdXQnOiAnZml4ZWQnLFxufTtcblxuYnVmLnB1c2goXCI8ZGl2IGNsYXNzPVxcXCJ0YWJsZS1jb250YWluZXJcXFwiPjx0YWJsZVwiICsgKGphZGUuYXR0cihcInN0eWxlXCIsIHRhYmxlU3R5bGUsIHRydWUsIHRydWUpKSArIChqYWRlLmNscyhbJ3N0aWNreS1oZWFkZXInLGNsYXNzZXNdLCBbbnVsbCx0cnVlXSkpICsgXCI+PGNvbGdyb3VwIGNsYXNzPVxcXCJjb2x1bW4tZ3JvdXBcXFwiPjwvY29sZ3JvdXA+PHRoZWFkIGNsYXNzPVxcXCJoZWFkZXJcXFwiPjwvdGhlYWQ+PC90YWJsZT48ZGl2IGNsYXNzPVxcXCJzdGlja3ktaGVhZGVyLWZpbGxlclxcXCI+PC9kaXY+PHRhYmxlXCIgKyAoamFkZS5hdHRyKFwic3R5bGVcIiwgdGFibGVTdHlsZSwgdHJ1ZSwgdHJ1ZSkpICsgKGphZGUuY2xzKFtjbGFzc2VzXSwgW3RydWVdKSkgKyBcIj48Y29sZ3JvdXAgY2xhc3M9XFxcImNvbHVtbi1ncm91cFxcXCI+PC9jb2xncm91cD48dGJvZHk+PHRyIGNsYXNzPVxcXCJ0b3AtZmlsbGVyXFxcIj48L3RyPjx0ciBjbGFzcz1cXFwiYm90dG9tLWZpbGxlclxcXCI+PC90cj48L3Rib2R5Pjx0Zm9vdCBjbGFzcz1cXFwiZm9vdGVyXFxcIj48L3Rmb290PjwvdGFibGU+PC9kaXY+XCIpO30uY2FsbCh0aGlzLFwiY2xhc3Nlc1wiIGluIGxvY2Fsc19mb3Jfd2l0aD9sb2NhbHNfZm9yX3dpdGguY2xhc3Nlczp0eXBlb2YgY2xhc3NlcyE9PVwidW5kZWZpbmVkXCI/Y2xhc3Nlczp1bmRlZmluZWQpKTs7cmV0dXJuIGJ1Zi5qb2luKFwiXCIpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vanMvdm5leHQvbGF5b3V0L3RhYmxlLXN0aWNreS5qYWRlXG4gKiogbW9kdWxlIGlkID0gMTA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgamFkZSA9IHJlcXVpcmUoXCJEOlxcXFx3b3Jrc3BhY2VcXFxcZm9ya1xcXFxwcm9qZWN0aW9uLWdyaWRcXFxcbm9kZV9tb2R1bGVzXFxcXGphZGVcXFxcbGliXFxcXHJ1bnRpbWUuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7XG52YXIgYnVmID0gW107XG52YXIgamFkZV9taXhpbnMgPSB7fTtcbnZhciBqYWRlX2ludGVycDtcbjt2YXIgbG9jYWxzX2Zvcl93aXRoID0gKGxvY2FscyB8fCB7fSk7KGZ1bmN0aW9uIChjb2xzLCB1bmRlZmluZWQpIHtcbi8vIGl0ZXJhdGUgY29scyB8fCBbXVxuOyhmdW5jdGlvbigpe1xuICB2YXIgJCRvYmogPSBjb2xzIHx8IFtdO1xuICBpZiAoJ251bWJlcicgPT0gdHlwZW9mICQkb2JqLmxlbmd0aCkge1xuXG4gICAgZm9yICh2YXIgJGluZGV4ID0gMCwgJCRsID0gJCRvYmoubGVuZ3RoOyAkaW5kZXggPCAkJGw7ICRpbmRleCsrKSB7XG4gICAgICB2YXIgY29sID0gJCRvYmpbJGluZGV4XTtcblxudmFyIGNvbHVtblN0eWxlID0gY29sLndpZHRoID8gJ3dpZHRoOiAnICsgY29sLndpZHRoICsgJzsnIDogbnVsbDtcbmJ1Zi5wdXNoKFwiPGNvbFwiICsgKGphZGUuYXR0cihcInN0eWxlXCIsIGNvbHVtblN0eWxlLCB0cnVlLCB0cnVlKSkgKyAoamFkZS5jbHMoW2NvbC5jbGFzc2VzXSwgW3RydWVdKSkgKyBcIj5cIik7XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdmFyICQkbCA9IDA7XG4gICAgZm9yICh2YXIgJGluZGV4IGluICQkb2JqKSB7XG4gICAgICAkJGwrKzsgICAgICB2YXIgY29sID0gJCRvYmpbJGluZGV4XTtcblxudmFyIGNvbHVtblN0eWxlID0gY29sLndpZHRoID8gJ3dpZHRoOiAnICsgY29sLndpZHRoICsgJzsnIDogbnVsbDtcbmJ1Zi5wdXNoKFwiPGNvbFwiICsgKGphZGUuYXR0cihcInN0eWxlXCIsIGNvbHVtblN0eWxlLCB0cnVlLCB0cnVlKSkgKyAoamFkZS5jbHMoW2NvbC5jbGFzc2VzXSwgW3RydWVdKSkgKyBcIj5cIik7XG4gICAgfVxuXG4gIH1cbn0pLmNhbGwodGhpcyk7XG59LmNhbGwodGhpcyxcImNvbHNcIiBpbiBsb2NhbHNfZm9yX3dpdGg/bG9jYWxzX2Zvcl93aXRoLmNvbHM6dHlwZW9mIGNvbHMhPT1cInVuZGVmaW5lZFwiP2NvbHM6dW5kZWZpbmVkLFwidW5kZWZpbmVkXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC51bmRlZmluZWQ6dHlwZW9mIHVuZGVmaW5lZCE9PVwidW5kZWZpbmVkXCI/dW5kZWZpbmVkOnVuZGVmaW5lZCkpOztyZXR1cm4gYnVmLmpvaW4oXCJcIik7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9qcy92bmV4dC9sYXlvdXQvY29sdW1uLWdyb3VwLmphZGVcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcInZhbHVlXCI6IFtcblx0XHR7XG5cdFx0XHRcIlVzZXJOYW1lXCI6IFwicnVzc2VsbHdoeXRlXCIsXG5cdFx0XHRcIkZpcnN0TmFtZVwiOiBcIlJ1c3NlbGxcIixcblx0XHRcdFwiTGFzdE5hbWVcIjogXCJXaHl0ZVwiLFxuXHRcdFx0XCJFbWFpbHNcIjogW1xuXHRcdFx0XHRcIlJ1c3NlbGxAZXhhbXBsZS5jb21cIixcblx0XHRcdFx0XCJSdXNzZWxsQGNvbnRvc28uY29tXCJcblx0XHRcdF0sXG5cdFx0XHRcIkFkZHJlc3NJbmZvXCI6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdFwiQWRkcmVzc1wiOiBcIjE4NyBTdWZmb2xrIExuLlwiLFxuXHRcdFx0XHRcdFwiQ2l0eVwiOiB7XG5cdFx0XHRcdFx0XHRcIkNvdW50cnlSZWdpb25cIjogXCJVbml0ZWQgU3RhdGVzXCIsXG5cdFx0XHRcdFx0XHRcIk5hbWVcIjogXCJCb2lzZVwiLFxuXHRcdFx0XHRcdFx0XCJSZWdpb25cIjogXCJJRFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRdLFxuXHRcdFx0XCJHZW5kZXJcIjogXCJNYWxlXCIsXG5cdFx0XHRcIkNvbmN1cnJlbmN5XCI6IDYzNTk5NzUyMTExMzU3MzIwMFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJVc2VyTmFtZVwiOiBcInNjb3R0a2V0Y2h1bVwiLFxuXHRcdFx0XCJGaXJzdE5hbWVcIjogXCJTY290dFwiLFxuXHRcdFx0XCJMYXN0TmFtZVwiOiBcIktldGNodW1cIixcblx0XHRcdFwiRW1haWxzXCI6IFtcblx0XHRcdFx0XCJTY290dEBleGFtcGxlLmNvbVwiXG5cdFx0XHRdLFxuXHRcdFx0XCJBZGRyZXNzSW5mb1wiOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRcIkFkZHJlc3NcIjogXCIyODE3IE1pbHRvbiBEci5cIixcblx0XHRcdFx0XHRcIkNpdHlcIjoge1xuXHRcdFx0XHRcdFx0XCJDb3VudHJ5UmVnaW9uXCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuXHRcdFx0XHRcdFx0XCJOYW1lXCI6IFwiQWxidXF1ZXJxdWVcIixcblx0XHRcdFx0XHRcdFwiUmVnaW9uXCI6IFwiTk1cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XSxcblx0XHRcdFwiR2VuZGVyXCI6IFwiTWFsZVwiLFxuXHRcdFx0XCJDb25jdXJyZW5jeVwiOiA2MzU5OTc1MjExMTM1NzMyMDBcblx0XHR9LFxuXHRcdHtcblx0XHRcdFwiVXNlck5hbWVcIjogXCJyb25hbGRtdW5keVwiLFxuXHRcdFx0XCJGaXJzdE5hbWVcIjogXCJSb25hbGRcIixcblx0XHRcdFwiTGFzdE5hbWVcIjogXCJNdW5keVwiLFxuXHRcdFx0XCJFbWFpbHNcIjogW1xuXHRcdFx0XHRcIlJvbmFsZEBleGFtcGxlLmNvbVwiLFxuXHRcdFx0XHRcIlJvbmFsZEBjb250b3NvLmNvbVwiXG5cdFx0XHRdLFxuXHRcdFx0XCJBZGRyZXNzSW5mb1wiOiBbXSxcblx0XHRcdFwiR2VuZGVyXCI6IFwiTWFsZVwiLFxuXHRcdFx0XCJDb25jdXJyZW5jeVwiOiA2MzU5OTc1MjExMTM1NzMyMDBcblx0XHR9LFxuXHRcdHtcblx0XHRcdFwiVXNlck5hbWVcIjogXCJqYXZpZXJhbGZyZWRcIixcblx0XHRcdFwiRmlyc3ROYW1lXCI6IFwiSmF2aWVyXCIsXG5cdFx0XHRcIkxhc3ROYW1lXCI6IFwiQWxmcmVkXCIsXG5cdFx0XHRcIkVtYWlsc1wiOiBbXG5cdFx0XHRcdFwiSmF2aWVyQGV4YW1wbGUuY29tXCIsXG5cdFx0XHRcdFwiSmF2aWVyQGNvbnRvc28uY29tXCJcblx0XHRcdF0sXG5cdFx0XHRcIkFkZHJlc3NJbmZvXCI6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdFwiQWRkcmVzc1wiOiBcIjg5IEplZmZlcnNvbiBXYXkgU3VpdGUgMlwiLFxuXHRcdFx0XHRcdFwiQ2l0eVwiOiB7XG5cdFx0XHRcdFx0XHRcIkNvdW50cnlSZWdpb25cIjogXCJVbml0ZWQgU3RhdGVzXCIsXG5cdFx0XHRcdFx0XHRcIk5hbWVcIjogXCJQb3J0bGFuZFwiLFxuXHRcdFx0XHRcdFx0XCJSZWdpb25cIjogXCJXQVwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRdLFxuXHRcdFx0XCJHZW5kZXJcIjogXCJNYWxlXCIsXG5cdFx0XHRcIkNvbmN1cnJlbmN5XCI6IDYzNTk5NzUyMTExMzU3MzIwMFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJVc2VyTmFtZVwiOiBcIndpbGxpZWFzaG1vcmVcIixcblx0XHRcdFwiRmlyc3ROYW1lXCI6IFwiV2lsbGllXCIsXG5cdFx0XHRcIkxhc3ROYW1lXCI6IFwiQXNobW9yZVwiLFxuXHRcdFx0XCJFbWFpbHNcIjogW1xuXHRcdFx0XHRcIldpbGxpZUBleGFtcGxlLmNvbVwiLFxuXHRcdFx0XHRcIldpbGxpZUBjb250b3NvLmNvbVwiXG5cdFx0XHRdLFxuXHRcdFx0XCJBZGRyZXNzSW5mb1wiOiBbXSxcblx0XHRcdFwiR2VuZGVyXCI6IFwiTWFsZVwiLFxuXHRcdFx0XCJDb25jdXJyZW5jeVwiOiA2MzU5OTc1MjExMTM1NzMyMDBcblx0XHR9LFxuXHRcdHtcblx0XHRcdFwiVXNlck5hbWVcIjogXCJ2aW5jZW50Y2FsYWJyZXNlXCIsXG5cdFx0XHRcIkZpcnN0TmFtZVwiOiBcIlZpbmNlbnRcIixcblx0XHRcdFwiTGFzdE5hbWVcIjogXCJDYWxhYnJlc2VcIixcblx0XHRcdFwiRW1haWxzXCI6IFtcblx0XHRcdFx0XCJWaW5jZW50QGV4YW1wbGUuY29tXCIsXG5cdFx0XHRcdFwiVmluY2VudEBjb250b3NvLmNvbVwiXG5cdFx0XHRdLFxuXHRcdFx0XCJBZGRyZXNzSW5mb1wiOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRcIkFkZHJlc3NcIjogXCI1NSBHcml6emx5IFBlYWsgUmQuXCIsXG5cdFx0XHRcdFx0XCJDaXR5XCI6IHtcblx0XHRcdFx0XHRcdFwiQ291bnRyeVJlZ2lvblwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcblx0XHRcdFx0XHRcdFwiTmFtZVwiOiBcIkJ1dHRlXCIsXG5cdFx0XHRcdFx0XHRcIlJlZ2lvblwiOiBcIk1UXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdF0sXG5cdFx0XHRcIkdlbmRlclwiOiBcIk1hbGVcIixcblx0XHRcdFwiQ29uY3VycmVuY3lcIjogNjM1OTk3NTIxMTEzNTczMjAwXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcIlVzZXJOYW1lXCI6IFwiY2x5ZGVndWVzc1wiLFxuXHRcdFx0XCJGaXJzdE5hbWVcIjogXCJDbHlkZVwiLFxuXHRcdFx0XCJMYXN0TmFtZVwiOiBcIkd1ZXNzXCIsXG5cdFx0XHRcIkVtYWlsc1wiOiBbXG5cdFx0XHRcdFwiQ2x5ZGVAZXhhbXBsZS5jb21cIlxuXHRcdFx0XSxcblx0XHRcdFwiQWRkcmVzc0luZm9cIjogW10sXG5cdFx0XHRcIkdlbmRlclwiOiBcIk1hbGVcIixcblx0XHRcdFwiQ29uY3VycmVuY3lcIjogNjM1OTk3NTIxMTEzNTczMjAwXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcIlVzZXJOYW1lXCI6IFwia2VpdGhwaW5ja25leVwiLFxuXHRcdFx0XCJGaXJzdE5hbWVcIjogXCJLZWl0aFwiLFxuXHRcdFx0XCJMYXN0TmFtZVwiOiBcIlBpbmNrbmV5XCIsXG5cdFx0XHRcIkVtYWlsc1wiOiBbXG5cdFx0XHRcdFwiS2VpdGhAZXhhbXBsZS5jb21cIixcblx0XHRcdFx0XCJLZWl0aEBjb250b3NvLmNvbVwiXG5cdFx0XHRdLFxuXHRcdFx0XCJBZGRyZXNzSW5mb1wiOiBbXSxcblx0XHRcdFwiR2VuZGVyXCI6IFwiTWFsZVwiLFxuXHRcdFx0XCJDb25jdXJyZW5jeVwiOiA2MzU5OTc1MjExMTM1NzMyMDBcblx0XHR9LFxuXHRcdHtcblx0XHRcdFwiVXNlck5hbWVcIjogXCJtYXJzaGFsbGdhcmF5XCIsXG5cdFx0XHRcIkZpcnN0TmFtZVwiOiBcIk1hcnNoYWxsXCIsXG5cdFx0XHRcIkxhc3ROYW1lXCI6IFwiR2FyYXlcIixcblx0XHRcdFwiRW1haWxzXCI6IFtcblx0XHRcdFx0XCJNYXJzaGFsbEBleGFtcGxlLmNvbVwiLFxuXHRcdFx0XHRcIk1hcnNoYWxsQGNvbnRvc28uY29tXCJcblx0XHRcdF0sXG5cdFx0XHRcIkFkZHJlc3NJbmZvXCI6IFtdLFxuXHRcdFx0XCJHZW5kZXJcIjogXCJNYWxlXCIsXG5cdFx0XHRcIkNvbmN1cnJlbmN5XCI6IDYzNTk5NzY2MDAxNTA2MTUwMFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJVc2VyTmFtZVwiOiBcInJ5YW50aGVyaWF1bHRcIixcblx0XHRcdFwiRmlyc3ROYW1lXCI6IFwiUnlhblwiLFxuXHRcdFx0XCJMYXN0TmFtZVwiOiBcIlRoZXJpYXVsdFwiLFxuXHRcdFx0XCJFbWFpbHNcIjogW1xuXHRcdFx0XHRcIlJ5YW5AZXhhbXBsZS5jb21cIixcblx0XHRcdFx0XCJSeWFuQGNvbnRvc28uY29tXCJcblx0XHRcdF0sXG5cdFx0XHRcIkFkZHJlc3NJbmZvXCI6IFtdLFxuXHRcdFx0XCJHZW5kZXJcIjogXCJNYWxlXCIsXG5cdFx0XHRcIkNvbmN1cnJlbmN5XCI6IDYzNTk5NzY2MDAxNTA2MTUwMFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJVc2VyTmFtZVwiOiBcImVsYWluZXN0ZXdhcnRcIixcblx0XHRcdFwiRmlyc3ROYW1lXCI6IFwiRWxhaW5lXCIsXG5cdFx0XHRcIkxhc3ROYW1lXCI6IFwiU3Rld2FydFwiLFxuXHRcdFx0XCJFbWFpbHNcIjogW1xuXHRcdFx0XHRcIkVsYWluZUBleGFtcGxlLmNvbVwiLFxuXHRcdFx0XHRcIkVsYWluZUBjb250b3NvLmNvbVwiXG5cdFx0XHRdLFxuXHRcdFx0XCJBZGRyZXNzSW5mb1wiOiBbXSxcblx0XHRcdFwiR2VuZGVyXCI6IFwiRmVtYWxlXCIsXG5cdFx0XHRcIkNvbmN1cnJlbmN5XCI6IDYzNTk5NzY2MDAxNTA2MTUwMFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJVc2VyTmFtZVwiOiBcInNhbGxpZXNhbXBzb25cIixcblx0XHRcdFwiRmlyc3ROYW1lXCI6IFwiU2FsbGllXCIsXG5cdFx0XHRcIkxhc3ROYW1lXCI6IFwiU2FtcHNvblwiLFxuXHRcdFx0XCJFbWFpbHNcIjogW1xuXHRcdFx0XHRcIlNhbGxpZUBleGFtcGxlLmNvbVwiLFxuXHRcdFx0XHRcIlNhbGxpZUBjb250b3NvLmNvbVwiXG5cdFx0XHRdLFxuXHRcdFx0XCJBZGRyZXNzSW5mb1wiOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRcIkFkZHJlc3NcIjogXCI4NyBQb2xrIFN0LiBTdWl0ZSA1XCIsXG5cdFx0XHRcdFx0XCJDaXR5XCI6IHtcblx0XHRcdFx0XHRcdFwiQ291bnRyeVJlZ2lvblwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcblx0XHRcdFx0XHRcdFwiTmFtZVwiOiBcIlNhbiBGcmFuY2lzY29cIixcblx0XHRcdFx0XHRcdFwiUmVnaW9uXCI6IFwiQ0FcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdFwiQWRkcmVzc1wiOiBcIjg5IENoaWFyb3NjdXJvIFJkLlwiLFxuXHRcdFx0XHRcdFwiQ2l0eVwiOiB7XG5cdFx0XHRcdFx0XHRcIkNvdW50cnlSZWdpb25cIjogXCJVbml0ZWQgU3RhdGVzXCIsXG5cdFx0XHRcdFx0XHRcIk5hbWVcIjogXCJQb3J0bGFuZFwiLFxuXHRcdFx0XHRcdFx0XCJSZWdpb25cIjogXCJPUlwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRdLFxuXHRcdFx0XCJHZW5kZXJcIjogXCJGZW1hbGVcIixcblx0XHRcdFwiQ29uY3VycmVuY3lcIjogNjM1OTk3NjYwMDE1MDYxNTAwXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcIlVzZXJOYW1lXCI6IFwiam9uaXJvc2FsZXNcIixcblx0XHRcdFwiRmlyc3ROYW1lXCI6IFwiSm9uaVwiLFxuXHRcdFx0XCJMYXN0TmFtZVwiOiBcIlJvc2FsZXNcIixcblx0XHRcdFwiRW1haWxzXCI6IFtcblx0XHRcdFx0XCJKb25pQGV4YW1wbGUuY29tXCIsXG5cdFx0XHRcdFwiSm9uaUBjb250b3NvLmNvbVwiXG5cdFx0XHRdLFxuXHRcdFx0XCJBZGRyZXNzSW5mb1wiOiBbXSxcblx0XHRcdFwiR2VuZGVyXCI6IFwiRmVtYWxlXCIsXG5cdFx0XHRcIkNvbmN1cnJlbmN5XCI6IDYzNTk5NzY2MDAxNTA2MTUwMFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJVc2VyTmFtZVwiOiBcImdlb3JnaW5hYmFybG93XCIsXG5cdFx0XHRcIkZpcnN0TmFtZVwiOiBcIkdlb3JnaW5hXCIsXG5cdFx0XHRcIkxhc3ROYW1lXCI6IFwiQmFybG93XCIsXG5cdFx0XHRcIkVtYWlsc1wiOiBbXG5cdFx0XHRcdFwiR2VvcmdpbmFAZXhhbXBsZS5jb21cIixcblx0XHRcdFx0XCJHZW9yZ2luYUBjb250b3NvLmNvbVwiXG5cdFx0XHRdLFxuXHRcdFx0XCJBZGRyZXNzSW5mb1wiOiBbXSxcblx0XHRcdFwiR2VuZGVyXCI6IFwiRmVtYWxlXCIsXG5cdFx0XHRcIkNvbmN1cnJlbmN5XCI6IDYzNTk5NzY2MDAxNTA2MTUwMFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJVc2VyTmFtZVwiOiBcImFuZ2VsaHVmZm1hblwiLFxuXHRcdFx0XCJGaXJzdE5hbWVcIjogXCJBbmdlbFwiLFxuXHRcdFx0XCJMYXN0TmFtZVwiOiBcIkh1ZmZtYW5cIixcblx0XHRcdFwiRW1haWxzXCI6IFtcblx0XHRcdFx0XCJBbmdlbEBleGFtcGxlLmNvbVwiXG5cdFx0XHRdLFxuXHRcdFx0XCJBZGRyZXNzSW5mb1wiOiBbXSxcblx0XHRcdFwiR2VuZGVyXCI6IFwiRmVtYWxlXCIsXG5cdFx0XHRcIkNvbmN1cnJlbmN5XCI6IDYzNTk5NzY2MDAxNTA2MTUwMFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJVc2VyTmFtZVwiOiBcImxhdXJlbG9zYm9yblwiLFxuXHRcdFx0XCJGaXJzdE5hbWVcIjogXCJMYXVyZWxcIixcblx0XHRcdFwiTGFzdE5hbWVcIjogXCJPc2Jvcm5cIixcblx0XHRcdFwiRW1haWxzXCI6IFtcblx0XHRcdFx0XCJMYXVyZWxAZXhhbXBsZS5jb21cIixcblx0XHRcdFx0XCJMYXVyZWxAY29udG9zby5jb21cIlxuXHRcdFx0XSxcblx0XHRcdFwiQWRkcmVzc0luZm9cIjogW10sXG5cdFx0XHRcIkdlbmRlclwiOiBcIkZlbWFsZVwiLFxuXHRcdFx0XCJDb25jdXJyZW5jeVwiOiA2MzU5OTc2NjAwMTUwNjE1MDBcblx0XHR9XG5cdF1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3Blb3BsZS5qc29uXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgamFkZSA9IHJlcXVpcmUoXCJEOlxcXFx3b3Jrc3BhY2VcXFxcZm9ya1xcXFxwcm9qZWN0aW9uLWdyaWRcXFxcbm9kZV9tb2R1bGVzXFxcXGphZGVcXFxcbGliXFxcXHJ1bnRpbWUuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7XG52YXIgYnVmID0gW107XG52YXIgamFkZV9taXhpbnMgPSB7fTtcbnZhciBqYWRlX2ludGVycDtcbjt2YXIgbG9jYWxzX2Zvcl93aXRoID0gKGxvY2FscyB8fCB7fSk7KGZ1bmN0aW9uICh2YWx1ZSkge1xuYnVmLnB1c2goXCI8ZGl2IGNsYXNzPVxcXCJ0ZXN0VG1wbFxcXCI+XCIgKyAoamFkZS5lc2NhcGUoKGphZGVfaW50ZXJwID0gdmFsdWUpID09IG51bGwgPyAnJyA6IGphZGVfaW50ZXJwKSkgKyBcIjwvZGl2PlwiKTt9LmNhbGwodGhpcyxcInZhbHVlXCIgaW4gbG9jYWxzX2Zvcl93aXRoP2xvY2Fsc19mb3Jfd2l0aC52YWx1ZTp0eXBlb2YgdmFsdWUhPT1cInVuZGVmaW5lZFwiP3ZhbHVlOnVuZGVmaW5lZCkpOztyZXR1cm4gYnVmLmpvaW4oXCJcIik7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3Rlc3RUbXBsLmphZGVcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=